{
  "nodes": [
    {
      "content": "Background jobs guidance | Microsoft Azure",
      "pos": [
        26,
        68
      ]
    },
    {
      "content": "Guidance on background tasks that run independently of the user interface.",
      "pos": [
        86,
        160
      ]
    },
    {
      "content": "Background jobs guidance",
      "pos": [
        448,
        472
      ]
    },
    {
      "content": "Overview",
      "pos": [
        534,
        542
      ]
    },
    {
      "content": "Many types of applications require background tasks that run independently of the user interface (UI).",
      "pos": [
        544,
        646
      ]
    },
    {
      "content": "Examples include batch jobs, intensive processing tasks, and long running processes such as workflows.",
      "pos": [
        647,
        749
      ]
    },
    {
      "content": "Background jobs can be executed without requiring user interaction; the application can start the job and then continue to process interactive requests from users.",
      "pos": [
        750,
        913
      ]
    },
    {
      "content": "This can help to minimize the load on the application UI, which can improve availability and reduce interactive response times.",
      "pos": [
        914,
        1041
      ]
    },
    {
      "content": "For example, if an application is required to generate thumbnails of images uploaded by users, it can do this as a background job and save the thumbnail to storage when complete without the user needing to wait for the process to complete.",
      "pos": [
        1043,
        1282
      ]
    },
    {
      "content": "In the same way, a user placing an order can initiate a background workflow that processes the order, while the UI allows the user to continue browsing the website.",
      "pos": [
        1283,
        1447
      ]
    },
    {
      "content": "When the background job is complete, it can update the stored orders data and send an email to the user confirming the order.",
      "pos": [
        1448,
        1573
      ]
    },
    {
      "content": "When considering whether to implement a task as a background job, the main criteria is whether the task can run without user interaction and without the UI needing to wait for the job to complete.",
      "pos": [
        1575,
        1771
      ]
    },
    {
      "content": "Tasks that require the user or the UI to wait while they are completed may not be appropriate as background jobs.",
      "pos": [
        1772,
        1885
      ]
    },
    {
      "content": "Types of background jobs",
      "pos": [
        1890,
        1914
      ]
    },
    {
      "content": "Background jobs typically have one or more of the following characteristics:",
      "pos": [
        1916,
        1992
      ]
    },
    {
      "content": "CPU intensive jobs such as mathematical calculations, structural model analysis, and more.",
      "pos": [
        1996,
        2086
      ]
    },
    {
      "content": "I/O intensive jobs such as executing a series of storage transactions or indexing files.",
      "pos": [
        2089,
        2177
      ]
    },
    {
      "content": "Batch jobs such as nightly data updates or scheduled processing.",
      "pos": [
        2180,
        2244
      ]
    },
    {
      "content": "Long running workflows such as order fulfillment or provisioning services and systems.",
      "pos": [
        2247,
        2333
      ]
    },
    {
      "content": "Sensitive data processing where the task is handed off to a more secure location for processing.",
      "pos": [
        2336,
        2432
      ]
    },
    {
      "content": "For example, you may not want to process sensitive data within a web role, and instead use a pattern such as <bpt id=\"p1\">[</bpt>Gatekeeper<ept id=\"p1\">](http://msdn.microsoft.com/library/dn589793.aspx)</ept> to transfer the data to an isolated background role that has access to protected storage.",
      "pos": [
        2433,
        2693
      ]
    },
    {
      "content": "Triggers",
      "pos": [
        2698,
        2706
      ]
    },
    {
      "content": "Background jobs can be initiated in several different ways.",
      "pos": [
        2708,
        2767
      ]
    },
    {
      "content": "Effectively, all of them fall into one of the following categories:",
      "pos": [
        2768,
        2835
      ]
    },
    {
      "content": "<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Event driven triggers<ept id=\"p2\">**</ept><ept id=\"p1\">](#event-driven-triggers)</ept>.",
      "pos": [
        2839,
        2891
      ]
    },
    {
      "content": "The task is started in response to an event, typically an action taken by a user or a step in a workflow.",
      "pos": [
        2892,
        2997
      ]
    },
    {
      "content": "<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Schedule driven triggers<ept id=\"p2\">**</ept><ept id=\"p1\">](#schedule-driven-triggers)</ept>.",
      "pos": [
        3000,
        3058
      ]
    },
    {
      "content": "The task is invoked on a schedule based on a timer.",
      "pos": [
        3059,
        3110
      ]
    },
    {
      "content": "This may be a recurring schedule, or a one-off invocation specified for a later time",
      "pos": [
        3111,
        3195
      ]
    },
    {
      "content": "Event driven triggers",
      "pos": [
        3201,
        3222
      ]
    },
    {
      "content": "Event driven invocation uses a trigger to start the background task.",
      "pos": [
        3224,
        3292
      ]
    },
    {
      "content": "Examples of using event driven triggers include:",
      "pos": [
        3293,
        3341
      ]
    },
    {
      "content": "The UI or another job places a message in a queue.",
      "pos": [
        3345,
        3395
      ]
    },
    {
      "content": "The message contains data about an action that has taken place, such as the user placing an order.",
      "pos": [
        3396,
        3494
      ]
    },
    {
      "content": "The background task listens on this queue and detects the arrival of a new message.",
      "pos": [
        3495,
        3578
      ]
    },
    {
      "content": "It reads the message and uses the data in it as the input to the background job.",
      "pos": [
        3579,
        3659
      ]
    },
    {
      "content": "The UI or another job saves or updates a value in storage.",
      "pos": [
        3662,
        3720
      ]
    },
    {
      "content": "The background task monitors the storage and detects changes.",
      "pos": [
        3721,
        3782
      ]
    },
    {
      "content": "It reads the data and uses it as the input to the background job.",
      "pos": [
        3783,
        3848
      ]
    },
    {
      "content": "The UI or another job makes a request to an endpoint, such as an HTTPS URI, or an API exposed as a web service.",
      "pos": [
        3851,
        3962
      ]
    },
    {
      "content": "It passes the data required to complete the background task as part of the request.",
      "pos": [
        3963,
        4046
      ]
    },
    {
      "content": "The endpoint or web service invokes the background task, which uses the data as its input.",
      "pos": [
        4047,
        4137
      ]
    },
    {
      "content": "Typical examples of tasks suited to event driven invocation include image processing, workflows, sending information to remote services, sending email messages, provisioning new users in multi-tenant applications, and more.",
      "pos": [
        4139,
        4362
      ]
    },
    {
      "content": "Schedule driven triggers",
      "pos": [
        4368,
        4392
      ]
    },
    {
      "content": "Schedule driven invocation uses a timer to start the background task.",
      "pos": [
        4394,
        4463
      ]
    },
    {
      "content": "Examples of using schedule driven triggers include:",
      "pos": [
        4464,
        4515
      ]
    },
    {
      "content": "A timer running locally within the application or as part of the application’s operating system invokes a background task on a regular basis.",
      "pos": [
        4519,
        4660
      ]
    },
    {
      "content": "A timer running in a different application, or a timer service such as Azure Scheduler, sends a request to an API or web service on a regular basis.",
      "pos": [
        4663,
        4811
      ]
    },
    {
      "content": "The API or web service invokes the background task.",
      "pos": [
        4812,
        4863
      ]
    },
    {
      "content": "A separate process or application starts a timer that causes the background task to be invoked once after a specified time delay, or at a specific time.",
      "pos": [
        4866,
        5018
      ]
    },
    {
      "content": "Typical examples of tasks suited to schedule driven invocation include batch processing routines such as updating related products lists for users based on their recent behavior, routine data processing tasks such as updating indexes or generating accumulated results, analyzing data for daily reports, data retention cleanup, data consistency checks, and more.",
      "pos": [
        5020,
        5381
      ]
    },
    {
      "content": "If you use a schedule driven task that must run as a single instance, be aware of the following:",
      "pos": [
        5383,
        5479
      ]
    },
    {
      "content": "If the compute instance that is running the scheduler (such as a Virtual Machine using Windows Scheduled Tasks) is scaled, you will have multiple instances of the scheduler running and these could start multiple instances of the task.",
      "pos": [
        5483,
        5717
      ]
    },
    {
      "content": "If tasks run for longer than the period between scheduler events, the scheduler may start another instance of the task while the previous one is still running.",
      "pos": [
        5720,
        5879
      ]
    },
    {
      "content": "Returning results",
      "pos": [
        5884,
        5901
      ]
    },
    {
      "content": "Background jobs execute asynchronously in a separate process, or even a separate location, from the UI or the process that invoked the background task.",
      "pos": [
        5903,
        6054
      ]
    },
    {
      "content": "Ideally, background tasks are “fire and forget” operations, and their execution progress has no impact on the UI or the calling process.",
      "pos": [
        6055,
        6191
      ]
    },
    {
      "content": "This means that the calling process does not wait for completion of the tasks, and therefore cannot automatically detect when the task ends.",
      "pos": [
        6192,
        6332
      ]
    },
    {
      "content": "If you require a background task to communicate with the calling task to indicate progress or completion, you must implement a mechanism for this.",
      "pos": [
        6333,
        6479
      ]
    },
    {
      "content": "Some examples are:",
      "pos": [
        6480,
        6498
      ]
    },
    {
      "content": "Write status indicator value to storage that is accessible to the UI or caller task, which can monitor or check this value when required.",
      "pos": [
        6502,
        6639
      ]
    },
    {
      "content": "Other data that the background task must return to the caller can be placed into the same storage.",
      "pos": [
        6640,
        6738
      ]
    },
    {
      "content": "Establish a reply queue that the UI or caller listens on.",
      "pos": [
        6741,
        6798
      ]
    },
    {
      "content": "The background task can send messages to the queue indicating status and completion.",
      "pos": [
        6799,
        6883
      ]
    },
    {
      "content": "Data that the background task must return to the caller can be placed into the messages.",
      "pos": [
        6884,
        6972
      ]
    },
    {
      "content": "If you are using Azure Service Bus, you can use the <bpt id=\"p1\">**</bpt>ReplyTo<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>CorrelationId<ept id=\"p2\">**</ept> properties to implement this capability.",
      "pos": [
        6973,
        7099
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Correlation in Service Bus Brokered Messaging<ept id=\"p1\">](http://www.cloudcasts.net/devguide/Default.aspx?id=13029)</ept>.",
      "pos": [
        7100,
        7232
      ]
    },
    {
      "content": "Expose an API or endpoint from the background task that the UI or caller can access to obtain status information.",
      "pos": [
        7235,
        7348
      ]
    },
    {
      "content": "Data that the background task must return to the caller can be included in the response.",
      "pos": [
        7349,
        7437
      ]
    },
    {
      "content": "Have the background task call back to the UI or caller through an API to indicate status at predefined points or on completion.",
      "pos": [
        7440,
        7567
      ]
    },
    {
      "content": "This might be through events raised locally, or through a publish and subscribe mechanism.",
      "pos": [
        7568,
        7658
      ]
    },
    {
      "content": "Data that the background task must return to the caller can be included in the request or event payload.",
      "pos": [
        7659,
        7763
      ]
    },
    {
      "content": "Hosting environment",
      "pos": [
        7768,
        7787
      ]
    },
    {
      "content": "You can host background tasks using a range of different Azure platform services:",
      "pos": [
        7789,
        7870
      ]
    },
    {
      "content": "<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Azure Web Sites<ept id=\"p2\">**</ept><ept id=\"p1\">](#azure-web-sites-and-webjobs)</ept>.",
      "pos": [
        7874,
        7926
      ]
    },
    {
      "content": "You can use WebJobs to execute custom jobs based on a range of different types of script or executable program within the context of the website.",
      "pos": [
        7927,
        8072
      ]
    },
    {
      "content": "<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Azure Cloud Services web and worker roles<ept id=\"p2\">**</ept><ept id=\"p1\">](#azure-cloud-services-web-and-worker-roles)</ept>.",
      "pos": [
        8075,
        8167
      ]
    },
    {
      "content": "You can write code within a role that executes as a background task.",
      "pos": [
        8168,
        8236
      ]
    },
    {
      "content": "<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Azure Virtual Machines<ept id=\"p2\">**</ept><ept id=\"p1\">](#azure-virtual-machines)</ept>.",
      "pos": [
        8239,
        8293
      ]
    },
    {
      "content": "If you have a Windows service or you want to use the Windows Task Scheduler, it is common to host your background tasks within a dedicated virtual machine.",
      "pos": [
        8294,
        8449
      ]
    },
    {
      "content": "The following sections describe each of these options in more detail, and include considerations to help you choose the appropriate option.",
      "pos": [
        8451,
        8590
      ]
    },
    {
      "content": "Azure Web Sites and WebJobs",
      "pos": [
        8596,
        8623
      ]
    },
    {
      "content": "You can use Azure WebJobs to execute custom jobs as background tasks within an Azure Web Sites hosted application.",
      "pos": [
        8625,
        8739
      ]
    },
    {
      "content": "WebJobs can run scripts or executable programs within the context of your website as a continuous process, or in response to a trigger event from Azure Scheduler or external factors such as changes to storage blobs and message queues.",
      "pos": [
        8740,
        8974
      ]
    },
    {
      "content": "Jobs can be started and stopped on demand, and shut down gracefully.",
      "pos": [
        8975,
        9043
      ]
    },
    {
      "content": "If a continuously running WebJob fails, it is automatically restarted.",
      "pos": [
        9044,
        9114
      ]
    },
    {
      "content": "Retry and error actions are configurable.",
      "pos": [
        9115,
        9156
      ]
    },
    {
      "content": "When configuring a WebJob:",
      "pos": [
        9158,
        9184
      ]
    },
    {
      "content": "If you want the job to respond to an event driven trigger, it should be configured as <bpt id=\"p1\">**</bpt>Run continuously<ept id=\"p1\">**</ept>.",
      "pos": [
        9188,
        9295
      ]
    },
    {
      "content": "The script or program is stored in the folder named site/wwwroot/app_data/jobs/continuous.",
      "pos": [
        9296,
        9386
      ]
    },
    {
      "content": "If you want the job to respond to a schedule driven trigger, it should be configured as <bpt id=\"p1\">**</bpt>Run on a schedule<ept id=\"p1\">**</ept>.",
      "pos": [
        9389,
        9499
      ]
    },
    {
      "content": "The script or program is stored in the folder named site/wwwroot/app_data/jobs/triggered.",
      "pos": [
        9500,
        9589
      ]
    },
    {
      "pos": [
        9592,
        9745
      ],
      "content": "If you choose the <bpt id=\"p1\">**</bpt>Run on demand<ept id=\"p1\">**</ept> option when you configure a job, it will execute the same code as the <bpt id=\"p2\">**</bpt>Run on a schedule<ept id=\"p2\">**</ept> option when you start it."
    },
    {
      "content": "Azure WebJobs run within the sandbox of the website, which means they can access environment variables, and share information such as connection strings with the website.",
      "pos": [
        9747,
        9917
      ]
    },
    {
      "content": "The job has access to the unique identifier of the machine running the job.",
      "pos": [
        9918,
        9993
      ]
    },
    {
      "content": "The connection string named <bpt id=\"p1\">**</bpt>AzureJobsStorage<ept id=\"p1\">**</ept> provides access to Azure storage queues, blobs, and tables for application data, and Service Bus for messaging and communication.",
      "pos": [
        9994,
        10172
      ]
    },
    {
      "content": "The connection string named <bpt id=\"p1\">**</bpt>AzureJobsDashboard<ept id=\"p1\">**</ept> provides access to the job action log files.",
      "pos": [
        10173,
        10268
      ]
    },
    {
      "content": "Azure WebJobs have the following characteristics:",
      "pos": [
        10270,
        10319
      ]
    },
    {
      "pos": [
        10323,
        10404
      ],
      "content": "<bpt id=\"p1\">**</bpt>Security<ept id=\"p1\">**</ept>: WebJobs are protected by the deployment credentials of the website."
    },
    {
      "pos": [
        10407,
        10671
      ],
      "content": "<bpt id=\"p1\">**</bpt>Supported file types<ept id=\"p1\">**</ept>: WebJobs can be defined using command scripts (.cmd), batch files (.bat), PowerShell scripts (.ps1), bash shell scripts (.sh), PHP scripts (.php), Python scripts (.py), JavaScript code (.js), and executable programs (.exe, .jar, and more)."
    },
    {
      "pos": [
        10674,
        11136
      ],
      "content": "<bpt id=\"p1\">**</bpt>Deployment<ept id=\"p1\">**</ept>: Scripts and executables can be deployed using the Azure portal, created and deployed by using the <bpt id=\"p2\">[</bpt>WebJobsVs<ept id=\"p2\">](https://visualstudiogallery.msdn.microsoft.com/f4824551-2660-4afa-aba1-1fcc1673c3d0)</ept> add-in for Visual Studio or the <bpt id=\"p3\">[</bpt>Visual Studio 2013 Update 4<ept id=\"p3\">](http://www.visualstudio.com/news/vs2013-update4-rc-vs)</ept>, by using the <bpt id=\"p4\">[</bpt>Azure WebJobs SDK<ept id=\"p4\">](websites-dotnet-webjobs-sdk-get-started.md)</ept>, or by copying them directly to the following locations:"
    },
    {
      "content": "for triggered execution: site/wwwroot/app_data/jobs/triggered/{job name}",
      "pos": [
        11141,
        11213
      ]
    },
    {
      "content": "for continuous execution: site/wwwroot/app_data/jobs/continuous/{job name}",
      "pos": [
        11218,
        11292
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Logging<ept id=\"p1\">**</ept>: Console.Out is treated (marked) as INFO and Console.Error as ERROR.",
      "pos": [
        11295,
        11375
      ]
    },
    {
      "content": "Monitoring and diagnostics information can be accessed using the Azure portal, and log files can be downloaded directly from the site.",
      "pos": [
        11376,
        11510
      ]
    },
    {
      "content": "They are saved in the following locations:",
      "pos": [
        11511,
        11553
      ]
    },
    {
      "content": "for triggered execution: Vfs/data/jobs/continuous/jobName",
      "pos": [
        11558,
        11615
      ]
    },
    {
      "content": "for continuous execution: Vfs/data/jobs/triggered/jobName",
      "pos": [
        11620,
        11677
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Configuration<ept id=\"p1\">**</ept>: WebJobs can be configured using the portal, the REST API, and PowerShell.",
      "pos": [
        11680,
        11772
      ]
    },
    {
      "content": "A configuration file named settings.job in the same root directory as the job script can be used to provide configuration information for a job.",
      "pos": [
        11773,
        11917
      ]
    },
    {
      "content": "For example:",
      "pos": [
        11918,
        11930
      ]
    },
    {
      "content": "{ \"stopping_wait_time\": 60 }",
      "pos": [
        11935,
        11963
      ]
    },
    {
      "content": "{ \"is_singleton\": true }",
      "pos": [
        11968,
        11992
      ]
    },
    {
      "content": "Considerations",
      "pos": [
        11998,
        12012
      ]
    },
    {
      "content": "By default, WebJobs scale with the website.",
      "pos": [
        12016,
        12059
      ]
    },
    {
      "content": "However, jobs can be configured to run on single instance by setting the <bpt id=\"p1\">**</bpt>is_singleton<ept id=\"p1\">**</ept> configuration property to true.",
      "pos": [
        12060,
        12181
      ]
    },
    {
      "content": "Single instance WebJobs are useful for tasks that you do not want to scale or run as simultaneous multiple instances, such as re-indexing, data analysis, and similar tasks.",
      "pos": [
        12182,
        12354
      ]
    },
    {
      "content": "To minimize the impact of jobs on the performance of the website, consider creating an empty Azure Web Sites instance in a new App Service Plan to host WebJobs that may be long running or resource intensive.",
      "pos": [
        12357,
        12564
      ]
    },
    {
      "content": "More information",
      "pos": [
        12570,
        12586
      ]
    },
    {
      "pos": [
        12590,
        12725
      ],
      "content": "<bpt id=\"p1\">[</bpt>Azure WebJobs Recommended Resources<ept id=\"p1\">](websites-webjobs-resources/)</ept> lists the many useful resources, downloads, and samples for WebJobs."
    },
    {
      "content": "Azure Cloud Services web and worker roles",
      "pos": [
        12730,
        12771
      ]
    },
    {
      "content": "Background tasks can be executed within a web role or in a separate worker role.",
      "pos": [
        12773,
        12853
      ]
    },
    {
      "content": "The decision whether to use a worker role should be based on consideration of scalability and elasticity requirements, task lifetime, release cadence, security, fault tolerance, contention, complexity, and the logical architecture.",
      "pos": [
        12854,
        13085
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Compute Resource Consolidation Pattern<ept id=\"p1\">](http://msdn.microsoft.com/library/dn589778.aspx)</ept>.",
      "pos": [
        13086,
        13202
      ]
    },
    {
      "content": "There are several ways to implement background tasks within a Cloud Services role:",
      "pos": [
        13204,
        13286
      ]
    },
    {
      "content": "Create an implementation of the <bpt id=\"p1\">**</bpt>RoleEntryPoint<ept id=\"p1\">**</ept> class in the role and use its methods to execute background tasks.",
      "pos": [
        13290,
        13407
      ]
    },
    {
      "content": "The tasks run in the context of WaIISHost.exe, and can use the <bpt id=\"p1\">**</bpt>GetSetting<ept id=\"p1\">**</ept> method of the <bpt id=\"p2\">**</bpt>CloudConfigurationManager<ept id=\"p2\">**</ept> class to load configuration settings.",
      "pos": [
        13408,
        13567
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Lifecycle (Cloud Services)<ept id=\"p1\">](#lifecycle-cloud-services-)</ept>.",
      "pos": [
        13568,
        13651
      ]
    },
    {
      "content": "Use startup tasks to execute background tasks when the application starts.",
      "pos": [
        13654,
        13728
      ]
    },
    {
      "content": "To force the tasks to continue to run in the background set the <bpt id=\"p1\">**</bpt>taskType<ept id=\"p1\">**</ept> property to <bpt id=\"p2\">**</bpt>background<ept id=\"p2\">**</ept> (if you do not do this, the application startup process will halt and wait for the task to finish).",
      "pos": [
        13729,
        13932
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Run Startup Tasks in Azure<ept id=\"p1\">](http://msdn.microsoft.com/library/azure/hh180155.aspx)</ept>.",
      "pos": [
        13933,
        14043
      ]
    },
    {
      "content": "Use the WebJobs SDK to implement background tasks as WebJobs that are initiated as a startup task.",
      "pos": [
        14046,
        14144
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Get Started with the Azure WebJobs SDK<ept id=\"p1\">](websites-dotnet-webjobs-sdk-get-started.md)</ept>.",
      "pos": [
        14145,
        14256
      ]
    },
    {
      "content": "Use a startup task to install a Windows service that executes one or more background tasks.",
      "pos": [
        14259,
        14350
      ]
    },
    {
      "content": "You must set the <bpt id=\"p1\">**</bpt>taskType<ept id=\"p1\">**</ept> property to <bpt id=\"p2\">**</bpt>background<ept id=\"p2\">**</ept> so that the service executes in the background.",
      "pos": [
        14351,
        14455
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Run Startup Tasks in Azure<ept id=\"p1\">](http://msdn.microsoft.com/library/azure/hh180155.aspx)</ept>.",
      "pos": [
        14456,
        14566
      ]
    },
    {
      "content": "Running background tasks in the web role",
      "pos": [
        14572,
        14612
      ]
    },
    {
      "content": "The main advantage of running background tasks in the web role is the saving in hosting costs because there is no requirement to deploy additional roles.",
      "pos": [
        14614,
        14767
      ]
    },
    {
      "content": "Running background tasks in a worker role",
      "pos": [
        14773,
        14814
      ]
    },
    {
      "content": "Running background tasks in a worker role has several advantages:",
      "pos": [
        14816,
        14881
      ]
    },
    {
      "content": "It allows you to manage scaling separately for each type of role.",
      "pos": [
        14885,
        14950
      ]
    },
    {
      "content": "For example, you may need more instances of a web role to support the current load, but fewer instances of the worker role that executes background tasks.",
      "pos": [
        14951,
        15105
      ]
    },
    {
      "content": "Scaling background task compute instances separately from the UI roles can reduce hosting cost, while maintaining acceptable performance.",
      "pos": [
        15106,
        15243
      ]
    },
    {
      "content": "It offloads the processing overhead for background tasks from the web role.",
      "pos": [
        15246,
        15321
      ]
    },
    {
      "content": "The web role that provides the UI can remain responsive, and it may mean fewer instances are required to support a given volume of requests from users.",
      "pos": [
        15322,
        15473
      ]
    },
    {
      "content": "It allows you to implement separation of concerns.",
      "pos": [
        15476,
        15526
      ]
    },
    {
      "content": "Each role type can implement a specific set of clearly defined and related tasks.",
      "pos": [
        15527,
        15608
      ]
    },
    {
      "content": "This makes designing and maintaining the code easier because there is less interdependence of code and functionality between each role.",
      "pos": [
        15609,
        15744
      ]
    },
    {
      "content": "It can help to isolate sensitive processes and data.",
      "pos": [
        15747,
        15799
      ]
    },
    {
      "content": "For example, web roles that implement the UI do not need to have access to data that is managed and controlled by a worker role.",
      "pos": [
        15800,
        15928
      ]
    },
    {
      "content": "This can be useful in strengthening security, especially when using a pattern such as the <bpt id=\"p1\">[</bpt>Gatekeeper Pattern<ept id=\"p1\">](http://msdn.microsoft.com/library/dn589793.aspx)</ept>.",
      "pos": [
        15929,
        16089
      ]
    },
    {
      "content": "Considerations",
      "pos": [
        16097,
        16111
      ]
    },
    {
      "content": "Consider the following points when choosing how and where to deploy background tasks when using Cloud Services web and worker roles:",
      "pos": [
        16113,
        16245
      ]
    },
    {
      "content": "Hosting background tasks in an existing web role can save the cost of running a separate worker role just for these tasks, but it is likely to affect the performance and availability of the application if there is contention for processing and other resources.",
      "pos": [
        16249,
        16509
      ]
    },
    {
      "content": "Using a separate worker role protects the web role from the impact of long running or resource intensive background tasks.",
      "pos": [
        16510,
        16632
      ]
    },
    {
      "content": "If you host background tasks using the <bpt id=\"p1\">**</bpt>RoleEntryPoint<ept id=\"p1\">**</ept> class, you can easily move this to another role.",
      "pos": [
        16635,
        16741
      ]
    },
    {
      "content": "For example, if you create the class in a web role and later decide you need to run the tasks in a worker role, you can move the <bpt id=\"p1\">**</bpt>RoleEntryPoint<ept id=\"p1\">**</ept> class implementation into the worker role.",
      "pos": [
        16742,
        16932
      ]
    },
    {
      "content": "Startup tasks are designed to execute a program or a script.",
      "pos": [
        16935,
        16995
      ]
    },
    {
      "content": "Deploying a background job as an executable program may be more difficult, especially if it also requires deployment of dependent assemblies.",
      "pos": [
        16996,
        17137
      ]
    },
    {
      "content": "It may be easier to deploy and use a script to define a background job when using startup tasks.",
      "pos": [
        17138,
        17234
      ]
    },
    {
      "content": "Exceptions that cause a background task to fail have a different impact depending on the way that they are hosted:",
      "pos": [
        17237,
        17351
      ]
    },
    {
      "content": "If you use the <bpt id=\"p1\">**</bpt>RoleEntryPoint<ept id=\"p1\">**</ept> class approach, a failed task will cause the role to restart so that the task automatically restarts.",
      "pos": [
        17356,
        17491
      ]
    },
    {
      "content": "This can affect availability of the application.",
      "pos": [
        17492,
        17540
      ]
    },
    {
      "content": "To prevent this, ensure that you include robust exception handling within the <bpt id=\"p1\">**</bpt>RoleEntryPoint<ept id=\"p1\">**</ept> class and all the background tasks.",
      "pos": [
        17541,
        17673
      ]
    },
    {
      "content": "Use code to restart tasks that fail where this is appropriate, and throw the exception to restart the role only if you cannot gracefully recover from the failure within your code.",
      "pos": [
        17674,
        17853
      ]
    },
    {
      "content": "If you use startup tasks, you are responsible for managing the task execution and checking if it fails.",
      "pos": [
        17858,
        17961
      ]
    },
    {
      "content": "Managing and monitoring startup tasks is more difficult than using the <bpt id=\"p1\">**</bpt>RoleEntryPoint<ept id=\"p1\">**</ept> class approach.",
      "pos": [
        17964,
        18069
      ]
    },
    {
      "content": "However, the Azure WebJobs SDK include a dashboard to make it easier to manage WebJobs that you initiate through startup tasks.",
      "pos": [
        18070,
        18197
      ]
    },
    {
      "content": "More information",
      "pos": [
        18203,
        18219
      ]
    },
    {
      "content": "Compute Resource Consolidation Pattern",
      "pos": [
        18224,
        18262
      ]
    },
    {
      "content": "Get Started with the Azure WebJobs SDK",
      "pos": [
        18316,
        18354
      ]
    },
    {
      "content": "Azure Virtual Machines",
      "pos": [
        18402,
        18424
      ]
    },
    {
      "content": "Background tasks may be implemented in a way that prevents them from being deployed to Azure Web Sites or Cloud Services, or this may not convenient.",
      "pos": [
        18426,
        18575
      ]
    },
    {
      "content": "Typical examples are Windows services, and third party utilities and executable programs.",
      "pos": [
        18576,
        18665
      ]
    },
    {
      "content": "It may also include programs written for an execution environment different to that hosting the application; for example, it may be a Unix or Linux program that you want to execute from a Windows or .NET application.",
      "pos": [
        18666,
        18882
      ]
    },
    {
      "content": "You can choose from a range of operating systems for an Azure virtual machine, and run your service or executable on that virtual machine.",
      "pos": [
        18883,
        19021
      ]
    },
    {
      "content": "To help you choose when to use Virtual Machines, see <bpt id=\"p1\">[</bpt>Azure Websites, Cloud Services and Virtual Machines comparison<ept id=\"p1\">](choose-web-site-cloud-service-vm.md)</ept>.",
      "pos": [
        19023,
        19178
      ]
    },
    {
      "content": "For information about the options for <bpt id=\"p1\">[</bpt>Virtual Machines, see Virtual Machine and Cloud Service Sizes for Azure<ept id=\"p1\">](http://msdn.microsoft.com/library/azure/dn197896.aspx)</ept>.",
      "pos": [
        19179,
        19346
      ]
    },
    {
      "content": "For more information about the operating systems and pre-built images available for Virtual Machines, see <bpt id=\"p1\">[</bpt>Azure Virtual Machines Gallery<ept id=\"p1\">](http://azure.microsoft.com/gallery/virtual-machines/)</ept>.",
      "pos": [
        19347,
        19540
      ]
    },
    {
      "content": "To initiate the background task in a separate virtual machine, you have a range of options:",
      "pos": [
        19542,
        19633
      ]
    },
    {
      "content": "You can execute the task on demand directly from your application by sending a request to an endpoint that the task exposes, passing in any data that the task requires.",
      "pos": [
        19637,
        19805
      ]
    },
    {
      "content": "This endpoint invokes the task.",
      "pos": [
        19806,
        19837
      ]
    },
    {
      "content": "You can configure the task to run on a schedule using a scheduler or timer available in your chosen operating system.",
      "pos": [
        19840,
        19957
      ]
    },
    {
      "content": "For example, on Windows you can use Windows Task Scheduler to execute scripts and tasks or, if you have SQL Server installed on the virtual machine, you can use the SQL Server Agent to execute scripts and tasks.",
      "pos": [
        19958,
        20169
      ]
    },
    {
      "content": "You can use Azure Scheduler to initiate the task by adding a message to a queue that the task listens on, or by sending a request to an API that the task exposes.",
      "pos": [
        20172,
        20334
      ]
    },
    {
      "pos": [
        20336,
        20447
      ],
      "content": "See the earlier section <bpt id=\"p1\">[</bpt>Triggers<ept id=\"p1\">](#triggers)</ept> for more information about how you can initiate background tasks."
    },
    {
      "content": "Considerations",
      "pos": [
        20455,
        20469
      ]
    },
    {
      "content": "Consider the following points when deciding whether to deploy background tasks in an Azure virtual machine:",
      "pos": [
        20471,
        20578
      ]
    },
    {
      "content": "Hosting background tasks in a separate Azure virtual machine provides flexibility and allows precise control over initiation, execution, scheduling, and resource allocation.",
      "pos": [
        20582,
        20755
      ]
    },
    {
      "content": "However, it will increase runtime cost if a virtual machine must be deployed just to run background tasks.",
      "pos": [
        20756,
        20862
      ]
    },
    {
      "content": "There is no facility to monitor the tasks in the Azure portal, and no automated restart capability for failed tasks, although you can monitor the basic status of the virtual machine and manage it using the <bpt id=\"p1\">[</bpt>Azure Service Management Cmdlets<ept id=\"p1\">](http://msdn.microsoft.com/library/azure/dn495240.aspx)</ept>.",
      "pos": [
        20865,
        21161
      ]
    },
    {
      "content": "However, there are no facilities to control processes and threads in compute nodes.",
      "pos": [
        21162,
        21245
      ]
    },
    {
      "content": "Typically, using a virtual machine will require additional effort to implement a mechanism that collects data from instrumentation in the task, and from the operating system in the virtual machine.",
      "pos": [
        21246,
        21443
      ]
    },
    {
      "content": "One solution that may be appropriate is to use the <bpt id=\"p1\">[</bpt>System Center Management Pack for Azure<ept id=\"p1\">](http://technet.microsoft.com/library/gg276383.aspx)</ept>.",
      "pos": [
        21444,
        21589
      ]
    },
    {
      "content": "You might consider creating monitoring probes that are exposed through HTTP endpoints.",
      "pos": [
        21592,
        21678
      ]
    },
    {
      "content": "The code for these probes could perform health checks, collect operational information and statistics, or collate error information, and return it to a management application.",
      "pos": [
        21679,
        21854
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Health Endpoint Monitoring Pattern<ept id=\"p1\">](http://msdn.microsoft.com/library/dn589789.aspx)</ept>.",
      "pos": [
        21855,
        21967
      ]
    },
    {
      "content": "More information",
      "pos": [
        21973,
        21989
      ]
    },
    {
      "pos": [
        21993,
        22087
      ],
      "content": "<bpt id=\"p1\">[</bpt>Virtual Machines<ept id=\"p1\">](http://azure.microsoft.com/services/virtual-machines/)</ept> on the Azure website"
    },
    {
      "content": "Azure Virtual Machines FAQ",
      "pos": [
        22091,
        22117
      ]
    },
    {
      "content": "Design considerations",
      "pos": [
        22178,
        22199
      ]
    },
    {
      "content": "There are several fundamental factors to consider when designing background tasks.",
      "pos": [
        22201,
        22283
      ]
    },
    {
      "content": "The following sections discuss partitioning, conflicts, and coordination.",
      "pos": [
        22284,
        22357
      ]
    },
    {
      "content": "Partitioning",
      "pos": [
        22362,
        22374
      ]
    },
    {
      "content": "If you decide to include background tasks within an existing compute instance (such as a website, web role, existing worker role, or virtual machine), you must consider how this will affect the quality attributes of the compute instance and the background task itself.",
      "pos": [
        22376,
        22644
      ]
    },
    {
      "content": "These factors will help you to decide whether to co-locate the tasks with the existing compute instance, or separate them out into a separate compute instance:",
      "pos": [
        22645,
        22804
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Availability<ept id=\"p1\">**</ept>: Background tasks may not need to have the same level of availability as other parts of the application, in particular the UI and other parts directly involved in user interaction.",
      "pos": [
        22808,
        23005
      ]
    },
    {
      "content": "Background tasks may be more tolerant of latency, retried connection failures, and other factors that affect availability because the operations can be queued.",
      "pos": [
        23006,
        23165
      ]
    },
    {
      "content": "However, there must be sufficient capacity to prevent backing up of requests that could block queues and affect the application as a whole.",
      "pos": [
        23166,
        23305
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Scalability<ept id=\"p1\">**</ept>: Background tasks are likely to have a different scalability requirement to the UI and the interactive parts of the application.",
      "pos": [
        23308,
        23452
      ]
    },
    {
      "content": "Scaling the UI may be necessary to meet peaks in demand, while outstanding background tasks could be completed during less busy times by a fewer number of compute instances.",
      "pos": [
        23453,
        23626
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Resiliency<ept id=\"p1\">**</ept>: Failure of a compute instance that just hosts background tasks may not fatally affect the application as a whole if the requests for these tasks can be queued or postponed until the task is available again.",
      "pos": [
        23629,
        23851
      ]
    },
    {
      "content": "If the compute instance and/or tasks can be restarted within an appropriate interval, users of the application may not be affected.",
      "pos": [
        23852,
        23983
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Security<ept id=\"p1\">**</ept>: Background tasks may have different security requirements or restrictions than the UI or other parts of the application.",
      "pos": [
        23986,
        24120
      ]
    },
    {
      "content": "By using a separate compute instance, you can specify a different security environment for the tasks.",
      "pos": [
        24121,
        24222
      ]
    },
    {
      "content": "You can also use patterns such as Gatekeeper to isolate the background compute instances from the UI in order to maximize security and separation.",
      "pos": [
        24223,
        24369
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Performance<ept id=\"p1\">**</ept>: You can choose the type of compute instance for background tasks to specifically match the performance requirements of the tasks.",
      "pos": [
        24372,
        24518
      ]
    },
    {
      "content": "This may mean using a less expensive compute option if the tasks do not require the same processing capabilities as the UI, or a larger instance if they require additional capacity and resources.",
      "pos": [
        24519,
        24714
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Manageability<ept id=\"p1\">**</ept>: Background tasks may have a different development and deployment rhythm from the main application code or the UI.",
      "pos": [
        24717,
        24849
      ]
    },
    {
      "content": "Deploying them to a separate compute instance can simplify updates and versioning.",
      "pos": [
        24850,
        24932
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Cost<ept id=\"p1\">**</ept>: Adding compute instances to execute background tasks increases hosting costs.",
      "pos": [
        24935,
        25022
      ]
    },
    {
      "content": "You should carefully consider the trade-off between additional capacity and these extra costs.",
      "pos": [
        25023,
        25117
      ]
    },
    {
      "pos": [
        25119,
        25303
      ],
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Leader Election pattern<ept id=\"p1\">](http://msdn.microsoft.com/library/dn568104.aspx)</ept> and <bpt id=\"p2\">[</bpt>Competing Consumers pattern<ept id=\"p2\">](http://msdn.microsoft.com/library/dn568101.aspx)</ept>."
    },
    {
      "content": "Conflicts",
      "pos": [
        25308,
        25317
      ]
    },
    {
      "content": "If you have multiple instances of a background job, it is possible that they will compete for access to resources and services such as databases and storage.",
      "pos": [
        25319,
        25476
      ]
    },
    {
      "content": "This concurrent access can result in resource contention, which may cause conflicts in availability of the services and in the integrity of data in storage.",
      "pos": [
        25477,
        25633
      ]
    },
    {
      "content": "Resource contention can be resolved by using a pessimistic locking approach to prevent competing instances of a task from concurrently accessing a service, or corrupting data.",
      "pos": [
        25634,
        25809
      ]
    },
    {
      "content": "Another approach to resolve conflicts is to define background tasks as a singleton, so that there is only ever one instance running.",
      "pos": [
        25811,
        25943
      ]
    },
    {
      "content": "However, this eliminates the reliability and performance benefits that a multiple-instance configuration could provide, especially if the UI can supply sufficient work to keep more than one background task busy.",
      "pos": [
        25944,
        26155
      ]
    },
    {
      "content": "It is vital to ensure that the background task can automatically restart, and that it has sufficient capacity to cope with peaks in demand.",
      "pos": [
        26156,
        26295
      ]
    },
    {
      "content": "This may be achieved by allocating a compute instance with sufficient resources, by implementing a queueing mechanism that can store requests for later execution when demand decreases, or by a combination of these techniques.",
      "pos": [
        26296,
        26521
      ]
    },
    {
      "content": "Coordination",
      "pos": [
        26526,
        26538
      ]
    },
    {
      "content": "The background tasks may be complex, and require multiple individual tasks to execute to produce a result or to fulfil all the requirements.",
      "pos": [
        26540,
        26680
      ]
    },
    {
      "content": "It is common in these scenarios to divide the task into smaller discreet steps or subtasks that can be executed by multiple consumers.",
      "pos": [
        26681,
        26815
      ]
    },
    {
      "content": "Multi-step jobs can be more efficient and more flexible because individual steps may be reusable in multiple jobs.",
      "pos": [
        26816,
        26930
      ]
    },
    {
      "content": "It is also easy to add, remove, or modify the order of the steps.",
      "pos": [
        26931,
        26996
      ]
    },
    {
      "content": "Coordinating multiple tasks and steps can be challenging, but there are three common patterns you can use to guide your implementation of a solution:",
      "pos": [
        26998,
        27147
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Decomposing a task into multiple reusable steps<ept id=\"p1\">**</ept>.",
      "pos": [
        27151,
        27203
      ]
    },
    {
      "content": "An application may be required to perform a variety of tasks of varying complexity on the information that it processes.",
      "pos": [
        27204,
        27324
      ]
    },
    {
      "content": "A straightforward but inflexible approach to implementing this application could be to perform this processing as monolithic module.",
      "pos": [
        27325,
        27457
      ]
    },
    {
      "content": "However, this approach is likely to reduce the opportunities for refactoring the code, optimizing it, or reusing it if parts of the same processing are required elsewhere within the application.",
      "pos": [
        27458,
        27652
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Pipes and Filters Pattern<ept id=\"p1\">](http://msdn.microsoft.com/library/dn568100.aspx)</ept>.",
      "pos": [
        27653,
        27756
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Managing execution of the steps for a task<ept id=\"p1\">**</ept>.",
      "pos": [
        27759,
        27806
      ]
    },
    {
      "content": "An application may perform tasks that comprise a number of steps, some of which may invoke remote services or access remote resources.",
      "pos": [
        27807,
        27941
      ]
    },
    {
      "content": "The individual steps may be independent of each other, but they are orchestrated by the application logic that implements the task.",
      "pos": [
        27942,
        28073
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Scheduler Agent Supervisor Pattern<ept id=\"p1\">](http://msdn.microsoft.com/library/dn589780.aspx)</ept>.",
      "pos": [
        28074,
        28186
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Managing recovery for steps of a task that fail<ept id=\"p1\">**</ept>.",
      "pos": [
        28189,
        28241
      ]
    },
    {
      "content": "An application may need to undo the work performed by a series of steps, which together define an eventually consistent operation, if one or more of the steps fail.",
      "pos": [
        28242,
        28406
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Compensating Transaction Pattern<ept id=\"p1\">](http://msdn.microsoft.com/library/dn589804.aspx)</ept>.",
      "pos": [
        28407,
        28517
      ]
    },
    {
      "content": "Lifecycle (Cloud Services)",
      "pos": [
        28522,
        28548
      ]
    },
    {
      "pos": [
        28551,
        28782
      ],
      "content": "If you decide to implement background jobs for Cloud Services applications that use web and worker roles by using the <bpt id=\"p1\">**</bpt>RoleEntryPoint<ept id=\"p1\">**</ept> class, it is important to understand the lifecycle of this class in order to use it correctly."
    },
    {
      "content": "Web and worker roles go through a set of distinct phases as they start, run, and stop.",
      "pos": [
        28784,
        28870
      ]
    },
    {
      "content": "The <bpt id=\"p1\">**</bpt>RoleEntryPoint<ept id=\"p1\">**</ept> class exposes a series of events that indicate when these stages are occurring.",
      "pos": [
        28871,
        28973
      ]
    },
    {
      "content": "You use these to initialize, run, and stop your custom background tasks.",
      "pos": [
        28974,
        29046
      ]
    },
    {
      "content": "The complete cycle is:",
      "pos": [
        29047,
        29069
      ]
    },
    {
      "pos": [
        29073,
        29168
      ],
      "content": "Azure loads the role assembly and searches it for a class that derives from <bpt id=\"p1\">**</bpt>RoleEntryPoint<ept id=\"p1\">**</ept>."
    },
    {
      "content": "If it finds this class, it calls <bpt id=\"p1\">**</bpt>RoleEntryPoint.OnStart()<ept id=\"p1\">**</ept>.",
      "pos": [
        29171,
        29233
      ]
    },
    {
      "content": "You override this method to initialize your background tasks.",
      "pos": [
        29234,
        29295
      ]
    },
    {
      "pos": [
        29298,
        29483
      ],
      "content": "After the <bpt id=\"p1\">**</bpt>OnStart<ept id=\"p1\">**</ept> method completes, Azure calls <bpt id=\"p2\">**</bpt>Application_Start()<ept id=\"p2\">**</ept> in the application’s Global file if this is present (for example, Global.asax in a web role running ASP.NET)."
    },
    {
      "content": "Azure calls <bpt id=\"p1\">**</bpt>RoleEntryPoint.Run()<ept id=\"p1\">**</ept> on a new foreground thread that executes in parallel with <bpt id=\"p2\">**</bpt>OnStart()<ept id=\"p2\">**</ept>.",
      "pos": [
        29486,
        29595
      ]
    },
    {
      "content": "You override this method to start your background tasks.",
      "pos": [
        29596,
        29652
      ]
    },
    {
      "content": "When the Run method ends, Azure first calls <bpt id=\"p1\">**</bpt>Application_End()<ept id=\"p1\">**</ept> in the application’s Global file if this is present, and then calls <bpt id=\"p2\">**</bpt>RoleEntryPoint.OnStop()<ept id=\"p2\">**</ept>.",
      "pos": [
        29655,
        29817
      ]
    },
    {
      "content": "You override the <bpt id=\"p1\">**</bpt>OnStop<ept id=\"p1\">**</ept> method to stop your background tasks, clean up resources, dispose of objects, and close connections that the tasks may have used.",
      "pos": [
        29818,
        29975
      ]
    },
    {
      "content": "The Azure worker role host process is stopped.",
      "pos": [
        29978,
        30024
      ]
    },
    {
      "content": "At this point, the role will be recycled and will restart.",
      "pos": [
        30025,
        30083
      ]
    },
    {
      "pos": [
        30085,
        30265
      ],
      "content": "For more details and an example of using the methods of the <bpt id=\"p1\">**</bpt>RoleEntryPoint<ept id=\"p1\">**</ept> class, see <bpt id=\"p2\">[</bpt>Compute Resource Consolidation Pattern<ept id=\"p2\">](http://msdn.microsoft.com/library/dn589778.aspx)</ept>."
    },
    {
      "content": "Considerations",
      "pos": [
        30270,
        30284
      ]
    },
    {
      "content": "Consider the following points when planning how you will run background tasks in a web or worker role:",
      "pos": [
        30286,
        30388
      ]
    },
    {
      "content": "The default <bpt id=\"p1\">**</bpt>Run<ept id=\"p1\">**</ept> method implementation in the <bpt id=\"p2\">**</bpt>RoleEntryPoint<ept id=\"p2\">**</ept> class contains a call to <bpt id=\"p3\">**</bpt>Thread.Sleep(Timeout.Infinite)<ept id=\"p3\">**</ept> that keeps the role alive indefinitely.",
      "pos": [
        30392,
        30559
      ]
    },
    {
      "content": "If you override the <bpt id=\"p1\">**</bpt>Run<ept id=\"p1\">**</ept> method (which is typically necessary to execute background tasks) you must not allow your code to exit from the method unless you want to recycle the role instance.",
      "pos": [
        30560,
        30752
      ]
    },
    {
      "content": "A typical implementation of the <bpt id=\"p1\">**</bpt>Run<ept id=\"p1\">**</ept> method includes code to start each of the background tasks, and a loop construct that periodically checks the state of all the background tasks.",
      "pos": [
        30755,
        30939
      ]
    },
    {
      "content": "It can restart any that fail, or monitor for cancellation tokens that indicate jobs have completed.",
      "pos": [
        30940,
        31039
      ]
    },
    {
      "content": "If a background task throws an unhandled exception, that task should be recycled while allowing any other background tasks in the role to continue running.",
      "pos": [
        31042,
        31197
      ]
    },
    {
      "content": "However, if the exception is caused by corruption of objects outside the task, such as shared storage, the exception should be handled by your <bpt id=\"p1\">**</bpt>RoleEntryPoint<ept id=\"p1\">**</ept> class, all tasks should be cancelled, and the <bpt id=\"p2\">**</bpt>Run<ept id=\"p2\">**</ept> method allowed to end.",
      "pos": [
        31198,
        31436
      ]
    },
    {
      "content": "Azure will then restart the role.",
      "pos": [
        31437,
        31470
      ]
    },
    {
      "content": "Use the <bpt id=\"p1\">**</bpt>OnStop<ept id=\"p1\">**</ept> method to pause or kill background tasks and clean up resources.",
      "pos": [
        31473,
        31556
      ]
    },
    {
      "content": "This may involve stopping long-running or multi-step tasks, and it is vital to consider how this can be done to avoid data inconsistencies.",
      "pos": [
        31557,
        31696
      ]
    },
    {
      "content": "If a role instance stops for any reason other than a user-initiated shutdown, the code running in the <bpt id=\"p1\">**</bpt>OnStop<ept id=\"p1\">**</ept> method must complete within five minutes before it is forcibly terminated.",
      "pos": [
        31697,
        31884
      ]
    },
    {
      "content": "Ensure that your code can complete in that time, or can tolerate not running to completion.",
      "pos": [
        31885,
        31976
      ]
    },
    {
      "content": "The Azure load balancer starts directing traffic to the role instance when the <bpt id=\"p1\">**</bpt>RoleEntryPoint.OnStart<ept id=\"p1\">**</ept> method returns true.",
      "pos": [
        31981,
        32107
      ]
    },
    {
      "content": "Therefore, consider putting all your initialization code in the <bpt id=\"p1\">**</bpt>OnStart<ept id=\"p1\">**</ept> method so that role instances that do not successfully initialize will not receive any traffic.",
      "pos": [
        32108,
        32279
      ]
    },
    {
      "content": "You can use startup tasks in addition to the methods of the <bpt id=\"p1\">**</bpt>RoleEntryPoint<ept id=\"p1\">**</ept> class.",
      "pos": [
        32282,
        32367
      ]
    },
    {
      "content": "You should use startup tasks to initialize any settings you need to change in the Azure load balancer because these tasks will execute before the role receives any requests.",
      "pos": [
        32368,
        32541
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Run Startup Tasks in Azure<ept id=\"p1\">](http://msdn.microsoft.com/library/azure/hh180155.aspx)</ept>.",
      "pos": [
        32542,
        32652
      ]
    },
    {
      "content": "If there is an error in a startup task, it may force the role to continually restart.",
      "pos": [
        32655,
        32740
      ]
    },
    {
      "content": "This can prevent you from performing a VIP swap back to a previously staged version because the swap requires exclusive access to the role, and this cannot be obtained while the role is restarting.",
      "pos": [
        32741,
        32938
      ]
    },
    {
      "content": "To resolve this:",
      "pos": [
        32939,
        32955
      ]
    },
    {
      "pos": [
        32963,
        33055
      ],
      "content": "Add the following code to the beginning of the <bpt id=\"p1\">**</bpt>OnStart<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>Run<ept id=\"p2\">**</ept> methods in your role:"
    },
    {
      "content": "Add the definition of the <bpt id=\"p1\">**</bpt>Freeze<ept id=\"p1\">**</ept> setting as a Boolean value to the ServiceDefinition.csdef and ServiceConfiguration.*.cscfg files for the role and set it to <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept>.",
      "pos": [
        33298,
        33469
      ]
    },
    {
      "content": "If the role goes into a repeated restart mode, you can change the setting to <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> to freeze role execution and allow it to be swapped with a previous version.",
      "pos": [
        33470,
        33632
      ]
    },
    {
      "content": "Resiliency considerations",
      "pos": [
        33637,
        33662
      ]
    },
    {
      "content": "Background tasks must be resilient in order to provide reliable services to the application.",
      "pos": [
        33664,
        33756
      ]
    },
    {
      "content": "When planning and designing background tasks, consider the following points:",
      "pos": [
        33757,
        33833
      ]
    },
    {
      "content": "Background tasks must be able to gracefully handle role or service restarts without corrupting data or introducing inconsistency into the application.",
      "pos": [
        33837,
        33987
      ]
    },
    {
      "content": "For long-running or multi-step tasks, consider using <bpt id=\"p1\">_</bpt>check pointing<ept id=\"p1\">_</ept> by saving the state of jobs in persistent storage, or as messages in a queue if this is appropriate.",
      "pos": [
        33988,
        34158
      ]
    },
    {
      "content": "For example, you can persist state information in a message in a queue and incrementally update this state information with the task progress so that the task can be processed from the last known good checkpoint instead of restarting from the beginning.",
      "pos": [
        34159,
        34412
      ]
    },
    {
      "content": "When using Azure Service Bus queues, you can use message sessions to enable the same scenario.",
      "pos": [
        34413,
        34507
      ]
    },
    {
      "content": "Sessions allow you to save and retrieve the application processing state by using the <bpt id=\"p1\">[</bpt>SetState<ept id=\"p1\">](http://msdn.microsoft.com/library/microsoft.servicebus.messaging.messagesession.setstate.aspx)</ept> and <bpt id=\"p2\">[</bpt>GetState<ept id=\"p2\">](http://msdn.microsoft.com/library/microsoft.servicebus.messaging.messagesession.getstate.aspx)</ept> methods.",
      "pos": [
        34508,
        34818
      ]
    },
    {
      "content": "For more information about designing reliable multi-step processes and workflows, see <bpt id=\"p1\">[</bpt>Scheduler Agent Supervisor Pattern<ept id=\"p1\">](http://msdn.microsoft.com/library/dn589780.aspx)</ept>.",
      "pos": [
        34819,
        34991
      ]
    },
    {
      "content": "When using web or worker roles to host multiple background tasks, design your override of the <bpt id=\"p1\">**</bpt>Run<ept id=\"p1\">**</ept> method to monitor for failed or stalled tasks, and restart them.",
      "pos": [
        34994,
        35160
      ]
    },
    {
      "content": "Where this is not practical, and you are using a worker role, force the worker role to restart by exiting from the <bpt id=\"p1\">**</bpt>Run<ept id=\"p1\">**</ept> method.",
      "pos": [
        35161,
        35291
      ]
    },
    {
      "content": "When using queues to communicate with background tasks, the queues can act as a buffer to store requests sent to the tasks while the application is under higher than usual load.",
      "pos": [
        35294,
        35471
      ]
    },
    {
      "content": "This allows the tasks to catch up with the UI during less busy periods.",
      "pos": [
        35472,
        35543
      ]
    },
    {
      "content": "It also means that recycling the role will not block the UI.",
      "pos": [
        35544,
        35604
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Queue-Based Load Leveling Pattern<ept id=\"p1\">](http://msdn.microsoft.com/library/dn589783.aspx)</ept>.",
      "pos": [
        35605,
        35716
      ]
    },
    {
      "content": "If some tasks are more important than others, consider implementing the <bpt id=\"p1\">[</bpt>Priority Queue Pattern<ept id=\"p1\">](http://msdn.microsoft.com/library/dn589794.aspx)</ept> to ensure that these tasks run before less important ones.",
      "pos": [
        35717,
        35921
      ]
    },
    {
      "content": "Background tasks that are initiated by, or otherwise process messages must be designed to handle inconsistencies such as messages arriving out of order, messages that repeatedly cause an error (often referred to as <bpt id=\"p1\">_</bpt>poison messages<ept id=\"p1\">_</ept>), and messages that are delivered more than once.",
      "pos": [
        35924,
        36206
      ]
    },
    {
      "content": "Consider the following:",
      "pos": [
        36207,
        36230
      ]
    },
    {
      "content": "Messages that must be processed in a specific order, such as those that change data based on its existing value (for example, adding a value to an existing value), may not arrive in the original order they were sent.",
      "pos": [
        36235,
        36451
      ]
    },
    {
      "content": "Alternatively, they may be handled by different instances of a background task in a different order due to varying loads on each instance.",
      "pos": [
        36452,
        36590
      ]
    },
    {
      "content": "Messages that must be processed in a specific order should include a sequence number, key, or some other indicator that background tasks can use to ensure they are processed in the correct order.",
      "pos": [
        36591,
        36786
      ]
    },
    {
      "content": "If you are using Azure Service Bus, you can use message sessions to guarantee the order of delivery.",
      "pos": [
        36787,
        36887
      ]
    },
    {
      "content": "However, it is usually more efficient where possible to design the process so that the message order is not important.",
      "pos": [
        36888,
        37006
      ]
    },
    {
      "content": "Typically, a background task will peek messages in the queue, which temporarily hides them from other message consumers, and then delete the messages after they have been successfully processed.",
      "pos": [
        37011,
        37205
      ]
    },
    {
      "content": "If a background task fails when processing a message, that message will reappear on the queue after the peek timeout expires, and will be processed by another instance of the task or during the next processing cycle of this instance.",
      "pos": [
        37206,
        37439
      ]
    },
    {
      "content": "If the message consistently causes an error in the consumer, it will block the task, the queue, and eventually the application itself when the queue becomes full.",
      "pos": [
        37440,
        37602
      ]
    },
    {
      "content": "Therefore, it is vital to detect and remove poison messages from the queue.",
      "pos": [
        37603,
        37678
      ]
    },
    {
      "content": "If you are using Azure Service Bus, messages that cause an error can be moved automatically or manually to an associated dead letter queue.",
      "pos": [
        37679,
        37818
      ]
    },
    {
      "content": "Queues are guaranteed at <bpt id=\"p1\">_</bpt>least once<ept id=\"p1\">_</ept> delivery mechanisms, but they may deliver the same message more than once.",
      "pos": [
        37823,
        37935
      ]
    },
    {
      "content": "In addition, if a background task fails after processing a message but before deleting it from the queue, the message will become available for processing again.",
      "pos": [
        37936,
        38097
      ]
    },
    {
      "content": "Background tasks should be idempotent, which means that processing the same message more than once does not cause an error or inconsistency in the application’s data.",
      "pos": [
        38098,
        38264
      ]
    },
    {
      "content": "Some operations are naturally idempotent, such as setting a stored value to a specific new value.",
      "pos": [
        38265,
        38362
      ]
    },
    {
      "content": "However, operations such as adding a value to an existing stored value without checking that the stored value is still the same as when the message was originally sent will cause inconsistencies.",
      "pos": [
        38363,
        38558
      ]
    },
    {
      "content": "Azure Service Bus queues can be configured to automatically remove duplicated messages.",
      "pos": [
        38560,
        38647
      ]
    },
    {
      "content": "Some messaging systems, such as Azure storage queues and Azure Service Bus queues, support a de-queue count property that indicates the number of times a message has been read from the queue.",
      "pos": [
        38652,
        38843
      ]
    },
    {
      "content": "This can be useful in handling repeated and poison messages.",
      "pos": [
        38844,
        38904
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Asynchronous Messaging Primer<ept id=\"p1\">](http://msdn.microsoft.com/library/dn589781.aspx)</ept> and <bpt id=\"p2\">[</bpt>Idempotency Patterns<ept id=\"p2\">](http://blog.jonathanoliver.com/2010/04/idempotency-patterns/)</ept>.",
      "pos": [
        38905,
        39101
      ]
    },
    {
      "content": "Scaling and performance considerations",
      "pos": [
        39106,
        39144
      ]
    },
    {
      "content": "Background tasks must offer sufficient performance to ensure they do not block the application, or cause inconsistencies due to delayed operation when the system is under load.",
      "pos": [
        39146,
        39322
      ]
    },
    {
      "content": "Typically, performance is improved by scaling the compute instances that host the background tasks.",
      "pos": [
        39323,
        39422
      ]
    },
    {
      "content": "When planning and designing background tasks, consider the following points around scalability and performance:",
      "pos": [
        39423,
        39534
      ]
    },
    {
      "content": "Azure supports autoscaling (both scaling out and scaling back in) based on current demand and load, or on a predefined schedule, for Web Sites, Cloud Services web and worker roles, and Virtual Machines hosted deployments.",
      "pos": [
        39538,
        39759
      ]
    },
    {
      "content": "Use this feature to ensure the application as a whole has sufficient performance capabilities while minimizing runtime costs.",
      "pos": [
        39760,
        39885
      ]
    },
    {
      "content": "Where background tasks have a different performance capability from the other parts of a Cloud Services application (for example, the UI or components such as the data access layer), hosting the background tasks together in a separate worker role allows the UI and background task roles to scale independently to manage the load.",
      "pos": [
        39888,
        40217
      ]
    },
    {
      "content": "If multiple background tasks have significantly different performance capabilities from each other, consider dividing them into separate worker roles and scaling each role type independently, but note that this may increase runtime costs compared to combining all the tasks into fewer roles.",
      "pos": [
        40218,
        40509
      ]
    },
    {
      "content": "Simply scaling the roles may not be sufficient to prevent loss of performance under load.",
      "pos": [
        40512,
        40601
      ]
    },
    {
      "content": "You may also need to scale storage queues and other resources to prevent a single point of the overall processing chain becoming a bottleneck.",
      "pos": [
        40602,
        40744
      ]
    },
    {
      "content": "Also, consider other limitations, such as the maximum throughput of storage and other services the application and the background tasks rely on.",
      "pos": [
        40745,
        40889
      ]
    },
    {
      "content": "Background tasks must be designed for scaling.",
      "pos": [
        40892,
        40938
      ]
    },
    {
      "content": "For example, they must be able to dynamically detect the number of storage queues in use in order to listen on or send messages to the appropriate queue.",
      "pos": [
        40939,
        41092
      ]
    },
    {
      "content": "By default, WebJobs scale with their associated Azure Web Sites instance.",
      "pos": [
        41095,
        41168
      ]
    },
    {
      "content": "However, if you want a WebJob to run as only a single instance, you can create a Settings.job file containing the JSON data <bpt id=\"p1\">**</bpt>{ \"is_singleton\": true }<ept id=\"p1\">**</ept>.",
      "pos": [
        41169,
        41322
      ]
    },
    {
      "content": "This forces Azure to only run one instance of the WebJob, even if there are multiple instances of the associated website, which can be a useful technique for scheduled jobs that must run as only a single instance.",
      "pos": [
        41323,
        41536
      ]
    },
    {
      "content": "Related patterns",
      "pos": [
        41541,
        41557
      ]
    },
    {
      "content": "Asynchronous Messaging Primer",
      "pos": [
        41562,
        41591
      ]
    },
    {
      "content": "Autoscaling Guidance",
      "pos": [
        41645,
        41665
      ]
    },
    {
      "content": "Compensating Transaction Pattern",
      "pos": [
        41719,
        41751
      ]
    },
    {
      "content": "Competing Consumers Pattern",
      "pos": [
        41805,
        41832
      ]
    },
    {
      "content": "Compute Partitioning Guidance",
      "pos": [
        41886,
        41915
      ]
    },
    {
      "content": "Compute Resource Consolidation Pattern",
      "pos": [
        41969,
        42007
      ]
    },
    {
      "content": "Gatekeeper Pattern",
      "pos": [
        42061,
        42079
      ]
    },
    {
      "content": "Leader Election Pattern",
      "pos": [
        42133,
        42156
      ]
    },
    {
      "content": "Pipes and Filters Pattern",
      "pos": [
        42210,
        42235
      ]
    },
    {
      "content": "Priority Queue Pattern",
      "pos": [
        42289,
        42311
      ]
    },
    {
      "content": "Queue-Based Load Leveling Pattern",
      "pos": [
        42365,
        42398
      ]
    },
    {
      "content": "Scheduler Agent Supervisor Pattern",
      "pos": [
        42452,
        42486
      ]
    },
    {
      "content": "More information",
      "pos": [
        42541,
        42557
      ]
    },
    {
      "content": "Scaling Azure Applications with Worker Roles",
      "pos": [
        42562,
        42606
      ]
    },
    {
      "content": "Executing Background Tasks",
      "pos": [
        42665,
        42691
      ]
    },
    {
      "pos": [
        42744,
        42872
      ],
      "content": "<bpt id=\"p1\">[</bpt>Azure Role Startup Life Cycle<ept id=\"p1\">](http://blog.syntaxc4.net/post/2011/04/13/windows-azure-role-startup-life-cycle.aspx)</ept> (blog post)"
    },
    {
      "pos": [
        42875,
        43036
      ],
      "content": "<bpt id=\"p1\">[</bpt>Azure Cloud Services Role Lifecycle<ept id=\"p1\">](http://channel9.msdn.com/Series/Windows-Azure-Cloud-Services-Tutorials/Windows-Azure-Cloud-Services-Role-Lifecycle)</ept> (video)"
    },
    {
      "content": "Get Started with the Azure WebJobs SDK",
      "pos": [
        43040,
        43078
      ]
    },
    {
      "content": "Azure Queues and Service Bus Queues - Compared and Contrasted",
      "pos": [
        43125,
        43186
      ]
    },
    {
      "content": "How To Enable Diagnostics in a Cloud Service",
      "pos": [
        43240,
        43284
      ]
    },
    {
      "content": "test",
      "pos": [
        43336,
        43340
      ]
    }
  ],
  "content": "<properties\n   pageTitle=\"Background jobs guidance | Microsoft Azure\"\n   description=\"Guidance on background tasks that run independently of the user interface.\"\n   services=\"\"\n   documentationCenter=\"na\"\n   authors=\"dragon119\"\n   manager=\"masimms\"\n   editor=\"\"\n   tags=\"\"/>\n\n<tags\n   ms.service=\"best-practice\"\n   ms.devlang=\"na\"\n   ms.topic=\"article\"\n   ms.tgt_pltfrm=\"na\"\n   ms.workload=\"na\"\n   ms.date=\"04/28/2015\"\n   ms.author=\"masashin\"/>\n\n# Background jobs guidance\n\n![](media/best-practices-background-jobs/pnp-logo.png)\n\n\n## Overview\n\nMany types of applications require background tasks that run independently of the user interface (UI). Examples include batch jobs, intensive processing tasks, and long running processes such as workflows. Background jobs can be executed without requiring user interaction; the application can start the job and then continue to process interactive requests from users. This can help to minimize the load on the application UI, which can improve availability and reduce interactive response times.\n\nFor example, if an application is required to generate thumbnails of images uploaded by users, it can do this as a background job and save the thumbnail to storage when complete without the user needing to wait for the process to complete. In the same way, a user placing an order can initiate a background workflow that processes the order, while the UI allows the user to continue browsing the website. When the background job is complete, it can update the stored orders data and send an email to the user confirming the order.\n\nWhen considering whether to implement a task as a background job, the main criteria is whether the task can run without user interaction and without the UI needing to wait for the job to complete. Tasks that require the user or the UI to wait while they are completed may not be appropriate as background jobs.\n\n## Types of background jobs\n\nBackground jobs typically have one or more of the following characteristics:\n\n- CPU intensive jobs such as mathematical calculations, structural model analysis, and more.\n- I/O intensive jobs such as executing a series of storage transactions or indexing files.\n- Batch jobs such as nightly data updates or scheduled processing.\n- Long running workflows such as order fulfillment or provisioning services and systems.\n- Sensitive data processing where the task is handed off to a more secure location for processing. For example, you may not want to process sensitive data within a web role, and instead use a pattern such as [Gatekeeper](http://msdn.microsoft.com/library/dn589793.aspx) to transfer the data to an isolated background role that has access to protected storage.\n\n## Triggers\n\nBackground jobs can be initiated in several different ways. Effectively, all of them fall into one of the following categories:\n\n- [**Event driven triggers**](#event-driven-triggers). The task is started in response to an event, typically an action taken by a user or a step in a workflow.\n- [**Schedule driven triggers**](#schedule-driven-triggers). The task is invoked on a schedule based on a timer. This may be a recurring schedule, or a one-off invocation specified for a later time\n\n### Event driven triggers\n\nEvent driven invocation uses a trigger to start the background task. Examples of using event driven triggers include:\n\n- The UI or another job places a message in a queue. The message contains data about an action that has taken place, such as the user placing an order. The background task listens on this queue and detects the arrival of a new message. It reads the message and uses the data in it as the input to the background job.\n- The UI or another job saves or updates a value in storage. The background task monitors the storage and detects changes. It reads the data and uses it as the input to the background job.\n- The UI or another job makes a request to an endpoint, such as an HTTPS URI, or an API exposed as a web service. It passes the data required to complete the background task as part of the request. The endpoint or web service invokes the background task, which uses the data as its input.\n\nTypical examples of tasks suited to event driven invocation include image processing, workflows, sending information to remote services, sending email messages, provisioning new users in multi-tenant applications, and more.\n\n### Schedule driven triggers\n\nSchedule driven invocation uses a timer to start the background task. Examples of using schedule driven triggers include:\n\n- A timer running locally within the application or as part of the application’s operating system invokes a background task on a regular basis.\n- A timer running in a different application, or a timer service such as Azure Scheduler, sends a request to an API or web service on a regular basis. The API or web service invokes the background task.\n- A separate process or application starts a timer that causes the background task to be invoked once after a specified time delay, or at a specific time.\n\nTypical examples of tasks suited to schedule driven invocation include batch processing routines such as updating related products lists for users based on their recent behavior, routine data processing tasks such as updating indexes or generating accumulated results, analyzing data for daily reports, data retention cleanup, data consistency checks, and more.\n\nIf you use a schedule driven task that must run as a single instance, be aware of the following:\n\n- If the compute instance that is running the scheduler (such as a Virtual Machine using Windows Scheduled Tasks) is scaled, you will have multiple instances of the scheduler running and these could start multiple instances of the task.\n- If tasks run for longer than the period between scheduler events, the scheduler may start another instance of the task while the previous one is still running.\n\n## Returning results\n\nBackground jobs execute asynchronously in a separate process, or even a separate location, from the UI or the process that invoked the background task. Ideally, background tasks are “fire and forget” operations, and their execution progress has no impact on the UI or the calling process. This means that the calling process does not wait for completion of the tasks, and therefore cannot automatically detect when the task ends.\nIf you require a background task to communicate with the calling task to indicate progress or completion, you must implement a mechanism for this. Some examples are:\n\n- Write status indicator value to storage that is accessible to the UI or caller task, which can monitor or check this value when required. Other data that the background task must return to the caller can be placed into the same storage.\n- Establish a reply queue that the UI or caller listens on. The background task can send messages to the queue indicating status and completion. Data that the background task must return to the caller can be placed into the messages. If you are using Azure Service Bus, you can use the **ReplyTo** and **CorrelationId** properties to implement this capability. For more information, see [Correlation in Service Bus Brokered Messaging](http://www.cloudcasts.net/devguide/Default.aspx?id=13029).\n- Expose an API or endpoint from the background task that the UI or caller can access to obtain status information. Data that the background task must return to the caller can be included in the response.\n- Have the background task call back to the UI or caller through an API to indicate status at predefined points or on completion. This might be through events raised locally, or through a publish and subscribe mechanism. Data that the background task must return to the caller can be included in the request or event payload.\n\n## Hosting environment\n\nYou can host background tasks using a range of different Azure platform services:\n\n- [**Azure Web Sites**](#azure-web-sites-and-webjobs). You can use WebJobs to execute custom jobs based on a range of different types of script or executable program within the context of the website.\n- [**Azure Cloud Services web and worker roles**](#azure-cloud-services-web-and-worker-roles). You can write code within a role that executes as a background task.\n- [**Azure Virtual Machines**](#azure-virtual-machines). If you have a Windows service or you want to use the Windows Task Scheduler, it is common to host your background tasks within a dedicated virtual machine.\n\nThe following sections describe each of these options in more detail, and include considerations to help you choose the appropriate option.\n\n### Azure Web Sites and WebJobs\n\nYou can use Azure WebJobs to execute custom jobs as background tasks within an Azure Web Sites hosted application. WebJobs can run scripts or executable programs within the context of your website as a continuous process, or in response to a trigger event from Azure Scheduler or external factors such as changes to storage blobs and message queues. Jobs can be started and stopped on demand, and shut down gracefully. If a continuously running WebJob fails, it is automatically restarted. Retry and error actions are configurable.\n\nWhen configuring a WebJob:\n\n- If you want the job to respond to an event driven trigger, it should be configured as **Run continuously**. The script or program is stored in the folder named site/wwwroot/app_data/jobs/continuous.\n- If you want the job to respond to a schedule driven trigger, it should be configured as **Run on a schedule**. The script or program is stored in the folder named site/wwwroot/app_data/jobs/triggered.\n- If you choose the **Run on demand** option when you configure a job, it will execute the same code as the **Run on a schedule** option when you start it.\n\nAzure WebJobs run within the sandbox of the website, which means they can access environment variables, and share information such as connection strings with the website. The job has access to the unique identifier of the machine running the job. The connection string named **AzureJobsStorage** provides access to Azure storage queues, blobs, and tables for application data, and Service Bus for messaging and communication. The connection string named **AzureJobsDashboard** provides access to the job action log files.\n\nAzure WebJobs have the following characteristics:\n\n- **Security**: WebJobs are protected by the deployment credentials of the website.\n- **Supported file types**: WebJobs can be defined using command scripts (.cmd), batch files (.bat), PowerShell scripts (.ps1), bash shell scripts (.sh), PHP scripts (.php), Python scripts (.py), JavaScript code (.js), and executable programs (.exe, .jar, and more).\n- **Deployment**: Scripts and executables can be deployed using the Azure portal, created and deployed by using the [WebJobsVs](https://visualstudiogallery.msdn.microsoft.com/f4824551-2660-4afa-aba1-1fcc1673c3d0) add-in for Visual Studio or the [Visual Studio 2013 Update 4](http://www.visualstudio.com/news/vs2013-update4-rc-vs), by using the [Azure WebJobs SDK](websites-dotnet-webjobs-sdk-get-started.md), or by copying them directly to the following locations:\n  - for triggered execution: site/wwwroot/app_data/jobs/triggered/{job name}\n  - for continuous execution: site/wwwroot/app_data/jobs/continuous/{job name}\n- **Logging**: Console.Out is treated (marked) as INFO and Console.Error as ERROR. Monitoring and diagnostics information can be accessed using the Azure portal, and log files can be downloaded directly from the site. They are saved in the following locations:\n  - for triggered execution: Vfs/data/jobs/continuous/jobName\n  - for continuous execution: Vfs/data/jobs/triggered/jobName\n- **Configuration**: WebJobs can be configured using the portal, the REST API, and PowerShell. A configuration file named settings.job in the same root directory as the job script can be used to provide configuration information for a job. For example:\n  - { \"stopping_wait_time\": 60 }\n  - { \"is_singleton\": true }\n\n### Considerations\n\n- By default, WebJobs scale with the website. However, jobs can be configured to run on single instance by setting the **is_singleton** configuration property to true. Single instance WebJobs are useful for tasks that you do not want to scale or run as simultaneous multiple instances, such as re-indexing, data analysis, and similar tasks.\n- To minimize the impact of jobs on the performance of the website, consider creating an empty Azure Web Sites instance in a new App Service Plan to host WebJobs that may be long running or resource intensive.\n\n### More information\n\n- [Azure WebJobs Recommended Resources](websites-webjobs-resources/) lists the many useful resources, downloads, and samples for WebJobs.\n\n## Azure Cloud Services web and worker roles\n\nBackground tasks can be executed within a web role or in a separate worker role. The decision whether to use a worker role should be based on consideration of scalability and elasticity requirements, task lifetime, release cadence, security, fault tolerance, contention, complexity, and the logical architecture. For more information, see [Compute Resource Consolidation Pattern](http://msdn.microsoft.com/library/dn589778.aspx).\n\nThere are several ways to implement background tasks within a Cloud Services role:\n\n- Create an implementation of the **RoleEntryPoint** class in the role and use its methods to execute background tasks. The tasks run in the context of WaIISHost.exe, and can use the **GetSetting** method of the **CloudConfigurationManager** class to load configuration settings. For more information, see [Lifecycle (Cloud Services)](#lifecycle-cloud-services-).\n- Use startup tasks to execute background tasks when the application starts. To force the tasks to continue to run in the background set the **taskType** property to **background** (if you do not do this, the application startup process will halt and wait for the task to finish). For more information, see [Run Startup Tasks in Azure](http://msdn.microsoft.com/library/azure/hh180155.aspx).\n- Use the WebJobs SDK to implement background tasks as WebJobs that are initiated as a startup task. For more information, see [Get Started with the Azure WebJobs SDK](websites-dotnet-webjobs-sdk-get-started.md).\n- Use a startup task to install a Windows service that executes one or more background tasks. You must set the **taskType** property to **background** so that the service executes in the background. For more information, see [Run Startup Tasks in Azure](http://msdn.microsoft.com/library/azure/hh180155.aspx).\n\n### Running background tasks in the web role\n\nThe main advantage of running background tasks in the web role is the saving in hosting costs because there is no requirement to deploy additional roles.\n\n### Running background tasks in a worker role\n\nRunning background tasks in a worker role has several advantages:\n\n- It allows you to manage scaling separately for each type of role. For example, you may need more instances of a web role to support the current load, but fewer instances of the worker role that executes background tasks. Scaling background task compute instances separately from the UI roles can reduce hosting cost, while maintaining acceptable performance.\n- It offloads the processing overhead for background tasks from the web role. The web role that provides the UI can remain responsive, and it may mean fewer instances are required to support a given volume of requests from users.\n- It allows you to implement separation of concerns. Each role type can implement a specific set of clearly defined and related tasks. This makes designing and maintaining the code easier because there is less interdependence of code and functionality between each role.\n- It can help to isolate sensitive processes and data. For example, web roles that implement the UI do not need to have access to data that is managed and controlled by a worker role. This can be useful in strengthening security, especially when using a pattern such as the [Gatekeeper Pattern](http://msdn.microsoft.com/library/dn589793.aspx).  \n\n### Considerations\n\nConsider the following points when choosing how and where to deploy background tasks when using Cloud Services web and worker roles:\n\n- Hosting background tasks in an existing web role can save the cost of running a separate worker role just for these tasks, but it is likely to affect the performance and availability of the application if there is contention for processing and other resources. Using a separate worker role protects the web role from the impact of long running or resource intensive background tasks.\n- If you host background tasks using the **RoleEntryPoint** class, you can easily move this to another role. For example, if you create the class in a web role and later decide you need to run the tasks in a worker role, you can move the **RoleEntryPoint** class implementation into the worker role.\n- Startup tasks are designed to execute a program or a script. Deploying a background job as an executable program may be more difficult, especially if it also requires deployment of dependent assemblies. It may be easier to deploy and use a script to define a background job when using startup tasks.\n- Exceptions that cause a background task to fail have a different impact depending on the way that they are hosted:\n  - If you use the **RoleEntryPoint** class approach, a failed task will cause the role to restart so that the task automatically restarts. This can affect availability of the application. To prevent this, ensure that you include robust exception handling within the **RoleEntryPoint** class and all the background tasks. Use code to restart tasks that fail where this is appropriate, and throw the exception to restart the role only if you cannot gracefully recover from the failure within your code.\n  - If you use startup tasks, you are responsible for managing the task execution and checking if it fails.\n- Managing and monitoring startup tasks is more difficult than using the **RoleEntryPoint** class approach. However, the Azure WebJobs SDK include a dashboard to make it easier to manage WebJobs that you initiate through startup tasks.\n\n### More information\n\n- [Compute Resource Consolidation Pattern](http://msdn.microsoft.com/library/dn589778.aspx)\n- [Get Started with the Azure WebJobs SDK](websites-dotnet-webjobs-sdk-get-started/)\n\n## Azure Virtual Machines\n\nBackground tasks may be implemented in a way that prevents them from being deployed to Azure Web Sites or Cloud Services, or this may not convenient. Typical examples are Windows services, and third party utilities and executable programs. It may also include programs written for an execution environment different to that hosting the application; for example, it may be a Unix or Linux program that you want to execute from a Windows or .NET application. You can choose from a range of operating systems for an Azure virtual machine, and run your service or executable on that virtual machine.\n\nTo help you choose when to use Virtual Machines, see [Azure Websites, Cloud Services and Virtual Machines comparison](choose-web-site-cloud-service-vm.md). For information about the options for [Virtual Machines, see Virtual Machine and Cloud Service Sizes for Azure](http://msdn.microsoft.com/library/azure/dn197896.aspx). For more information about the operating systems and pre-built images available for Virtual Machines, see [Azure Virtual Machines Gallery](http://azure.microsoft.com/gallery/virtual-machines/).\n\nTo initiate the background task in a separate virtual machine, you have a range of options:\n\n- You can execute the task on demand directly from your application by sending a request to an endpoint that the task exposes, passing in any data that the task requires. This endpoint invokes the task.\n- You can configure the task to run on a schedule using a scheduler or timer available in your chosen operating system. For example, on Windows you can use Windows Task Scheduler to execute scripts and tasks or, if you have SQL Server installed on the virtual machine, you can use the SQL Server Agent to execute scripts and tasks.\n- You can use Azure Scheduler to initiate the task by adding a message to a queue that the task listens on, or by sending a request to an API that the task exposes.\n\nSee the earlier section [Triggers](#triggers) for more information about how you can initiate background tasks.  \n\n### Considerations\n\nConsider the following points when deciding whether to deploy background tasks in an Azure virtual machine:\n\n- Hosting background tasks in a separate Azure virtual machine provides flexibility and allows precise control over initiation, execution, scheduling, and resource allocation. However, it will increase runtime cost if a virtual machine must be deployed just to run background tasks.\n- There is no facility to monitor the tasks in the Azure portal, and no automated restart capability for failed tasks, although you can monitor the basic status of the virtual machine and manage it using the [Azure Service Management Cmdlets](http://msdn.microsoft.com/library/azure/dn495240.aspx). However, there are no facilities to control processes and threads in compute nodes. Typically, using a virtual machine will require additional effort to implement a mechanism that collects data from instrumentation in the task, and from the operating system in the virtual machine. One solution that may be appropriate is to use the [System Center Management Pack for Azure](http://technet.microsoft.com/library/gg276383.aspx).\n- You might consider creating monitoring probes that are exposed through HTTP endpoints. The code for these probes could perform health checks, collect operational information and statistics, or collate error information, and return it to a management application. For more information, see [Health Endpoint Monitoring Pattern](http://msdn.microsoft.com/library/dn589789.aspx).\n\n### More information\n\n- [Virtual Machines](http://azure.microsoft.com/services/virtual-machines/) on the Azure website\n- [Azure Virtual Machines FAQ](http://msdn.microsoft.com/library/azure/dn683781.aspx)\n\n## Design considerations\n\nThere are several fundamental factors to consider when designing background tasks. The following sections discuss partitioning, conflicts, and coordination.\n\n## Partitioning\n\nIf you decide to include background tasks within an existing compute instance (such as a website, web role, existing worker role, or virtual machine), you must consider how this will affect the quality attributes of the compute instance and the background task itself. These factors will help you to decide whether to co-locate the tasks with the existing compute instance, or separate them out into a separate compute instance:\n\n- **Availability**: Background tasks may not need to have the same level of availability as other parts of the application, in particular the UI and other parts directly involved in user interaction. Background tasks may be more tolerant of latency, retried connection failures, and other factors that affect availability because the operations can be queued. However, there must be sufficient capacity to prevent backing up of requests that could block queues and affect the application as a whole.\n- **Scalability**: Background tasks are likely to have a different scalability requirement to the UI and the interactive parts of the application. Scaling the UI may be necessary to meet peaks in demand, while outstanding background tasks could be completed during less busy times by a fewer number of compute instances.\n- **Resiliency**: Failure of a compute instance that just hosts background tasks may not fatally affect the application as a whole if the requests for these tasks can be queued or postponed until the task is available again. If the compute instance and/or tasks can be restarted within an appropriate interval, users of the application may not be affected.\n- **Security**: Background tasks may have different security requirements or restrictions than the UI or other parts of the application. By using a separate compute instance, you can specify a different security environment for the tasks. You can also use patterns such as Gatekeeper to isolate the background compute instances from the UI in order to maximize security and separation.\n- **Performance**: You can choose the type of compute instance for background tasks to specifically match the performance requirements of the tasks. This may mean using a less expensive compute option if the tasks do not require the same processing capabilities as the UI, or a larger instance if they require additional capacity and resources.\n- **Manageability**: Background tasks may have a different development and deployment rhythm from the main application code or the UI. Deploying them to a separate compute instance can simplify updates and versioning.\n- **Cost**: Adding compute instances to execute background tasks increases hosting costs. You should carefully consider the trade-off between additional capacity and these extra costs.\n\nFor more information, see [Leader Election pattern](http://msdn.microsoft.com/library/dn568104.aspx) and [Competing Consumers pattern](http://msdn.microsoft.com/library/dn568101.aspx).\n\n## Conflicts\n\nIf you have multiple instances of a background job, it is possible that they will compete for access to resources and services such as databases and storage. This concurrent access can result in resource contention, which may cause conflicts in availability of the services and in the integrity of data in storage. Resource contention can be resolved by using a pessimistic locking approach to prevent competing instances of a task from concurrently accessing a service, or corrupting data.\n\nAnother approach to resolve conflicts is to define background tasks as a singleton, so that there is only ever one instance running. However, this eliminates the reliability and performance benefits that a multiple-instance configuration could provide, especially if the UI can supply sufficient work to keep more than one background task busy. It is vital to ensure that the background task can automatically restart, and that it has sufficient capacity to cope with peaks in demand. This may be achieved by allocating a compute instance with sufficient resources, by implementing a queueing mechanism that can store requests for later execution when demand decreases, or by a combination of these techniques.\n\n## Coordination\n\nThe background tasks may be complex, and require multiple individual tasks to execute to produce a result or to fulfil all the requirements. It is common in these scenarios to divide the task into smaller discreet steps or subtasks that can be executed by multiple consumers. Multi-step jobs can be more efficient and more flexible because individual steps may be reusable in multiple jobs. It is also easy to add, remove, or modify the order of the steps.\n\nCoordinating multiple tasks and steps can be challenging, but there are three common patterns you can use to guide your implementation of a solution:\n\n- **Decomposing a task into multiple reusable steps**. An application may be required to perform a variety of tasks of varying complexity on the information that it processes. A straightforward but inflexible approach to implementing this application could be to perform this processing as monolithic module. However, this approach is likely to reduce the opportunities for refactoring the code, optimizing it, or reusing it if parts of the same processing are required elsewhere within the application. For more information, see [Pipes and Filters Pattern](http://msdn.microsoft.com/library/dn568100.aspx).\n- **Managing execution of the steps for a task**. An application may perform tasks that comprise a number of steps, some of which may invoke remote services or access remote resources. The individual steps may be independent of each other, but they are orchestrated by the application logic that implements the task. For more information, see [Scheduler Agent Supervisor Pattern](http://msdn.microsoft.com/library/dn589780.aspx).\n- **Managing recovery for steps of a task that fail**. An application may need to undo the work performed by a series of steps, which together define an eventually consistent operation, if one or more of the steps fail. For more information, see [Compensating Transaction Pattern](http://msdn.microsoft.com/library/dn589804.aspx).\n\n## Lifecycle (Cloud Services)\n\n If you decide to implement background jobs for Cloud Services applications that use web and worker roles by using the **RoleEntryPoint** class, it is important to understand the lifecycle of this class in order to use it correctly.\n\nWeb and worker roles go through a set of distinct phases as they start, run, and stop. The **RoleEntryPoint** class exposes a series of events that indicate when these stages are occurring. You use these to initialize, run, and stop your custom background tasks. The complete cycle is:\n\n- Azure loads the role assembly and searches it for a class that derives from **RoleEntryPoint**.\n- If it finds this class, it calls **RoleEntryPoint.OnStart()**. You override this method to initialize your background tasks.\n- After the **OnStart** method completes, Azure calls **Application_Start()** in the application’s Global file if this is present (for example, Global.asax in a web role running ASP.NET).\n- Azure calls **RoleEntryPoint.Run()** on a new foreground thread that executes in parallel with **OnStart()**. You override this method to start your background tasks.\n- When the Run method ends, Azure first calls **Application_End()** in the application’s Global file if this is present, and then calls **RoleEntryPoint.OnStop()**. You override the **OnStop** method to stop your background tasks, clean up resources, dispose of objects, and close connections that the tasks may have used.\n- The Azure worker role host process is stopped. At this point, the role will be recycled and will restart.\n\nFor more details and an example of using the methods of the **RoleEntryPoint** class, see [Compute Resource Consolidation Pattern](http://msdn.microsoft.com/library/dn589778.aspx).\n\n## Considerations\n\nConsider the following points when planning how you will run background tasks in a web or worker role:\n\n- The default **Run** method implementation in the **RoleEntryPoint** class contains a call to **Thread.Sleep(Timeout.Infinite)** that keeps the role alive indefinitely. If you override the **Run** method (which is typically necessary to execute background tasks) you must not allow your code to exit from the method unless you want to recycle the role instance.\n- A typical implementation of the **Run** method includes code to start each of the background tasks, and a loop construct that periodically checks the state of all the background tasks. It can restart any that fail, or monitor for cancellation tokens that indicate jobs have completed.\n- If a background task throws an unhandled exception, that task should be recycled while allowing any other background tasks in the role to continue running. However, if the exception is caused by corruption of objects outside the task, such as shared storage, the exception should be handled by your **RoleEntryPoint** class, all tasks should be cancelled, and the **Run** method allowed to end. Azure will then restart the role.\n- Use the **OnStop** method to pause or kill background tasks and clean up resources. This may involve stopping long-running or multi-step tasks, and it is vital to consider how this can be done to avoid data inconsistencies. If a role instance stops for any reason other than a user-initiated shutdown, the code running in the **OnStop** method must complete within five minutes before it is forcibly terminated. Ensure that your code can complete in that time, or can tolerate not running to completion.  \n- The Azure load balancer starts directing traffic to the role instance when the **RoleEntryPoint.OnStart** method returns true. Therefore, consider putting all your initialization code in the **OnStart** method so that role instances that do not successfully initialize will not receive any traffic.\n- You can use startup tasks in addition to the methods of the **RoleEntryPoint** class. You should use startup tasks to initialize any settings you need to change in the Azure load balancer because these tasks will execute before the role receives any requests. For more information, see [Run Startup Tasks in Azure](http://msdn.microsoft.com/library/azure/hh180155.aspx).\n- If there is an error in a startup task, it may force the role to continually restart. This can prevent you from performing a VIP swap back to a previously staged version because the swap requires exclusive access to the role, and this cannot be obtained while the role is restarting. To resolve this:\n    -  Add the following code to the beginning of the **OnStart** and **Run** methods in your role:\n\n    ```C#\n    var freeze = CloudConfigurationManager.GetSetting(\"Freeze\");\n    if (freeze != null)\n    {\n        if (Boolean.Parse(freeze))\n        {\n            Thread.Sleep(System.Threading.Timeout.Infinite);\n        }\n    }\n    ```\n\n   - Add the definition of the **Freeze** setting as a Boolean value to the ServiceDefinition.csdef and ServiceConfiguration.*.cscfg files for the role and set it to **false**. If the role goes into a repeated restart mode, you can change the setting to **true** to freeze role execution and allow it to be swapped with a previous version.\n\n## Resiliency considerations\n\nBackground tasks must be resilient in order to provide reliable services to the application. When planning and designing background tasks, consider the following points:\n\n- Background tasks must be able to gracefully handle role or service restarts without corrupting data or introducing inconsistency into the application. For long-running or multi-step tasks, consider using _check pointing_ by saving the state of jobs in persistent storage, or as messages in a queue if this is appropriate. For example, you can persist state information in a message in a queue and incrementally update this state information with the task progress so that the task can be processed from the last known good checkpoint instead of restarting from the beginning. When using Azure Service Bus queues, you can use message sessions to enable the same scenario. Sessions allow you to save and retrieve the application processing state by using the [SetState](http://msdn.microsoft.com/library/microsoft.servicebus.messaging.messagesession.setstate.aspx) and [GetState](http://msdn.microsoft.com/library/microsoft.servicebus.messaging.messagesession.getstate.aspx) methods. For more information about designing reliable multi-step processes and workflows, see [Scheduler Agent Supervisor Pattern](http://msdn.microsoft.com/library/dn589780.aspx).\n- When using web or worker roles to host multiple background tasks, design your override of the **Run** method to monitor for failed or stalled tasks, and restart them. Where this is not practical, and you are using a worker role, force the worker role to restart by exiting from the **Run** method.\n- When using queues to communicate with background tasks, the queues can act as a buffer to store requests sent to the tasks while the application is under higher than usual load. This allows the tasks to catch up with the UI during less busy periods. It also means that recycling the role will not block the UI. For more information, see [Queue-Based Load Leveling Pattern](http://msdn.microsoft.com/library/dn589783.aspx). If some tasks are more important than others, consider implementing the [Priority Queue Pattern](http://msdn.microsoft.com/library/dn589794.aspx) to ensure that these tasks run before less important ones.\n- Background tasks that are initiated by, or otherwise process messages must be designed to handle inconsistencies such as messages arriving out of order, messages that repeatedly cause an error (often referred to as _poison messages_), and messages that are delivered more than once. Consider the following:\n  - Messages that must be processed in a specific order, such as those that change data based on its existing value (for example, adding a value to an existing value), may not arrive in the original order they were sent. Alternatively, they may be handled by different instances of a background task in a different order due to varying loads on each instance. Messages that must be processed in a specific order should include a sequence number, key, or some other indicator that background tasks can use to ensure they are processed in the correct order. If you are using Azure Service Bus, you can use message sessions to guarantee the order of delivery. However, it is usually more efficient where possible to design the process so that the message order is not important.\n  - Typically, a background task will peek messages in the queue, which temporarily hides them from other message consumers, and then delete the messages after they have been successfully processed. If a background task fails when processing a message, that message will reappear on the queue after the peek timeout expires, and will be processed by another instance of the task or during the next processing cycle of this instance. If the message consistently causes an error in the consumer, it will block the task, the queue, and eventually the application itself when the queue becomes full. Therefore, it is vital to detect and remove poison messages from the queue. If you are using Azure Service Bus, messages that cause an error can be moved automatically or manually to an associated dead letter queue.\n  - Queues are guaranteed at _least once_ delivery mechanisms, but they may deliver the same message more than once. In addition, if a background task fails after processing a message but before deleting it from the queue, the message will become available for processing again. Background tasks should be idempotent, which means that processing the same message more than once does not cause an error or inconsistency in the application’s data. Some operations are naturally idempotent, such as setting a stored value to a specific new value. However, operations such as adding a value to an existing stored value without checking that the stored value is still the same as when the message was originally sent will cause inconsistencies.  Azure Service Bus queues can be configured to automatically remove duplicated messages.\n  - Some messaging systems, such as Azure storage queues and Azure Service Bus queues, support a de-queue count property that indicates the number of times a message has been read from the queue. This can be useful in handling repeated and poison messages. For more information, see [Asynchronous Messaging Primer](http://msdn.microsoft.com/library/dn589781.aspx) and [Idempotency Patterns](http://blog.jonathanoliver.com/2010/04/idempotency-patterns/).\n\n## Scaling and performance considerations\n\nBackground tasks must offer sufficient performance to ensure they do not block the application, or cause inconsistencies due to delayed operation when the system is under load. Typically, performance is improved by scaling the compute instances that host the background tasks. When planning and designing background tasks, consider the following points around scalability and performance:\n\n- Azure supports autoscaling (both scaling out and scaling back in) based on current demand and load, or on a predefined schedule, for Web Sites, Cloud Services web and worker roles, and Virtual Machines hosted deployments. Use this feature to ensure the application as a whole has sufficient performance capabilities while minimizing runtime costs.\n- Where background tasks have a different performance capability from the other parts of a Cloud Services application (for example, the UI or components such as the data access layer), hosting the background tasks together in a separate worker role allows the UI and background task roles to scale independently to manage the load. If multiple background tasks have significantly different performance capabilities from each other, consider dividing them into separate worker roles and scaling each role type independently, but note that this may increase runtime costs compared to combining all the tasks into fewer roles.\n- Simply scaling the roles may not be sufficient to prevent loss of performance under load. You may also need to scale storage queues and other resources to prevent a single point of the overall processing chain becoming a bottleneck. Also, consider other limitations, such as the maximum throughput of storage and other services the application and the background tasks rely on.\n- Background tasks must be designed for scaling. For example, they must be able to dynamically detect the number of storage queues in use in order to listen on or send messages to the appropriate queue.\n- By default, WebJobs scale with their associated Azure Web Sites instance. However, if you want a WebJob to run as only a single instance, you can create a Settings.job file containing the JSON data **{ \"is_singleton\": true }**. This forces Azure to only run one instance of the WebJob, even if there are multiple instances of the associated website, which can be a useful technique for scheduled jobs that must run as only a single instance.\n\n## Related patterns\n\n- [Asynchronous Messaging Primer](http://msdn.microsoft.com/library/dn589781.aspx)\n- [Autoscaling Guidance](http://msdn.microsoft.com/library/dn589774.aspx)\n- [Compensating Transaction Pattern](http://msdn.microsoft.com/library/dn589804.aspx)\n- [Competing Consumers Pattern](http://msdn.microsoft.com/library/dn568101.aspx)\n- [Compute Partitioning Guidance](http://msdn.microsoft.com/library/dn589773.aspx)\n- [Compute Resource Consolidation Pattern](http://msdn.microsoft.com/library/dn589778.aspx)\n- [Gatekeeper Pattern](http://msdn.microsoft.com/library/dn589793.aspx)\n- [Leader Election Pattern](http://msdn.microsoft.com/library/dn568104.aspx)\n- [Pipes and Filters Pattern](http://msdn.microsoft.com/library/dn568100.aspx)\n- [Priority Queue Pattern](http://msdn.microsoft.com/library/dn589794.aspx)\n- [Queue-Based Load Leveling Pattern](http://msdn.microsoft.com/library/dn589783.aspx)\n- [Scheduler Agent Supervisor Pattern](http://msdn.microsoft.com/library/dn589780.aspx)\n\n## More information\n\n- [Scaling Azure Applications with Worker Roles](http://msdn.microsoft.com/library/hh534484.aspx#sec8)\n- [Executing Background Tasks](http://msdn.microsoft.com/library/ff803365.aspx)\n- [Azure Role Startup Life Cycle](http://blog.syntaxc4.net/post/2011/04/13/windows-azure-role-startup-life-cycle.aspx) (blog post)\n- [Azure Cloud Services Role Lifecycle](http://channel9.msdn.com/Series/Windows-Azure-Cloud-Services-Tutorials/Windows-Azure-Cloud-Services-Role-Lifecycle) (video)\n- [Get Started with the Azure WebJobs SDK](websites-dotnet-webjobs-sdk-get-started/)\n- [Azure Queues and Service Bus Queues - Compared and Contrasted](http://msdn.microsoft.com/library/hh767287.aspx)\n- [How To Enable Diagnostics in a Cloud Service](http://msdn.microsoft.com/library/dn482131.aspx)\n\ntest\n"
}