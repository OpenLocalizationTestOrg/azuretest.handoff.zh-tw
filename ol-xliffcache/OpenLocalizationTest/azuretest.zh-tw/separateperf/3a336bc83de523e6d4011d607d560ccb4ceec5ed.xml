{
  "nodes": [
    {
      "content": "Best practices for designing Azure Resource Manager templates",
      "pos": [
        27,
        88
      ]
    },
    {
      "content": "Show design patterns for Azure Resource Manager templates",
      "pos": [
        107,
        164
      ]
    },
    {
      "content": "Best practices for designing Azure Resource Manager templates",
      "pos": [
        493,
        554
      ]
    },
    {
      "content": "In our work with enterprises, system integrator (SIs), cloud service vendor (CSVs), and open source software (OSS) project teams, it's often necessary to quickly",
      "pos": [
        556,
        717
      ]
    },
    {
      "content": "deploy environments, workloads, or scale units.",
      "pos": [
        719,
        766
      ]
    },
    {
      "content": "These deployments need to be supported, follow proven practices, and adhere to identified policies.",
      "pos": [
        767,
        866
      ]
    },
    {
      "content": "Using a flexible",
      "pos": [
        867,
        883
      ]
    },
    {
      "content": "approach based on Azure Resource Manager templates, you can deploy complex topologies quickly and consistently and then adapt these deployments easily as",
      "pos": [
        885,
        1038
      ]
    },
    {
      "content": "core offerings evolve or to accommodate variants for outlier scenarios or customers.",
      "pos": [
        1040,
        1124
      ]
    },
    {
      "content": "This topic is part of a larger whitepaper.",
      "pos": [
        1126,
        1168
      ]
    },
    {
      "content": "To read the full paper, download [World Class ARM Templates Considerations and Proven Practices](http://download.microsoft.com/download/8/E/1/8E1DBEFA-CECE-4DC9-A813-93520A5D7CFE/World Class ARM Templates - Considerations and Proven Practices.pdf).",
      "pos": [
        1169,
        1417
      ]
    },
    {
      "content": "Templates combine the benefits of the underlying Azure Resource Manager with the adaptability and readability of JavaScript Object Notation (JSON).",
      "pos": [
        1419,
        1566
      ]
    },
    {
      "content": "Using",
      "pos": [
        1567,
        1572
      ]
    },
    {
      "content": "templates, you can:",
      "pos": [
        1574,
        1593
      ]
    },
    {
      "content": "Deploy topologies and their workloads consistently.",
      "pos": [
        1597,
        1648
      ]
    },
    {
      "content": "Manage all your resources in an application together using resource groups.",
      "pos": [
        1651,
        1726
      ]
    },
    {
      "content": "Apply role-based access control (RBAC) to grant appropriate access to users, groups, and services.",
      "pos": [
        1729,
        1827
      ]
    },
    {
      "content": "Use tagging associations to streamline tasks such as billing rollups.",
      "pos": [
        1830,
        1899
      ]
    },
    {
      "content": "This article provides details on consumption scenarios, architecture, and implementation patterns identified during our design sessions and real-world template",
      "pos": [
        1901,
        2060
      ]
    },
    {
      "content": "implementations with Azure Customer Advisory Team (AzureCAT) customers.",
      "pos": [
        2062,
        2133
      ]
    },
    {
      "content": "Far from academic, these are proven practices informed by the development of templates",
      "pos": [
        2134,
        2220
      ]
    },
    {
      "content": "for 12 of the top Linux-based OSS technologies, including: Apache Kafka, Apache Spark, Cloudera, Couchbase, Hortonworks HDP, DataStax Enterprise powered by",
      "pos": [
        2222,
        2377
      ]
    },
    {
      "content": "Apache Cassandra, Elasticsearch, Jenkins, MongoDB, Nagios, PostgreSQL, Redis, and Nagios.",
      "pos": [
        2379,
        2468
      ]
    },
    {
      "content": "The majority of these templates were developed with a well-known vendor of",
      "pos": [
        2469,
        2543
      ]
    },
    {
      "content": "a given distribution and influenced by the requirements of Microsoft’s enterprise and SI customers during recent projects.",
      "pos": [
        2545,
        2667
      ]
    },
    {
      "content": "This article shares these proven practices to help you architect world class Azure Resource Manager templates.",
      "pos": [
        2669,
        2779
      ]
    },
    {
      "content": "In our work with customers, we have identified a number of Resource Manager template consumption experiences across enterprises, System Integrators (SI)s, and CSVs.",
      "pos": [
        2783,
        2947
      ]
    },
    {
      "content": "The following sections provides a high-level overview of common scenarios and patterns for different customer types.",
      "pos": [
        2949,
        3065
      ]
    },
    {
      "content": "Enterprises and system integrators",
      "pos": [
        3070,
        3104
      ]
    },
    {
      "content": "Within large organizations, we commonly see two consumers of ARM templates: internal software development teams and corporate IT.",
      "pos": [
        3106,
        3235
      ]
    },
    {
      "content": "The scenarios for the",
      "pos": [
        3236,
        3257
      ]
    },
    {
      "content": "SIs we’ve worked with have mapped to those of Enterprises, so the same considerations apply.",
      "pos": [
        3259,
        3351
      ]
    },
    {
      "content": "Internal software development teams",
      "pos": [
        3357,
        3392
      ]
    },
    {
      "content": "If your team develops software to support your business, templates provide an easy way to quickly deploy technologies for use in business-specific solutions.",
      "pos": [
        3394,
        3551
      ]
    },
    {
      "content": "You can also use templates to rapidly create training environments that enable team members to gain necessary skills.",
      "pos": [
        3553,
        3670
      ]
    },
    {
      "content": "You can use templates as-is or extend or compose them to accommodate your needs.",
      "pos": [
        3672,
        3752
      ]
    },
    {
      "content": "Using tagging within templates, you can provide a billing summary with",
      "pos": [
        3753,
        3823
      ]
    },
    {
      "content": "various views such as team, project, individual, and education.",
      "pos": [
        3825,
        3888
      ]
    },
    {
      "content": "Businesses often want software development teams to create a template for consistent deployment of a solution while also offering constraints so certain",
      "pos": [
        3890,
        4042
      ]
    },
    {
      "content": "items within that environment remain fixed and can’t be overridden.",
      "pos": [
        4044,
        4111
      ]
    },
    {
      "content": "For example, a bank might require a template to include RBAC so a programmer can’t revise a",
      "pos": [
        4112,
        4203
      ]
    },
    {
      "content": "banking solution to send data to a personal storage account.",
      "pos": [
        4205,
        4265
      ]
    },
    {
      "content": "Corporate IT",
      "pos": [
        4271,
        4283
      ]
    },
    {
      "content": "Corporate IT organizations typically use templates for delivering cloud capacity and cloud-hosted capabilities.",
      "pos": [
        4285,
        4396
      ]
    },
    {
      "content": "Cloud capacity",
      "pos": [
        4403,
        4417
      ]
    },
    {
      "content": "A common way for corporate IT groups to provide cloud capacity for teams within their organization is with “t-shirt sizes”, which are standard offering sizes",
      "pos": [
        4419,
        4576
      ]
    },
    {
      "content": "such as small, medium, and large.",
      "pos": [
        4578,
        4611
      ]
    },
    {
      "content": "The t-shirt sized offerings can mix different resource types and quantities while providing a level of standardization that",
      "pos": [
        4612,
        4735
      ]
    },
    {
      "content": "makes it possible to use templates.",
      "pos": [
        4737,
        4772
      ]
    },
    {
      "content": "The templates deliver capacity in a consistent way that enforces corporate policies and uses tagging to provide",
      "pos": [
        4773,
        4884
      ]
    },
    {
      "content": "chargeback to consuming organizations.",
      "pos": [
        4886,
        4924
      ]
    },
    {
      "content": "For example, you may need to provide development, test, or production environments within which the software development teams can deploy their solutions.",
      "pos": [
        4926,
        5080
      ]
    },
    {
      "content": "The environment has a predefined network topology and elements which the software development teams cannot change, such as rules governing access to the public",
      "pos": [
        5082,
        5241
      ]
    },
    {
      "content": "internet and packet inspection.",
      "pos": [
        5243,
        5274
      ]
    },
    {
      "content": "You may also have organization-specific roles for these environments with distinct access rights for the environment.",
      "pos": [
        5275,
        5392
      ]
    },
    {
      "content": "Cloud-hosted capabilities",
      "pos": [
        5399,
        5424
      ]
    },
    {
      "content": "You can use templates to support cloud-hosted capabilities, including individual software packages or composite offerings that are offered to internal lines",
      "pos": [
        5426,
        5582
      ]
    },
    {
      "content": "of business.",
      "pos": [
        5584,
        5596
      ]
    },
    {
      "content": "An example of a composite offering would be analytics-as-a-service—analytics, visualization, and other technologies—delivered in an optimized,",
      "pos": [
        5597,
        5739
      ]
    },
    {
      "content": "connected configuration on a predefined network topology.",
      "pos": [
        5741,
        5798
      ]
    },
    {
      "content": "Cloud-hosted capabilities are affected by the security and role considerations established by the cloud capacity offering on which they’re built as described above.",
      "pos": [
        5800,
        5964
      ]
    },
    {
      "content": "These capabilities are offered as is or as a managed service.",
      "pos": [
        5965,
        6026
      ]
    },
    {
      "content": "For the latter, access-constrained roles are required to enable access into the environment for",
      "pos": [
        6027,
        6122
      ]
    },
    {
      "content": "management purposes.",
      "pos": [
        6124,
        6144
      ]
    },
    {
      "content": "Cloud service vendors",
      "pos": [
        6149,
        6170
      ]
    },
    {
      "content": "After talking to many CSVs, we have identified multiple approaches you can take to deploy services for your customers and associated requirements.",
      "pos": [
        6172,
        6318
      ]
    },
    {
      "content": "CSV-hosted offering",
      "pos": [
        6324,
        6343
      ]
    },
    {
      "content": "If you host your offering in your own Azure subscription, two hosting approaches are common: deploying a distinct deployment for every customer or deploying",
      "pos": [
        6345,
        6501
      ]
    },
    {
      "content": "scale units that underpin a shared infrastructure used for all customers.",
      "pos": [
        6503,
        6576
      ]
    },
    {
      "content": "Distinct deployments for each customer.",
      "pos": [
        6582,
        6621
      ]
    },
    {
      "content": "Distinct deployments per customer require fixed topologies of different known configurations.",
      "pos": [
        6624,
        6717
      ]
    },
    {
      "content": "These may have different",
      "pos": [
        6718,
        6742
      ]
    },
    {
      "content": "virtual machine (VM) sizes, varying numbers of nodes, and different amounts of associated storage.",
      "pos": [
        6744,
        6842
      ]
    },
    {
      "content": "Tagging of deployments is used for roll-up billing of each customer.",
      "pos": [
        6843,
        6911
      ]
    },
    {
      "content": "RBAC may be enabled to allow customers access to aspects of their cloud environment.",
      "pos": [
        6913,
        6997
      ]
    },
    {
      "content": "Scale units in shared multi-tenant environments.",
      "pos": [
        7002,
        7050
      ]
    },
    {
      "content": "A template can represent a scale unit for multi-tenant environments.",
      "pos": [
        7053,
        7121
      ]
    },
    {
      "content": "In this case, the same infrastructure",
      "pos": [
        7122,
        7159
      ]
    },
    {
      "content": "is used to support all customers.",
      "pos": [
        7161,
        7194
      ]
    },
    {
      "content": "The deployments represent a group of resources that deliver a level of capacity for the hosted offering, such as number of users",
      "pos": [
        7195,
        7323
      ]
    },
    {
      "content": "and number of transactions.",
      "pos": [
        7325,
        7352
      ]
    },
    {
      "content": "These scale units are increased or decreased as demand requires.",
      "pos": [
        7353,
        7417
      ]
    },
    {
      "content": "CSV offering injected into customer subscription",
      "pos": [
        7423,
        7471
      ]
    },
    {
      "content": "You may want to deploy your software into subscriptions owned by end customers.",
      "pos": [
        7473,
        7552
      ]
    },
    {
      "content": "You can use templates to deploy distinct deployments into a customer’s Azure account.",
      "pos": [
        7553,
        7638
      ]
    },
    {
      "content": "These deployments use RBAC so you can update and manage the deployment within the customer’s account.",
      "pos": [
        7640,
        7741
      ]
    },
    {
      "content": "Azure Marketplace",
      "pos": [
        7747,
        7764
      ]
    },
    {
      "content": "If you want to advertise and sell your offerings through a marketplace, such as Azure Marketplace, you can develop templates to deliver distinct types of",
      "pos": [
        7766,
        7919
      ]
    },
    {
      "content": "deployments that will run in a customer’s Azure account.",
      "pos": [
        7921,
        7977
      ]
    },
    {
      "content": "This distinct deployments can be typically described as a t-shirt size (small, medium, large),",
      "pos": [
        7978,
        8072
      ]
    },
    {
      "content": "product/audience type (community, developer, enterprise), or feature type (basic, high availability).",
      "pos": [
        8074,
        8175
      ]
    },
    {
      "content": "In some cases, these types will allow you to specify",
      "pos": [
        8177,
        8229
      ]
    },
    {
      "content": "certain attributes of the deployment, such as VM type or number of disks.",
      "pos": [
        8231,
        8304
      ]
    },
    {
      "content": "OSS projects",
      "pos": [
        8309,
        8321
      ]
    },
    {
      "content": "Within open source projects, Resource Manager templates enable a community to deploy a solution quickly using proven practices.",
      "pos": [
        8323,
        8450
      ]
    },
    {
      "content": "You can store templates in a",
      "pos": [
        8451,
        8479
      ]
    },
    {
      "content": "GitHub repository so the community can revise them over time.",
      "pos": [
        8481,
        8542
      ]
    },
    {
      "content": "End users can then deploy these templates in their own Azure subscriptions.",
      "pos": [
        8543,
        8618
      ]
    },
    {
      "content": "The following sections identify the things you need to consider before designing your solution.",
      "pos": [
        8620,
        8715
      ]
    },
    {
      "content": "Identifying what is outside and inside of a VM",
      "pos": [
        8720,
        8766
      ]
    },
    {
      "content": "As you design your template, it’s helpful to look at the requirements in terms of what’s outside and inside of the virtual machines (VMs):",
      "pos": [
        8768,
        8906
      ]
    },
    {
      "content": "Outside means the VMs and other resources of your deployment, such as the network topology, tagging, references to the certs/secrets, and role-based access control.",
      "pos": [
        8910,
        9074
      ]
    },
    {
      "content": "All of these resources are part of your template.",
      "pos": [
        9075,
        9124
      ]
    },
    {
      "content": "Inside means the installed software and overall desired state configuration.",
      "pos": [
        9127,
        9203
      ]
    },
    {
      "content": "Other mechanisms, such as VM extensions or scripts, are used in whole or in part.",
      "pos": [
        9204,
        9285
      ]
    },
    {
      "content": "These mechanisms may be identified and executed by the template but aren’t in it.",
      "pos": [
        9286,
        9367
      ]
    },
    {
      "content": "Common examples of activities you would do “inside the box” include -",
      "pos": [
        9369,
        9438
      ]
    },
    {
      "content": "Install or remove server roles and features",
      "pos": [
        9444,
        9487
      ]
    },
    {
      "content": "Install and configure software at the node or cluster level",
      "pos": [
        9490,
        9549
      ]
    },
    {
      "content": "Deploy websites on a web server",
      "pos": [
        9552,
        9583
      ]
    },
    {
      "content": "Deploy database schemas",
      "pos": [
        9586,
        9609
      ]
    },
    {
      "content": "Manage registry or other types of configuration settings",
      "pos": [
        9612,
        9668
      ]
    },
    {
      "content": "Manage files and directories",
      "pos": [
        9671,
        9699
      ]
    },
    {
      "content": "Start, stop, and manage processes and services",
      "pos": [
        9702,
        9748
      ]
    },
    {
      "content": "Manage local groups and user accounts",
      "pos": [
        9751,
        9788
      ]
    },
    {
      "content": "Install and manage packages (.msi, .exe, yum, etc.)",
      "pos": [
        9791,
        9842
      ]
    },
    {
      "content": "Manage environment variables",
      "pos": [
        9845,
        9873
      ]
    },
    {
      "content": "Run native scripts (Windows PowerShell, bash, etc.)",
      "pos": [
        9876,
        9927
      ]
    },
    {
      "content": "Desired state configuration (DSC)",
      "pos": [
        9933,
        9966
      ]
    },
    {
      "content": "Thinking about the internal state of your VMs beyond deployment, you’ll want to make sure this deployment doesn’t “drift” from the configuration that you have",
      "pos": [
        9968,
        10126
      ]
    },
    {
      "content": "defined and checked into source control.",
      "pos": [
        10128,
        10168
      ]
    },
    {
      "content": "This ensures your developers or operations staff don’t manually make ad-hoc changes to an environment that are not vetted,",
      "pos": [
        10169,
        10291
      ]
    },
    {
      "content": "tested or recorded in source control.",
      "pos": [
        10293,
        10330
      ]
    },
    {
      "content": "This is important, because the manual changes are not in source control, they are also not part of the standard deployment",
      "pos": [
        10331,
        10453
      ]
    },
    {
      "content": "and will impact future automated deployments of the software.",
      "pos": [
        10455,
        10516
      ]
    },
    {
      "content": "Beyond your internal employees, desired state configuration is also important from a security perspective.",
      "pos": [
        10518,
        10624
      ]
    },
    {
      "content": "Hackers are regularly trying to compromise and exploit",
      "pos": [
        10626,
        10680
      ]
    },
    {
      "content": "software systems.",
      "pos": [
        10682,
        10699
      ]
    },
    {
      "content": "When successful, its common to install files and otherwise change the state of a compromised system.",
      "pos": [
        10700,
        10800
      ]
    },
    {
      "content": "Using desired state configuration, you can",
      "pos": [
        10801,
        10843
      ]
    },
    {
      "content": "identify deltas between the desired and actual state and restore a known configuration.",
      "pos": [
        10845,
        10932
      ]
    },
    {
      "content": "There are resource extensions for the most popular mechanisms for DSC - PowerShell DSC, Chef, and Puppet.",
      "pos": [
        10934,
        11039
      ]
    },
    {
      "content": "Each of these can deploy the initial state of your VM and",
      "pos": [
        11040,
        11097
      ]
    },
    {
      "content": "also be used to make sure the desired state is maintained.",
      "pos": [
        11099,
        11157
      ]
    },
    {
      "content": "Common template scopes",
      "pos": [
        11162,
        11184
      ]
    },
    {
      "content": "In our experience, we’ve seen three key solution templates scopes emerge.",
      "pos": [
        11186,
        11259
      ]
    },
    {
      "content": "These three scopes – capacity, capability, and end-to-end solution – are described in",
      "pos": [
        11260,
        11345
      ]
    },
    {
      "content": "more detail below.",
      "pos": [
        11347,
        11365
      ]
    },
    {
      "content": "Capacity scope",
      "pos": [
        11371,
        11385
      ]
    },
    {
      "content": "A capacity scope delivers a set of resources in a standard topology that is pre-configured to be in compliance with regulations and policies.",
      "pos": [
        11387,
        11528
      ]
    },
    {
      "content": "The most common",
      "pos": [
        11529,
        11544
      ]
    },
    {
      "content": "example is deploying a standard development environment in an Enterprise IT or SI scenario.",
      "pos": [
        11546,
        11637
      ]
    },
    {
      "content": "Capability scope",
      "pos": [
        11643,
        11659
      ]
    },
    {
      "content": "A capability scope is focused on deploying and configuring a topology for a given technology.",
      "pos": [
        11661,
        11754
      ]
    },
    {
      "content": "Common scenarios including technologies such as SQL Server,",
      "pos": [
        11755,
        11814
      ]
    },
    {
      "content": "Cassandra, Hadoop, etc.",
      "pos": [
        11816,
        11839
      ]
    },
    {
      "content": "End-to-end solution scope",
      "pos": [
        11845,
        11870
      ]
    },
    {
      "content": "An End-to-End Solution Scope is targeted beyond a single capability, and instead focused on delivering an end to end solution comprised of multiple capabilities.",
      "pos": [
        11872,
        12033
      ]
    },
    {
      "content": "A solution-scoped template scope manifests itself as a set of one or more capability scoped templates with solution specific resources, logic, and desired state.",
      "pos": [
        12037,
        12198
      ]
    },
    {
      "content": "An example of a solution-scoped template is an end to end data pipeline solution template that might mix solution specific topology and state with",
      "pos": [
        12199,
        12345
      ]
    },
    {
      "content": "multiple capability scoped solution templates such as Kafka, Storm, and Hadoop.",
      "pos": [
        12347,
        12426
      ]
    },
    {
      "content": "Choosing free-form vs. known configurations",
      "pos": [
        12431,
        12474
      ]
    },
    {
      "content": "You might initially think a template should give consumers the utmost flexibility, but many considerations affect the choice of whether to use free-form",
      "pos": [
        12476,
        12628
      ]
    },
    {
      "content": "configurations vs. known configurations.",
      "pos": [
        12630,
        12670
      ]
    },
    {
      "content": "This section identifies the key customer requirements and technical considerations that shaped the approach shared in",
      "pos": [
        12671,
        12788
      ]
    },
    {
      "content": "this document.",
      "pos": [
        12790,
        12804
      ]
    },
    {
      "content": "Free-form configurations",
      "pos": [
        12810,
        12834
      ]
    },
    {
      "content": "On the surface, free-form configurations sound ideal.",
      "pos": [
        12836,
        12889
      ]
    },
    {
      "content": "They allow you to select a VM type and provide an arbitrary number of nodes and attached disks for those nodes—and",
      "pos": [
        12890,
        13004
      ]
    },
    {
      "content": "do so as parameters to a template.",
      "pos": [
        13006,
        13040
      ]
    },
    {
      "content": "When you look closely, though, and consider templates that will deploy multiple virtual machines of different sizes, additional",
      "pos": [
        13041,
        13168
      ]
    },
    {
      "content": "considerations appear that make the choice less appropriate in a number of scenarios.",
      "pos": [
        13170,
        13255
      ]
    },
    {
      "content": "In the article <bpt id=\"p1\">[</bpt>Virtual Machine and Cloud Service Sizes for Azure<ept id=\"p1\">](http://msdn.microsoft.com/library/azure/dn641267.aspx)</ept> on the Azure website, the different VM",
      "pos": [
        13257,
        13417
      ]
    },
    {
      "content": "types and available sizes are identified, and each of the number of durable disks (2, 4, 8, 16, or 32) that can be attached.",
      "pos": [
        13419,
        13543
      ]
    },
    {
      "content": "Each attached disk provides 500 IOPS",
      "pos": [
        13544,
        13580
      ]
    },
    {
      "content": "and multiples of these disks can be pooled for a multiplier of that number of IOPS.",
      "pos": [
        13582,
        13665
      ]
    },
    {
      "content": "For example, 16 disks can be pooled to provide 8,000 IOPS.",
      "pos": [
        13666,
        13724
      ]
    },
    {
      "content": "Pooling is done with",
      "pos": [
        13725,
        13745
      ]
    },
    {
      "content": "configuration in the operating system, using Microsoft Windows Storage Spaces or redundant array of inexpensive disks (RAID) in Linux.",
      "pos": [
        13747,
        13881
      ]
    },
    {
      "content": "A free-form configuration enables the selection of a number of VM instances, a number of different VM types and sizes for those instances, a number of disks that",
      "pos": [
        13883,
        14044
      ]
    },
    {
      "content": "can vary based on the VM type, and one or more scripts to configure the VM contents.",
      "pos": [
        14046,
        14130
      ]
    },
    {
      "content": "It is common that a deployment may have multiple types of nodes, such as master and data nodes, so this flexibility is often provided for every node type.",
      "pos": [
        14132,
        14286
      ]
    },
    {
      "content": "As you start to deploy clusters of any significance, you begin to work with multiples of all of these.",
      "pos": [
        14288,
        14390
      ]
    },
    {
      "content": "If you were deploying a Hadoop cluster, for example,",
      "pos": [
        14391,
        14443
      ]
    },
    {
      "content": "with 8 master nodes and 200 data nodes, and pooled 4 attached disks on each master node and pooled 16 attached disks per data node, you would have 208 VMs and",
      "pos": [
        14445,
        14603
      ]
    },
    {
      "content": "3,232 disks to manage.",
      "pos": [
        14605,
        14627
      ]
    },
    {
      "content": "A storage account will throttle requests above its identified 20,000 transactions/second limit, so you should look at storage account partitioning and use",
      "pos": [
        14629,
        14783
      ]
    },
    {
      "content": "calculations to determine the appropriate number of storage accounts to accommodate this topology.",
      "pos": [
        14785,
        14883
      ]
    },
    {
      "content": "Given the multitude of combinations supported by the free-form",
      "pos": [
        14884,
        14946
      ]
    },
    {
      "content": "approach, dynamic calculations are required to determine the appropriate partitioning.",
      "pos": [
        14948,
        15034
      ]
    },
    {
      "content": "The Azure Resource Manager Template Language does not presently provide",
      "pos": [
        15035,
        15106
      ]
    },
    {
      "content": "mathematical functions, so you must perform these calculations in code, generating a unique, hard-coded template with the appropriate details.",
      "pos": [
        15108,
        15250
      ]
    },
    {
      "content": "In enterprise IT and SI scenarios, someone must maintain the templates and provide support for the deployed topologies for one or more organizations.",
      "pos": [
        15252,
        15401
      ]
    },
    {
      "content": "This additional overhead — different configurations and templates for each customer — is far from desirable.",
      "pos": [
        15403,
        15511
      ]
    },
    {
      "content": "You can use these templates to deploy environments in your customer’s Azure subscription, but both corporate IT teams and CSVs typically deploy them into their",
      "pos": [
        15513,
        15672
      ]
    },
    {
      "content": "own subscriptions, using a chargeback function to bill their customers.",
      "pos": [
        15674,
        15745
      ]
    },
    {
      "content": "In these scenarios, the goal is to deploy capacity for multiple customers across a pool",
      "pos": [
        15746,
        15833
      ]
    },
    {
      "content": "of subscriptions and keep deployments densely populated into the subscriptions to minimize subscription sprawl—that is, more subscriptions to manage.",
      "pos": [
        15835,
        15984
      ]
    },
    {
      "content": "With truly",
      "pos": [
        15985,
        15995
      ]
    },
    {
      "content": "dynamic deployment sizes, achieving this type of density requires careful planning and additional development for scaffolding work on behalf of the organization.",
      "pos": [
        15997,
        16158
      ]
    },
    {
      "content": "In addition, you can’t create subscriptions via an API call but must do so manually through the portal.",
      "pos": [
        16160,
        16263
      ]
    },
    {
      "content": "As the number of subscriptions increases, any resulting",
      "pos": [
        16264,
        16319
      ]
    },
    {
      "content": "subscription sprawl requires human intervention—it can’t be automated.",
      "pos": [
        16321,
        16391
      ]
    },
    {
      "content": "With so much variability in the sizes of deployments, you would have to pre-provision a",
      "pos": [
        16392,
        16479
      ]
    },
    {
      "content": "number of subscriptions manually to ensure subscriptions are available.",
      "pos": [
        16481,
        16552
      ]
    },
    {
      "content": "Considering all these factors, a truly free-form configuration is less appealing than at first blush.",
      "pos": [
        16554,
        16655
      ]
    },
    {
      "content": "Known configurations — the t-shirt sizing approach",
      "pos": [
        16661,
        16711
      ]
    },
    {
      "content": "Rather than offer a template that provides total flexibility and countless variations, in our experience a common pattern is to provide the ability to select",
      "pos": [
        16713,
        16870
      ]
    },
    {
      "content": "known configurations — in effect, standard t-shirt sizes such as sandbox, small, medium, and large.",
      "pos": [
        16872,
        16971
      ]
    },
    {
      "content": "Other examples of t-shirt sizes are product offerings,",
      "pos": [
        16972,
        17026
      ]
    },
    {
      "content": "such as community edition or enterprise edition.",
      "pos": [
        17028,
        17076
      ]
    },
    {
      "content": "In other cases, it may be workload specific configurations of a technology – such as map reduce or no sql.",
      "pos": [
        17078,
        17184
      ]
    },
    {
      "content": "Many enterprise IT organizations, OSS vendors, and SIs make their offerings available today in this way in on-premises, virtualized environments",
      "pos": [
        17186,
        17330
      ]
    },
    {
      "content": "(enterprises) or as software-as-a-service (SaaS) offerings (CSVs and OSVs).",
      "pos": [
        17332,
        17407
      ]
    },
    {
      "content": "This approach provides good, known configurations of varying sizes that are preconfigured for customers.",
      "pos": [
        17409,
        17513
      ]
    },
    {
      "content": "Without known configurations, end customers",
      "pos": [
        17514,
        17557
      ]
    },
    {
      "content": "must determine cluster sizing on their own, factor in platform resource constraints, and do math to identify the resulting partitioning of storage accounts",
      "pos": [
        17559,
        17714
      ]
    },
    {
      "content": "and other resources (due to cluster size and resource constraints).",
      "pos": [
        17716,
        17783
      ]
    },
    {
      "content": "Known configurations enable customers to easily select the right t-shirt size—that is,",
      "pos": [
        17784,
        17870
      ]
    },
    {
      "content": "a given deployment.",
      "pos": [
        17872,
        17891
      ]
    },
    {
      "content": "In addition to making a better experience for the customer, a small number of known configurations is easier to support and can help you",
      "pos": [
        17892,
        18028
      ]
    },
    {
      "content": "deliver a higher level of density.",
      "pos": [
        18030,
        18064
      ]
    },
    {
      "content": "A known configuration approach focused on t-shirt sizes may also have varying number of nodes within a size.",
      "pos": [
        18066,
        18174
      ]
    },
    {
      "content": "For example, a small t-shirt size may be",
      "pos": [
        18175,
        18215
      ]
    },
    {
      "content": "between 3 and 10 nodes.",
      "pos": [
        18217,
        18240
      ]
    },
    {
      "content": "The t-shirt size would be designed to accommodate up to 10 nodes and provide the consumer the ability to make free form selections up to",
      "pos": [
        18242,
        18378
      ]
    },
    {
      "content": "the maximum size identified.",
      "pos": [
        18380,
        18408
      ]
    },
    {
      "content": "A t-shirt size based on workload type, may be more free form in nature in terms of the number of nodes that can be deployed but will have workload distinct",
      "pos": [
        18412,
        18567
      ]
    },
    {
      "content": "node size and configuration of the software on the node.",
      "pos": [
        18569,
        18625
      ]
    },
    {
      "content": "T-shirt sizes based on product offerings, such as community or Enterprise, may have distinct resource types and maximum number of nodes that can be deployed,",
      "pos": [
        18627,
        18784
      ]
    },
    {
      "content": "typically tied to licensing considerations or feature availability across the different offerings.",
      "pos": [
        18786,
        18884
      ]
    },
    {
      "content": "You can also accommodate customers with unique variants using the JSON-based templates.",
      "pos": [
        18886,
        18973
      ]
    },
    {
      "content": "When dealing with outliers, you can incorporate the appropriate planning",
      "pos": [
        18974,
        19046
      ]
    },
    {
      "content": "and considerations for development, support, and costing.",
      "pos": [
        19048,
        19105
      ]
    },
    {
      "content": "Based on the customer template consumption scenarios, requirements identified at the start of this document, and our hands-on experience creating numerous templates,",
      "pos": [
        19107,
        19272
      ]
    },
    {
      "content": "we identified a pattern for template decomposition.",
      "pos": [
        19274,
        19325
      ]
    },
    {
      "content": "Capacity and capability-scoped solution templates",
      "pos": [
        19330,
        19379
      ]
    },
    {
      "content": "Decomposition provides a modular approach to template development that supports reuse, extensibility, testing, and tooling.",
      "pos": [
        19381,
        19504
      ]
    },
    {
      "content": "This section provides detail on how a",
      "pos": [
        19505,
        19542
      ]
    },
    {
      "content": "decomposition approach can be applied to templates with a Capacity or Capability scope.",
      "pos": [
        19544,
        19631
      ]
    },
    {
      "content": "In this approach, a main template receives parameter values from a template consumer, then links to several types of templates and scripts downstream as",
      "pos": [
        19633,
        19785
      ]
    },
    {
      "content": "shown below.",
      "pos": [
        19787,
        19799
      ]
    },
    {
      "content": "Parameters, static variables, and generated variables are used to provide values in and out of the linked templates.",
      "pos": [
        19800,
        19916
      ]
    },
    {
      "content": "Template parameters",
      "pos": [
        19920,
        19939
      ]
    },
    {
      "content": "Parameters are passed to a main template then to linked templates",
      "pos": [
        20026,
        20091
      ]
    },
    {
      "content": "This following sections focus on the types of templates and scripts that a single template would be decomposed into and examines approaches for passing state",
      "pos": [
        20095,
        20252
      ]
    },
    {
      "content": "information among the templates.",
      "pos": [
        20254,
        20286
      ]
    },
    {
      "content": "Each template and the script types in the image are described along with examples.",
      "pos": [
        20287,
        20369
      ]
    },
    {
      "content": "For a contextual example, see",
      "pos": [
        20370,
        20399
      ]
    },
    {
      "content": "\"Putting it together: a sample implementation\" later in this document.",
      "pos": [
        20401,
        20471
      ]
    },
    {
      "content": "Template metadata",
      "pos": [
        20477,
        20494
      ]
    },
    {
      "content": "Template metadata (the metadata.json file) contains key/value pairs that describe a template in JSON, which can be read by humans and software systems.",
      "pos": [
        20496,
        20647
      ]
    },
    {
      "content": "Template metadata",
      "pos": [
        20651,
        20668
      ]
    },
    {
      "content": "Template metadata is described in the metadata.json file",
      "pos": [
        20753,
        20809
      ]
    },
    {
      "content": "Software agents can retrieve the metadata.json file and publish the information and a link to the template in a web page or directory.",
      "pos": [
        20813,
        20947
      ]
    },
    {
      "content": "Elements",
      "pos": [
        20948,
        20956
      ]
    },
    {
      "content": "include <bpt id=\"p1\">*</bpt>itemDisplayName<ept id=\"p1\">*</ept>, <bpt id=\"p2\">*</bpt>description<ept id=\"p2\">*</ept>, <bpt id=\"p3\">*</bpt>summary<ept id=\"p3\">*</ept>, <bpt id=\"p4\">*</bpt>githubUsername<ept id=\"p4\">*</ept>, and <bpt id=\"p5\">*</bpt>dateUpdated<ept id=\"p5\">*</ept>.",
      "pos": [
        20958,
        21047
      ]
    },
    {
      "content": "An example file is shown below in its entirety.",
      "pos": [
        21049,
        21096
      ]
    },
    {
      "content": "Main template",
      "pos": [
        21661,
        21674
      ]
    },
    {
      "content": "The main template (the azuredeploy.json file) is called by an end user and is the template through which a set of user-defined parameters are presented.",
      "pos": [
        21676,
        21828
      ]
    },
    {
      "content": "Main template",
      "pos": [
        21832,
        21845
      ]
    },
    {
      "content": "The main template receives parameters from a user",
      "pos": [
        21926,
        21975
      ]
    },
    {
      "content": "The role of this template is to receive parameters from a user, use that information to populate a set of complex object variables, then execute the appropriate",
      "pos": [
        21979,
        22139
      ]
    },
    {
      "content": "set of related templates using template linking.",
      "pos": [
        22141,
        22189
      ]
    },
    {
      "content": "One parameter that is provided is a known configuration type also known as the t-shirt size parameter because of its standardized values such as small,",
      "pos": [
        22191,
        22342
      ]
    },
    {
      "content": "medium, or large.",
      "pos": [
        22344,
        22361
      ]
    },
    {
      "content": "In practice you can use this parameter in multiple ways.",
      "pos": [
        22362,
        22418
      ]
    },
    {
      "content": "For details, see \"Known configuration resources template\" later in this document.",
      "pos": [
        22419,
        22500
      ]
    },
    {
      "content": "Some resources are deployed regardless of the known configuration specified by a user parameter.",
      "pos": [
        22502,
        22598
      ]
    },
    {
      "content": "These resources are provisioned using a single shared",
      "pos": [
        22599,
        22652
      ]
    },
    {
      "content": "resource template and are shared by other templates, so the shared resource template is run first.",
      "pos": [
        22654,
        22752
      ]
    },
    {
      "content": "Some resources are deployed optionally regardless of the specified known configuration.",
      "pos": [
        22754,
        22841
      ]
    },
    {
      "content": "Shared resources template",
      "pos": [
        22847,
        22872
      ]
    },
    {
      "content": "This template delivers resources that are common across all known configurations.",
      "pos": [
        22874,
        22955
      ]
    },
    {
      "content": "It contains the virtual network, availability sets, and other resources that",
      "pos": [
        22956,
        23032
      ]
    },
    {
      "content": "are required regardless of the known configuration template that is deployed.",
      "pos": [
        23034,
        23111
      ]
    },
    {
      "content": "Template resources",
      "pos": [
        23115,
        23133
      ]
    },
    {
      "content": "Shared resources template",
      "pos": [
        23219,
        23244
      ]
    },
    {
      "content": "Resource names, such as the virtual network name, are based on the main template.",
      "pos": [
        23248,
        23329
      ]
    },
    {
      "content": "You can specify them as a variable within that template or receive them as a",
      "pos": [
        23330,
        23406
      ]
    },
    {
      "content": "parameter from the user, as required by your organization.",
      "pos": [
        23408,
        23466
      ]
    },
    {
      "content": "Optional resources template",
      "pos": [
        23472,
        23499
      ]
    },
    {
      "content": "The optional resources template contains resources that are programmatically deployed based on the value of a parameter or variable.",
      "pos": [
        23501,
        23633
      ]
    },
    {
      "content": "Optional resources",
      "pos": [
        23637,
        23655
      ]
    },
    {
      "content": "Optional resources template",
      "pos": [
        23741,
        23768
      ]
    },
    {
      "content": "For example, you can use an optional resources template to configure a jumpbox that enables indirect access to a deployed environment from the public",
      "pos": [
        23772,
        23921
      ]
    },
    {
      "content": "Internet.",
      "pos": [
        23923,
        23932
      ]
    },
    {
      "content": "You would use a parameter or variable to identify whether the jumpbox should be enabled and the <bpt id=\"p1\">*</bpt>concat<ept id=\"p1\">*</ept> function to build the target name for the",
      "pos": [
        23933,
        24079
      ]
    },
    {
      "content": "template, such as <bpt id=\"p1\">*</bpt>jumpbox_enabled.json<ept id=\"p1\">*</ept>.",
      "pos": [
        24081,
        24122
      ]
    },
    {
      "content": "Template linking would use the resulting variable to install the jumpbox.",
      "pos": [
        24123,
        24196
      ]
    },
    {
      "content": "You can link the optional resources template from multiple places:",
      "pos": [
        24198,
        24264
      ]
    },
    {
      "content": "When applicable to every deployment, create a parameter-driven link from the shared resources template.",
      "pos": [
        24270,
        24373
      ]
    },
    {
      "content": "When applicable to select known configurations—for example, only install on large deployments—create a parameter-driven or variable-driven link from the",
      "pos": [
        24378,
        24530
      ]
    },
    {
      "content": "known configuration template.",
      "pos": [
        24532,
        24561
      ]
    },
    {
      "content": "Whether a given resource is optional may not be driven by the template consumer but instead by the template provider.",
      "pos": [
        24563,
        24680
      ]
    },
    {
      "content": "For example, you may need to satisfy a",
      "pos": [
        24681,
        24719
      ]
    },
    {
      "content": "particular product requirement or product add-on (common for CSVs) or to enforce policies (common for SIs and enterprise IT groups).",
      "pos": [
        24721,
        24853
      ]
    },
    {
      "content": "In these cases, you can use a",
      "pos": [
        24854,
        24883
      ]
    },
    {
      "content": "variable to identify whether the resource should be deployed.",
      "pos": [
        24885,
        24946
      ]
    },
    {
      "content": "Known configuration resources template",
      "pos": [
        24952,
        24990
      ]
    },
    {
      "content": "In the main template, a parameter can be exposed to allow the template consumer to specify a desired known configuration to deploy.",
      "pos": [
        24992,
        25123
      ]
    },
    {
      "content": "In many cases, this known",
      "pos": [
        25124,
        25149
      ]
    },
    {
      "content": "configuration uses a t-shirt size approach with a set of fixed configuration sizes such as sandbox, small, medium, and large.",
      "pos": [
        25151,
        25276
      ]
    },
    {
      "content": "Known configuration resources",
      "pos": [
        25280,
        25309
      ]
    },
    {
      "content": "Known configuration resources template",
      "pos": [
        25389,
        25427
      ]
    },
    {
      "content": "The t-shirt size approach is commonly used, but the parameters can represent any set of known configurations.",
      "pos": [
        25431,
        25540
      ]
    },
    {
      "content": "For example, you can specify a set of environments",
      "pos": [
        25541,
        25591
      ]
    },
    {
      "content": "for an enterprise application such as Development, Test, and Product.",
      "pos": [
        25593,
        25662
      ]
    },
    {
      "content": "Or you could use it for a cloud service to represent different scale units, product versions,",
      "pos": [
        25663,
        25756
      ]
    },
    {
      "content": "or product configurations such as Community, Developer, or Enterprise.",
      "pos": [
        25758,
        25828
      ]
    },
    {
      "content": "As with the shared resource template, variables are passed to the known configurations template from either:",
      "pos": [
        25830,
        25938
      ]
    },
    {
      "content": "An end user—that is, the parameters sent to the main template.",
      "pos": [
        25944,
        26006
      ]
    },
    {
      "content": "An organization—that is, the variables in the main template that represent internal requirements or policies.",
      "pos": [
        26011,
        26120
      ]
    },
    {
      "content": "Member resources template",
      "pos": [
        26126,
        26151
      ]
    },
    {
      "content": "Within a known configuration, one or more member node types are often included.",
      "pos": [
        26153,
        26232
      ]
    },
    {
      "content": "For example, with Hadoop you would have master nodes and data nodes.",
      "pos": [
        26233,
        26301
      ]
    },
    {
      "content": "If you are installing MongoDB, you would have data nodes and an arbiter.",
      "pos": [
        26303,
        26375
      ]
    },
    {
      "content": "If you are deploying DataStax, you would have data nodes as well as a VM",
      "pos": [
        26376,
        26448
      ]
    },
    {
      "content": "with OpsCenter installed.",
      "pos": [
        26450,
        26475
      ]
    },
    {
      "content": "Members resources",
      "pos": [
        26479,
        26496
      ]
    },
    {
      "content": "Member resources template",
      "pos": [
        26580,
        26605
      ]
    },
    {
      "content": "Each type of nodes can have different sizes of VMs, numbers of attached disks, scripts to install and set up the nodes, port configurations for the VM(s),",
      "pos": [
        26609,
        26763
      ]
    },
    {
      "content": "number of instances, and other details.",
      "pos": [
        26765,
        26804
      ]
    },
    {
      "content": "So each node type gets its own member resource template, which contains the details for deploying and configuring an",
      "pos": [
        26805,
        26921
      ]
    },
    {
      "content": "infrastructure as well as executing scripts to deploy and configure software within the VM.",
      "pos": [
        26923,
        27014
      ]
    },
    {
      "content": "For VMs, typically two types of scripts are used, widely reusable and custom scripts.",
      "pos": [
        27016,
        27101
      ]
    },
    {
      "content": "Widely reusable scripts",
      "pos": [
        27107,
        27130
      ]
    },
    {
      "content": "Widely reusable scripts can be used across multiple types of templates.",
      "pos": [
        27132,
        27203
      ]
    },
    {
      "content": "One of the better examples of these widely reusable scripts sets up RAID on Linux to",
      "pos": [
        27204,
        27288
      ]
    },
    {
      "content": "pool disks and gain a greater number of IOPS.",
      "pos": [
        27290,
        27335
      ]
    },
    {
      "content": "Regardless of the software being installed in the VM, this script provides reuse of proven practices for common scenarios.",
      "pos": [
        27336,
        27458
      ]
    },
    {
      "content": "Reusable scripts",
      "pos": [
        27462,
        27478
      ]
    },
    {
      "content": "Member resources templates can call widely reusable scripts",
      "pos": [
        27562,
        27621
      ]
    },
    {
      "content": "Custom scripts",
      "pos": [
        27629,
        27643
      ]
    },
    {
      "content": "Templates commonly call one or more scripts that install and configure software within VMs.",
      "pos": [
        27645,
        27736
      ]
    },
    {
      "content": "A common pattern is seen with large topologies where multiple",
      "pos": [
        27737,
        27798
      ]
    },
    {
      "content": "instances of one or more member types are deployed.",
      "pos": [
        27800,
        27851
      ]
    },
    {
      "content": "An installation script is initiated for every VM that can be run in parallel, followed by a setup script",
      "pos": [
        27852,
        27956
      ]
    },
    {
      "content": "that is called after all VMs (or all VMs of a given member type) are deployed.",
      "pos": [
        27958,
        28036
      ]
    },
    {
      "content": "Custom scripts",
      "pos": [
        28040,
        28054
      ]
    },
    {
      "content": "Member resources templates can call scripts for a specific purpose such as VM configuration",
      "pos": [
        28136,
        28227
      ]
    },
    {
      "content": "Capability-scoped solution template example - Redis",
      "pos": [
        28234,
        28285
      ]
    },
    {
      "content": "To show how an implementation might work, let’s look at a practical example of building a template that will facilitate the deployment and configuration of",
      "pos": [
        28287,
        28442
      ]
    },
    {
      "content": "Redis in standard t-shirt sizes.",
      "pos": [
        28444,
        28476
      ]
    },
    {
      "content": "For the deployment, there will be set of shared resources (virtual network, storage account, availability sets) and an optional resource (jumpbox).",
      "pos": [
        28480,
        28627
      ]
    },
    {
      "content": "There are",
      "pos": [
        28628,
        28637
      ]
    },
    {
      "content": "multiple known configurations represented as t-shirt sizes (small, medium, large) but each with a single node type.",
      "pos": [
        28639,
        28754
      ]
    },
    {
      "content": "There are also two purpose specific scripts",
      "pos": [
        28755,
        28798
      ]
    },
    {
      "content": "(installation, configuration).",
      "pos": [
        28800,
        28830
      ]
    },
    {
      "content": "Creating the template files",
      "pos": [
        28836,
        28863
      ]
    },
    {
      "content": "You would create a Main Template named azuredeploy.json.",
      "pos": [
        28865,
        28921
      ]
    },
    {
      "content": "You create Shared Resources Template named shared-resources.json",
      "pos": [
        28923,
        28987
      ]
    },
    {
      "content": "You create an Optional Resource Template to enable the deployment of a jumpbox, named jumpbox_enabled.json",
      "pos": [
        28989,
        29095
      ]
    },
    {
      "content": "Redis will use just a single node type, so you’ll create a single Member Resource Template named node-resources.json.",
      "pos": [
        29097,
        29214
      ]
    },
    {
      "content": "With Redis, you’ll want to install each individual node and then, once all nodes are installed you’ll want to set up the cluster.",
      "pos": [
        29216,
        29345
      ]
    },
    {
      "content": "You have scripts to",
      "pos": [
        29347,
        29366
      ]
    },
    {
      "content": "accommodate both of these, redis-cluster-install.sh and redis-cluster-setup.sh.",
      "pos": [
        29368,
        29447
      ]
    },
    {
      "content": "Linking the templates",
      "pos": [
        29453,
        29474
      ]
    },
    {
      "content": "Using template linking, the main template links out to the shared resources template, which establishes the virtual network.",
      "pos": [
        29476,
        29600
      ]
    },
    {
      "content": "Logic is added within the main template to enable consumers of the template to specify if a jumpbox should be deployed.",
      "pos": [
        29602,
        29721
      ]
    },
    {
      "content": "An <bpt id=\"p1\">*</bpt>enabled<ept id=\"p1\">*</ept> value for the <bpt id=\"p2\">*</bpt>EnableJumpbox<ept id=\"p2\">*</ept>",
      "pos": [
        29722,
        29764
      ]
    },
    {
      "content": "parameter indicates that the customer wants to deploy a jumpbox.",
      "pos": [
        29766,
        29830
      ]
    },
    {
      "content": "When this value is provided, the template concatenates <bpt id=\"p1\">*</bpt>_enabled<ept id=\"p1\">*</ept> as a suffix to a base template",
      "pos": [
        29831,
        29927
      ]
    },
    {
      "content": "name for the jumpbox capability.",
      "pos": [
        29929,
        29961
      ]
    },
    {
      "content": "The main template applies the <bpt id=\"p1\">*</bpt>large<ept id=\"p1\">*</ept> parameter value as a suffix to a base template name for t-shirt sizes, and then uses that value in a template link out to",
      "pos": [
        29963,
        30122
      ]
    },
    {
      "content": "<bpt id=\"p1\">*</bpt>technology_on_os_large.json<ept id=\"p1\">*</ept>.",
      "pos": [
        30124,
        30154
      ]
    },
    {
      "content": "The topology would resemble this illustration.",
      "pos": [
        30156,
        30202
      ]
    },
    {
      "content": "Redis template",
      "pos": [
        30206,
        30220
      ]
    },
    {
      "content": "Template structure for a Redis template",
      "pos": [
        30302,
        30341
      ]
    },
    {
      "content": "Configuring state",
      "pos": [
        30349,
        30366
      ]
    },
    {
      "content": "For the nodes in the cluster, there are two steps to configuring the state, both represented by Purpose Specific Scripts.",
      "pos": [
        30368,
        30489
      ]
    },
    {
      "content": "“redis-cluster-install.sh” will",
      "pos": [
        30491,
        30522
      ]
    },
    {
      "content": "perform an installation of Redis and “redis-cluster-setup.sh” will set up the cluster.",
      "pos": [
        30524,
        30610
      ]
    },
    {
      "content": "Supporting Different Size Deployments",
      "pos": [
        30616,
        30653
      ]
    },
    {
      "content": "Inside of variables, the t-shirt size template specifies the number of nodes of each type to deploy for the specified size (<bpt id=\"p1\">*</bpt>large<ept id=\"p1\">*</ept>).",
      "pos": [
        30655,
        30788
      ]
    },
    {
      "content": "It then deploys that number of",
      "pos": [
        30789,
        30819
      ]
    },
    {
      "content": "VM instances using resource loops, providing unique names to resources by appending a node name with a numeric sequence number from <bpt id=\"p1\">*</bpt>copyIndex()<ept id=\"p1\">*</ept>.",
      "pos": [
        30821,
        30967
      ]
    },
    {
      "content": "It does this for",
      "pos": [
        30968,
        30984
      ]
    },
    {
      "content": "both hot and warm zone VMs, as defined in the t-shirt name template",
      "pos": [
        30986,
        31053
      ]
    },
    {
      "content": "Decomposition and end-to-end solution scoped templates",
      "pos": [
        31058,
        31112
      ]
    },
    {
      "content": "A solution template with an end-to-end solution scope is focused on delivering an end-to-end solution.",
      "pos": [
        31114,
        31216
      ]
    },
    {
      "content": "This will typically be a composition of multiple capability",
      "pos": [
        31218,
        31277
      ]
    },
    {
      "content": "scoped templates with additional resources, logic and state.",
      "pos": [
        31279,
        31339
      ]
    },
    {
      "content": "As highlighted in the image below, the same model used for capability scoped templates is extended for templates with an End-to-End Solution Scope.",
      "pos": [
        31341,
        31488
      ]
    },
    {
      "content": "A Shared Resources Template and Optional Resources Templates serve the same function as in the capacity and capability scoped template approaches, but are",
      "pos": [
        31490,
        31644
      ]
    },
    {
      "content": "scoped for the end to end solution.",
      "pos": [
        31646,
        31681
      ]
    },
    {
      "content": "As end to end solution scoped templates also can typically have t-shirt sizes, the Known Configuration Resources template reflects what is required for a",
      "pos": [
        31683,
        31836
      ]
    },
    {
      "content": "given known configuration of the solution.",
      "pos": [
        31838,
        31880
      ]
    },
    {
      "content": "The Known Configuration Resources Template will link to one or more capability scoped solution templates that are relevant to the end to end solution as well",
      "pos": [
        31882,
        32039
      ]
    },
    {
      "content": "as the Member Resource Templates that are required for the end to end solution.",
      "pos": [
        32041,
        32120
      ]
    },
    {
      "content": "As the t-shirt size of the solution may be different than that of individual capability scoped template, variables within the Known Configuration Resources",
      "pos": [
        32122,
        32277
      ]
    },
    {
      "content": "Template are used to provide the appropriate values for downstream capability scoped solution templates to deploy the appropriate t-shirt size.",
      "pos": [
        32279,
        32422
      ]
    },
    {
      "content": "End-to-end",
      "pos": [
        32426,
        32436
      ]
    },
    {
      "content": "The model used for capacity or capability scoped solution templates can be readily extended for end to end solution template scopes",
      "pos": [
        32514,
        32645
      ]
    },
    {
      "content": "Preparing templates for the Marketplace",
      "pos": [
        32652,
        32691
      ]
    },
    {
      "content": "The above approach readily accommodates scenarios where Enterprises, SIs, and CSVs want to either deploy the templates themselves or enable their customers to",
      "pos": [
        32693,
        32851
      ]
    },
    {
      "content": "deploy on their own.",
      "pos": [
        32853,
        32873
      ]
    },
    {
      "content": "Another desired scenario is deploying a template via the marketplace.",
      "pos": [
        32875,
        32944
      ]
    },
    {
      "content": "This decomposition approach will work for the marketplace as well, with some minor changes.",
      "pos": [
        32946,
        33037
      ]
    },
    {
      "content": "As mentioned previously, templates can be used to offer distinct deployment types for sale in the marketplace.",
      "pos": [
        33039,
        33149
      ]
    },
    {
      "content": "Distinct deployment types may be",
      "pos": [
        33150,
        33182
      ]
    },
    {
      "content": "t-shirt sizes (small, medium, large) , product/audience type (community, developer, enterprise), or feature type (basic, high availability).",
      "pos": [
        33184,
        33324
      ]
    },
    {
      "content": "As shown below, the existing end to end solution or capability scoped templates can be readily utilized to list the different known configurations in the marketplace.",
      "pos": [
        33326,
        33492
      ]
    },
    {
      "content": "The parameters to the main template are first modified to remove the inbound parameter named tshirtSize.",
      "pos": [
        33494,
        33598
      ]
    },
    {
      "content": "While the distinct deployment types map to the Known Configuration Resources Template, they also need the common resources and configuration found in",
      "pos": [
        33600,
        33749
      ]
    },
    {
      "content": "the Shared Resources Template and potentially those in Optional Resource Templates.",
      "pos": [
        33751,
        33834
      ]
    },
    {
      "content": "If you want to publish your template to the marketplace, you simply establish distinct copies of your Main template that replaces the previously available",
      "pos": [
        33836,
        33990
      ]
    },
    {
      "content": "inbound parameter of tshirtSize to a variable embedded within the template.",
      "pos": [
        33992,
        34067
      ]
    },
    {
      "content": "Marketplace",
      "pos": [
        34071,
        34082
      ]
    },
    {
      "content": "Adapting a solution scoped template for the marketplace",
      "pos": [
        34161,
        34216
      ]
    },
    {
      "content": "Next steps",
      "pos": [
        34223,
        34233
      ]
    },
    {
      "pos": [
        34237,
        34446
      ],
      "content": "To see contextual examples of how to implement the design priciples presented in this topic, see <bpt id=\"p1\">[</bpt>Contextual examples of best practices for implementing templates<ept id=\"p1\">](best-practices-resource-manager-examples.md)</ept>."
    },
    {
      "pos": [
        34449,
        34626
      ],
      "content": "For recommendations about how to handle security in Azure Resource Manager, see <bpt id=\"p1\">[</bpt>Security considerations for Azure Resource Manager<ept id=\"p1\">](best-practices-resource-manager-security.md)</ept>"
    },
    {
      "pos": [
        34629,
        34783
      ],
      "content": "To learn about sharing state into and out of templates, see <bpt id=\"p1\">[</bpt>Sharing state in Azure Resource Manager templates<ept id=\"p1\">](best-practices-resource-manager-state.md)</ept>."
    },
    {
      "content": "test",
      "pos": [
        34785,
        34789
      ]
    }
  ],
  "content": "<properties\n    pageTitle=\"Best practices for designing Azure Resource Manager templates\"\n    description=\"Show design patterns for Azure Resource Manager templates\"\n    services=\"azure-resource-manager\"\n    documentationCenter=\"\"\n    authors=\"mmercuri\"\n    manager=\"georgem\"\n    editor=\"tysonn\"/>\n\n<tags\n    ms.service=\"azure-resource-manager\"\n    ms.workload=\"multiple\"\n    ms.tgt_pltfrm=\"na\"\n    ms.devlang=\"na\"\n    ms.topic=\"article\"\n    ms.date=\"08/13/2015\"\n    ms.author=\"mmercuri\"/>\n\n# Best practices for designing Azure Resource Manager templates\n\nIn our work with enterprises, system integrator (SIs), cloud service vendor (CSVs), and open source software (OSS) project teams, it's often necessary to quickly \ndeploy environments, workloads, or scale units. These deployments need to be supported, follow proven practices, and adhere to identified policies. Using a flexible \napproach based on Azure Resource Manager templates, you can deploy complex topologies quickly and consistently and then adapt these deployments easily as \ncore offerings evolve or to accommodate variants for outlier scenarios or customers.\n\nThis topic is part of a larger whitepaper. To read the full paper, download [World Class ARM Templates Considerations and Proven Practices](http://download.microsoft.com/download/8/E/1/8E1DBEFA-CECE-4DC9-A813-93520A5D7CFE/World Class ARM Templates - Considerations and Proven Practices.pdf).\n\nTemplates combine the benefits of the underlying Azure Resource Manager with the adaptability and readability of JavaScript Object Notation (JSON). Using \ntemplates, you can:\n\n- Deploy topologies and their workloads consistently.\n- Manage all your resources in an application together using resource groups.\n- Apply role-based access control (RBAC) to grant appropriate access to users, groups, and services.\n- Use tagging associations to streamline tasks such as billing rollups.\n\nThis article provides details on consumption scenarios, architecture, and implementation patterns identified during our design sessions and real-world template \nimplementations with Azure Customer Advisory Team (AzureCAT) customers. Far from academic, these are proven practices informed by the development of templates \nfor 12 of the top Linux-based OSS technologies, including: Apache Kafka, Apache Spark, Cloudera, Couchbase, Hortonworks HDP, DataStax Enterprise powered by \nApache Cassandra, Elasticsearch, Jenkins, MongoDB, Nagios, PostgreSQL, Redis, and Nagios. The majority of these templates were developed with a well-known vendor of \na given distribution and influenced by the requirements of Microsoft’s enterprise and SI customers during recent projects.\n\nThis article shares these proven practices to help you architect world class Azure Resource Manager templates.  \n\nIn our work with customers, we have identified a number of Resource Manager template consumption experiences across enterprises, System Integrators (SI)s, and CSVs. \nThe following sections provides a high-level overview of common scenarios and patterns for different customer types.\n\n## Enterprises and system integrators\n\nWithin large organizations, we commonly see two consumers of ARM templates: internal software development teams and corporate IT. The scenarios for the \nSIs we’ve worked with have mapped to those of Enterprises, so the same considerations apply.\n\n### Internal software development teams\n\nIf your team develops software to support your business, templates provide an easy way to quickly deploy technologies for use in business-specific solutions. \nYou can also use templates to rapidly create training environments that enable team members to gain necessary skills.\n\nYou can use templates as-is or extend or compose them to accommodate your needs. Using tagging within templates, you can provide a billing summary with \nvarious views such as team, project, individual, and education.\n\nBusinesses often want software development teams to create a template for consistent deployment of a solution while also offering constraints so certain \nitems within that environment remain fixed and can’t be overridden. For example, a bank might require a template to include RBAC so a programmer can’t revise a \nbanking solution to send data to a personal storage account.\n\n### Corporate IT\n\nCorporate IT organizations typically use templates for delivering cloud capacity and cloud-hosted capabilities.\n\n#### Cloud capacity\n\nA common way for corporate IT groups to provide cloud capacity for teams within their organization is with “t-shirt sizes”, which are standard offering sizes \nsuch as small, medium, and large. The t-shirt sized offerings can mix different resource types and quantities while providing a level of standardization that \nmakes it possible to use templates. The templates deliver capacity in a consistent way that enforces corporate policies and uses tagging to provide \nchargeback to consuming organizations.\n\nFor example, you may need to provide development, test, or production environments within which the software development teams can deploy their solutions. \nThe environment has a predefined network topology and elements which the software development teams cannot change, such as rules governing access to the public \ninternet and packet inspection. You may also have organization-specific roles for these environments with distinct access rights for the environment.\n\n#### Cloud-hosted capabilities\n\nYou can use templates to support cloud-hosted capabilities, including individual software packages or composite offerings that are offered to internal lines \nof business. An example of a composite offering would be analytics-as-a-service—analytics, visualization, and other technologies—delivered in an optimized, \nconnected configuration on a predefined network topology.\n\nCloud-hosted capabilities are affected by the security and role considerations established by the cloud capacity offering on which they’re built as described above.\nThese capabilities are offered as is or as a managed service. For the latter, access-constrained roles are required to enable access into the environment for \nmanagement purposes.\n\n## Cloud service vendors\n\nAfter talking to many CSVs, we have identified multiple approaches you can take to deploy services for your customers and associated requirements.\n\n### CSV-hosted offering\n\nIf you host your offering in your own Azure subscription, two hosting approaches are common: deploying a distinct deployment for every customer or deploying \nscale units that underpin a shared infrastructure used for all customers.\n\n- **Distinct deployments for each customer.** Distinct deployments per customer require fixed topologies of different known configurations. These may have different \nvirtual machine (VM) sizes, varying numbers of nodes, and different amounts of associated storage. Tagging of deployments is used for roll-up billing of each customer. \nRBAC may be enabled to allow customers access to aspects of their cloud environment.\n- **Scale units in shared multi-tenant environments.** A template can represent a scale unit for multi-tenant environments. In this case, the same infrastructure \nis used to support all customers. The deployments represent a group of resources that deliver a level of capacity for the hosted offering, such as number of users \nand number of transactions. These scale units are increased or decreased as demand requires.\n\n### CSV offering injected into customer subscription\n\nYou may want to deploy your software into subscriptions owned by end customers. You can use templates to deploy distinct deployments into a customer’s Azure account.\n\nThese deployments use RBAC so you can update and manage the deployment within the customer’s account.\n\n### Azure Marketplace\n\nIf you want to advertise and sell your offerings through a marketplace, such as Azure Marketplace, you can develop templates to deliver distinct types of \ndeployments that will run in a customer’s Azure account. This distinct deployments can be typically described as a t-shirt size (small, medium, large), \nproduct/audience type (community, developer, enterprise), or feature type (basic, high availability).  In some cases, these types will allow you to specify \ncertain attributes of the deployment, such as VM type or number of disks.\n\n## OSS projects\n\nWithin open source projects, Resource Manager templates enable a community to deploy a solution quickly using proven practices. You can store templates in a \nGitHub repository so the community can revise them over time. End users can then deploy these templates in their own Azure subscriptions.\n\nThe following sections identify the things you need to consider before designing your solution.\n\n## Identifying what is outside and inside of a VM\n\nAs you design your template, it’s helpful to look at the requirements in terms of what’s outside and inside of the virtual machines (VMs):\n\n- Outside means the VMs and other resources of your deployment, such as the network topology, tagging, references to the certs/secrets, and role-based access control. All of these resources are part of your template.\n- Inside means the installed software and overall desired state configuration. Other mechanisms, such as VM extensions or scripts, are used in whole or in part. These mechanisms may be identified and executed by the template but aren’t in it.\n\nCommon examples of activities you would do “inside the box” include -  \n\n- Install or remove server roles and features\n- Install and configure software at the node or cluster level\n- Deploy websites on a web server\n- Deploy database schemas\n- Manage registry or other types of configuration settings\n- Manage files and directories\n- Start, stop, and manage processes and services\n- Manage local groups and user accounts\n- Install and manage packages (.msi, .exe, yum, etc.)\n- Manage environment variables\n- Run native scripts (Windows PowerShell, bash, etc.)\n\n### Desired state configuration (DSC)\n\nThinking about the internal state of your VMs beyond deployment, you’ll want to make sure this deployment doesn’t “drift” from the configuration that you have \ndefined and checked into source control. This ensures your developers or operations staff don’t manually make ad-hoc changes to an environment that are not vetted, \ntested or recorded in source control. This is important, because the manual changes are not in source control, they are also not part of the standard deployment \nand will impact future automated deployments of the software.\n\nBeyond your internal employees, desired state configuration is also important from a security perspective.  Hackers are regularly trying to compromise and exploit \nsoftware systems. When successful, its common to install files and otherwise change the state of a compromised system. Using desired state configuration, you can \nidentify deltas between the desired and actual state and restore a known configuration.\n\nThere are resource extensions for the most popular mechanisms for DSC - PowerShell DSC, Chef, and Puppet. Each of these can deploy the initial state of your VM and \nalso be used to make sure the desired state is maintained.\n\n## Common template scopes\n\nIn our experience, we’ve seen three key solution templates scopes emerge. These three scopes – capacity, capability, and end-to-end solution – are described in \nmore detail below.\n\n### Capacity scope\n\nA capacity scope delivers a set of resources in a standard topology that is pre-configured to be in compliance with regulations and policies. The most common \nexample is deploying a standard development environment in an Enterprise IT or SI scenario.\n\n### Capability scope\n\nA capability scope is focused on deploying and configuring a topology for a given technology. Common scenarios including technologies such as SQL Server, \nCassandra, Hadoop, etc.\n\n### End-to-end solution scope\n\nAn End-to-End Solution Scope is targeted beyond a single capability, and instead focused on delivering an end to end solution comprised of multiple capabilities.  \n\nA solution-scoped template scope manifests itself as a set of one or more capability scoped templates with solution specific resources, logic, and desired state. An example of a solution-scoped template is an end to end data pipeline solution template that might mix solution specific topology and state with \nmultiple capability scoped solution templates such as Kafka, Storm, and Hadoop.\n\n## Choosing free-form vs. known configurations\n\nYou might initially think a template should give consumers the utmost flexibility, but many considerations affect the choice of whether to use free-form \nconfigurations vs. known configurations. This section identifies the key customer requirements and technical considerations that shaped the approach shared in \nthis document.\n\n### Free-form configurations\n\nOn the surface, free-form configurations sound ideal. They allow you to select a VM type and provide an arbitrary number of nodes and attached disks for those nodes—and \ndo so as parameters to a template. When you look closely, though, and consider templates that will deploy multiple virtual machines of different sizes, additional \nconsiderations appear that make the choice less appropriate in a number of scenarios.\n\nIn the article [Virtual Machine and Cloud Service Sizes for Azure](http://msdn.microsoft.com/library/azure/dn641267.aspx) on the Azure website, the different VM \ntypes and available sizes are identified, and each of the number of durable disks (2, 4, 8, 16, or 32) that can be attached. Each attached disk provides 500 IOPS \nand multiples of these disks can be pooled for a multiplier of that number of IOPS. For example, 16 disks can be pooled to provide 8,000 IOPS. Pooling is done with \nconfiguration in the operating system, using Microsoft Windows Storage Spaces or redundant array of inexpensive disks (RAID) in Linux.\n\nA free-form configuration enables the selection of a number of VM instances, a number of different VM types and sizes for those instances, a number of disks that \ncan vary based on the VM type, and one or more scripts to configure the VM contents.\n\nIt is common that a deployment may have multiple types of nodes, such as master and data nodes, so this flexibility is often provided for every node type.\n\nAs you start to deploy clusters of any significance, you begin to work with multiples of all of these. If you were deploying a Hadoop cluster, for example, \nwith 8 master nodes and 200 data nodes, and pooled 4 attached disks on each master node and pooled 16 attached disks per data node, you would have 208 VMs and \n3,232 disks to manage.\n\nA storage account will throttle requests above its identified 20,000 transactions/second limit, so you should look at storage account partitioning and use \ncalculations to determine the appropriate number of storage accounts to accommodate this topology. Given the multitude of combinations supported by the free-form \napproach, dynamic calculations are required to determine the appropriate partitioning. The Azure Resource Manager Template Language does not presently provide \nmathematical functions, so you must perform these calculations in code, generating a unique, hard-coded template with the appropriate details.\n\nIn enterprise IT and SI scenarios, someone must maintain the templates and provide support for the deployed topologies for one or more organizations. \nThis additional overhead — different configurations and templates for each customer — is far from desirable.\n\nYou can use these templates to deploy environments in your customer’s Azure subscription, but both corporate IT teams and CSVs typically deploy them into their \nown subscriptions, using a chargeback function to bill their customers. In these scenarios, the goal is to deploy capacity for multiple customers across a pool \nof subscriptions and keep deployments densely populated into the subscriptions to minimize subscription sprawl—that is, more subscriptions to manage. With truly \ndynamic deployment sizes, achieving this type of density requires careful planning and additional development for scaffolding work on behalf of the organization.\n\nIn addition, you can’t create subscriptions via an API call but must do so manually through the portal. As the number of subscriptions increases, any resulting \nsubscription sprawl requires human intervention—it can’t be automated. With so much variability in the sizes of deployments, you would have to pre-provision a \nnumber of subscriptions manually to ensure subscriptions are available.\n\nConsidering all these factors, a truly free-form configuration is less appealing than at first blush.\n\n### Known configurations — the t-shirt sizing approach\n\nRather than offer a template that provides total flexibility and countless variations, in our experience a common pattern is to provide the ability to select \nknown configurations — in effect, standard t-shirt sizes such as sandbox, small, medium, and large. Other examples of t-shirt sizes are product offerings, \nsuch as community edition or enterprise edition.  In other cases, it may be workload specific configurations of a technology – such as map reduce or no sql.\n\nMany enterprise IT organizations, OSS vendors, and SIs make their offerings available today in this way in on-premises, virtualized environments \n(enterprises) or as software-as-a-service (SaaS) offerings (CSVs and OSVs).\n\nThis approach provides good, known configurations of varying sizes that are preconfigured for customers. Without known configurations, end customers \nmust determine cluster sizing on their own, factor in platform resource constraints, and do math to identify the resulting partitioning of storage accounts \nand other resources (due to cluster size and resource constraints). Known configurations enable customers to easily select the right t-shirt size—that is, \na given deployment. In addition to making a better experience for the customer, a small number of known configurations is easier to support and can help you \ndeliver a higher level of density.\n\nA known configuration approach focused on t-shirt sizes may also have varying number of nodes within a size. For example, a small t-shirt size may be \nbetween 3 and 10 nodes.  The t-shirt size would be designed to accommodate up to 10 nodes and provide the consumer the ability to make free form selections up to \nthe maximum size identified.  \n\nA t-shirt size based on workload type, may be more free form in nature in terms of the number of nodes that can be deployed but will have workload distinct \nnode size and configuration of the software on the node.\n\nT-shirt sizes based on product offerings, such as community or Enterprise, may have distinct resource types and maximum number of nodes that can be deployed, \ntypically tied to licensing considerations or feature availability across the different offerings.\n\nYou can also accommodate customers with unique variants using the JSON-based templates. When dealing with outliers, you can incorporate the appropriate planning \nand considerations for development, support, and costing.\n\nBased on the customer template consumption scenarios, requirements identified at the start of this document, and our hands-on experience creating numerous templates, \nwe identified a pattern for template decomposition.\n\n## Capacity and capability-scoped solution templates\n\nDecomposition provides a modular approach to template development that supports reuse, extensibility, testing, and tooling. This section provides detail on how a \ndecomposition approach can be applied to templates with a Capacity or Capability scope.\n\nIn this approach, a main template receives parameter values from a template consumer, then links to several types of templates and scripts downstream as \nshown below. Parameters, static variables, and generated variables are used to provide values in and out of the linked templates.\n\n![Template parameters](./media/best-practices-resource-manager-design-templates/template-parameters.png)\n\n**Parameters are passed to a main template then to linked templates**\n\nThis following sections focus on the types of templates and scripts that a single template would be decomposed into and examines approaches for passing state \ninformation among the templates. Each template and the script types in the image are described along with examples. For a contextual example, see \n\"Putting it together: a sample implementation\" later in this document.\n\n### Template metadata\n\nTemplate metadata (the metadata.json file) contains key/value pairs that describe a template in JSON, which can be read by humans and software systems.\n\n![Template metadata](./media/best-practices-resource-manager-design-templates/template-metadata.png)\n\n**Template metadata is described in the metadata.json file**\n\nSoftware agents can retrieve the metadata.json file and publish the information and a link to the template in a web page or directory. Elements \ninclude *itemDisplayName*, *description*, *summary*, *githubUsername*, and *dateUpdated*.\n\nAn example file is shown below in its entirety.\n\n    {\n        \"itemDisplayName\": \"PostgreSQL 9.3 on Ubuntu VMs\",\n        \"description\": \"This template creates a PostgreSQL streaming-replication between a master and one or more slave servers each with 2 striped data disks. The database servers are deployed into a private-only subnet with one publicly accessible jumpbox VM in a DMZ subnet with public IP.\",\n        \"summary\": \"PostgreSQL stream-replication with multiple slave servers and a publicly accessible jumpbox VM\",\n        \"githubUsername\": \"arsenvlad\",\n        \"dateUpdated\": \"2015-04-24\"\n    }\n\n### Main template\n\nThe main template (the azuredeploy.json file) is called by an end user and is the template through which a set of user-defined parameters are presented.\n\n![Main template](./media/best-practices-resource-manager-design-templates/main-template.png)\n\n**The main template receives parameters from a user**\n\nThe role of this template is to receive parameters from a user, use that information to populate a set of complex object variables, then execute the appropriate \nset of related templates using template linking.\n\nOne parameter that is provided is a known configuration type also known as the t-shirt size parameter because of its standardized values such as small, \nmedium, or large. In practice you can use this parameter in multiple ways. For details, see \"Known configuration resources template\" later in this document.\n\nSome resources are deployed regardless of the known configuration specified by a user parameter. These resources are provisioned using a single shared \nresource template and are shared by other templates, so the shared resource template is run first.\n\nSome resources are deployed optionally regardless of the specified known configuration.\n\n### Shared resources template\n\nThis template delivers resources that are common across all known configurations. It contains the virtual network, availability sets, and other resources that \nare required regardless of the known configuration template that is deployed.\n\n![Template resources](./media/best-practices-resource-manager-design-templates/template-resources.png)\n\n**Shared resources template**\n\nResource names, such as the virtual network name, are based on the main template. You can specify them as a variable within that template or receive them as a \nparameter from the user, as required by your organization.\n\n### Optional resources template\n\nThe optional resources template contains resources that are programmatically deployed based on the value of a parameter or variable.\n\n![Optional resources](./media/best-practices-resource-manager-design-templates/optional-resources.png)\n\n**Optional resources template**\n\nFor example, you can use an optional resources template to configure a jumpbox that enables indirect access to a deployed environment from the public \nInternet. You would use a parameter or variable to identify whether the jumpbox should be enabled and the *concat* function to build the target name for the \ntemplate, such as *jumpbox_enabled.json*. Template linking would use the resulting variable to install the jumpbox.\n\nYou can link the optional resources template from multiple places:\n\n-   When applicable to every deployment, create a parameter-driven link from the shared resources template.\n-   When applicable to select known configurations—for example, only install on large deployments—create a parameter-driven or variable-driven link from the \nknown configuration template.\n\nWhether a given resource is optional may not be driven by the template consumer but instead by the template provider. For example, you may need to satisfy a \nparticular product requirement or product add-on (common for CSVs) or to enforce policies (common for SIs and enterprise IT groups). In these cases, you can use a \nvariable to identify whether the resource should be deployed.\n\n### Known configuration resources template\n\nIn the main template, a parameter can be exposed to allow the template consumer to specify a desired known configuration to deploy. In many cases, this known \nconfiguration uses a t-shirt size approach with a set of fixed configuration sizes such as sandbox, small, medium, and large.\n\n![Known configuration resources](./media/best-practices-resource-manager-design-templates/known-config.png)\n\n**Known configuration resources template**\n\nThe t-shirt size approach is commonly used, but the parameters can represent any set of known configurations. For example, you can specify a set of environments \nfor an enterprise application such as Development, Test, and Product. Or you could use it for a cloud service to represent different scale units, product versions, \nor product configurations such as Community, Developer, or Enterprise.\n\nAs with the shared resource template, variables are passed to the known configurations template from either:\n\n-   An end user—that is, the parameters sent to the main template.\n-   An organization—that is, the variables in the main template that represent internal requirements or policies.\n\n### Member resources template\n\nWithin a known configuration, one or more member node types are often included. For example, with Hadoop you would have master nodes and data nodes. \nIf you are installing MongoDB, you would have data nodes and an arbiter. If you are deploying DataStax, you would have data nodes as well as a VM \nwith OpsCenter installed.\n\n![Members resources](./media/best-practices-resource-manager-design-templates/member-resources.png)\n\n**Member resources template**\n\nEach type of nodes can have different sizes of VMs, numbers of attached disks, scripts to install and set up the nodes, port configurations for the VM(s), \nnumber of instances, and other details. So each node type gets its own member resource template, which contains the details for deploying and configuring an \ninfrastructure as well as executing scripts to deploy and configure software within the VM.\n\nFor VMs, typically two types of scripts are used, widely reusable and custom scripts.\n\n### Widely reusable scripts\n\nWidely reusable scripts can be used across multiple types of templates. One of the better examples of these widely reusable scripts sets up RAID on Linux to \npool disks and gain a greater number of IOPS. Regardless of the software being installed in the VM, this script provides reuse of proven practices for common scenarios.\n\n![Reusable scripts](./media/best-practices-resource-manager-design-templates/reusable-scripts.png)\n\n**Member resources templates can call widely reusable scripts**\n\n### Custom scripts\n\nTemplates commonly call one or more scripts that install and configure software within VMs. A common pattern is seen with large topologies where multiple \ninstances of one or more member types are deployed. An installation script is initiated for every VM that can be run in parallel, followed by a setup script \nthat is called after all VMs (or all VMs of a given member type) are deployed.\n\n![Custom scripts](./media/best-practices-resource-manager-design-templates/custom-scripts.png)\n\n**Member resources templates can call scripts for a specific purpose such as VM configuration**\n\n## Capability-scoped solution template example - Redis\n\nTo show how an implementation might work, let’s look at a practical example of building a template that will facilitate the deployment and configuration of \nRedis in standard t-shirt sizes.  \n\nFor the deployment, there will be set of shared resources (virtual network, storage account, availability sets) and an optional resource (jumpbox). There are \nmultiple known configurations represented as t-shirt sizes (small, medium, large) but each with a single node type. There are also two purpose specific scripts \n(installation, configuration).\n\n### Creating the template files\n\nYou would create a Main Template named azuredeploy.json.\n\nYou create Shared Resources Template named shared-resources.json\n\nYou create an Optional Resource Template to enable the deployment of a jumpbox, named jumpbox_enabled.json\n\nRedis will use just a single node type, so you’ll create a single Member Resource Template named node-resources.json.\n\nWith Redis, you’ll want to install each individual node and then, once all nodes are installed you’ll want to set up the cluster.  You have scripts to \naccommodate both of these, redis-cluster-install.sh and redis-cluster-setup.sh.\n\n### Linking the templates\n\nUsing template linking, the main template links out to the shared resources template, which establishes the virtual network.\n\nLogic is added within the main template to enable consumers of the template to specify if a jumpbox should be deployed. An *enabled* value for the *EnableJumpbox* \nparameter indicates that the customer wants to deploy a jumpbox. When this value is provided, the template concatenates *_enabled* as a suffix to a base template \nname for the jumpbox capability.\n\nThe main template applies the *large* parameter value as a suffix to a base template name for t-shirt sizes, and then uses that value in a template link out to \n*technology_on_os_large.json*.\n\nThe topology would resemble this illustration.\n\n![Redis template](./media/best-practices-resource-manager-design-templates/redis-template.png)\n\n**Template structure for a Redis template**\n\n### Configuring state\n\nFor the nodes in the cluster, there are two steps to configuring the state, both represented by Purpose Specific Scripts.  “redis-cluster-install.sh” will \nperform an installation of Redis and “redis-cluster-setup.sh” will set up the cluster.\n\n### Supporting Different Size Deployments\n\nInside of variables, the t-shirt size template specifies the number of nodes of each type to deploy for the specified size (*large*). It then deploys that number of \nVM instances using resource loops, providing unique names to resources by appending a node name with a numeric sequence number from *copyIndex()*. It does this for \nboth hot and warm zone VMs, as defined in the t-shirt name template\n\n## Decomposition and end-to-end solution scoped templates\n\nA solution template with an end-to-end solution scope is focused on delivering an end-to-end solution.  This will typically be a composition of multiple capability \nscoped templates with additional resources, logic and state.\n\nAs highlighted in the image below, the same model used for capability scoped templates is extended for templates with an End-to-End Solution Scope.\n\nA Shared Resources Template and Optional Resources Templates serve the same function as in the capacity and capability scoped template approaches, but are \nscoped for the end to end solution.\n\nAs end to end solution scoped templates also can typically have t-shirt sizes, the Known Configuration Resources template reflects what is required for a \ngiven known configuration of the solution.\n\nThe Known Configuration Resources Template will link to one or more capability scoped solution templates that are relevant to the end to end solution as well \nas the Member Resource Templates that are required for the end to end solution.\n\nAs the t-shirt size of the solution may be different than that of individual capability scoped template, variables within the Known Configuration Resources \nTemplate are used to provide the appropriate values for downstream capability scoped solution templates to deploy the appropriate t-shirt size.\n\n![End-to-end](./media/best-practices-resource-manager-design-templates/end-to-end.png)\n\n**The model used for capacity or capability scoped solution templates can be readily extended for end to end solution template scopes**\n\n## Preparing templates for the Marketplace\n\nThe above approach readily accommodates scenarios where Enterprises, SIs, and CSVs want to either deploy the templates themselves or enable their customers to \ndeploy on their own.\n\nAnother desired scenario is deploying a template via the marketplace.  This decomposition approach will work for the marketplace as well, with some minor changes.\n\nAs mentioned previously, templates can be used to offer distinct deployment types for sale in the marketplace. Distinct deployment types may be \nt-shirt sizes (small, medium, large) , product/audience type (community, developer, enterprise), or feature type (basic, high availability).\n\nAs shown below, the existing end to end solution or capability scoped templates can be readily utilized to list the different known configurations in the marketplace.\n\nThe parameters to the main template are first modified to remove the inbound parameter named tshirtSize.\n\nWhile the distinct deployment types map to the Known Configuration Resources Template, they also need the common resources and configuration found in \nthe Shared Resources Template and potentially those in Optional Resource Templates.\n\nIf you want to publish your template to the marketplace, you simply establish distinct copies of your Main template that replaces the previously available \ninbound parameter of tshirtSize to a variable embedded within the template.\n\n![Marketplace](./media/best-practices-resource-manager-design-templates/marketplace.png)\n\n**Adapting a solution scoped template for the marketplace**\n\n## Next steps\n\n- To see contextual examples of how to implement the design priciples presented in this topic, see [Contextual examples of best practices for implementing templates](best-practices-resource-manager-examples.md).\n- For recommendations about how to handle security in Azure Resource Manager, see [Security considerations for Azure Resource Manager](best-practices-resource-manager-security.md)\n- To learn about sharing state into and out of templates, see [Sharing state in Azure Resource Manager templates](best-practices-resource-manager-state.md).\n\ntest\n"
}