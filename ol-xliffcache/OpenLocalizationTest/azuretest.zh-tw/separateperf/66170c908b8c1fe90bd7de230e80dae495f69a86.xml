{
  "nodes": [
    {
      "content": "How to use Azure Search from a .NET Application | Microsoft Azure",
      "pos": [
        26,
        91
      ]
    },
    {
      "content": "How to use Azure Search from a .NET Application",
      "pos": [
        109,
        156
      ]
    },
    {
      "content": "How to use Azure Search from a .NET Application",
      "pos": [
        442,
        489
      ]
    },
    {
      "content": "This article is a walkthrough to get you up and running with the <bpt id=\"p1\">[</bpt>Azure Search .NET SDK<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn951165.aspx)</ept>.",
      "pos": [
        493,
        638
      ]
    },
    {
      "content": "You can use the .NET SDK to implement a rich search experience in your application using Azure Search.",
      "pos": [
        639,
        741
      ]
    },
    {
      "content": "What's in the Azure Search SDK",
      "pos": [
        746,
        776
      ]
    },
    {
      "content": "The SDK consists of a client library, <ph id=\"ph1\">`Microsoft.Azure.Search`</ph>.",
      "pos": [
        781,
        844
      ]
    },
    {
      "content": "It enables you to manage your indexes, data sources, and indexers, as well as upload and manage documents, and execute queries, all without having to deal with the details of HTTP and JSON.",
      "pos": [
        845,
        1034
      ]
    },
    {
      "content": "The client library defines classes like <ph id=\"ph1\">`Index`</ph>, <ph id=\"ph2\">`Field`</ph>, and <ph id=\"ph3\">`Document`</ph>, as well as operations like <ph id=\"ph4\">`Indexes.Create`</ph> and <ph id=\"ph5\">`Documents.Search`</ph> on the <ph id=\"ph6\">`SearchServiceClient`</ph> and <ph id=\"ph7\">`SearchIndexClient`</ph> classes.",
      "pos": [
        1036,
        1238
      ]
    },
    {
      "content": "These classes are organized into the following namespaces:",
      "pos": [
        1239,
        1297
      ]
    },
    {
      "content": "Microsoft.Azure.Search",
      "pos": [
        1302,
        1324
      ]
    },
    {
      "content": "Microsoft.Azure.Search.Models",
      "pos": [
        1399,
        1428
      ]
    },
    {
      "content": "The current version of the Azure Search .NET SDK is a pre-release version.",
      "pos": [
        1508,
        1582
      ]
    },
    {
      "content": "If you would like to provide feedback for us to incorporate in the first stable version, please visit our <bpt id=\"p1\">[</bpt>feedback page<ept id=\"p1\">](http://feedback.azure.com/forums/263029-azure-search)</ept>.",
      "pos": [
        1583,
        1759
      ]
    },
    {
      "content": "The .NET SDK supports version <ph id=\"ph1\">`2015-02-28`</ph> of the Azure Search REST API, documented on <bpt id=\"p1\">[</bpt>MSDN<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn798935.aspx)</ept>.",
      "pos": [
        1761,
        1911
      ]
    },
    {
      "content": "New features that are <bpt id=\"p1\">*</bpt>not<ept id=\"p1\">*</ept> part of this version, such as support for Microsoft's natural language processors or the <ph id=\"ph1\">`moreLikeThis`</ph> search parameter, are in <bpt id=\"p2\">[</bpt>preview<ept id=\"p2\">](search-api-2015-02-28-preview.md)</ept> and not yet available in the SDK.",
      "pos": [
        1912,
        2146
      ]
    },
    {
      "content": "You can check back on <bpt id=\"p1\">[</bpt>Search service versioning<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn864560.aspx)</ept> or <bpt id=\"p2\">[</bpt>Latest updates to Azure Search<ept id=\"p2\">](search-latest-updates.md)</ept> for status updates on either feature.",
      "pos": [
        2147,
        2352
      ]
    },
    {
      "content": "Other features not supported in this SDK include:",
      "pos": [
        2354,
        2403
      ]
    },
    {
      "content": "<bpt id=\"p1\">[</bpt>Management Operations<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn832684.aspx)</ept>.",
      "pos": [
        2409,
        2489
      ]
    },
    {
      "content": "Management operations include provisioning Azure Search services and managing API keys.",
      "pos": [
        2490,
        2577
      ]
    },
    {
      "content": "These will be supported in a separate Azure Search .NET Management SDK in the future.",
      "pos": [
        2578,
        2663
      ]
    },
    {
      "content": "Requirements for the SDK",
      "pos": [
        2668,
        2692
      ]
    },
    {
      "content": "Visual Studio 2013 or a newer version.",
      "pos": [
        2700,
        2738
      ]
    },
    {
      "content": "Your own Azure Search service.",
      "pos": [
        2743,
        2773
      ]
    },
    {
      "content": "In order to use the SDK, you will need the name of your service and one or more API keys.",
      "pos": [
        2774,
        2863
      ]
    },
    {
      "content": "<bpt id=\"p1\">[</bpt>Create a service in the portal<ept id=\"p1\">](search-create-service-portal.md)</ept> will help you through these steps.",
      "pos": [
        2864,
        2964
      ]
    },
    {
      "content": "Download the Azure Search .NET SDK <bpt id=\"p1\">[</bpt>NuGet package<ept id=\"p1\">](http://www.nuget.org/packages/Microsoft.Azure.Search)</ept> by using \"Manage NuGet Packages\" in Visual Studio.",
      "pos": [
        2969,
        3124
      ]
    },
    {
      "content": "Just search for the package name <ph id=\"ph1\">`Microsoft.Azure.Search`</ph> on NuGet.org.",
      "pos": [
        3125,
        3196
      ]
    },
    {
      "content": "Make sure to select \"Include Prerelease\" to ensure that the pre-release SDK will appear in the search results.",
      "pos": [
        3197,
        3307
      ]
    },
    {
      "content": "The Azure Search .NET SDK supports applications targeting the .NET Framework 4.0 or higher, as well as Windows Store apps targeting Windows 8.1 and Windows Phone 8.1.",
      "pos": [
        3309,
        3475
      ]
    },
    {
      "content": "Silverlight is not supported.",
      "pos": [
        3476,
        3505
      ]
    },
    {
      "content": "Core Scenarios",
      "pos": [
        3510,
        3524
      ]
    },
    {
      "content": "There are several things you'll need to do in your search application.",
      "pos": [
        3529,
        3599
      ]
    },
    {
      "content": "In this tutorial, we'll cover these core scenarios:",
      "pos": [
        3600,
        3651
      ]
    },
    {
      "content": "Creating an index",
      "pos": [
        3655,
        3672
      ]
    },
    {
      "content": "Populating the index with documents",
      "pos": [
        3675,
        3710
      ]
    },
    {
      "content": "Searching for documents using full-text search and filters",
      "pos": [
        3713,
        3771
      ]
    },
    {
      "content": "The sample code that follows illustrates each of these.",
      "pos": [
        3773,
        3828
      ]
    },
    {
      "content": "Feel free to use the code snippets in your own application.",
      "pos": [
        3829,
        3888
      ]
    },
    {
      "content": "Overview",
      "pos": [
        3894,
        3902
      ]
    },
    {
      "content": "The sample application we'll be exploring creates a new index named \"hotels\", populates it with a few documents, then executes some search queries.",
      "pos": [
        3908,
        4055
      ]
    },
    {
      "content": "Here is the main program, showing the overall flow:",
      "pos": [
        4056,
        4107
      ]
    },
    {
      "content": "We'll walk through this step by step.",
      "pos": [
        5514,
        5551
      ]
    },
    {
      "content": "First we need to create a new <ph id=\"ph1\">`SearchServiceClient`</ph>.",
      "pos": [
        5552,
        5604
      ]
    },
    {
      "content": "This object allows you to manage indexes.",
      "pos": [
        5605,
        5646
      ]
    },
    {
      "content": "In order to construct one, you need to provide your Azure Search service name as well as an admin API key.",
      "pos": [
        5647,
        5753
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> If you provide an incorrect key (for example, a query key where an admin key was required), the <ph id=\"ph2\">`SearchServiceClient`</ph> will throw a <ph id=\"ph3\">`CloudException`</ph> with the error message \"Forbidden\" the first time you call an operation method on it, such as <ph id=\"ph4\">`Indexes.Create`</ph>.",
      "pos": [
        6211,
        6483
      ]
    },
    {
      "content": "If this happens to you, double-check our API key.",
      "pos": [
        6484,
        6533
      ]
    },
    {
      "content": "The next few lines call methods to create an index named \"hotels\", deleting it first if it already exists.",
      "pos": [
        6535,
        6641
      ]
    },
    {
      "content": "We will walk through these methods a little later.",
      "pos": [
        6642,
        6692
      ]
    },
    {
      "content": "Next, the index needs to be populated.",
      "pos": [
        6902,
        6940
      ]
    },
    {
      "content": "To do this, we will need a <ph id=\"ph1\">`SearchIndexClient`</ph>.",
      "pos": [
        6941,
        6988
      ]
    },
    {
      "content": "There are two ways to obtain one: by constructing it, or by calling <ph id=\"ph1\">`Indexes.GetClient`</ph> on the <ph id=\"ph2\">`SearchServiceClient`</ph>.",
      "pos": [
        6989,
        7106
      ]
    },
    {
      "content": "We use the latter for convenience.",
      "pos": [
        7107,
        7141
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> In a typical search application, index management and population is handled by a separate component from search queries.",
      "pos": [
        7229,
        7362
      ]
    },
    {
      "content": "<ph id=\"ph1\">`Indexes.GetClient`</ph> is convenient for populating an index because it saves you the trouble of providing another <ph id=\"ph2\">`SearchCredentials`</ph>.",
      "pos": [
        7363,
        7495
      ]
    },
    {
      "content": "It does this by passing the admin key that you used to create the <ph id=\"ph1\">`SearchServiceClient`</ph> to the new <ph id=\"ph2\">`SearchIndexClient`</ph>.",
      "pos": [
        7496,
        7615
      ]
    },
    {
      "content": "However, in the part of your application that executes queries, it is better to create the <ph id=\"ph1\">`SearchIndexClient`</ph> directly so that you can pass in a query key instead of an admin key.",
      "pos": [
        7616,
        7796
      ]
    },
    {
      "content": "This is consistent with the principle of least privilege and will help to make your application more secure.",
      "pos": [
        7797,
        7905
      ]
    },
    {
      "content": "You can find out more about admin keys and query keys <bpt id=\"p1\">[</bpt>here<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn798935.aspx)</ept>.",
      "pos": [
        7906,
        8023
      ]
    },
    {
      "content": "Now that we have a <ph id=\"ph1\">`SearchIndexClient`</ph>, we can populate the index.",
      "pos": [
        8025,
        8091
      ]
    },
    {
      "content": "This is done by another method that we will walk through later.",
      "pos": [
        8092,
        8155
      ]
    },
    {
      "pos": [
        8258,
        8360
      ],
      "content": "Finally, we execute a few search queries and display the results, again using the <ph id=\"ph1\">`SearchIndexClient`</ph>:"
    },
    {
      "content": "If you run this application with a valid service name and API key, the output should look like this:",
      "pos": [
        8788,
        8888
      ]
    },
    {
      "content": "The full source code of the application is provided at the end of this article.",
      "pos": [
        9484,
        9563
      ]
    },
    {
      "pos": [
        9565,
        9638
      ],
      "content": "Next, we will take a closer look at each of the methods called by <ph id=\"ph1\">`Main`</ph>."
    },
    {
      "content": "Creating an Index",
      "pos": [
        9644,
        9661
      ]
    },
    {
      "content": "After creating a <ph id=\"ph1\">`SearchServiceClient`</ph>, the next thing <ph id=\"ph2\">`Main`</ph> does is delete the \"hotels\" index if it already exists.",
      "pos": [
        9667,
        9784
      ]
    },
    {
      "content": "That is done by the following method:",
      "pos": [
        9785,
        9822
      ]
    },
    {
      "pos": [
        10046,
        10146
      ],
      "content": "This method uses the given <ph id=\"ph1\">`SearchServiceClient`</ph> to check if the index exists, and if so, delete it."
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> The example code in this article uses the synchronous methods of the Azure Search .NET SDK for simplicity.",
      "pos": [
        10150,
        10269
      ]
    },
    {
      "content": "We recommend that you use the asynchronous methods in your own applications to keep them scalable and responsive.",
      "pos": [
        10270,
        10383
      ]
    },
    {
      "content": "For example, in the method above you could use <ph id=\"ph1\">`ExistsAsync`</ph> and <ph id=\"ph2\">`DeleteAsync`</ph> instead of <ph id=\"ph3\">`Exists`</ph> and <ph id=\"ph4\">`Delete`</ph>.",
      "pos": [
        10384,
        10496
      ]
    },
    {
      "pos": [
        10498,
        10563
      ],
      "content": "Next, <ph id=\"ph1\">`Main`</ph> creates a new \"hotels\" index by calling this method:"
    },
    {
      "content": "This method creates a new <ph id=\"ph1\">`Index`</ph> object with a list of <ph id=\"ph2\">`Field`</ph> objects that defines the schema of the new index.",
      "pos": [
        12007,
        12120
      ]
    },
    {
      "content": "Each field has a name, data type, and several attributes that define its search behavior.",
      "pos": [
        12121,
        12210
      ]
    },
    {
      "content": "In addition to fields, you can also add scoring profiles, suggesters, or CORS options to the Index (these are omitted from the sample for brevity).",
      "pos": [
        12211,
        12358
      ]
    },
    {
      "content": "You can find more information about the Index object and its constituent parts in the SDK reference on <bpt id=\"p1\">[</bpt>MSDN<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/microsoft.azure.search.models.index_members.aspx)</ept>, as well as in the <bpt id=\"p2\">[</bpt>Azure Search REST API reference<ept id=\"p2\">](https://msdn.microsoft.com/library/azure/dn798935.aspx)</ept>.",
      "pos": [
        12359,
        12669
      ]
    },
    {
      "content": "Populating the Index",
      "pos": [
        12675,
        12695
      ]
    },
    {
      "content": "The next step in <ph id=\"ph1\">`Main`</ph> is to populate the newly-created index.",
      "pos": [
        12701,
        12764
      ]
    },
    {
      "content": "This is done in the following method:",
      "pos": [
        12765,
        12802
      ]
    },
    {
      "content": "This method has four parts.",
      "pos": [
        16242,
        16269
      ]
    },
    {
      "content": "The first creates an array of <ph id=\"ph1\">`Hotel`</ph> objects that will serve as our input data to upload to the index.",
      "pos": [
        16270,
        16373
      ]
    },
    {
      "content": "This data is hard-coded for simplicity.",
      "pos": [
        16374,
        16413
      ]
    },
    {
      "content": "In your own application, your data will likely come from an external data source such as a SQL database.",
      "pos": [
        16414,
        16518
      ]
    },
    {
      "content": "The second part creates an <ph id=\"ph1\">`IndexAction`</ph> for each <ph id=\"ph2\">`Hotel`</ph>, then groups those together in a new <ph id=\"ph3\">`IndexBatch`</ph>.",
      "pos": [
        16520,
        16628
      ]
    },
    {
      "content": "The batch is then uploaded to the Azure Search index by the <ph id=\"ph1\">`Documents.Index`</ph> method.",
      "pos": [
        16629,
        16714
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> In this example, we are just uploading documents.",
      "pos": [
        16718,
        16780
      ]
    },
    {
      "content": "If you wanted to merge changes into an existing document or a delete a document, you could create an <ph id=\"ph1\">`IndexAction`</ph> with the corresponding <ph id=\"ph2\">`IndexActionType`</ph>.",
      "pos": [
        16781,
        16937
      ]
    },
    {
      "content": "We don't need to specify <ph id=\"ph1\">`IndexActionType`</ph> in this example because the default is <ph id=\"ph2\">`Upload`</ph>.",
      "pos": [
        16938,
        17029
      ]
    },
    {
      "content": "The third part of this method is a catch block that handles an important error case for indexing.",
      "pos": [
        17031,
        17128
      ]
    },
    {
      "content": "If your Azure Search service fails to index some of the documents in the batch, an <ph id=\"ph1\">`IndexBatchException`</ph> is thrown by <ph id=\"ph2\">`Documents.Index`</ph>.",
      "pos": [
        17129,
        17265
      ]
    },
    {
      "content": "This can happen if you are indexing documents while your service is under heavy load.",
      "pos": [
        17266,
        17351
      ]
    },
    {
      "content": "We strongly recommend explicitly handling this case in your code.",
      "pos": [
        17354,
        17419
      ]
    },
    {
      "content": "You can delay and then retry indexing the documents that failed, or you can log and continue like the sample does, or you can do something else depending on your application's data consistency requirements.",
      "pos": [
        17422,
        17628
      ]
    },
    {
      "content": "Finally, the method delays for two seconds.",
      "pos": [
        17630,
        17673
      ]
    },
    {
      "content": "Indexing happens asynchronously in your Azure Search service, so the sample application needs to wait a short time to ensure that the documents are available for searching.",
      "pos": [
        17674,
        17846
      ]
    },
    {
      "content": "Delays like this are typically only necessary in demos, tests, and sample applications.",
      "pos": [
        17847,
        17934
      ]
    },
    {
      "content": "How the .NET SDK Handles Documents",
      "pos": [
        17941,
        17975
      ]
    },
    {
      "content": "You may be wondering how the Azure Search .NET SDK is able to upload instances of a user-defined class like <ph id=\"ph1\">`Hotel`</ph> to the index.",
      "pos": [
        17982,
        18111
      ]
    },
    {
      "content": "To help answer that question, let's look at the <ph id=\"ph1\">`Hotel`</ph> class:",
      "pos": [
        18112,
        18174
      ]
    },
    {
      "content": "The first thing to notice is that each public property of <ph id=\"ph1\">`Hotel`</ph> corresponds to a field in the index definition, but with one crucial difference: The name of each field starts with a lower-case letter (\"camel case\"), while the name of each public property of <ph id=\"ph2\">`Hotel`</ph> starts with an upper-case letter (\"Pascal case\").",
      "pos": [
        19008,
        19325
      ]
    },
    {
      "content": "This is a common scenario in .NET applications that perform data-binding where the target schema is outside the control of the application developer.",
      "pos": [
        19326,
        19475
      ]
    },
    {
      "content": "Rather than having to violate the .NET naming guidelines by making property names camel-case, you can tell the SDK to map the property names to camel-case automatically with the <ph id=\"ph1\">`[SerializePropertyNamesAsCamelCase]`</ph> attribute.",
      "pos": [
        19476,
        19702
      ]
    },
    {
      "content": "The second important thing about the <ph id=\"ph1\">`Hotel`</ph> class are the data types of the public properties.",
      "pos": [
        19704,
        19799
      ]
    },
    {
      "content": "The .NET types of  these properties map to their equivalent field types in the index definition.",
      "pos": [
        19800,
        19896
      ]
    },
    {
      "content": "For example, the <ph id=\"ph1\">`Category`</ph> string property maps to the <ph id=\"ph2\">`category`</ph> field, which is of type <ph id=\"ph3\">`Edm.String`</ph>.",
      "pos": [
        19897,
        20001
      ]
    },
    {
      "content": "There are similar type mappings between <ph id=\"ph1\">`bool?`</ph> and <ph id=\"ph2\">`Edm.Boolean`</ph>, <ph id=\"ph3\">`DateTimeOffset?`</ph> and <ph id=\"ph4\">`Edm.DateTimeOffset`</ph>, etc. The specific rules for the type mapping are documented with the <ph id=\"ph5\">`Documents.Get`</ph> method on <bpt id=\"p1\">[</bpt>MSDN<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn931291.aspx)</ept>.",
      "pos": [
        20002,
        20271
      ]
    },
    {
      "content": "Note that value types such as <ph id=\"ph1\">`bool`</ph> and <ph id=\"ph2\">`int`</ph> are nullable in the <ph id=\"ph3\">`Hotel`</ph> class because all primitive field types in Azure Search are nullable.",
      "pos": [
        20272,
        20416
      ]
    },
    {
      "content": "This ability to use your own classes as documents works in both directions; You can also retrieve search results and have the SDK automatically deserialize them to a type of your choice, as we will see in the next section.",
      "pos": [
        20418,
        20640
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> The Azure Search .NET SDK also supports dynamically-typed documents using the <ph id=\"ph2\">`Document`</ph> class, which is a key/value mapping of field names to field values.",
      "pos": [
        20644,
        20813
      ]
    },
    {
      "content": "This is useful in scenarios where you don't know the index schema at design-time, or where it would be inconvenient to bind to specific model classes.",
      "pos": [
        20814,
        20964
      ]
    },
    {
      "content": "All the methods in the SDK that deal with documents have overloads that work with the <ph id=\"ph1\">`Document`</ph> class, as well as strongly-typed overloads that take a generic type parameter.",
      "pos": [
        20965,
        21140
      ]
    },
    {
      "content": "Only the latter are used in the sample code in this tutorial.",
      "pos": [
        21141,
        21202
      ]
    },
    {
      "content": "You can find out more about the <ph id=\"ph1\">`Document`</ph> class <bpt id=\"p1\">[</bpt>here<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/microsoft.azure.search.models.document.aspx)</ept>.",
      "pos": [
        21203,
        21345
      ]
    },
    {
      "content": "Searching for Documents in the Index",
      "pos": [
        21351,
        21387
      ]
    },
    {
      "content": "The last step in the sample application is to search for some documents in the index.",
      "pos": [
        21393,
        21478
      ]
    },
    {
      "content": "The following method does this:",
      "pos": [
        21479,
        21510
      ]
    },
    {
      "content": "First, this method creates a new <ph id=\"ph1\">`SearchParameters`</ph> object.",
      "pos": [
        22069,
        22128
      ]
    },
    {
      "content": "This is used to specify additional options for the query such as sorting, filtering, paging, and faceting.",
      "pos": [
        22129,
        22235
      ]
    },
    {
      "content": "In this example, we're only setting the <ph id=\"ph1\">`Filter`</ph> property.",
      "pos": [
        22236,
        22294
      ]
    },
    {
      "content": "The next step is to actually execute the search query.",
      "pos": [
        22296,
        22350
      ]
    },
    {
      "content": "This is done using the <ph id=\"ph1\">`Documents.Search`</ph> method.",
      "pos": [
        22351,
        22400
      ]
    },
    {
      "content": "In this case, we pass the search text to use as a string, plus the search parameters created earlier.",
      "pos": [
        22401,
        22502
      ]
    },
    {
      "content": "We also specify <ph id=\"ph1\">`Hotel`</ph> as the type parameter for <ph id=\"ph2\">`Documents.Search`</ph>, which tells the SDK to deserialize documents in the search results into objects of type <ph id=\"ph3\">`Hotel`</ph>.",
      "pos": [
        22503,
        22669
      ]
    },
    {
      "content": "Finally, this method iterates through all the matches in the search results, printing each document to the console.",
      "pos": [
        22671,
        22786
      ]
    },
    {
      "content": "Let's take a closer look at how this method is called:",
      "pos": [
        22788,
        22842
      ]
    },
    {
      "content": "In the first call, we're looking for all documents containing the query terms \"fancy\" or \"wifi\".",
      "pos": [
        22989,
        23085
      ]
    },
    {
      "content": "In the second call, the search text is set to \"*\", which means \"find everything\".",
      "pos": [
        23086,
        23167
      ]
    },
    {
      "content": "You can find more information about the search query expression syntax <bpt id=\"p1\">[</bpt>here<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn798920.aspx)</ept>.",
      "pos": [
        23168,
        23302
      ]
    },
    {
      "content": "The second call uses an OData <ph id=\"ph1\">`$filter`</ph> expression, <ph id=\"ph2\">`category eq 'Luxury'`</ph>.",
      "pos": [
        23304,
        23379
      ]
    },
    {
      "content": "This constrains the search to only return documents where the <ph id=\"ph1\">`category`</ph> field exactly matches the string \"Luxury\".",
      "pos": [
        23380,
        23495
      ]
    },
    {
      "content": "You can find out more about the OData syntax that Azure Search supports <bpt id=\"p1\">[</bpt>here<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn798921.aspx)</ept>.",
      "pos": [
        23496,
        23631
      ]
    },
    {
      "content": "Now that you know what these two calls do, it should be easier to see why their output looks like this:",
      "pos": [
        23633,
        23736
      ]
    },
    {
      "content": "The first search returns two documents.",
      "pos": [
        24207,
        24246
      ]
    },
    {
      "content": "The first has \"Fancy\" in the name, while the second has \"wifi\" in the <ph id=\"ph1\">`tags`</ph> field.",
      "pos": [
        24247,
        24330
      ]
    },
    {
      "content": "The second search returns two documents, which happen to be the only documents in the index that have the <ph id=\"ph1\">`category`</ph> field set to \"Luxury\".",
      "pos": [
        24331,
        24470
      ]
    },
    {
      "content": "This step completes the tutorial, but don't stop here.",
      "pos": [
        24472,
        24526
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Next steps<ept id=\"p1\">**</ept> provides additional resources for learning more about Azure Search.",
      "pos": [
        24527,
        24609
      ]
    },
    {
      "content": "Next Steps",
      "pos": [
        24614,
        24624
      ]
    },
    {
      "pos": [
        24631,
        24758
      ],
      "content": "Deepen your knowledge through <bpt id=\"p1\">[</bpt>videos and other samples and tutorials<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn818681.aspx)</ept>."
    },
    {
      "pos": [
        24761,
        24918
      ],
      "content": "Read about features and capabilities in this version of the Azure Search SDK: <bpt id=\"p1\">[</bpt>Azure Search Overview<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn798933.aspx)</ept>"
    },
    {
      "pos": [
        24921,
        25051
      ],
      "content": "Review <bpt id=\"p1\">[</bpt>naming conventions<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn857353.aspx)</ept> to learn the rules for naming various objects."
    },
    {
      "pos": [
        25054,
        25156
      ],
      "content": "Review <bpt id=\"p1\">[</bpt>supported data types<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn798938.aspx)</ept> in Azure Search."
    },
    {
      "content": "Sample Application Source Code",
      "pos": [
        25162,
        25192
      ]
    },
    {
      "content": "Here is the full source code of the sample application used in this walk through.",
      "pos": [
        25197,
        25278
      ]
    },
    {
      "content": "Note that you will need to replace the service name and API key placeholders in Program.cs with your own values if you want to build and run the sample.",
      "pos": [
        25279,
        25431
      ]
    },
    {
      "content": "Program.cs:",
      "pos": [
        25433,
        25444
      ]
    },
    {
      "content": "Hotel.cs:",
      "pos": [
        33940,
        33949
      ]
    }
  ],
  "content": "<properties\n   pageTitle=\"How to use Azure Search from a .NET Application | Microsoft Azure\"\n   description=\"How to use Azure Search from a .NET Application\"\n   services=\"search\"\n   documentationCenter=\"\"\n   authors=\"brjohnstmsft\"\n   manager=\"pablocas\"\n   editor=\"\"/>\n\n<tags\n   ms.service=\"search\"\n   ms.devlang=\"dotnet\"\n   ms.workload=\"search\"\n   ms.topic=\"article\"\n   ms.tgt_pltfrm=\"na\"\n   ms.date=\"07/08/2015\"\n   ms.author=\"brjohnst\"/>\n\n# How to use Azure Search from a .NET Application #\n\nThis article is a walkthrough to get you up and running with the [Azure Search .NET SDK](https://msdn.microsoft.com/library/azure/dn951165.aspx). You can use the .NET SDK to implement a rich search experience in your application using Azure Search.\n\n## What's in the Azure Search SDK ##\n\nThe SDK consists of a client library, `Microsoft.Azure.Search`. It enables you to manage your indexes, data sources, and indexers, as well as upload and manage documents, and execute queries, all without having to deal with the details of HTTP and JSON.\n\nThe client library defines classes like `Index`, `Field`, and `Document`, as well as operations like `Indexes.Create` and `Documents.Search` on the `SearchServiceClient` and `SearchIndexClient` classes. These classes are organized into the following namespaces:\n\n- [Microsoft.Azure.Search](https://msdn.microsoft.com/library/azure/microsoft.azure.search.aspx)\n- [Microsoft.Azure.Search.Models](https://msdn.microsoft.com/library/azure/microsoft.azure.search.models.aspx)\n\nThe current version of the Azure Search .NET SDK is a pre-release version. If you would like to provide feedback for us to incorporate in the first stable version, please visit our [feedback page](http://feedback.azure.com/forums/263029-azure-search).\n\nThe .NET SDK supports version `2015-02-28` of the Azure Search REST API, documented on [MSDN](https://msdn.microsoft.com/library/azure/dn798935.aspx). New features that are *not* part of this version, such as support for Microsoft's natural language processors or the `moreLikeThis` search parameter, are in [preview](search-api-2015-02-28-preview.md) and not yet available in the SDK. You can check back on [Search service versioning](https://msdn.microsoft.com/library/azure/dn864560.aspx) or [Latest updates to Azure Search](search-latest-updates.md) for status updates on either feature.\n\nOther features not supported in this SDK include:\n\n  - [Management Operations](https://msdn.microsoft.com/library/azure/dn832684.aspx). Management operations include provisioning Azure Search services and managing API keys. These will be supported in a separate Azure Search .NET Management SDK in the future.\n\n## Requirements for the SDK ##\n\n1. Visual Studio 2013 or a newer version.\n\n2. Your own Azure Search service. In order to use the SDK, you will need the name of your service and one or more API keys. [Create a service in the portal](search-create-service-portal.md) will help you through these steps.\n\n3. Download the Azure Search .NET SDK [NuGet package](http://www.nuget.org/packages/Microsoft.Azure.Search) by using \"Manage NuGet Packages\" in Visual Studio. Just search for the package name `Microsoft.Azure.Search` on NuGet.org. Make sure to select \"Include Prerelease\" to ensure that the pre-release SDK will appear in the search results.\n\nThe Azure Search .NET SDK supports applications targeting the .NET Framework 4.0 or higher, as well as Windows Store apps targeting Windows 8.1 and Windows Phone 8.1. Silverlight is not supported.\n\n## Core Scenarios ##\n\nThere are several things you'll need to do in your search application. In this tutorial, we'll cover these core scenarios:\n\n- Creating an index\n- Populating the index with documents\n- Searching for documents using full-text search and filters\n\nThe sample code that follows illustrates each of these. Feel free to use the code snippets in your own application.\n\n### Overview ###\n\nThe sample application we'll be exploring creates a new index named \"hotels\", populates it with a few documents, then executes some search queries. Here is the main program, showing the overall flow:\n\n    // This sample shows how to delete, create, upload documents and query an index\n    static void Main(string[] args)\n    {\n        // Put your search service name here. This is the hostname portion of your service URL.\n        // For example, if your service URL is https://myservice.search.windows.net, then your\n        // service name is myservice.\n        string searchServiceName = \"myservice\";\n\n        string apiKey = \"Put your API admin key here.\"\n\n        SearchServiceClient serviceClient = new SearchServiceClient(searchServiceName, new SearchCredentials(apiKey));\n\n        Console.WriteLine(\"{0}\", \"Deleting index...\\n\");\n        DeleteHotelsIndexIfExists(serviceClient);\n\n        Console.WriteLine(\"{0}\", \"Creating index...\\n\");\n        CreateHotelsIndex(serviceClient);\n\n        SearchIndexClient indexClient = serviceClient.Indexes.GetClient(\"hotels\");\n\n        Console.WriteLine(\"{0}\", \"Uploading documents...\\n\");\n        UploadDocuments(indexClient);\n\n        Console.WriteLine(\"{0}\", \"Searching documents 'fancy wifi'...\\n\");\n        SearchDocuments(indexClient, searchText: \"fancy wifi\");\n\n        Console.WriteLine(\"\\n{0}\", \"Filter documents with category 'Luxury'...\\n\");\n        SearchDocuments(indexClient, searchText: \"*\", filter: \"category eq 'Luxury'\");\n\n        Console.WriteLine(\"{0}\", \"Complete.  Press any key to end application...\\n\");\n        Console.ReadKey();\n    }\n\nWe'll walk through this step by step. First we need to create a new `SearchServiceClient`. This object allows you to manage indexes. In order to construct one, you need to provide your Azure Search service name as well as an admin API key.\n\n        // Put your search service name here. This is the hostname portion of your service URL.\n        // For example, if your service URL is https://myservice.search.windows.net, then your\n        // service name is myservice.\n        string searchServiceName = \"myservice\";\n\n        string apiKey = \"Put your API admin key here.\"\n\n        SearchServiceClient serviceClient = new SearchServiceClient(searchServiceName, new SearchCredentials(apiKey));\n\n> [AZURE.NOTE] If you provide an incorrect key (for example, a query key where an admin key was required), the `SearchServiceClient` will throw a `CloudException` with the error message \"Forbidden\" the first time you call an operation method on it, such as `Indexes.Create`. If this happens to you, double-check our API key.\n\nThe next few lines call methods to create an index named \"hotels\", deleting it first if it already exists. We will walk through these methods a little later.\n\n        Console.WriteLine(\"{0}\", \"Deleting index...\\n\");\n        DeleteHotelsIndexIfExists(serviceClient);\n\n        Console.WriteLine(\"{0}\", \"Creating index...\\n\");\n        CreateHotelsIndex(serviceClient);\n\nNext, the index needs to be populated. To do this, we will need a `SearchIndexClient`. There are two ways to obtain one: by constructing it, or by calling `Indexes.GetClient` on the `SearchServiceClient`. We use the latter for convenience.\n\n        SearchIndexClient indexClient = serviceClient.Indexes.GetClient(\"hotels\");\n\n> [AZURE.NOTE] In a typical search application, index management and population is handled by a separate component from search queries. `Indexes.GetClient` is convenient for populating an index because it saves you the trouble of providing another `SearchCredentials`. It does this by passing the admin key that you used to create the `SearchServiceClient` to the new `SearchIndexClient`. However, in the part of your application that executes queries, it is better to create the `SearchIndexClient` directly so that you can pass in a query key instead of an admin key. This is consistent with the principle of least privilege and will help to make your application more secure. You can find out more about admin keys and query keys [here](https://msdn.microsoft.com/library/azure/dn798935.aspx).\n\nNow that we have a `SearchIndexClient`, we can populate the index. This is done by another method that we will walk through later.\n\n        Console.WriteLine(\"{0}\", \"Uploading documents...\\n\");\n        UploadDocuments(indexClient);\n\nFinally, we execute a few search queries and display the results, again using the `SearchIndexClient`:\n\n        Console.WriteLine(\"{0}\", \"Searching documents 'fancy wifi'...\\n\");\n        SearchDocuments(indexClient, searchText: \"fancy wifi\");\n\n        Console.WriteLine(\"\\n{0}\", \"Filter documents with category 'Luxury'...\\n\");\n        SearchDocuments(indexClient, searchText: \"*\", filter: \"category eq 'Luxury'\");\n\n        Console.WriteLine(\"{0}\", \"Complete.  Press any key to end application...\\n\");\n        Console.ReadKey();\n\nIf you run this application with a valid service name and API key, the output should look like this:\n\n    Deleting index...\n\n    Creating index...\n\n    Uploading documents...\n\n    Searching documents 'fancy wifi'...\n\n    ID: 1058-441    Name: Fancy Stay        Category: Luxury        Tags: [pool, view, concierge]\n    ID: 956-532     Name: Express Rooms     Category: Budget        Tags: [wifi, budget]\n\n    Filter documents with category 'Luxury'...\n\n    ID: 1058-441    Name: Fancy Stay        Category: Luxury        Tags: [pool, view, concierge]\n    ID: 566-518     Name: Surprisingly Expensive Suites     Category: Luxury        Tags: []\n    Complete.  Press any key to end application...\n\nThe full source code of the application is provided at the end of this article.\n\nNext, we will take a closer look at each of the methods called by `Main`.\n\n### Creating an Index ###\n\nAfter creating a `SearchServiceClient`, the next thing `Main` does is delete the \"hotels\" index if it already exists. That is done by the following method:\n\n    private static void DeleteHotelsIndexIfExists(SearchServiceClient serviceClient)\n    {\n        if (serviceClient.Indexes.Exists(\"hotels\"))\n        {\n            serviceClient.Indexes.Delete(\"hotels\");\n        }\n    }\n\nThis method uses the given `SearchServiceClient` to check if the index exists, and if so, delete it.\n\n> [AZURE.NOTE] The example code in this article uses the synchronous methods of the Azure Search .NET SDK for simplicity. We recommend that you use the asynchronous methods in your own applications to keep them scalable and responsive. For example, in the method above you could use `ExistsAsync` and `DeleteAsync` instead of `Exists` and `Delete`.\n\nNext, `Main` creates a new \"hotels\" index by calling this method:\n\n    private static void CreateHotelsIndex(SearchServiceClient serviceClient)\n    {\n        var definition = new Index()\n        {\n            Name = \"hotels\",\n            Fields = new[]\n            {\n                new Field(\"hotelId\", DataType.String)                       { IsKey = true },\n                new Field(\"hotelName\", DataType.String)                     { IsSearchable = true, IsFilterable = true },\n                new Field(\"baseRate\", DataType.Double)                      { IsFilterable = true, IsSortable = true },\n                new Field(\"category\", DataType.String)                      { IsSearchable = true, IsFilterable = true, IsSortable = true, IsFacetable = true },\n                new Field(\"tags\", DataType.Collection(DataType.String))     { IsSearchable = true, IsFilterable = true, IsFacetable = true },\n                new Field(\"parkingIncluded\", DataType.Boolean)              { IsFilterable = true, IsFacetable = true },\n                new Field(\"lastRenovationDate\", DataType.DateTimeOffset)    { IsFilterable = true, IsSortable = true, IsFacetable = true },\n                new Field(\"rating\", DataType.Int32)                         { IsFilterable = true, IsSortable = true, IsFacetable = true },\n                new Field(\"location\", DataType.GeographyPoint)              { IsFilterable = true, IsSortable = true }\n            }\n        };\n\n        serviceClient.Indexes.Create(definition);\n    }\n\nThis method creates a new `Index` object with a list of `Field` objects that defines the schema of the new index. Each field has a name, data type, and several attributes that define its search behavior. In addition to fields, you can also add scoring profiles, suggesters, or CORS options to the Index (these are omitted from the sample for brevity). You can find more information about the Index object and its constituent parts in the SDK reference on [MSDN](https://msdn.microsoft.com/library/azure/microsoft.azure.search.models.index_members.aspx), as well as in the [Azure Search REST API reference](https://msdn.microsoft.com/library/azure/dn798935.aspx).\n\n### Populating the Index ###\n\nThe next step in `Main` is to populate the newly-created index. This is done in the following method:\n\n    private static void UploadDocuments(SearchIndexClient indexClient)\n    {\n        var documents =\n            new Hotel[]\n            {\n                new Hotel()\n                { \n                    HotelId = \"1058-441\", \n                    HotelName = \"Fancy Stay\", \n                    BaseRate = 199.0, \n                    Category = \"Luxury\", \n                    Tags = new[] { \"pool\", \"view\", \"concierge\" }, \n                    ParkingIncluded = false, \n                    LastRenovationDate = new DateTimeOffset(2010, 6, 27, 0, 0, 0, TimeSpan.Zero), \n                    Rating = 5, \n                    Location = GeographyPoint.Create(47.678581, -122.131577)\n                },\n                new Hotel()\n                { \n                    HotelId = \"666-437\", \n                    HotelName = \"Roach Motel\",\n                    BaseRate = 79.99,\n                    Category = \"Budget\",\n                    Tags = new[] { \"motel\", \"budget\" },\n                    ParkingIncluded = true,\n                    LastRenovationDate = new DateTimeOffset(1982, 4, 28, 0, 0, 0, TimeSpan.Zero),\n                    Rating = 1,\n                    Location = GeographyPoint.Create(49.678581, -122.131577)\n                },\n                new Hotel() \n                { \n                    HotelId = \"970-501\", \n                    HotelName = \"Econo-Stay\",\n                    BaseRate = 129.99,\n                    Category = \"Budget\",\n                    Tags = new[] { \"pool\", \"budget\" },\n                    ParkingIncluded = true,\n                    LastRenovationDate = new DateTimeOffset(1995, 7, 1, 0, 0, 0, TimeSpan.Zero),\n                    Rating = 4,\n                    Location = GeographyPoint.Create(46.678581, -122.131577)\n                },\n                new Hotel()\n                { \n                    HotelId = \"956-532\", \n                    HotelName = \"Express Rooms\",\n                    BaseRate = 129.99,\n                    Category = \"Budget\",\n                    Tags = new[] { \"wifi\", \"budget\" },\n                    ParkingIncluded = true,\n                    LastRenovationDate = new DateTimeOffset(1995, 7, 1, 0, 0, 0, TimeSpan.Zero),\n                    Rating = 4,\n                    Location = GeographyPoint.Create(48.678581, -122.131577)\n                },\n                new Hotel() \n                { \n                    HotelId = \"566-518\", \n                    HotelName = \"Surprisingly Expensive Suites\",\n                    BaseRate = 279.99,\n                    Category = \"Luxury\",\n                    ParkingIncluded = false\n                }\n            };\n\n        try\n        {\n            indexClient.Documents.Index(IndexBatch.Create(documents.Select(doc => IndexAction.Create(doc))));\n        }\n        catch (IndexBatchException e)\n        {\n            // Sometimes when your Search service is under load, indexing will fail for some of the documents in\n            // the batch. Depending on your application, you can take compensating actions like delaying and\n            // retrying. For this simple demo, we just log the failed document keys and continue.\n            Console.WriteLine(\n                \"Failed to index some of the documents: {0}\",\n                String.Join(\", \", e.IndexResponse.Results.Where(r => !r.Succeeded).Select(r => r.Key)));\n        }\n\n        // Wait a while for indexing to complete.\n        Thread.Sleep(2000);\n    }\n\nThis method has four parts. The first creates an array of `Hotel` objects that will serve as our input data to upload to the index. This data is hard-coded for simplicity. In your own application, your data will likely come from an external data source such as a SQL database.\n\nThe second part creates an `IndexAction` for each `Hotel`, then groups those together in a new `IndexBatch`. The batch is then uploaded to the Azure Search index by the `Documents.Index` method.\n\n> [AZURE.NOTE] In this example, we are just uploading documents. If you wanted to merge changes into an existing document or a delete a document, you could create an `IndexAction` with the corresponding `IndexActionType`. We don't need to specify `IndexActionType` in this example because the default is `Upload`.\n\nThe third part of this method is a catch block that handles an important error case for indexing. If your Azure Search service fails to index some of the documents in the batch, an `IndexBatchException` is thrown by `Documents.Index`. This can happen if you are indexing documents while your service is under heavy load. **We strongly recommend explicitly handling this case in your code.** You can delay and then retry indexing the documents that failed, or you can log and continue like the sample does, or you can do something else depending on your application's data consistency requirements.\n\nFinally, the method delays for two seconds. Indexing happens asynchronously in your Azure Search service, so the sample application needs to wait a short time to ensure that the documents are available for searching. Delays like this are typically only necessary in demos, tests, and sample applications.\n\n#### How the .NET SDK Handles Documents ####\n\nYou may be wondering how the Azure Search .NET SDK is able to upload instances of a user-defined class like `Hotel` to the index. To help answer that question, let's look at the `Hotel` class:\n\n    [SerializePropertyNamesAsCamelCase]\n    public class Hotel\n    {\n        public string HotelId { get; set; }\n\n        public string HotelName { get; set; }\n\n        public double? BaseRate { get; set; }\n\n        public string Category { get; set; }\n\n        public string[] Tags { get; set; }\n\n        public bool? ParkingIncluded { get; set; }\n\n        public DateTimeOffset? LastRenovationDate { get; set; }\n\n        public int? Rating { get; set; }\n\n        public GeographyPoint Location { get; set; }\n\n        public override string ToString()\n        {\n            return String.Format(\n                \"ID: {0}\\tName: {1}\\tCategory: {2}\\tTags: [{3}]\",\n                HotelId,\n                HotelName,\n                Category,\n                (Tags != null) ? String.Join(\", \", Tags) : String.Empty);\n        }\n    }\n\nThe first thing to notice is that each public property of `Hotel` corresponds to a field in the index definition, but with one crucial difference: The name of each field starts with a lower-case letter (\"camel case\"), while the name of each public property of `Hotel` starts with an upper-case letter (\"Pascal case\"). This is a common scenario in .NET applications that perform data-binding where the target schema is outside the control of the application developer. Rather than having to violate the .NET naming guidelines by making property names camel-case, you can tell the SDK to map the property names to camel-case automatically with the `[SerializePropertyNamesAsCamelCase]` attribute.\n\nThe second important thing about the `Hotel` class are the data types of the public properties. The .NET types of  these properties map to their equivalent field types in the index definition. For example, the `Category` string property maps to the `category` field, which is of type `Edm.String`. There are similar type mappings between `bool?` and `Edm.Boolean`, `DateTimeOffset?` and `Edm.DateTimeOffset`, etc. The specific rules for the type mapping are documented with the `Documents.Get` method on [MSDN](https://msdn.microsoft.com/library/azure/dn931291.aspx). Note that value types such as `bool` and `int` are nullable in the `Hotel` class because all primitive field types in Azure Search are nullable.\n\nThis ability to use your own classes as documents works in both directions; You can also retrieve search results and have the SDK automatically deserialize them to a type of your choice, as we will see in the next section.\n\n> [AZURE.NOTE] The Azure Search .NET SDK also supports dynamically-typed documents using the `Document` class, which is a key/value mapping of field names to field values. This is useful in scenarios where you don't know the index schema at design-time, or where it would be inconvenient to bind to specific model classes. All the methods in the SDK that deal with documents have overloads that work with the `Document` class, as well as strongly-typed overloads that take a generic type parameter. Only the latter are used in the sample code in this tutorial. You can find out more about the `Document` class [here](https://msdn.microsoft.com/library/azure/microsoft.azure.search.models.document.aspx).\n\n### Searching for Documents in the Index ###\n\nThe last step in the sample application is to search for some documents in the index. The following method does this:\n\n    private static void SearchDocuments(SearchIndexClient indexClient, string searchText, string filter = null)\n    {\n        // Execute search based on search text and optional filter\n        var sp = new SearchParameters();\n\n        if (!String.IsNullOrEmpty(filter))\n        {\n            sp.Filter = filter;\n        }\n\n        DocumentSearchResponse<Hotel> response = indexClient.Documents.Search<Hotel>(searchText, sp);\n        foreach (SearchResult<Hotel> result in response)\n        {\n            Console.WriteLine(result.Document);\n        }\n    }\n\nFirst, this method creates a new `SearchParameters` object. This is used to specify additional options for the query such as sorting, filtering, paging, and faceting. In this example, we're only setting the `Filter` property.\n\nThe next step is to actually execute the search query. This is done using the `Documents.Search` method. In this case, we pass the search text to use as a string, plus the search parameters created earlier. We also specify `Hotel` as the type parameter for `Documents.Search`, which tells the SDK to deserialize documents in the search results into objects of type `Hotel`.\n\nFinally, this method iterates through all the matches in the search results, printing each document to the console.\n\nLet's take a closer look at how this method is called:\n\n    SearchDocuments(indexClient, searchText: \"fancy wifi\");\n\n    SearchDocuments(indexClient, searchText: \"*\", filter: \"category eq 'Luxury'\");\n\nIn the first call, we're looking for all documents containing the query terms \"fancy\" or \"wifi\". In the second call, the search text is set to \"*\", which means \"find everything\". You can find more information about the search query expression syntax [here](https://msdn.microsoft.com/library/azure/dn798920.aspx).\n\nThe second call uses an OData `$filter` expression, `category eq 'Luxury'`. This constrains the search to only return documents where the `category` field exactly matches the string \"Luxury\". You can find out more about the OData syntax that Azure Search supports [here](https://msdn.microsoft.com/library/azure/dn798921.aspx).\n\nNow that you know what these two calls do, it should be easier to see why their output looks like this:\n\n    Searching documents 'fancy wifi'...\n\n    ID: 1058-441    Name: Fancy Stay        Category: Luxury        Tags: [pool, view, concierge]\n    ID: 956-532     Name: Express Rooms     Category: Budget        Tags: [wifi, budget]\n\n    Filter documents with category 'Luxury'...\n\n    ID: 1058-441    Name: Fancy Stay        Category: Luxury        Tags: [pool, view, concierge]\n    ID: 566-518     Name: Surprisingly Expensive Suites     Category: Luxury        Tags: []\n\nThe first search returns two documents. The first has \"Fancy\" in the name, while the second has \"wifi\" in the `tags` field. The second search returns two documents, which happen to be the only documents in the index that have the `category` field set to \"Luxury\".\n\nThis step completes the tutorial, but don't stop here. **Next steps** provides additional resources for learning more about Azure Search.\n\n## Next Steps ##\n\n- Deepen your knowledge through [videos and other samples and tutorials](https://msdn.microsoft.com/library/azure/dn818681.aspx).\n- Read about features and capabilities in this version of the Azure Search SDK: [Azure Search Overview](https://msdn.microsoft.com/library/azure/dn798933.aspx)\n- Review [naming conventions](https://msdn.microsoft.com/library/azure/dn857353.aspx) to learn the rules for naming various objects.\n- Review [supported data types](https://msdn.microsoft.com/library/azure/dn798938.aspx) in Azure Search.\n\n\n## Sample Application Source Code ##\n\nHere is the full source code of the sample application used in this walk through. Note that you will need to replace the service name and API key placeholders in Program.cs with your own values if you want to build and run the sample.\n\nProgram.cs:\n\n    using System;\n    using System.Configuration;\n    using System.Linq;\n    using System.Threading;\n    using Microsoft.Azure.Search;\n    using Microsoft.Azure.Search.Models;\n    using Microsoft.Spatial;\n\n    namespace AzureSearch.NETSDKSample\n    {\n        class Program\n        {\n            // This sample shows how to delete, create, upload documents and query an index\n            static void Main(string[] args)\n            {\n                // Put your search service name here. This is the hostname portion of your service URL.\n                // For example, if your service URL is https://myservice.search.windows.net, then your\n                // service name is myservice.\n                string searchServiceName = \"myservice\";\n\n                string apiKey = \"Put your API admin key here.\"\n\n                SearchServiceClient serviceClient = new SearchServiceClient(searchServiceName, new SearchCredentials(apiKey));\n\n                Console.WriteLine(\"{0}\", \"Deleting index...\\n\");\n                DeleteHotelsIndexIfExists(serviceClient);\n\n                Console.WriteLine(\"{0}\", \"Creating index...\\n\");\n                CreateHotelsIndex(serviceClient);\n\n                SearchIndexClient indexClient = serviceClient.Indexes.GetClient(\"hotels\");\n\n                Console.WriteLine(\"{0}\", \"Uploading documents...\\n\");\n                UploadDocuments(indexClient);\n\n                Console.WriteLine(\"{0}\", \"Searching documents 'fancy wifi'...\\n\");\n                SearchDocuments(indexClient, searchText: \"fancy wifi\");\n\n                Console.WriteLine(\"\\n{0}\", \"Filter documents with category 'Luxury'...\\n\");\n                SearchDocuments(indexClient, searchText: \"*\", filter: \"category eq 'Luxury'\");\n\n                Console.WriteLine(\"{0}\", \"Complete.  Press any key to end application...\\n\");\n                Console.ReadKey();\n            }\n\n            private static void DeleteHotelsIndexIfExists(SearchServiceClient serviceClient)\n            {\n                if (serviceClient.Indexes.Exists(\"hotels\"))\n                {\n                    serviceClient.Indexes.Delete(\"hotels\");\n                }\n            }\n\n            private static void CreateHotelsIndex(SearchServiceClient serviceClient)\n            {\n                var definition = new Index()\n                {\n                    Name = \"hotels\",\n                    Fields = new[]\n                    {\n                        new Field(\"hotelId\", DataType.String)                       { IsKey = true },\n                        new Field(\"hotelName\", DataType.String)                     { IsSearchable = true, IsFilterable = true },\n                        new Field(\"baseRate\", DataType.Double)                      { IsFilterable = true, IsSortable = true },\n                        new Field(\"category\", DataType.String)                      { IsSearchable = true, IsFilterable = true, IsSortable = true, IsFacetable = true },\n                        new Field(\"tags\", DataType.Collection(DataType.String))     { IsSearchable = true, IsFilterable = true, IsFacetable = true },\n                        new Field(\"parkingIncluded\", DataType.Boolean)              { IsFilterable = true, IsFacetable = true },\n                        new Field(\"lastRenovationDate\", DataType.DateTimeOffset)    { IsFilterable = true, IsSortable = true, IsFacetable = true },\n                        new Field(\"rating\", DataType.Int32)                         { IsFilterable = true, IsSortable = true, IsFacetable = true },\n                        new Field(\"location\", DataType.GeographyPoint)              { IsFilterable = true, IsSortable = true }\n                    }\n                };\n\n                serviceClient.Indexes.Create(definition);\n            }\n\n            private static void UploadDocuments(SearchIndexClient indexClient)\n            {\n                var documents =\n                    new Hotel[]\n                    {\n                        new Hotel()\n                        { \n                            HotelId = \"1058-441\", \n                            HotelName = \"Fancy Stay\", \n                            BaseRate = 199.0, \n                            Category = \"Luxury\", \n                            Tags = new[] { \"pool\", \"view\", \"concierge\" }, \n                            ParkingIncluded = false, \n                            LastRenovationDate = new DateTimeOffset(2010, 6, 27, 0, 0, 0, TimeSpan.Zero), \n                            Rating = 5, \n                            Location = GeographyPoint.Create(47.678581, -122.131577)\n                        },\n                        new Hotel()\n                        { \n                            HotelId = \"666-437\", \n                            HotelName = \"Roach Motel\",\n                            BaseRate = 79.99,\n                            Category = \"Budget\",\n                            Tags = new[] { \"motel\", \"budget\" },\n                            ParkingIncluded = true,\n                            LastRenovationDate = new DateTimeOffset(1982, 4, 28, 0, 0, 0, TimeSpan.Zero),\n                            Rating = 1,\n                            Location = GeographyPoint.Create(49.678581, -122.131577)\n                        },\n                        new Hotel() \n                        { \n                            HotelId = \"970-501\", \n                            HotelName = \"Econo-Stay\",\n                            BaseRate = 129.99,\n                            Category = \"Budget\",\n                            Tags = new[] { \"pool\", \"budget\" },\n                            ParkingIncluded = true,\n                            LastRenovationDate = new DateTimeOffset(1995, 7, 1, 0, 0, 0, TimeSpan.Zero),\n                            Rating = 4,\n                            Location = GeographyPoint.Create(46.678581, -122.131577)\n                        },\n                        new Hotel()\n                        { \n                            HotelId = \"956-532\", \n                            HotelName = \"Express Rooms\",\n                            BaseRate = 129.99,\n                            Category = \"Budget\",\n                            Tags = new[] { \"wifi\", \"budget\" },\n                            ParkingIncluded = true,\n                            LastRenovationDate = new DateTimeOffset(1995, 7, 1, 0, 0, 0, TimeSpan.Zero),\n                            Rating = 4,\n                            Location = GeographyPoint.Create(48.678581, -122.131577)\n                        },\n                        new Hotel() \n                    {\n                            HotelId = \"566-518\", \n                            HotelName = \"Surprisingly Expensive Suites\",\n                            BaseRate = 279.99,\n                            Category = \"Luxury\",\n                            ParkingIncluded = false\n                        }\n                    };\n\n                try\n                {\n                    indexClient.Documents.Index(IndexBatch.Create(documents.Select(doc => IndexAction.Create(doc))));\n                }\n                catch (IndexBatchException e)\n                {\n                    // Sometimes when your Search service is under load, indexing will fail for some of the documents in\n                    // the batch. Depending on your application, you can take compensating actions like delaying and\n                    // retrying. For this simple demo, we just log the failed document keys and continue.\n                    Console.WriteLine(\n                        \"Failed to index some of the documents: {0}\",\n                        String.Join(\", \", e.IndexResponse.Results.Where(r => !r.Succeeded).Select(r => r.Key)));\n                }\n\n                // Wait a while for indexing to complete.\n                Thread.Sleep(2000);\n            }\n\n            private static void SearchDocuments(SearchIndexClient indexClient, string searchText, string filter = null)\n            {\n                // Execute search based on search text and optional filter\n                var sp = new SearchParameters();\n\n                if (!String.IsNullOrEmpty(filter))\n                {\n                    sp.Filter = filter;\n                }\n\n                DocumentSearchResponse<Hotel> response = indexClient.Documents.Search<Hotel>(searchText, sp);\n                foreach (SearchResult<Hotel> result in response)\n                {\n                    Console.WriteLine(result.Document);\n                }\n            }\n        }\n    }\n\nHotel.cs:\n\n    using System;\n    using Microsoft.Azure.Search.Models;\n    using Microsoft.Spatial;\n\n    namespace AzureSearch.NETSDKSample\n    {\n        [SerializePropertyNamesAsCamelCase]\n        public class Hotel\n        {\n            public string HotelId { get; set; }\n\n            public string HotelName { get; set; }\n\n            public double? BaseRate { get; set; }\n\n            public string Category { get; set; }\n\n            public string[] Tags { get; set; }\n\n            public bool? ParkingIncluded { get; set; }\n\n            public DateTimeOffset? LastRenovationDate { get; set; }\n\n            public int? Rating { get; set; }\n\n            public GeographyPoint Location { get; set; }\n\n            public override string ToString()\n            {\n                return String.Format(\n                    \"ID: {0}\\tName: {1}\\tCategory: {2}\\tTags: [{3}]\",\n                    HotelId,\n                    HotelName,\n                    Category,\n                    (Tags != null) ? String.Join(\", \", Tags) : String.Empty);\n            }\n        }\n    }\n "
}