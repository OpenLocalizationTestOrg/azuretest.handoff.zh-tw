<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>DataStax Enterprise on Ubuntu with a Resource Manager Template</source>
          <target state="new">DataStax Enterprise on Ubuntu with a Resource Manager Template</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Learn to easily deploy a new DataStax Enterprise cluster on Ubuntu VMs using Azure PowerShell or the Azure CLI and a Resource Manager template</source>
          <target state="new">Learn to easily deploy a new DataStax Enterprise cluster on Ubuntu VMs using Azure PowerShell or the Azure CLI and a Resource Manager template</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source><ph id="ph1">

#</ph> DataStax Enterprise on Ubuntu with a Resource Manager Template

DataStax is a recognized industry leader in developing and delivering solutions based on Apache Cassandra™ - the commercially-supported, enterprise-ready NoSQL distributed database technology that is widely-acknowledged as agile, always-on, and predictably scalable to any size.</source>
          <target state="new"><ph id="ph1">

#</ph> DataStax Enterprise on Ubuntu with a Resource Manager Template

DataStax is a recognized industry leader in developing and delivering solutions based on Apache Cassandra™ - the commercially-supported, enterprise-ready NoSQL distributed database technology that is widely-acknowledged as agile, always-on, and predictably scalable to any size.</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>DataStax offers both the Enterprise (DSE) and Community (DSC) flavors.</source>
          <target state="new">DataStax offers both the Enterprise (DSE) and Community (DSC) flavors.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>In addition to what the Community edition provides, Datastax Enterprise is Production-certified Cassandra with capabilities like in-memory computing, enterprise-level security, fast and powerful integrated analytics, and enterprise management.</source>
          <target state="new">In addition to what the Community edition provides, Datastax Enterprise is Production-certified Cassandra with capabilities like in-memory computing, enterprise-level security, fast and powerful integrated analytics, and enterprise management.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&gt;[AZURE.NOTE]</ph> Unlike the Community edition, in order to deploy DataStax Enterprise, you need to have a valid DataStax account (username and password) to pass in as parameters during template deployment.</source>
          <target state="new"><ph id="ph1">&gt;[AZURE.NOTE]</ph> Unlike the Community edition, in order to deploy DataStax Enterprise, you need to have a valid DataStax account (username and password) to pass in as parameters during template deployment.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Visit the <bpt id="p1">[</bpt><ept id="p1">Datastax](http://www.datastax.com)</ept> website to set up your account if you don’t have one already.</source>
          <target state="new">Visit the <bpt id="p1">[</bpt><ept id="p1">Datastax](http://www.datastax.com)</ept> website to set up your account if you don’t have one already.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>In addition to what is already available in Azure Marketplace, now you can also easily deploy a new Datastax Enterprise cluster on Ubuntu VMs using a Resource Manager template deployed through <bpt id="p1">[</bpt><ept id="p1">Azure PowerShell](../powershell-install-configure.md)</ept> or the <bpt id="p2">[</bpt><ept id="p2">Azure CLI](../xplat-cli.md)</ept>.</source>
          <target state="new">In addition to what is already available in Azure Marketplace, now you can also easily deploy a new Datastax Enterprise cluster on Ubuntu VMs using a Resource Manager template deployed through <bpt id="p1">[</bpt><ept id="p1">Azure PowerShell](../powershell-install-configure.md)</ept> or the <bpt id="p2">[</bpt><ept id="p2">Azure CLI](../xplat-cli.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Newly deployed clusters based on this template will have the topology described in the following diagram, although other topologies can be easily achieved by customizing the template presented in this article.</source>
          <target state="new">Newly deployed clusters based on this template will have the topology described in the following diagram, although other topologies can be easily achieved by customizing the template presented in this article.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><ph id="ph1">![cluster-architecture](media/virtual-machines-datastax-enterprise-template/cluster-architecture.png)</ph>

Using parameters, you can define the number of nodes that will be deployed in the new Apache Cassandra cluster.</source>
          <target state="new"><ph id="ph1">![cluster-architecture](media/virtual-machines-datastax-enterprise-template/cluster-architecture.png)</ph>

Using parameters, you can define the number of nodes that will be deployed in the new Apache Cassandra cluster.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>An instance of the DataStax Operation Center service will be also deployed in a standalone VM within the same VNET, giving you the ability to monitor the status of the cluster and all individual nodes, add/remove nodes, and perform all administrative tasks related to that cluster.</source>
          <target state="new">An instance of the DataStax Operation Center service will be also deployed in a standalone VM within the same VNET, giving you the ability to monitor the status of the cluster and all individual nodes, add/remove nodes, and perform all administrative tasks related to that cluster.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Once the deployment is complete, you can access the Datastax Operations Center VM instance using the configured DNS address.</source>
          <target state="new">Once the deployment is complete, you can access the Datastax Operations Center VM instance using the configured DNS address.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The OpsCenter VM has SSH port 22 enabled, as well as port 8443 for HTTPS.</source>
          <target state="new">The OpsCenter VM has SSH port 22 enabled, as well as port 8443 for HTTPS.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The DNS address for the operations center will include the <bpt id="p1">*</bpt>dnsName<ept id="p1">*</ept> and <bpt id="p2">*</bpt>region<ept id="p2">*</ept> entered as parameters, resulting in the format <ph id="ph1">`{dnsName}.{region}.cloudapp.azure.com`</ph>.</source>
          <target state="new">The DNS address for the operations center will include the <bpt id="p1">*</bpt>dnsName<ept id="p1">*</ept> and <bpt id="p2">*</bpt>region<ept id="p2">*</ept> entered as parameters, resulting in the format <ph id="ph1">`{dnsName}.{region}.cloudapp.azure.com`</ph>.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>If you created a deployment with the <bpt id="p1">*</bpt>dnsName<ept id="p1">*</ept> parameter set to "datastax” in the "West US” region you could access the Datastax Operations Center VM for the deployment at <ph id="ph1">`https://datastax.westus.cloudapp.azure.com:8443`</ph>.</source>
          <target state="new">If you created a deployment with the <bpt id="p1">*</bpt>dnsName<ept id="p1">*</ept> parameter set to "datastax” in the "West US” region you could access the Datastax Operations Center VM for the deployment at <ph id="ph1">`https://datastax.westus.cloudapp.azure.com:8443`</ph>.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&gt; [AZURE.NOTE]</ph> The certificate used in the deployment is a self-signed certificate that will create a browser warning.</source>
          <target state="new"><ph id="ph1">&gt; [AZURE.NOTE]</ph> The certificate used in the deployment is a self-signed certificate that will create a browser warning.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>You can follow the process on the <bpt id="p1">[</bpt><ept id="p1">Datastax](http://www.datastax.com/)</ept> web site for replacing the certificate with your own SSL certificate.</source>
          <target state="new">You can follow the process on the <bpt id="p1">[</bpt><ept id="p1">Datastax](http://www.datastax.com/)</ept> web site for replacing the certificate with your own SSL certificate.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Before diving into more details related to the Azure Resource Manager and the template we will use for this deployment, make sure you have Azure PowerShell or the Azure CLI configured correctly.</source>
          <target state="new">Before diving into more details related to the Azure Resource Manager and the template we will use for this deployment, make sure you have Azure PowerShell or the Azure CLI configured correctly.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.INCLUDE [arm-getting-setup-powershell](../../includes/arm-getting-setup-powershell.md)]</ph><ph id="ph2">

[AZURE.INCLUDE [xplat-getting-set-up-arm](../../includes/xplat-getting-set-up-arm.md)]</ph><ph id="ph3">

##</ph> Create a Datastax Enterprise-based Cassandra cluster with a Resource Manager template

Follow these steps to create an Apache Cassandra cluster, based on DataStax Enterprise, using a Resource Manager template from the Github template repository.</source>
          <target state="new"><ph id="ph1">[AZURE.INCLUDE [arm-getting-setup-powershell](../../includes/arm-getting-setup-powershell.md)]</ph><ph id="ph2">

[AZURE.INCLUDE [xplat-getting-set-up-arm](../../includes/xplat-getting-set-up-arm.md)]</ph><ph id="ph3">

##</ph> Create a Datastax Enterprise-based Cassandra cluster with a Resource Manager template

Follow these steps to create an Apache Cassandra cluster, based on DataStax Enterprise, using a Resource Manager template from the Github template repository.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Each step will include directions for both Azure PowerShell and the Azure CLI.</source>
          <target state="new">Each step will include directions for both Azure PowerShell and the Azure CLI.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Step 1-a: Download the template files using PowerShell

Create a local folder for the JSON template and other associated files (for example, C:\Azure\Templates\DataStax).</source>
          <target state="new">Step 1-a: Download the template files using PowerShell

Create a local folder for the JSON template and other associated files (for example, C:\Azure\Templates\DataStax).</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Substitute in the folder name of your local folder and run the next set of commands.</source>
          <target state="new">Substitute in the folder name of your local folder and run the next set of commands.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>$folderName="C:\Azure\Templates\DataStax"
    $webclient = New-Object System.Net.WebClient
    $url = "https://raw.githubusercontent.com/azure/azure-quickstart-templates/master/datastax-enterprise/azuredeploy.json"
    $filePath = $folderName + "\azuredeploy.json"
    $webclient.DownloadFile($url,$filePath)
    $url = "https://raw.githubusercontent.com/azure/azure-quickstart-templates/master/datastax-enterprise/azuredeploy-parameters.json"
    $filePath = $folderName + "\azuredeploy-parameters.json"
    $webclient.DownloadFile($url,$filePath)
    $url = "https://raw.githubusercontent.com/azure/azure-quickstart-templates/master/datastax-enterprise/dsenode.sh"
    $filePath = $folderName + "\dsenode.sh"
    $webclient.DownloadFile($url,$filePath)
    $url = "https://raw.githubusercontent.com/azure/azure-quickstart-templates/master/datastax-enterprise/ephemeral-nodes-resources.json"
    $filePath = $folderName + "\ephemeral-nodes-resources.json"
    $webclient.DownloadFile($url,$filePath)
    $url = "https://raw.githubusercontent.com/azure/azure-quickstart-templates/master/datastax-enterprise/metadata.json"
    $filePath = $folderName + "\metadata.json"
    $webclient.DownloadFile($url,$filePath)
    $url = "https://raw.githubusercontent.com/azure/azure-quickstart-templates/master/datastax-enterprise/opscenter-install-resources.json"
    $filePath = $folderName + "\opscenter-install-resources.json"
    $webclient.DownloadFile($url,$filePath)
    $url = "https://raw.githubusercontent.com/azure/azure-quickstart-templates/master/datastax-enterprise/opscenter-resources.json"
    $filePath = $folderName + "\opscenter-resources.json"
    $webclient.DownloadFile($url,$filePath)
    $url = "https://raw.githubusercontent.com/azure/azure-quickstart-templates/master/datastax-enterprise/opscenter.sh"
    $filePath = $folderName + "\opscenter.sh"
    $webclient.DownloadFile($url,$filePath)
    $url = "https://raw.githubusercontent.com/azure/azure-quickstart-templates/master/datastax-enterprise/shared-resources.json"
    $filePath = $folderName + "shared-resources.json"
    $webclient.DownloadFile($url,$filePath)

### Step 1-b: Download the template files using the Azure CLI

Clone the entire template repository using a git client of your choice, as shown in the next example.</source>
          <target state="new">$folderName="C:\Azure\Templates\DataStax"
    $webclient = New-Object System.Net.WebClient
    $url = "https://raw.githubusercontent.com/azure/azure-quickstart-templates/master/datastax-enterprise/azuredeploy.json"
    $filePath = $folderName + "\azuredeploy.json"
    $webclient.DownloadFile($url,$filePath)
    $url = "https://raw.githubusercontent.com/azure/azure-quickstart-templates/master/datastax-enterprise/azuredeploy-parameters.json"
    $filePath = $folderName + "\azuredeploy-parameters.json"
    $webclient.DownloadFile($url,$filePath)
    $url = "https://raw.githubusercontent.com/azure/azure-quickstart-templates/master/datastax-enterprise/dsenode.sh"
    $filePath = $folderName + "\dsenode.sh"
    $webclient.DownloadFile($url,$filePath)
    $url = "https://raw.githubusercontent.com/azure/azure-quickstart-templates/master/datastax-enterprise/ephemeral-nodes-resources.json"
    $filePath = $folderName + "\ephemeral-nodes-resources.json"
    $webclient.DownloadFile($url,$filePath)
    $url = "https://raw.githubusercontent.com/azure/azure-quickstart-templates/master/datastax-enterprise/metadata.json"
    $filePath = $folderName + "\metadata.json"
    $webclient.DownloadFile($url,$filePath)
    $url = "https://raw.githubusercontent.com/azure/azure-quickstart-templates/master/datastax-enterprise/opscenter-install-resources.json"
    $filePath = $folderName + "\opscenter-install-resources.json"
    $webclient.DownloadFile($url,$filePath)
    $url = "https://raw.githubusercontent.com/azure/azure-quickstart-templates/master/datastax-enterprise/opscenter-resources.json"
    $filePath = $folderName + "\opscenter-resources.json"
    $webclient.DownloadFile($url,$filePath)
    $url = "https://raw.githubusercontent.com/azure/azure-quickstart-templates/master/datastax-enterprise/opscenter.sh"
    $filePath = $folderName + "\opscenter.sh"
    $webclient.DownloadFile($url,$filePath)
    $url = "https://raw.githubusercontent.com/azure/azure-quickstart-templates/master/datastax-enterprise/shared-resources.json"
    $filePath = $folderName + "shared-resources.json"
    $webclient.DownloadFile($url,$filePath)

### Step 1-b: Download the template files using the Azure CLI

Clone the entire template repository using a git client of your choice, as shown in the next example.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>git clone https://github.com/Azure/azure-quickstart-templates C:\Azure\Templates

When completed, look for the datastax-enterprise folder in your C:\Azure\Templates directory.</source>
          <target state="new">git clone https://github.com/Azure/azure-quickstart-templates C:\Azure\Templates

When completed, look for the datastax-enterprise folder in your C:\Azure\Templates directory.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Step 2: (optional) Understand the template parameters</source>
          <target state="new">Step 2: (optional) Understand the template parameters</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>When you deploy non-trivial solutions like an Apache Cassandra cluster based on DataStax, you must specify a set of configuration parameters to deal with a number of required settings.</source>
          <target state="new">When you deploy non-trivial solutions like an Apache Cassandra cluster based on DataStax, you must specify a set of configuration parameters to deal with a number of required settings.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>By declaring these parameters in the template definition, it’s possible to specify values during deployment through an external file or in the command line.</source>
          <target state="new">By declaring these parameters in the template definition, it’s possible to specify values during deployment through an external file or in the command line.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>In the "parameters" section at the top of the azuredeploy.json file, you’ll find the set of parameters that are required by the template to configure a Datastax Enterprise cluster.</source>
          <target state="new">In the "parameters" section at the top of the azuredeploy.json file, you’ll find the set of parameters that are required by the template to configure a Datastax Enterprise cluster.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Here is an example of the parameters section from this template's azuredeploy.json file.</source>
          <target state="new">Here is an example of the parameters section from this template's azuredeploy.json file.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Each parameter has details such as data type and allowed values.</source>
          <target state="new">Each parameter has details such as data type and allowed values.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This allows for validation of parameters passed during template execution in an interactive mode (for example, PowerShell or Azure CLI), as well as a self-discovery UI that could be dynamically-built by parsing the list of required parameters and their descriptions.</source>
          <target state="new">This allows for validation of parameters passed during template execution in an interactive mode (for example, PowerShell or Azure CLI), as well as a self-discovery UI that could be dynamically-built by parsing the list of required parameters and their descriptions.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Step 3-a: Deploy a DataStax Enterprise cluster with a template using PowerShell</source>
          <target state="new">Step 3-a: Deploy a DataStax Enterprise cluster with a template using PowerShell</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Prepare a parameters file for your deployment by creating a JSON file containing run-time values for all parameters.</source>
          <target state="new">Prepare a parameters file for your deployment by creating a JSON file containing run-time values for all parameters.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>This file will then be passed as a single entity to the deployment command.</source>
          <target state="new">This file will then be passed as a single entity to the deployment command.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>If you do not include a parameters file, PowerShell will use any default values specified in the template, and then prompt you to fill in the remaining values.</source>
          <target state="new">If you do not include a parameters file, PowerShell will use any default values specified in the template, and then prompt you to fill in the remaining values.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The next example is a set of parameters from the azuredeploy-parameters.json file.</source>
          <target state="new">The next example is a set of parameters from the azuredeploy-parameters.json file.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Fill in an Azure deployment name, resource group name, Azure location, and the folder of your saved JSON deployment file.</source>
          <target state="new">Fill in an Azure deployment name, resource group name, Azure location, and the folder of your saved JSON deployment file.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Then run the next set of commands.</source>
          <target state="new">Then run the next set of commands.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>When you run the <bpt id="p1">**</bpt>New-AzureResourceGroupDeployment<ept id="p1">**</ept> command, this will extract parameter values from the JSON parameters file, and will start executing the template accordingly.</source>
          <target state="new">When you run the <bpt id="p1">**</bpt>New-AzureResourceGroupDeployment<ept id="p1">**</ept> command, this will extract parameter values from the JSON parameters file, and will start executing the template accordingly.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Defining and using multiple parameter files with your different environments (for example, Test, or Production) will promote template reuse and simplify complex multi-environment solutions.</source>
          <target state="new">Defining and using multiple parameter files with your different environments (for example, Test, or Production) will promote template reuse and simplify complex multi-environment solutions.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>When deploying, keep in mind that a new Azure Storage Account needs to be created so the name you provide as the storage account parameter must be unique and meet all requirements for an Azure Storage Account (lowercase letters and numbers only).</source>
          <target state="new">When deploying, keep in mind that a new Azure Storage Account needs to be created so the name you provide as the storage account parameter must be unique and meet all requirements for an Azure Storage Account (lowercase letters and numbers only).</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>During and after deployment, you can check all the requests that were made during provisioning, including any errors that occurred.</source>
          <target state="new">During and after deployment, you can check all the requests that were made during provisioning, including any errors that occurred.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>To do that, go to the <bpt id="p1">[</bpt>Azure Portal<ept id="p1">](https://portal.azure.com)</ept> and do the following:</source>
          <target state="new">To do that, go to the <bpt id="p1">[</bpt>Azure Portal<ept id="p1">](https://portal.azure.com)</ept> and do the following:</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Click "Browse” on the left-hand navigation bar, scroll down and click "Resource Groups”.</source>
          <target state="new">Click "Browse” on the left-hand navigation bar, scroll down and click "Resource Groups”.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>After clicking the Resource Group that you just created, it will bring up the "Resource Group” blade.</source>
          <target state="new">After clicking the Resource Group that you just created, it will bring up the "Resource Group” blade.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>By clicking the "Events” bar graph in the "Monitoring” part of the "Resource Group” blade, you can see the events for your deployment:</source>
          <target state="new">By clicking the "Events” bar graph in the "Monitoring” part of the "Resource Group” blade, you can see the events for your deployment:</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Clicking individual events lets you drill further down into the details of each individual operation made on behalf of the template.</source>
          <target state="new">Clicking individual events lets you drill further down into the details of each individual operation made on behalf of the template.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>After your tests, if you need to remove this resource group and all of its resources (the storage account, virtual machine, and virtual network), use the next command.</source>
          <target state="new">After your tests, if you need to remove this resource group and all of its resources (the storage account, virtual machine, and virtual network), use the next command.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Step 3-b: Deploy a DataStax Enterprise cluster with a template using the Azure CLI</source>
          <target state="new">Step 3-b: Deploy a DataStax Enterprise cluster with a template using the Azure CLI</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>To deploy a Datastax Enterprise cluster via the Azure CLI, first create a Resource Group by specifying a name and a location with the next command.</source>
          <target state="new">To deploy a Datastax Enterprise cluster via the Azure CLI, first create a Resource Group by specifying a name and a location with the next command.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Pass this Resource Group name, the location of the JSON template file, and the location of the parameters file (see the above PowerShell section for details) into the following command.</source>
          <target state="new">Pass this Resource Group name, the location of the JSON template file, and the location of the parameters file (see the above PowerShell section for details) into the following command.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You can check the status of individual resources deployments with the following command.</source>
          <target state="new">You can check the status of individual resources deployments with the following command.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>A tour of the Datastax Enterprise template structure and file organization</source>
          <target state="new">A tour of the Datastax Enterprise template structure and file organization</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>In order to design a robust and reusable Resource Manager template, additional thinking is needed to organize the series of complex and interrelated tasks required during the deployment of a complex solution like DataStax Enterprise.</source>
          <target state="new">In order to design a robust and reusable Resource Manager template, additional thinking is needed to organize the series of complex and interrelated tasks required during the deployment of a complex solution like DataStax Enterprise.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Leveraging ARM <bpt id="p1">**</bpt>template linking<ept id="p1">**</ept> and <bpt id="p2">**</bpt>resource looping<ept id="p2">**</ept> in addition to script execution through related extensions, it’s possible to implement a modular approach that can be reused with virtually any complex template-based deployment.</source>
          <target state="new">Leveraging ARM <bpt id="p1">**</bpt>template linking<ept id="p1">**</ept> and <bpt id="p2">**</bpt>resource looping<ept id="p2">**</ept> in addition to script execution through related extensions, it’s possible to implement a modular approach that can be reused with virtually any complex template-based deployment.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The next diagram describes the relationships between all the files downloaded from GitHub for this deployment.</source>
          <target state="new">The next diagram describes the relationships between all the files downloaded from GitHub for this deployment.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><ph id="ph1">![datastax-enterprise-files](media/virtual-machines-datastax-enterprise-template/datastax-enterprise-files.png)</ph>

This section steps you through the structure of the azuredeploy.json file for the Datastax Enterprise cluster.</source>
          <target state="new"><ph id="ph1">![datastax-enterprise-files](media/virtual-machines-datastax-enterprise-template/datastax-enterprise-files.png)</ph>

This section steps you through the structure of the azuredeploy.json file for the Datastax Enterprise cluster.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>"parameters" section

The "parameters" section of azuredeploy.json specifies modifiable parameters that are used in this template.</source>
          <target state="new">"parameters" section

The "parameters" section of azuredeploy.json specifies modifiable parameters that are used in this template.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The previously mentioned azuredeploy-parameters.json file is used to pass values into the "parameters" section of azuredeploy.json during template execution.</source>
          <target state="new">The previously mentioned azuredeploy-parameters.json file is used to pass values into the "parameters" section of azuredeploy.json during template execution.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>"variables" section

The "variables" section specifies variables that can be used throughout this template.</source>
          <target state="new">"variables" section

The "variables" section specifies variables that can be used throughout this template.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>This contains a number of fields (JSON data types or fragments) that will be set to constants or calculated values at execution time.</source>
          <target state="new">This contains a number of fields (JSON data types or fragments) that will be set to constants or calculated values at execution time.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The next example shows the "variables" section for this Datastax template.</source>
          <target state="new">The next example shows the "variables" section for this Datastax template.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>"variables": {
    "templateBaseUrl": "https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/datastax-enterprise/",
    "sharedTemplateUrl": "[concat(variables('templateBaseUrl'), 'shared-resources.json')]",
    "clusterNodesTemplateUrl": "[concat(variables('templateBaseUrl'), 'ephemeral-nodes-resources.json')]",
    "opsCenterTemplateUrl": "[concat(variables('templateBaseUrl'), 'opscenter-resources.json')]",
    "opsCenterInstallTemplateUrl": "[concat(variables('templateBaseUrl'), 'opscenter-install-resources.json')]",
    "opsCenterVmSize": "Standard_A1",
    "networkSettings": {
        "virtualNetworkName": "[parameters('virtualNetworkName')]",
        "addressPrefix": "10.0.0.0/16",
        "subnet": {
            "dse": {
                "name": "dse",
                "prefix": "10.0.0.0/24",
                "vnet": "[parameters('virtualNetworkName')]"
            }
        },
        "statics": {
            "clusterRange": {
                "base": "10.0.0.",
                "start": 5
            },
            "opsCenter": "10.0.0.240"
        }
    },
    "osSettings": {
        "imageReference": {
            "publisher": "Canonical",
            "offer": "UbuntuServer",
            "sku": "14.04.2-LTS",
            "version": "latest"
        },
        "scripts": [
            "[concat(variables('templateBaseUrl'), 'dsenode.sh')]",
            "[concat(variables('templateBaseUrl'), 'opscenter.sh')]",
            "https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/shared_scripts/ubuntu/vm-disk-utils-0.1.sh"
        ]
    },
    "sharedStorageAccountName": "[concat(parameters('storageAccountPrefix'),'cmn')]",
    "nodeList": "[concat(variables('networkSettings').statics.clusterRange.base, variables('networkSettings').statics.clusterRange.start, '-', parameters('clusterNodeCount'))]"
    },

In the previous example, you can see two different approaches.</source>
          <target state="new">"variables": {
    "templateBaseUrl": "https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/datastax-enterprise/",
    "sharedTemplateUrl": "[concat(variables('templateBaseUrl'), 'shared-resources.json')]",
    "clusterNodesTemplateUrl": "[concat(variables('templateBaseUrl'), 'ephemeral-nodes-resources.json')]",
    "opsCenterTemplateUrl": "[concat(variables('templateBaseUrl'), 'opscenter-resources.json')]",
    "opsCenterInstallTemplateUrl": "[concat(variables('templateBaseUrl'), 'opscenter-install-resources.json')]",
    "opsCenterVmSize": "Standard_A1",
    "networkSettings": {
        "virtualNetworkName": "[parameters('virtualNetworkName')]",
        "addressPrefix": "10.0.0.0/16",
        "subnet": {
            "dse": {
                "name": "dse",
                "prefix": "10.0.0.0/24",
                "vnet": "[parameters('virtualNetworkName')]"
            }
        },
        "statics": {
            "clusterRange": {
                "base": "10.0.0.",
                "start": 5
            },
            "opsCenter": "10.0.0.240"
        }
    },
    "osSettings": {
        "imageReference": {
            "publisher": "Canonical",
            "offer": "UbuntuServer",
            "sku": "14.04.2-LTS",
            "version": "latest"
        },
        "scripts": [
            "[concat(variables('templateBaseUrl'), 'dsenode.sh')]",
            "[concat(variables('templateBaseUrl'), 'opscenter.sh')]",
            "https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/shared_scripts/ubuntu/vm-disk-utils-0.1.sh"
        ]
    },
    "sharedStorageAccountName": "[concat(parameters('storageAccountPrefix'),'cmn')]",
    "nodeList": "[concat(variables('networkSettings').statics.clusterRange.base, variables('networkSettings').statics.clusterRange.start, '-', parameters('clusterNodeCount'))]"
    },

In the previous example, you can see two different approaches.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>In the first fragment, the "osSettings” variable is a nested JSON element containing 4 key-value pairs.</source>
          <target state="new">In the first fragment, the "osSettings” variable is a nested JSON element containing 4 key-value pairs.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>"osSettings": {
          "imageReference": {
            "publisher": "Canonical",
            "offer": "UbuntuServer",
            "sku": "14.04.2-LTS",
            "version": "latest"
          },

     
In the second fragment, the "scripts" variable is a JSON array where each element will be calculated at runtime using a template language function (concat) and the value of another variable plus string constants.</source>
          <target state="new">"osSettings": {
          "imageReference": {
            "publisher": "Canonical",
            "offer": "UbuntuServer",
            "sku": "14.04.2-LTS",
            "version": "latest"
          },

     
In the second fragment, the "scripts" variable is a JSON array where each element will be calculated at runtime using a template language function (concat) and the value of another variable plus string constants.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>"scripts": [
            "[concat(variables('templateBaseUrl'), 'dsenode.sh')]",
            "[concat(variables('templateBaseUrl'), 'opscenter.sh')]",
            "https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/shared_scripts/ubuntu/vm-disk-utils-0.1.sh"
          ]

### "resources" section

The "resources" section is where most of the action is happening.</source>
          <target state="new">"scripts": [
            "[concat(variables('templateBaseUrl'), 'dsenode.sh')]",
            "[concat(variables('templateBaseUrl'), 'opscenter.sh')]",
            "https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/shared_scripts/ubuntu/vm-disk-utils-0.1.sh"
          ]

### "resources" section

The "resources" section is where most of the action is happening.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Looking inside this section, you can immediately identify two different cases: the first one is an element defined of type <ph id="ph1">`Microsoft.Resources/deployments`</ph> that basically means the invocation of a nested deployment within the main one.</source>
          <target state="new">Looking inside this section, you can immediately identify two different cases: the first one is an element defined of type <ph id="ph1">`Microsoft.Resources/deployments`</ph> that basically means the invocation of a nested deployment within the main one.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Through the "templateLink" element (and related version property), it’s possible to specify a linked template file that will be invoked by passing a set of parameters as input, as shown in the next example.</source>
          <target state="new">Through the "templateLink" element (and related version property), it’s possible to specify a linked template file that will be invoked by passing a set of parameters as input, as shown in the next example.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>{
          "name": "shared",
          "type": "Microsoft.Resources/deployments",
          "apiVersion": "2015-01-01",
          "properties": {
            "mode": "Incremental",
            "templateLink": {
              "uri": "[variables('sharedTemplateUrl')]",
              "contentVersion": "1.0.0.0"
            },
            "parameters": {
              "region": {
                "value": "[parameters('region')]"
              },
              "networkSettings": {
                "value": "[variables('networkSettings')]"
              },
              "storageAccountName": {
                "value": "[variables('sharedStorageAccountName')]"
              }
            }
          }
        },

From this first example, it is clear how azuredeploy.json in this scenario has been organized as a sort of orchestration mechanism, invoking a number of other template files, each one responsible for part of the required deployment activities.</source>
          <target state="new">{
          "name": "shared",
          "type": "Microsoft.Resources/deployments",
          "apiVersion": "2015-01-01",
          "properties": {
            "mode": "Incremental",
            "templateLink": {
              "uri": "[variables('sharedTemplateUrl')]",
              "contentVersion": "1.0.0.0"
            },
            "parameters": {
              "region": {
                "value": "[parameters('region')]"
              },
              "networkSettings": {
                "value": "[variables('networkSettings')]"
              },
              "storageAccountName": {
                "value": "[variables('sharedStorageAccountName')]"
              }
            }
          }
        },

From this first example, it is clear how azuredeploy.json in this scenario has been organized as a sort of orchestration mechanism, invoking a number of other template files, each one responsible for part of the required deployment activities.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>In particular, the following linked templates will be used for this deployment:</source>
          <target state="new">In particular, the following linked templates will be used for this deployment:</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>shared-resource.json<ept id="p1">**</ept>: Contains the definition of all resources that will be shared across the deployment.</source>
          <target state="new"><bpt id="p1">**</bpt>shared-resource.json<ept id="p1">**</ept>: Contains the definition of all resources that will be shared across the deployment.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Examples are storage accounts used to store VM’s OS disks and virtual networks.</source>
          <target state="new">Examples are storage accounts used to store VM’s OS disks and virtual networks.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>opscenter-resources.json<ept id="p1">**</ept>: Deploys an OpsCenter VM and all related resources, including a network interface and public IP address.</source>
          <target state="new"><bpt id="p1">**</bpt>opscenter-resources.json<ept id="p1">**</ept>: Deploys an OpsCenter VM and all related resources, including a network interface and public IP address.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>opscenter-install-resources.json<ept id="p1">**</ept>: Deploys the OpsCenter VM extension (custom script for Linux) that will invoke the specific bash script file (opscenter.sh) required to set up the OpsCenter service within that VM.</source>
          <target state="new"><bpt id="p1">**</bpt>opscenter-install-resources.json<ept id="p1">**</ept>: Deploys the OpsCenter VM extension (custom script for Linux) that will invoke the specific bash script file (opscenter.sh) required to set up the OpsCenter service within that VM.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>ephemeral-nodes-resources.json<ept id="p1">**</ept>: Deploys all cluster node VMs and connected resources (for example, network cards, and private IPs.).</source>
          <target state="new"><bpt id="p1">**</bpt>ephemeral-nodes-resources.json<ept id="p1">**</ept>: Deploys all cluster node VMs and connected resources (for example, network cards, and private IPs.).</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>This template will also deploy VM extensions (custom scripts for Linux) and invoke a bash script (dsenode.sh) to physically install Apache Cassandra bits on each node.</source>
          <target state="new">This template will also deploy VM extensions (custom scripts for Linux) and invoke a bash script (dsenode.sh) to physically install Apache Cassandra bits on each node.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Let’s drill down into how this last template is used, as it is one of the most interesting from a template development perspective.</source>
          <target state="new">Let’s drill down into how this last template is used, as it is one of the most interesting from a template development perspective.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>One important concept to highlight is how a single template file can deploy multiple copies of a single resource type, and for each instance can set unique values for required settings.</source>
          <target state="new">One important concept to highlight is how a single template file can deploy multiple copies of a single resource type, and for each instance can set unique values for required settings.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This concept is known as Resource Looping.</source>
          <target state="new">This concept is known as Resource Looping.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>When ephemeral-nodes-resources.json is invoked from within the main azuredeploy.json file, a parameter called nodeCount is provided as part of the parameters list.</source>
          <target state="new">When ephemeral-nodes-resources.json is invoked from within the main azuredeploy.json file, a parameter called nodeCount is provided as part of the parameters list.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Within the child template, nodeCount (the number of nodes to deploy in the cluster) will be used inside the <bpt id="p1">**</bpt>"copy”<ept id="p1">**</ept> element of each resource that needs to be deployed in multiple copies, as highlighted in the next example.</source>
          <target state="new">Within the child template, nodeCount (the number of nodes to deploy in the cluster) will be used inside the <bpt id="p1">**</bpt>"copy”<ept id="p1">**</ept> element of each resource that needs to be deployed in multiple copies, as highlighted in the next example.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>For all settings where you need unique values for different instances of the deployed resource, the <bpt id="p1">**</bpt>copyindex()<ept id="p1">**</ept> function can be used to obtain a numeric value indicating the current index in that particular resource loop creation.</source>
          <target state="new">For all settings where you need unique values for different instances of the deployed resource, the <bpt id="p1">**</bpt>copyindex()<ept id="p1">**</ept> function can be used to obtain a numeric value indicating the current index in that particular resource loop creation.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>In the next example, you can see this concept applied to multiple VMs being created for the Datastax Enterprise cluster nodes.</source>
          <target state="new">In the next example, you can see this concept applied to multiple VMs being created for the Datastax Enterprise cluster nodes.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Another important concept in resource creation is the ability to specify dependencies and precedencies between resources, as you can see in the <bpt id="p1">**</bpt>dependsOn<ept id="p1">**</ept> JSON array.</source>
          <target state="new">Another important concept in resource creation is the ability to specify dependencies and precedencies between resources, as you can see in the <bpt id="p1">**</bpt>dependsOn<ept id="p1">**</ept> JSON array.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>In this particular template, each node will also have an attached 1 TB disk (see "dataDisks") that can be used for hosting backups and snapshots of the Apache Cassandra instance.</source>
          <target state="new">In this particular template, each node will also have an attached 1 TB disk (see "dataDisks") that can be used for hosting backups and snapshots of the Apache Cassandra instance.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Attached disks are formatted as part of the node preparation activities triggered by the execution of the dsenode.sh script file.</source>
          <target state="new">Attached disks are formatted as part of the node preparation activities triggered by the execution of the dsenode.sh script file.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>In the next example, the first row of that script invokes another script.</source>
          <target state="new">In the next example, the first row of that script invokes another script.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>vm-disk-utils-0.1.sh is part of the shared_scripts\ubuntu folder in the azure-quickstart-tempates github repo, and contains very useful functions for disk mounting, formatting, and striping.</source>
          <target state="new">vm-disk-utils-0.1.sh is part of the shared_scripts\ubuntu folder in the azure-quickstart-tempates github repo, and contains very useful functions for disk mounting, formatting, and striping.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>These functions can be used in all templates in the repo.</source>
          <target state="new">These functions can be used in all templates in the repo.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Another interesting fragment to explore is the one related to CustomScriptForLinux VM extensions.</source>
          <target state="new">Another interesting fragment to explore is the one related to CustomScriptForLinux VM extensions.</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>These are installed as a separate type of resource, with a dependency on each cluster node (and the OpsCenter instance).</source>
          <target state="new">These are installed as a separate type of resource, with a dependency on each cluster node (and the OpsCenter instance).</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>They leverage the same resource looping mechanism described for virtual machines.</source>
          <target state="new">They leverage the same resource looping mechanism described for virtual machines.</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>By familiarizing yourself with the other files included in this deployment, you will be able to understand all the details and best practices required to organize and orchestrate complex deployment strategies for multi-nodes solutions, based on any technology, leveraging Azure Resource Manager templates.</source>
          <target state="new">By familiarizing yourself with the other files included in this deployment, you will be able to understand all the details and best practices required to organize and orchestrate complex deployment strategies for multi-nodes solutions, based on any technology, leveraging Azure Resource Manager templates.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>While not mandatory, a recommended approach is to structure your template files as shown in the following diagram.</source>
          <target state="new">While not mandatory, a recommended approach is to structure your template files as shown in the following diagram.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>datastax-enterprise-template-structure</source>
          <target state="new">datastax-enterprise-template-structure</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>This approach suggests that you:</source>
          <target state="new">This approach suggests that you:</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Define your core template file as a central orchestration point for all specific deployment activities, leveraging template linking to invoke sub template executions.</source>
          <target state="new">Define your core template file as a central orchestration point for all specific deployment activities, leveraging template linking to invoke sub template executions.</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Create a specific template file that will deploy all resources shared across all other specific deployment tasks (for example, storage accounts, and vnet configuration).</source>
          <target state="new">Create a specific template file that will deploy all resources shared across all other specific deployment tasks (for example, storage accounts, and vnet configuration).</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>This can be heavily reused between deployments that have similar requirements in terms of common infrastructure.</source>
          <target state="new">This can be heavily reused between deployments that have similar requirements in terms of common infrastructure.</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Include optional resource templates for spot requirements specific of a given resource.</source>
          <target state="new">Include optional resource templates for spot requirements specific of a given resource.</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>For identical members of a group of resources (for example, nodes in a cluster) create specific templates that leverage resource looping in order to deploy multiple instances with unique properties.</source>
          <target state="new">For identical members of a group of resources (for example, nodes in a cluster) create specific templates that leverage resource looping in order to deploy multiple instances with unique properties.</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>For all post deployment tasks (for example, product installation,and configurations) leverage script deployment extensions and create scripts specific to each technology.</source>
          <target state="new">For all post deployment tasks (for example, product installation,and configurations) leverage script deployment extensions and create scripts specific to each technology.</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Azure Resource Manager Template Language<ept id="p1">](../resource-group-authoring-templates.md)</ept>.</source>
          <target state="new">For more information, see <bpt id="p1">[</bpt>Azure Resource Manager Template Language<ept id="p1">](../resource-group-authoring-templates.md)</ept>.</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">24d0730de84dcaccd5f38b0ecb3704d481b660b0</xliffext:olfilehash>
  </header>
</xliff>