{
  "nodes": [
    {
      "content": "DocumentDB resource model and concepts | Microsoft Azure",
      "pos": [
        28,
        84
      ]
    },
    {
      "content": "Microsoft Azure DocumentDB is a fully-managed NoSQL document database that uses a hierarchichal model of database accounts, databases, collections, stored procedures, triggers, UDFs, documents, attachments, media, users, and permissions to manage resources.",
      "pos": [
        104,
        361
      ]
    },
    {
      "content": "DocumentDB resource model and concepts",
      "pos": [
        680,
        718
      ]
    },
    {
      "content": "The database entities that DocumentDB manages are referred to as <bpt id=\"p1\">**</bpt>resources<ept id=\"p1\">**</ept>.",
      "pos": [
        720,
        799
      ]
    },
    {
      "content": "Each resource is uniquely identified by a logical URI.",
      "pos": [
        800,
        854
      ]
    },
    {
      "content": "You can interact with the resources using standard HTTP verbs, request/response headers and status codes.",
      "pos": [
        855,
        960
      ]
    },
    {
      "content": "By reading this article, you'll be able to answer the following questions:",
      "pos": [
        963,
        1037
      ]
    },
    {
      "content": "What are the DocumentDB resources?",
      "pos": [
        1041,
        1075
      ]
    },
    {
      "content": "What is the hierarchy of DocumentDB resources?",
      "pos": [
        1078,
        1124
      ]
    },
    {
      "content": "What are system defined resources versus user defined resources?",
      "pos": [
        1127,
        1191
      ]
    },
    {
      "content": "How do I address a resource?",
      "pos": [
        1194,
        1222
      ]
    },
    {
      "content": "How do I work with collections?",
      "pos": [
        1225,
        1256
      ]
    },
    {
      "content": "How do I work with stored procedures, triggers and User Defined Functions (UDFs)?",
      "pos": [
        1259,
        1340
      ]
    },
    {
      "content": "Hierarchical resource model",
      "pos": [
        1344,
        1371
      ]
    },
    {
      "content": "As the following diagram illustrates, the DocumentDB <bpt id=\"p1\">**</bpt>resource model<ept id=\"p1\">**</ept> consists of sets of resources under a database account, each addressable via a logical and stable URI.",
      "pos": [
        1372,
        1546
      ]
    },
    {
      "content": "A set of resources will be referred to as a <bpt id=\"p1\">**</bpt>feed<ept id=\"p1\">**</ept> in this article.",
      "pos": [
        1547,
        1616
      ]
    },
    {
      "pos": [
        1620,
        1829
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> DocumentDB offers a highly efficient TCP protocol which is also RESTful in its communication model, available through the <bpt id=\"p1\">[</bpt>.NET client SDK<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn781482.aspx)</ept>."
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Hierarchical resource model under a database account<ept id=\"p1\">**</ept>",
      "pos": [
        1840,
        1896
      ]
    },
    {
      "content": "To start working with resources, you must <bpt id=\"p1\">[</bpt>create a DocumentDB database account<ept id=\"p1\">](documentdb-create-account.md)</ept> using your Azure subscription.",
      "pos": [
        1901,
        2042
      ]
    },
    {
      "content": "A database account can consist of a set of <bpt id=\"p1\">**</bpt>databases<ept id=\"p1\">**</ept>, each containing multiple <bpt id=\"p2\">**</bpt>collections<ept id=\"p2\">**</ept>, each of which in-turn contain <bpt id=\"p3\">**</bpt>stored procedures, triggers, UDFs, documents<ept id=\"p3\">**</ept> and related <bpt id=\"p4\">**</bpt>attachments<ept id=\"p4\">**</ept> (preview feature).",
      "pos": [
        2043,
        2268
      ]
    },
    {
      "content": "A database also has associated <bpt id=\"p1\">**</bpt>users<ept id=\"p1\">**</ept>, each with a set of <bpt id=\"p2\">**</bpt>permissions<ept id=\"p2\">**</ept> to access collections, stored procedures, triggers, UDFs, documents or attachments.",
      "pos": [
        2269,
        2429
      ]
    },
    {
      "content": "While databases, users, permissions and collections are system-defined resources with well-known schemas, documents and attachments contain arbitrary, user defined JSON content.",
      "pos": [
        2430,
        2607
      ]
    },
    {
      "content": "Resource",
      "pos": [
        2612,
        2620
      ]
    },
    {
      "content": "Description",
      "pos": [
        2624,
        2635
      ]
    },
    {
      "content": "Database account",
      "pos": [
        2662,
        2678
      ]
    },
    {
      "content": "A database account is associated with a set of databases and a fixed amount of blob storage for attachments (preview feature).",
      "pos": [
        2682,
        2808
      ]
    },
    {
      "content": "You can create one or more database accounts using your Azure subscription.",
      "pos": [
        2809,
        2884
      ]
    },
    {
      "content": "Every Standard database account is allocated a minimum capacity of one S1 collection.",
      "pos": [
        2885,
        2970
      ]
    },
    {
      "content": "For more information, visit our <bpt id=\"p1\">[</bpt>pricing page<ept id=\"p1\">](https://azure.microsoft.com/pricing/details/documentdb/)</ept>.",
      "pos": [
        2971,
        3075
      ]
    },
    {
      "content": "Database",
      "pos": [
        3077,
        3085
      ]
    },
    {
      "content": "A database is a logical container of document storage partitioned across collections.",
      "pos": [
        3089,
        3174
      ]
    },
    {
      "content": "It is also a users container.",
      "pos": [
        3175,
        3204
      ]
    },
    {
      "content": "User",
      "pos": [
        3206,
        3210
      ]
    },
    {
      "content": "The logical namespace for scoping/partitioning permissions.",
      "pos": [
        3214,
        3273
      ]
    },
    {
      "content": "Permission",
      "pos": [
        3276,
        3286
      ]
    },
    {
      "content": "An authorization token associated with a user for authorized access to a specific resource.",
      "pos": [
        3288,
        3379
      ]
    },
    {
      "content": "Collection",
      "pos": [
        3381,
        3391
      ]
    },
    {
      "content": "A collection is a container of JSON documents and the associated JavaScript application logic.",
      "pos": [
        3393,
        3487
      ]
    },
    {
      "content": "A collection is a billable entity, where the cost is determined by the performance level associated with the collection.",
      "pos": [
        3488,
        3608
      ]
    },
    {
      "content": "The performance levels (S1, S2 and S3) provide 10GB of storage and a fixed amount of throughput.",
      "pos": [
        3609,
        3705
      ]
    },
    {
      "content": "For more information on performance levels, visit our <bpt id=\"p1\">[</bpt>performance page<ept id=\"p1\">](documentdb-performance-levels.md)</ept>.",
      "pos": [
        3706,
        3813
      ]
    },
    {
      "content": "Stored Procedure",
      "pos": [
        3815,
        3831
      ]
    },
    {
      "content": "Application logic written in JavaScript which is registered with a collection and transactionally executed within the database engine.",
      "pos": [
        3835,
        3969
      ]
    },
    {
      "content": "Trigger",
      "pos": [
        3971,
        3978
      ]
    },
    {
      "content": "Application logic written in JavaScript modeling side effects associated with insert, replace or delete operations.",
      "pos": [
        3983,
        4098
      ]
    },
    {
      "content": "UDF",
      "pos": [
        4100,
        4103
      ]
    },
    {
      "content": "A side effect free, application logic written in JavaScript.",
      "pos": [
        4108,
        4168
      ]
    },
    {
      "content": "UDFs enable you to model a custom query operator and thereby extend the core DocumentDB query language.",
      "pos": [
        4169,
        4272
      ]
    },
    {
      "content": "Document",
      "pos": [
        4274,
        4282
      ]
    },
    {
      "content": "User defined (arbitrary) JSON content.",
      "pos": [
        4286,
        4324
      ]
    },
    {
      "content": "By default, no schema needs to be defined nor do secondary indices need to be provided for all the documents added to a collection.",
      "pos": [
        4325,
        4456
      ]
    },
    {
      "content": "(Preview) Attachment",
      "pos": [
        4458,
        4478
      ]
    },
    {
      "content": "An attachment is a special document containing references and associated metadata for external blob/media.",
      "pos": [
        4482,
        4588
      ]
    },
    {
      "content": "The developer can choose to have the blob managed by DocumentDB or store it with an external blob service provider such as OneDrive, Dropbox, etc.",
      "pos": [
        4589,
        4735
      ]
    },
    {
      "content": "System vs. user defined resources",
      "pos": [
        4741,
        4774
      ]
    },
    {
      "content": "Resources such as database accounts, databases, collections, users, permissions, stored procedures, triggers, and UDFs - all have a fixed schema and are called system resources.",
      "pos": [
        4775,
        4952
      ]
    },
    {
      "content": "In contrast, resources such as documents and attachments have no restrictions on the schema and are examples of user defined resources.",
      "pos": [
        4953,
        5088
      ]
    },
    {
      "content": "In DocumentDB, both system and user defined resources are represented and managed as standard-compliant JSON.",
      "pos": [
        5089,
        5198
      ]
    },
    {
      "content": "All resources, system or user defined, have the following common properties.",
      "pos": [
        5199,
        5275
      ]
    },
    {
      "pos": [
        5278,
        5412
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> Note that all system generated properties in a resource are prefixed with an underscore (_) in their JSON representation."
    },
    {
      "content": "Property",
      "pos": [
        5417,
        5425
      ]
    },
    {
      "content": "User settable or system generated?",
      "pos": [
        5427,
        5461
      ]
    },
    {
      "content": "Purpose",
      "pos": [
        5462,
        5469
      ]
    },
    {
      "content": "_rid",
      "pos": [
        5482,
        5486
      ]
    },
    {
      "content": "System generated",
      "pos": [
        5487,
        5503
      ]
    },
    {
      "content": "System generated, unique and hierarchical identifier of the resource.",
      "pos": [
        5504,
        5573
      ]
    },
    {
      "content": "_etag",
      "pos": [
        5574,
        5579
      ]
    },
    {
      "content": "System generated",
      "pos": [
        5580,
        5596
      ]
    },
    {
      "content": "etag of the resource required for optimistic concurrency control.",
      "pos": [
        5597,
        5662
      ]
    },
    {
      "content": "_ts",
      "pos": [
        5663,
        5666
      ]
    },
    {
      "content": "System generated",
      "pos": [
        5667,
        5683
      ]
    },
    {
      "content": "Last updated timestamp of the resource.",
      "pos": [
        5684,
        5723
      ]
    },
    {
      "content": "_self",
      "pos": [
        5724,
        5729
      ]
    },
    {
      "content": "System generated",
      "pos": [
        5730,
        5746
      ]
    },
    {
      "content": "Unique addressable URI of the resource.",
      "pos": [
        5747,
        5786
      ]
    },
    {
      "content": "id",
      "pos": [
        5787,
        5789
      ]
    },
    {
      "content": "User settable",
      "pos": [
        5790,
        5803
      ]
    },
    {
      "content": "User defined unique name of the resource.",
      "pos": [
        5804,
        5845
      ]
    },
    {
      "content": "Wire representation of resources",
      "pos": [
        5850,
        5882
      ]
    },
    {
      "content": "DocumentDB does not mandate any proprietary extensions to the JSON standard or special encodings; it works with standard compliant JSON documents.",
      "pos": [
        5883,
        6029
      ]
    },
    {
      "content": "Addressing a resource",
      "pos": [
        6037,
        6058
      ]
    },
    {
      "content": "All resources are URI addressable.",
      "pos": [
        6059,
        6093
      ]
    },
    {
      "content": "The value of the <bpt id=\"p1\">**</bpt>_self<ept id=\"p1\">**</ept> property of a resource represents the relative URI of the resource.",
      "pos": [
        6094,
        6188
      ]
    },
    {
      "content": "The format of the URI consists of the /\\&lt;feed\\&gt;/{_rid} path segments:",
      "pos": [
        6189,
        6258
      ]
    },
    {
      "content": "Value of the _self",
      "pos": [
        6263,
        6281
      ]
    },
    {
      "content": "Description",
      "pos": [
        6283,
        6294
      ]
    },
    {
      "content": "/dbs",
      "pos": [
        6329,
        6333
      ]
    },
    {
      "content": "Feed of databases under a database account.",
      "pos": [
        6337,
        6380
      ]
    },
    {
      "content": "/dbs/{_rid-db}",
      "pos": [
        6382,
        6396
      ]
    },
    {
      "content": "Database with the unique id property with the value {_rid-db}.",
      "pos": [
        6398,
        6460
      ]
    },
    {
      "content": "/dbs/{_rid-db}/colls/",
      "pos": [
        6462,
        6483
      ]
    },
    {
      "content": "Feed of collections under a database.",
      "pos": [
        6486,
        6523
      ]
    },
    {
      "content": "/dbs/{_rid-db}/colls/{_rid-coll}",
      "pos": [
        6525,
        6557
      ]
    },
    {
      "content": "Collection with the unique id property with the value {_rid-coll}.",
      "pos": [
        6561,
        6627
      ]
    },
    {
      "content": "/dbs/{_rid-db}/users/",
      "pos": [
        6629,
        6650
      ]
    },
    {
      "content": "Feed of users under a database.",
      "pos": [
        6653,
        6684
      ]
    },
    {
      "content": "/dbs/{_rid-db}/users/{_rid-user}",
      "pos": [
        6687,
        6719
      ]
    },
    {
      "content": "User with the unique id property with the value {_rid-user}.",
      "pos": [
        6723,
        6783
      ]
    },
    {
      "content": "/dbs/{_rid-db}/users/{_rid-user}/permissions",
      "pos": [
        6785,
        6829
      ]
    },
    {
      "content": "Feed of permissions under a database.",
      "pos": [
        6833,
        6870
      ]
    },
    {
      "content": "/dbs/{_rid-db}/users/{_rid-user}/permissions/{_rid-permission}",
      "pos": [
        6873,
        6935
      ]
    },
    {
      "content": "Permission with the unique id property with the value {_rid-permission}.",
      "pos": [
        6937,
        7009
      ]
    },
    {
      "content": "A resource also has a unique user defined name exposed via the id property of the resource.",
      "pos": [
        7015,
        7106
      ]
    },
    {
      "content": "The id is a user defined string, of up to 256 characters that is unique within the context of a specific parent resource.",
      "pos": [
        7107,
        7228
      ]
    },
    {
      "content": "For instance, the value of the id property of all documents within a given collection are unique but they are not guaranteed to be unique across collections.",
      "pos": [
        7229,
        7386
      ]
    },
    {
      "content": "Similarly, the value of the id property of all permissions for a given user are unique but they are not guaranteed to be unique across all users.",
      "pos": [
        7387,
        7532
      ]
    },
    {
      "content": "The _rid property is used to construct the addressable _self link of a resource.",
      "pos": [
        7533,
        7613
      ]
    },
    {
      "content": "Each resource also has a system generated hierarchical resource identifier (also referred to as an RID), which is available via the _rid property.",
      "pos": [
        7618,
        7764
      ]
    },
    {
      "content": "The RID encodes the entire hierarchy of a given resource and it is a very convenient internal representation used to enforce referential integrity in a distributed manner.",
      "pos": [
        7765,
        7936
      ]
    },
    {
      "content": "The RID is unique within a database account and is internally used by DocumentDB for efficient routing without requiring cross partition lookups.",
      "pos": [
        7937,
        8082
      ]
    },
    {
      "content": "The values of the _self and the  _rid properties are both alternate and canonical representations of a resource.",
      "pos": [
        8085,
        8197
      ]
    },
    {
      "content": "Database accounts",
      "pos": [
        8203,
        8220
      ]
    },
    {
      "content": "You can provision one or more DocumentDB database accounts using your Azure subscription.",
      "pos": [
        8221,
        8310
      ]
    },
    {
      "content": "Each Standard tier database account will be given a minimum capacity of one S1 collection.",
      "pos": [
        8311,
        8401
      ]
    },
    {
      "content": "You can <bpt id=\"p1\">[</bpt>create and manage DocumentDB database accounts<ept id=\"p1\">](documentdb-create-account.md)</ept> via the Azure portal at <bpt id=\"p2\">[</bpt>http://portal.azure.com/<ept id=\"p2\">](http://portal.azure.com/)</ept>.",
      "pos": [
        8403,
        8567
      ]
    },
    {
      "content": "Creating and managing a database account requires administrative access and can only be performed under your Azure subscription.",
      "pos": [
        8568,
        8696
      ]
    },
    {
      "content": "Database account properties",
      "pos": [
        8702,
        8729
      ]
    },
    {
      "content": "As part of provisioning and managing a database account you can configure and read the following properties:",
      "pos": [
        8730,
        8838
      ]
    },
    {
      "content": "Property Name",
      "pos": [
        8842,
        8855
      ]
    },
    {
      "content": "Description",
      "pos": [
        8856,
        8867
      ]
    },
    {
      "content": "Consistency Policy",
      "pos": [
        8876,
        8894
      ]
    },
    {
      "content": "Set this property to configure the default consistency level for all the collections under your database account.",
      "pos": [
        8895,
        9008
      ]
    },
    {
      "content": "You can override the consistency level on a per request basis using the [x-ms-consistency-level] request header.",
      "pos": [
        9009,
        9121
      ]
    },
    {
      "content": "In the future, we may support overriding the consistency level on a per collection basis.",
      "pos": [
        9122,
        9211
      ]
    },
    {
      "content": "Note that this property only applies to the <ph id=\"ph1\">&lt;i&gt;</ph>user defined resources<ph id=\"ph2\">&lt;/i&gt;</ph>.",
      "pos": [
        9218,
        9292
      ]
    },
    {
      "content": "All system defined resources are configured to support reads/queries with strong consistency.",
      "pos": [
        9293,
        9386
      ]
    },
    {
      "content": "Primary Key and Secondary Key",
      "pos": [
        9387,
        9416
      ]
    },
    {
      "content": "These are the primary and secondary keys that provide administrative access to all of the resources under the database account.",
      "pos": [
        9417,
        9544
      ]
    },
    {
      "content": "MaxMediaStorageUsageInMB (READ)",
      "pos": [
        9545,
        9576
      ]
    },
    {
      "content": "Maximum amount of media storage available for the database account.",
      "pos": [
        9577,
        9644
      ]
    },
    {
      "content": "MediaStorageUsageInMB (READ)",
      "pos": [
        9645,
        9673
      ]
    },
    {
      "content": "Current usage of media storage for the database account.",
      "pos": [
        9674,
        9730
      ]
    },
    {
      "pos": [
        9732,
        10097
      ],
      "content": "Note that in addition to provisioning, configuring and managing your database account from the Azure portal, you can also programmatically create and manage DocumentDB database accounts by using the <bpt id=\"p1\">[</bpt>Azure DocumentDB REST APIs<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn781481.aspx)</ept> as well as <bpt id=\"p2\">[</bpt>client SDKs<ept id=\"p2\">](https://msdn.microsoft.com/library/azure/dn781482.aspx)</ept>."
    },
    {
      "content": "Databases",
      "pos": [
        10103,
        10112
      ]
    },
    {
      "content": "A DocumentDB database is a logical container of one or more collections and users, as shown in the following diagram.",
      "pos": [
        10113,
        10230
      ]
    },
    {
      "content": "You can create any number of databases under a DocumentDB database account subject to offer limits.",
      "pos": [
        10231,
        10330
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>A Database is a logical container of users and collections<ept id=\"p1\">**</ept>",
      "pos": [
        10343,
        10405
      ]
    },
    {
      "content": "A database can contain virtually unlimited document storage partitioned by collections, which form the transaction domains for the documents contained within them.",
      "pos": [
        10407,
        10570
      ]
    },
    {
      "content": "Elastic scale of a DocumentDB database",
      "pos": [
        10576,
        10614
      ]
    },
    {
      "content": "A DocumentDB database is elastic by default – ranging from a few GB to petabytes of SSD backed document storage and provisioned throughput.",
      "pos": [
        10615,
        10754
      ]
    },
    {
      "content": "Unlike a database in traditional RDBMS, a database in DocumentDB is not scoped to a single machine.",
      "pos": [
        10757,
        10856
      ]
    },
    {
      "content": "With DocumentDB, as your application’s scale needs to grow, you can create more collections or databases or both.",
      "pos": [
        10857,
        10970
      ]
    },
    {
      "content": "Indeed, various first party applications within Microsoft have been using DocumentDB at a consumer scale by creating extremely large DocumentDB databases each containing thousands of collections with terabytes of document storage.",
      "pos": [
        10971,
        11201
      ]
    },
    {
      "content": "You can grow or shrink a database by adding or removing collections to meet your application’s scale requirements.",
      "pos": [
        11202,
        11316
      ]
    },
    {
      "content": "You can create any number of collections within a database subject to the offer.",
      "pos": [
        11319,
        11399
      ]
    },
    {
      "content": "Each collection has SSD backed storage and throughput provisioned for you depending on the selected performance tier.",
      "pos": [
        11400,
        11517
      ]
    },
    {
      "content": "A DocumentDB database is also a container of users.",
      "pos": [
        11519,
        11570
      ]
    },
    {
      "content": "A user, in-turn, is a logical namespace for a set of permissions that provides fine-grained authorization and access to collections, documents and attachments.",
      "pos": [
        11571,
        11730
      ]
    },
    {
      "content": "As with other resources in the DocumentDB resource model, databases can be created, replaced, deleted, read or enumerated easily using either <bpt id=\"p1\">[</bpt>Azure DocumentDB REST APIs<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn781481.aspx)</ept> or any of the <bpt id=\"p2\">[</bpt>client SDKs<ept id=\"p2\">](https://msdn.microsoft.com/library/azure/dn781482.aspx)</ept>.",
      "pos": [
        11735,
        12046
      ]
    },
    {
      "content": "DocumentDB guarantees strong consistency for reading or querying the metadata of a database resource.",
      "pos": [
        12047,
        12148
      ]
    },
    {
      "content": "Deleting a database automatically ensures that you cannot access any of the collections or users contained within it.",
      "pos": [
        12149,
        12266
      ]
    },
    {
      "content": "Collections",
      "pos": [
        12273,
        12284
      ]
    },
    {
      "content": "A DocumentDB collection is a container for your JSON documents.",
      "pos": [
        12285,
        12348
      ]
    },
    {
      "content": "A collection is also a unit of scale for transactions and queries.",
      "pos": [
        12349,
        12415
      ]
    },
    {
      "content": "You can scale out a DocumentDB database by adding more collections.",
      "pos": [
        12416,
        12483
      ]
    },
    {
      "content": "If your application needs to scale more, you can add a collection, each allocated with SSD backed storage and a fixed amount of throughput depending on its performance tier.",
      "pos": [
        12484,
        12657
      ]
    },
    {
      "content": "Elastic SSD backed document storage",
      "pos": [
        12663,
        12698
      ]
    },
    {
      "content": "A collection is intrinsically elastic - it automatically grows and shrinks as you add or remove documents.",
      "pos": [
        12699,
        12805
      ]
    },
    {
      "content": "Although the first party usage of DocumentDB has tested it with thousands of collections within a database with each ranging from a few gigabytes to terabytes in size, DocumentDB currently limits the elasticity of a given collection to 10GB.",
      "pos": [
        12806,
        13047
      ]
    },
    {
      "content": "Automatic indexing of collections",
      "pos": [
        13053,
        13086
      ]
    },
    {
      "content": "DocumentDB is a true schema-free database system.",
      "pos": [
        13087,
        13136
      ]
    },
    {
      "content": "It does not assume or require any schema for the JSON documents.",
      "pos": [
        13137,
        13201
      ]
    },
    {
      "content": "As you add documents to a collection, DocumentDB automatically indexes them and they are available for you to query.",
      "pos": [
        13202,
        13318
      ]
    },
    {
      "content": "Automatic indexing of documents without requiring schema or secondary indexes is a key capability of DocumentDB and is enabled by write-optimized, lock-free and log-structured index maintenance techniques.",
      "pos": [
        13319,
        13524
      ]
    },
    {
      "content": "DocumentDB supports sustained volume of extremely fast writes while still serving consistent queries.",
      "pos": [
        13525,
        13626
      ]
    },
    {
      "content": "Both document and index storage are used to calculate the storage consumed by each collection.",
      "pos": [
        13627,
        13721
      ]
    },
    {
      "content": "You can control the storage and performance trade-offs associated with indexing by configuring the indexing policy for a collection.",
      "pos": [
        13722,
        13854
      ]
    },
    {
      "content": "Configuring the indexing policy of a collection",
      "pos": [
        13860,
        13907
      ]
    },
    {
      "content": "The indexing policy of each collection allows you to make performance and storage trade-offs associated with indexing.",
      "pos": [
        13908,
        14026
      ]
    },
    {
      "content": "The following options are available to you as part of indexing configuration:",
      "pos": [
        14027,
        14104
      ]
    },
    {
      "content": "Choose whether the collection automatically indexes all of the documents or not.",
      "pos": [
        14112,
        14192
      ]
    },
    {
      "content": "By default, all documents are automatically indexed.",
      "pos": [
        14193,
        14245
      ]
    },
    {
      "content": "You can choose to turn off automatic indexing and selectively add only specific documents to the index.",
      "pos": [
        14246,
        14349
      ]
    },
    {
      "content": "Conversely, you can selectively choose to exclude only specific documents.",
      "pos": [
        14350,
        14424
      ]
    },
    {
      "content": "You can achieve this by setting the automatic property to be true or false on the indexingPolicy of a collection and using the [x-ms-indexingdirective] request header while inserting, replacing or deleting a document.",
      "pos": [
        14425,
        14642
      ]
    },
    {
      "content": "Choose whether to include or exclude specific paths or patterns in your documents from the index.",
      "pos": [
        14649,
        14746
      ]
    },
    {
      "content": "You can achieve this by setting includedPaths and excludedPaths on the indexingPolicy of a collection respectively.",
      "pos": [
        14747,
        14862
      ]
    },
    {
      "content": "You can also configure the storage and performance trade-offs for range and hash queries for specific path patterns.",
      "pos": [
        14863,
        14979
      ]
    },
    {
      "content": "Choose between synchronous (consistent) and asynchronous (lazy) index updates.",
      "pos": [
        14985,
        15063
      ]
    },
    {
      "content": "By default, the index is updated synchronously on each insert, replace or delete of a document to the collection.",
      "pos": [
        15064,
        15177
      ]
    },
    {
      "content": "This enables the queries to honor the same consistency level as that of the document reads.",
      "pos": [
        15178,
        15269
      ]
    },
    {
      "content": "While DocumentDB is write optimized and supports sustained volumes of document writes along with synchronous index maintenance and serving consistent queries, you can configure certain collections to update their index lazily.",
      "pos": [
        15270,
        15496
      ]
    },
    {
      "content": "Lazy indexing boosts the write performance further and is ideal for bulk ingestion scenarios for primarily read-heavy collections.",
      "pos": [
        15497,
        15627
      ]
    },
    {
      "content": "The indexing policy can only be configured during the creation of a collection.",
      "pos": [
        15629,
        15708
      ]
    },
    {
      "content": "Once the collection has been created the policy cannot be updated.",
      "pos": [
        15709,
        15775
      ]
    },
    {
      "content": "Querying a collection",
      "pos": [
        15780,
        15801
      ]
    },
    {
      "content": "The documents within a collection can have arbitrary schemas and you can query documents within a collection without providing any schema or secondary indices upfront.",
      "pos": [
        15802,
        15969
      ]
    },
    {
      "content": "You can query the collection using the <bpt id=\"p1\">[</bpt>DocumentDB SQL query language<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn782250.aspx)</ept>, which provides rich hierarchical and relational operators and extensibility via JavaScript-based UDFs.",
      "pos": [
        15970,
        16200
      ]
    },
    {
      "content": "JSON grammar allows for modeling JSON documents as trees with labels as the tree nodes.",
      "pos": [
        16201,
        16288
      ]
    },
    {
      "content": "This is exploited both by DocumentDB’s automatic indexing techniques as well as DocumentDB's SQL query dialect.",
      "pos": [
        16289,
        16400
      ]
    },
    {
      "content": "The DocumentDB query language consists of three main aspects:",
      "pos": [
        16401,
        16462
      ]
    },
    {
      "content": "A small set of query operations that map naturally to the tree structure including hierarchical queries and projections.",
      "pos": [
        16471,
        16591
      ]
    },
    {
      "content": "A subset of relational operations including composition, filter, projections, aggregates and self joins.",
      "pos": [
        16597,
        16701
      ]
    },
    {
      "content": "Pure JavaScript based UDFs that work with (1) and (2).",
      "pos": [
        16707,
        16761
      ]
    },
    {
      "content": "The DocumentDB query model attempts to strike a balance between functionality, efficiency and simplicity.",
      "pos": [
        16765,
        16870
      ]
    },
    {
      "content": "The DocumentDB database engine natively compiles and executes the SQL query statements.",
      "pos": [
        16871,
        16958
      ]
    },
    {
      "content": "You can query a collection using the <bpt id=\"p1\">[</bpt>Azure DocumentDB REST APIs<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn781481.aspx)</ept> or any of the <bpt id=\"p2\">[</bpt>client SDKs<ept id=\"p2\">](https://msdn.microsoft.com/library/azure/dn781482.aspx)</ept>.",
      "pos": [
        16959,
        17165
      ]
    },
    {
      "content": "The .NET SDK comes with a LINQ provider.",
      "pos": [
        17166,
        17206
      ]
    },
    {
      "pos": [
        17208,
        17338
      ],
      "content": "You can try out DocumentDB and run SQL queries against our dataset in the <bpt id=\"p1\">[</bpt>Query Playground<ept id=\"p1\">](https://www.documentdb.com/sql/demo)</ept>."
    },
    {
      "content": "Multi-document transactions",
      "pos": [
        17343,
        17370
      ]
    },
    {
      "content": "Database transactions provide a safe and predictable programming model for dealing with concurrent changes to the data.",
      "pos": [
        17371,
        17490
      ]
    },
    {
      "content": "In RDBMS, the traditional way to write business logic is to write <bpt id=\"p1\">**</bpt>stored-procedures<ept id=\"p1\">**</ept> and/or <bpt id=\"p2\">**</bpt>triggers<ept id=\"p2\">**</ept> and ship it to the database server for transactional execution.",
      "pos": [
        17491,
        17662
      ]
    },
    {
      "content": "In RDBMS, the application programmer is required to deal with two disparate programming languages:",
      "pos": [
        17663,
        17761
      ]
    },
    {
      "content": "The (non-transactional) application programming language (e.g. JavaScript, Python, C#, Java, etc.).",
      "pos": [
        17766,
        17865
      ]
    },
    {
      "content": "T-SQL, the transactional programming language which is natively executed by the database.",
      "pos": [
        17869,
        17958
      ]
    },
    {
      "content": "By virtue of its deep commitment to JavaScript and JSON directly within the database engine, DocumentDB provides an intuitive programming model for executing JavaScript based application logic directly on the collections in terms of stored procedures and triggers.",
      "pos": [
        17960,
        18224
      ]
    },
    {
      "content": "This allows for both of the following:",
      "pos": [
        18225,
        18263
      ]
    },
    {
      "content": "Efficient implementation of concurrency control, recovery, automatic indexing of the JSON object graphs directly in the database engine.",
      "pos": [
        18267,
        18403
      ]
    },
    {
      "content": "Naturally expressing control flow, variable scoping, assignment and integration of exception handling primitives with database transactions directly in terms of the JavaScript programming language.",
      "pos": [
        18407,
        18604
      ]
    },
    {
      "content": "The JavaScript logic registered at a collection level can then issue database operations on the documents of the given collection.",
      "pos": [
        18609,
        18739
      ]
    },
    {
      "content": "DocumentDB implicitly wraps the JavaScript based stored procedures and triggers within an ambient ACID transactions with snapshot isolation across documents within a collection.",
      "pos": [
        18740,
        18917
      ]
    },
    {
      "content": "During the course of its execution, if the JavaScript throws an exception, then the entire transaction is aborted.",
      "pos": [
        18918,
        19032
      ]
    },
    {
      "content": "The resulting programming model is a very simple yet powerful.",
      "pos": [
        19033,
        19095
      ]
    },
    {
      "content": "JavaScript developers get a “durable” programming model while still using their familiar language constructs and library primitives.",
      "pos": [
        19096,
        19228
      ]
    },
    {
      "content": "The ability to execute JavaScript directly within the database engine in the same address space as the buffer pool enables performant and transactional execution of database operations against the documents of a collection.",
      "pos": [
        19233,
        19456
      ]
    },
    {
      "content": "Further, because DocumentDB database engine makes a deep commitment to the JSON and JavaScript eliminates any impedance mismatch between the type systems of application and the database.",
      "pos": [
        19457,
        19643
      ]
    },
    {
      "content": "After creating a collection, you can register stored procedures, triggers and UDFs with a collection using the <bpt id=\"p1\">[</bpt>Azure DocumentDB REST APIs<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn781481.aspx)</ept> or any of the <bpt id=\"p2\">[</bpt>client SDKs<ept id=\"p2\">](https://msdn.microsoft.com/library/azure/dn781482.aspx)</ept>.",
      "pos": [
        19648,
        19928
      ]
    },
    {
      "content": "After registration, you can reference and execute them.",
      "pos": [
        19929,
        19984
      ]
    },
    {
      "content": "Consider the following stored procedure written entirely in JavaScript, takes two arguments (book name and author name) and creates a new document, queries for a document and then updates it – all within the auspices of an implicit ACID transaction.",
      "pos": [
        19985,
        20234
      ]
    },
    {
      "content": "At any point during the execution, if a JavaScript exception is thrown, the entire transaction aborts.",
      "pos": [
        20235,
        20337
      ]
    },
    {
      "content": "The client can “ship” the above JavaScript logic to the database for transactional execution via HTTP POST.",
      "pos": [
        21851,
        21958
      ]
    },
    {
      "content": "For more information about using HTTP methods, see <bpt id=\"p1\">[</bpt>RESTful interactions with DocumentDB resources<ept id=\"p1\">](documentdb-interactions-with-resources.md)</ept>.",
      "pos": [
        21959,
        22102
      ]
    },
    {
      "content": "Notice that because the database natively understands JSON and JavaScript, there is no type system mismatch, no “OR mapping” or code generation magic required.",
      "pos": [
        22570,
        22729
      ]
    },
    {
      "content": "Stored procedures and triggers interact with a collection and the documents in a collection through a well-defined object model which exposes the current collection context.",
      "pos": [
        22734,
        22907
      ]
    },
    {
      "content": "Collections in DocumentDB can be created, deleted, read or enumerated easily using either the <bpt id=\"p1\">[</bpt>Azure DocumentDB REST APIs<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn781481.aspx)</ept> or any of the <bpt id=\"p2\">[</bpt>client SDKs<ept id=\"p2\">](https://msdn.microsoft.com/library/azure/dn781482.aspx)</ept>.",
      "pos": [
        22911,
        23174
      ]
    },
    {
      "content": "DocumentDB always provides strong consistency for reading or querying the metadata of a collection.",
      "pos": [
        23175,
        23274
      ]
    },
    {
      "content": "Deleting a collection automatically ensures that you cannot access any of the documents, attachments, stored procedures, triggers, and UDFs contained within it.",
      "pos": [
        23275,
        23435
      ]
    },
    {
      "content": "<ph id=\"ph1\"> </ph>",
      "pos": [
        23439,
        23440
      ]
    },
    {
      "content": "Stored procedures, triggers and UDFs",
      "pos": [
        23443,
        23479
      ]
    },
    {
      "content": "As described in the previous section, you can write application logic to run directly within a transaction inside of the database engine.",
      "pos": [
        23480,
        23617
      ]
    },
    {
      "content": "The application logic can be written entirely in JavaScript and can be modeled as a stored procedure, trigger or a UDF.",
      "pos": [
        23618,
        23737
      ]
    },
    {
      "content": "The JavaScript code within a stored procedure or a trigger can insert, replace, delete, read or query documents within a collection.",
      "pos": [
        23738,
        23870
      ]
    },
    {
      "content": "On the other hand, the JavaScript within a UDF can only perform side effect free computation by enumerating the documents of the result set of the query and produce another result set.",
      "pos": [
        23871,
        24055
      ]
    },
    {
      "content": "For multi-tenancy, DocumentDB enforces a strict reservation based resource governance.",
      "pos": [
        24056,
        24142
      ]
    },
    {
      "content": "Each stored procedure, trigger or a UDF gets a fixed quantum of operating system resources to do its work.",
      "pos": [
        24143,
        24249
      ]
    },
    {
      "content": "Further, stored procedures, triggers or UDFs cannot link against external JavaScript libraries and are blacklisted if they exceed the resource budgets allocated to them.",
      "pos": [
        24250,
        24419
      ]
    },
    {
      "content": "You can register, unregister stored procedures, triggers or UDFs with a collection by using the REST APIs.",
      "pos": [
        24420,
        24526
      ]
    },
    {
      "content": "Upon registration a stored procedure, trigger, or a UDF is pre-compiled and stored as byte code which gets executed later.",
      "pos": [
        24528,
        24650
      ]
    },
    {
      "content": "The following section illustrate how you can use the DocumentDB JavaScript SDK to register, execute, and unregister a stored procedure, trigger, and a UDF.",
      "pos": [
        24651,
        24806
      ]
    },
    {
      "content": "The JavaScript SDK is a simple wrapper over the <bpt id=\"p1\">[</bpt>DocumentDB REST APIs<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn781481.aspx)</ept>.",
      "pos": [
        24807,
        24934
      ]
    },
    {
      "content": "Registering a stored procedure",
      "pos": [
        24940,
        24970
      ]
    },
    {
      "content": "Registration of a stored procedure creates a new stored procedure resource on a collection via HTTP POST.",
      "pos": [
        24971,
        25076
      ]
    },
    {
      "content": "Executing a stored procedure",
      "pos": [
        26017,
        26045
      ]
    },
    {
      "content": "Execution of a stored procedure is done by issuing an HTTP POST against an existing stored procedure resource by passing parameters to the procedure in the request body.",
      "pos": [
        26046,
        26215
      ]
    },
    {
      "content": "Unregistering a stored procedure",
      "pos": [
        26574,
        26606
      ]
    },
    {
      "content": "Un-registering a stored procedure is simply done by issuing an HTTP DELETE against an existing stored procedure resource.",
      "pos": [
        26607,
        26728
      ]
    },
    {
      "content": "Registering a pre-trigger",
      "pos": [
        26946,
        26971
      ]
    },
    {
      "content": "Registration of a trigger is done by creating a new trigger resource on a collection via HTTP POST.",
      "pos": [
        26972,
        27071
      ]
    },
    {
      "content": "You can specify if the trigger is a pre or a post trigger and the type of operation it can be associated with (e.g. Create, Replace, Delete, or All).",
      "pos": [
        27072,
        27221
      ]
    },
    {
      "content": "Executing a pre-trigger",
      "pos": [
        27821,
        27844
      ]
    },
    {
      "content": "Execution of a trigger is done by specifying the name of an existing trigger at the time of issuing the POST/PUT/DELETE request of a document resource via the request header.",
      "pos": [
        27845,
        28019
      ]
    },
    {
      "content": "Unregistering a pre-trigger",
      "pos": [
        28347,
        28374
      ]
    },
    {
      "content": "Un-registering a trigger is simply done via issuing an HTTP DELETE against an existing trigger resource.",
      "pos": [
        28375,
        28479
      ]
    },
    {
      "content": "Registering a UDF",
      "pos": [
        28673,
        28690
      ]
    },
    {
      "content": "Registration of a UDF is done by creating a new UDF resource on a collection via HTTP POST.",
      "pos": [
        28691,
        28782
      ]
    },
    {
      "content": "Executing a UDF as part of the query",
      "pos": [
        29168,
        29204
      ]
    },
    {
      "content": "A UDF can be specified as part of the SQL query and is used as a way to extend the core <bpt id=\"p1\">[</bpt>SQL query language of DocumentDB<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn782250.aspx)</ept>.",
      "pos": [
        29205,
        29384
      ]
    },
    {
      "content": "Unregistering a UDF",
      "pos": [
        29739,
        29758
      ]
    },
    {
      "content": "Un-registering a UDF is simply done by issuing an HTTP DELETE against an existing UDF resource.",
      "pos": [
        29760,
        29855
      ]
    },
    {
      "pos": [
        30050,
        30421
      ],
      "content": "Although the snippets above showed the registration (POST), un-registration (PUT), read/list (GET) and execution (POST) via the <bpt id=\"p1\">[</bpt>DocumentDB JavaScript SDK<ept id=\"p1\">](https://github.com/Azure/azure-documentdb-js)</ept>, you can also use the <bpt id=\"p2\">[</bpt>REST APIs<ept id=\"p2\">](https://msdn.microsoft.com/library/azure/dn781481.aspx)</ept> or other <bpt id=\"p3\">[</bpt>client SDKs<ept id=\"p3\">](https://msdn.microsoft.com/library/azure/dn781482.aspx)</ept>."
    },
    {
      "content": "Documents",
      "pos": [
        30426,
        30435
      ]
    },
    {
      "content": "You can insert, replace, delete, read, enumerate and query arbitrary JSON documents in a collection.",
      "pos": [
        30436,
        30536
      ]
    },
    {
      "content": "DocumentDB does not mandate any schema and does not require secondary indexes in order to support querying over documents in a collection.",
      "pos": [
        30537,
        30675
      ]
    },
    {
      "content": "Being a truly open database service, DocumentDB does not invent any specialized data types (e.g. date time) or specific encodings for JSON documents.",
      "pos": [
        30680,
        30829
      ]
    },
    {
      "content": "Note that DocumentDB does not require any special JSON conventions to codify the relationships among various documents; the SQL query language of DocumentDB provides very powerful hierarchical and relational query operators to query and project documents without any special annotations or need to codify relationships among documents using distinguished properties.",
      "pos": [
        30830,
        31196
      ]
    },
    {
      "content": "As with all other resources, documents can be created, replaced, deleted, read, enumerated and queried easily using either REST APIs or any of the <bpt id=\"p1\">[</bpt>client SDKs<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn781482.aspx)</ept>.",
      "pos": [
        31201,
        31418
      ]
    },
    {
      "content": "Deleting a document instantly frees up the quota corresponding to all of the nested attachments.",
      "pos": [
        31419,
        31515
      ]
    },
    {
      "content": "The read consistency level of documents follows the consistency policy on the database account.",
      "pos": [
        31516,
        31611
      ]
    },
    {
      "content": "This policy can be overridden on a per-request basis depending on data consistency requirements of your application.",
      "pos": [
        31612,
        31728
      ]
    },
    {
      "content": "When querying documents, the read consistency follows the indexing mode set on the collection.",
      "pos": [
        31729,
        31823
      ]
    },
    {
      "content": "For “consistent”, this follows the account’s consistency policy.",
      "pos": [
        31824,
        31888
      ]
    },
    {
      "content": "Attachments and media",
      "pos": [
        31893,
        31914
      ]
    },
    {
      "pos": [
        31916,
        31981
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> Attachment and media resources are preview features."
    },
    {
      "content": "DocumentDB allows you to store binary blobs/media either with DocumentDB or to your own remote media store.",
      "pos": [
        31984,
        32091
      ]
    },
    {
      "content": "It also allows you to represent the metadata of a media in terms of a special document called attachment.",
      "pos": [
        32092,
        32197
      ]
    },
    {
      "content": "An attachment in DocumentDB is a special (JSON) document that references the media/blob stored elsewhere.",
      "pos": [
        32198,
        32303
      ]
    },
    {
      "content": "An attachment is simply a special document that captures the metadata (e.g. location, author etc.) of a media stored in a remote media storage.",
      "pos": [
        32304,
        32447
      ]
    },
    {
      "content": "Consider a social reading application which uses DocumentDB to store ink annotations, and metadata including comments, highlights, bookmarks, ratings, likes/dislikes etc. associated for an e-book of a given user.",
      "pos": [
        32450,
        32662
      ]
    },
    {
      "content": "The content of the book itself is stored in the media storage either available as part of DocumentDB database account or a remote media store.",
      "pos": [
        32671,
        32813
      ]
    },
    {
      "content": "An application may store each user’s metadata as a distinct document -- e.g. Joe’s metadata for book1 is stored in a document referenced by /colls/joe/docs/book1.",
      "pos": [
        32819,
        32981
      ]
    },
    {
      "content": "Attachments pointing to the content pages of a given book of a user are stored under the corresponding document e.g. /colls/joe/docs/book1/chapter1, /colls/joe/docs/book1/chapter2 etc.",
      "pos": [
        32987,
        33171
      ]
    },
    {
      "content": "Note that the examples use friendly ids to convey the resource hierarchy.",
      "pos": [
        33174,
        33247
      ]
    },
    {
      "content": "Resources are accessed via the REST APIs through unique resource ids.",
      "pos": [
        33248,
        33317
      ]
    },
    {
      "content": "For the media that is managed by DocumentDB, the _media property of the attachment will reference the media by its URI.",
      "pos": [
        33320,
        33439
      ]
    },
    {
      "content": "DocumentDB will ensure to garbage collect the media when all of the outstanding references are dropped.",
      "pos": [
        33440,
        33543
      ]
    },
    {
      "content": "DocumentDB automatically generates the attachment when you upload the new media and populates the _media to point to the newly added media.",
      "pos": [
        33544,
        33683
      ]
    },
    {
      "content": "If you choose to store the media in a remote blob store managed by you (e.g. OneDrive, Azure Storage, DropBox etc), you can still use attachments to reference the media.",
      "pos": [
        33684,
        33853
      ]
    },
    {
      "content": "In this case, you will create the attachment yourself and populate its _media property.",
      "pos": [
        33854,
        33941
      ]
    },
    {
      "content": "As with all other resources, attachments can be created, replaced, deleted, read or enumerated easily using either REST APIs or any of the client SDKs.",
      "pos": [
        33946,
        34097
      ]
    },
    {
      "content": "As with documents, the read consistency level of attachments follows the consistency policy on the database account.",
      "pos": [
        34098,
        34214
      ]
    },
    {
      "content": "This policy can be overridden on a per-request basis depending on data consistency requirements of your application.",
      "pos": [
        34215,
        34331
      ]
    },
    {
      "content": "When querying for attachments, the read consistency follows the indexing mode set on the collection.",
      "pos": [
        34332,
        34432
      ]
    },
    {
      "content": "For “consistent”, this follows the account’s consistency policy.",
      "pos": [
        34433,
        34497
      ]
    },
    {
      "content": "Users",
      "pos": [
        34503,
        34508
      ]
    },
    {
      "content": "A DocumentDB user represents a logical namespace for grouping permissions.",
      "pos": [
        34509,
        34583
      ]
    },
    {
      "content": "A DocumentDB user may correspond to a user in an identity management system or a predefined application role.",
      "pos": [
        34584,
        34693
      ]
    },
    {
      "content": "For DocumentDB, a user simply represents an abstraction to group a set of permissions under a database.",
      "pos": [
        34694,
        34797
      ]
    },
    {
      "content": "For implementing multi-tenancy in your application, you can create users in DocumentDB which corresponds to your actual users or the tenants of your application.",
      "pos": [
        34802,
        34963
      ]
    },
    {
      "content": "You can then create permissions for a given user that correspond to the access control over various collections, documents, attachments, etc.",
      "pos": [
        34964,
        35105
      ]
    },
    {
      "content": "As your applications need to scale with your user growth, you can adopt various ways to shard your data.",
      "pos": [
        35110,
        35214
      ]
    },
    {
      "content": "You can model each of your users as follows:",
      "pos": [
        35215,
        35259
      ]
    },
    {
      "content": "Each user maps to a database.",
      "pos": [
        35268,
        35297
      ]
    },
    {
      "content": "Each user maps to a collection.",
      "pos": [
        35302,
        35333
      ]
    },
    {
      "content": "Documents corresponding to multiple users go to a dedicated collection.",
      "pos": [
        35339,
        35410
      ]
    },
    {
      "content": "Documents corresponding to multiple users go to a set of collections.",
      "pos": [
        35416,
        35485
      ]
    },
    {
      "content": "Regardless of the specific sharding strategy you choose, you can model your actual users as users in DocumentDB database and associate fine grained permissions to each user.",
      "pos": [
        35490,
        35663
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Sharding strategies and modeling users<ept id=\"p1\">**</ept>",
      "pos": [
        35676,
        35718
      ]
    },
    {
      "content": "Like all other resources, users in DocumentDB can be created, replaced, deleted, read or enumerated easily using either REST APIs or any of the client SDKs.",
      "pos": [
        35720,
        35876
      ]
    },
    {
      "content": "DocumentDB always provides strong consistency for reading or querying the metadata of a user resource.",
      "pos": [
        35877,
        35979
      ]
    },
    {
      "content": "It is worth pointing out that deleting a user automatically ensures that you cannot access any of the permissions contained within it.",
      "pos": [
        35980,
        36114
      ]
    },
    {
      "content": "Even though the DocumentDB reclaims the quota of the permissions as part of the deleted user in the background, the deleted permissions is available instantly again for you to use.",
      "pos": [
        36115,
        36295
      ]
    },
    {
      "content": "Permissions",
      "pos": [
        36301,
        36312
      ]
    },
    {
      "content": "From the access control perspective, resources such as database accounts, databases, users and permission are considered <bpt id=\"p1\">*</bpt>administrative<ept id=\"p1\">*</ept> resources since these require administrative permissions.",
      "pos": [
        36313,
        36508
      ]
    },
    {
      "content": "On the other hand, resources including the collections, documents, attachments, stored procedures, triggers, and UDFs are scoped under a given database and considered <bpt id=\"p1\">*</bpt>application resources<ept id=\"p1\">*</ept>.",
      "pos": [
        36509,
        36700
      ]
    },
    {
      "content": "Corresponding to the two types of resources and the roles that access them (namely the administrator and user), the authorization model defines two types of <bpt id=\"p1\">*</bpt>access keys<ept id=\"p1\">*</ept>: <bpt id=\"p2\">*</bpt>master key<ept id=\"p2\">*</ept> and <bpt id=\"p3\">*</bpt>resource key<ept id=\"p3\">*</ept>.",
      "pos": [
        36701,
        36905
      ]
    },
    {
      "content": "The master key is a part of the database account and is provided to the developer (or administrator) who is provisioning the database account.",
      "pos": [
        36906,
        37048
      ]
    },
    {
      "content": "This master key has administrator semantics, in that it can be used to authorize access to both administrative and application resources.",
      "pos": [
        37049,
        37186
      ]
    },
    {
      "content": "In contrast, a resource key is a granular access key that allows access to a <bpt id=\"p1\">*</bpt>specific<ept id=\"p1\">*</ept> application resource.",
      "pos": [
        37187,
        37296
      ]
    },
    {
      "content": "Thus, it captures the relationship between the user of a database and the permissions the user has for a specific resource (e.g. collection, document, attachment, stored procedure, trigger, or UDF).",
      "pos": [
        37297,
        37495
      ]
    },
    {
      "content": "The only way to obtain a resource key is by creating a permission resource under a given user.",
      "pos": [
        37500,
        37594
      ]
    },
    {
      "content": "Note that In order to create or retrieve a permission, a master key must be presented in the authorization header.",
      "pos": [
        37595,
        37709
      ]
    },
    {
      "content": "A permission resource ties the resource, its access and the user.",
      "pos": [
        37710,
        37775
      ]
    },
    {
      "content": "After creating a permission resource, the user only needs to present the associated resource key in order to gain access to the relevant resource.",
      "pos": [
        37776,
        37922
      ]
    },
    {
      "content": "Hence, a resource key can be viewed as a logical and compact representation of the permission resource.",
      "pos": [
        37923,
        38026
      ]
    },
    {
      "content": "As with all other resources, permissions in DocumentDB can be created, replaced, deleted, read or enumerated easily using either REST APIs or any of the client SDKs.",
      "pos": [
        38030,
        38195
      ]
    },
    {
      "content": "DocumentDB always provides strong consistency for reading or querying the metadata of a permission.",
      "pos": [
        38196,
        38295
      ]
    },
    {
      "content": "Next steps",
      "pos": [
        38300,
        38310
      ]
    },
    {
      "content": "Learn more about working with resources by using HTTP commands in <bpt id=\"p1\">[</bpt>RESTful interactions with DocumentDB resources<ept id=\"p1\">](documentdb-interactions-with-resources.md)</ept>.",
      "pos": [
        38311,
        38469
      ]
    },
    {
      "content": "test",
      "pos": [
        38616,
        38620
      ]
    }
  ],
  "content": "<properties \n    pageTitle=\"DocumentDB resource model and concepts | Microsoft Azure\" \n    description=\"Microsoft Azure DocumentDB is a fully-managed NoSQL document database that uses a hierarchichal model of database accounts, databases, collections, stored procedures, triggers, UDFs, documents, attachments, media, users, and permissions to manage resources.\"  \n    services=\"documentdb\" \n    documentationCenter=\"\" \n    authors=\"mimig1\" \n    manager=\"jhubbard\" \n    editor=\"monicar\"/>\n\n<tags \n    ms.service=\"documentdb\" \n    ms.workload=\"data-services\" \n    ms.tgt_pltfrm=\"na\" \n    ms.devlang=\"na\" \n    ms.topic=\"article\" \n    ms.date=\"08/03/2015\" \n    ms.author=\"anhoh\"/>\n\n#DocumentDB resource model and concepts\n\nThe database entities that DocumentDB manages are referred to as **resources**. Each resource is uniquely identified by a logical URI. You can interact with the resources using standard HTTP verbs, request/response headers and status codes. \n\nBy reading this article, you'll be able to answer the following questions:\n\n- What are the DocumentDB resources?\n- What is the hierarchy of DocumentDB resources?\n- What are system defined resources versus user defined resources?\n- How do I address a resource?\n- How do I work with collections?\n- How do I work with stored procedures, triggers and User Defined Functions (UDFs)?\n\n##Hierarchical resource model\nAs the following diagram illustrates, the DocumentDB **resource model** consists of sets of resources under a database account, each addressable via a logical and stable URI. A set of resources will be referred to as a **feed** in this article. \n\n>[AZURE.NOTE] DocumentDB offers a highly efficient TCP protocol which is also RESTful in its communication model, available through the [.NET client SDK](https://msdn.microsoft.com/library/azure/dn781482.aspx).\n\n![][1]  \n**Hierarchical resource model under a database account**   \n\nTo start working with resources, you must [create a DocumentDB database account](documentdb-create-account.md) using your Azure subscription. A database account can consist of a set of **databases**, each containing multiple **collections**, each of which in-turn contain **stored procedures, triggers, UDFs, documents** and related **attachments** (preview feature). A database also has associated **users**, each with a set of **permissions** to access collections, stored procedures, triggers, UDFs, documents or attachments. While databases, users, permissions and collections are system-defined resources with well-known schemas, documents and attachments contain arbitrary, user defined JSON content.  \n\n|Resource   |Description\n|-----------|-----------\n|Database account   |A database account is associated with a set of databases and a fixed amount of blob storage for attachments (preview feature). You can create one or more database accounts using your Azure subscription. Every Standard database account is allocated a minimum capacity of one S1 collection. For more information, visit our [pricing page](https://azure.microsoft.com/pricing/details/documentdb/).\n|Database   |A database is a logical container of document storage partitioned across collections. It is also a users container.\n|User   |The logical namespace for scoping/partitioning permissions. \n|Permission |An authorization token associated with a user for authorized access to a specific resource.\n|Collection |A collection is a container of JSON documents and the associated JavaScript application logic. A collection is a billable entity, where the cost is determined by the performance level associated with the collection. The performance levels (S1, S2 and S3) provide 10GB of storage and a fixed amount of throughput. For more information on performance levels, visit our [performance page](documentdb-performance-levels.md).\n|Stored Procedure   |Application logic written in JavaScript which is registered with a collection and transactionally executed within the database engine.\n|Trigger    |Application logic written in JavaScript modeling side effects associated with insert, replace or delete operations.\n|UDF    |A side effect free, application logic written in JavaScript. UDFs enable you to model a custom query operator and thereby extend the core DocumentDB query language.\n|Document   |User defined (arbitrary) JSON content. By default, no schema needs to be defined nor do secondary indices need to be provided for all the documents added to a collection.\n|(Preview) Attachment   |An attachment is a special document containing references and associated metadata for external blob/media. The developer can choose to have the blob managed by DocumentDB or store it with an external blob service provider such as OneDrive, Dropbox, etc. \n\n\n##System vs. user defined resources\nResources such as database accounts, databases, collections, users, permissions, stored procedures, triggers, and UDFs - all have a fixed schema and are called system resources. In contrast, resources such as documents and attachments have no restrictions on the schema and are examples of user defined resources. In DocumentDB, both system and user defined resources are represented and managed as standard-compliant JSON. All resources, system or user defined, have the following common properties.\n\n>[AZURE.NOTE] Note that all system generated properties in a resource are prefixed with an underscore (_) in their JSON representation.  \n\n\nProperty |User settable or system generated?|Purpose\n---|---|---\n_rid|System generated|System generated, unique and hierarchical identifier of the resource.\n_etag|System generated|etag of the resource required for optimistic concurrency control.\n_ts|System generated|Last updated timestamp of the resource.\n_self|System generated|Unique addressable URI of the resource.\nid|User settable|User defined unique name of the resource.\n\n###Wire representation of resources\nDocumentDB does not mandate any proprietary extensions to the JSON standard or special encodings; it works with standard compliant JSON documents.  \n \n###Addressing a resource\nAll resources are URI addressable. The value of the **_self** property of a resource represents the relative URI of the resource. The format of the URI consists of the /\\<feed\\>/{_rid} path segments:  \n\n|Value of the _self |Description\n|-------------------|-----------\n|/dbs   |Feed of databases under a database account.\n|/dbs/{_rid-db} |Database with the unique id property with the value {_rid-db}.\n|/dbs/{_rid-db}/colls/  |Feed of collections under a database.\n|/dbs/{_rid-db}/colls/{_rid-coll}   |Collection with the unique id property with the value {_rid-coll}.\n|/dbs/{_rid-db}/users/  |Feed of users under a database. \n|/dbs/{_rid-db}/users/{_rid-user}   |User with the unique id property with the value {_rid-user}.\n|/dbs/{_rid-db}/users/{_rid-user}/permissions   |Feed of permissions under a database. \n|/dbs/{_rid-db}/users/{_rid-user}/permissions/{_rid-permission} |Permission with the unique id property with the value {_rid-permission}.  \n  \nA resource also has a unique user defined name exposed via the id property of the resource. The id is a user defined string, of up to 256 characters that is unique within the context of a specific parent resource. For instance, the value of the id property of all documents within a given collection are unique but they are not guaranteed to be unique across collections. Similarly, the value of the id property of all permissions for a given user are unique but they are not guaranteed to be unique across all users. The _rid property is used to construct the addressable _self link of a resource.   \n\nEach resource also has a system generated hierarchical resource identifier (also referred to as an RID), which is available via the _rid property. The RID encodes the entire hierarchy of a given resource and it is a very convenient internal representation used to enforce referential integrity in a distributed manner. The RID is unique within a database account and is internally used by DocumentDB for efficient routing without requiring cross partition lookups. \n\nThe values of the _self and the  _rid properties are both alternate and canonical representations of a resource.  \n\n##Database accounts\nYou can provision one or more DocumentDB database accounts using your Azure subscription. Each Standard tier database account will be given a minimum capacity of one S1 collection.\n\nYou can [create and manage DocumentDB database accounts](documentdb-create-account.md) via the Azure portal at [http://portal.azure.com/](http://portal.azure.com/). Creating and managing a database account requires administrative access and can only be performed under your Azure subscription. \n\n###Database account properties\nAs part of provisioning and managing a database account you can configure and read the following properties:  \n\nProperty Name|Description\n---|---\nConsistency Policy|Set this property to configure the default consistency level for all the collections under your database account. You can override the consistency level on a per request basis using the [x-ms-consistency-level] request header. In the future, we may support overriding the consistency level on a per collection basis. <p><p>Note that this property only applies to the <i>user defined resources</i>. All system defined resources are configured to support reads/queries with strong consistency.\nPrimary Key and Secondary Key|These are the primary and secondary keys that provide administrative access to all of the resources under the database account.\nMaxMediaStorageUsageInMB (READ)|Maximum amount of media storage available for the database account.\nMediaStorageUsageInMB (READ)|Current usage of media storage for the database account.\n\nNote that in addition to provisioning, configuring and managing your database account from the Azure portal, you can also programmatically create and manage DocumentDB database accounts by using the [Azure DocumentDB REST APIs](https://msdn.microsoft.com/library/azure/dn781481.aspx) as well as [client SDKs](https://msdn.microsoft.com/library/azure/dn781482.aspx).  \n\n##Databases\nA DocumentDB database is a logical container of one or more collections and users, as shown in the following diagram. You can create any number of databases under a DocumentDB database account subject to offer limits.  \n\n![][2]  \n**A Database is a logical container of users and collections**\n\nA database can contain virtually unlimited document storage partitioned by collections, which form the transaction domains for the documents contained within them. \n\n###Elastic scale of a DocumentDB database\nA DocumentDB database is elastic by default – ranging from a few GB to petabytes of SSD backed document storage and provisioned throughput. \n\nUnlike a database in traditional RDBMS, a database in DocumentDB is not scoped to a single machine. With DocumentDB, as your application’s scale needs to grow, you can create more collections or databases or both. Indeed, various first party applications within Microsoft have been using DocumentDB at a consumer scale by creating extremely large DocumentDB databases each containing thousands of collections with terabytes of document storage. You can grow or shrink a database by adding or removing collections to meet your application’s scale requirements. \n\nYou can create any number of collections within a database subject to the offer. Each collection has SSD backed storage and throughput provisioned for you depending on the selected performance tier.\n\nA DocumentDB database is also a container of users. A user, in-turn, is a logical namespace for a set of permissions that provides fine-grained authorization and access to collections, documents and attachments.  \n \nAs with other resources in the DocumentDB resource model, databases can be created, replaced, deleted, read or enumerated easily using either [Azure DocumentDB REST APIs](https://msdn.microsoft.com/library/azure/dn781481.aspx) or any of the [client SDKs](https://msdn.microsoft.com/library/azure/dn781482.aspx). DocumentDB guarantees strong consistency for reading or querying the metadata of a database resource. Deleting a database automatically ensures that you cannot access any of the collections or users contained within it.   \n\n##Collections\nA DocumentDB collection is a container for your JSON documents. A collection is also a unit of scale for transactions and queries. You can scale out a DocumentDB database by adding more collections. If your application needs to scale more, you can add a collection, each allocated with SSD backed storage and a fixed amount of throughput depending on its performance tier.\n \n###Elastic SSD backed document storage\nA collection is intrinsically elastic - it automatically grows and shrinks as you add or remove documents. Although the first party usage of DocumentDB has tested it with thousands of collections within a database with each ranging from a few gigabytes to terabytes in size, DocumentDB currently limits the elasticity of a given collection to 10GB. \n\n###Automatic indexing of collections\nDocumentDB is a true schema-free database system. It does not assume or require any schema for the JSON documents. As you add documents to a collection, DocumentDB automatically indexes them and they are available for you to query. Automatic indexing of documents without requiring schema or secondary indexes is a key capability of DocumentDB and is enabled by write-optimized, lock-free and log-structured index maintenance techniques. DocumentDB supports sustained volume of extremely fast writes while still serving consistent queries. Both document and index storage are used to calculate the storage consumed by each collection. You can control the storage and performance trade-offs associated with indexing by configuring the indexing policy for a collection. \n\n###Configuring the indexing policy of a collection\nThe indexing policy of each collection allows you to make performance and storage trade-offs associated with indexing. The following options are available to you as part of indexing configuration:  \n\n-   Choose whether the collection automatically indexes all of the documents or not. By default, all documents are automatically indexed. You can choose to turn off automatic indexing and selectively add only specific documents to the index. Conversely, you can selectively choose to exclude only specific documents. You can achieve this by setting the automatic property to be true or false on the indexingPolicy of a collection and using the [x-ms-indexingdirective] request header while inserting, replacing or deleting a document.  \n-   Choose whether to include or exclude specific paths or patterns in your documents from the index. You can achieve this by setting includedPaths and excludedPaths on the indexingPolicy of a collection respectively. You can also configure the storage and performance trade-offs for range and hash queries for specific path patterns. \n-   Choose between synchronous (consistent) and asynchronous (lazy) index updates. By default, the index is updated synchronously on each insert, replace or delete of a document to the collection. This enables the queries to honor the same consistency level as that of the document reads. While DocumentDB is write optimized and supports sustained volumes of document writes along with synchronous index maintenance and serving consistent queries, you can configure certain collections to update their index lazily. Lazy indexing boosts the write performance further and is ideal for bulk ingestion scenarios for primarily read-heavy collections.\n\nThe indexing policy can only be configured during the creation of a collection. Once the collection has been created the policy cannot be updated.\n\n###Querying a collection\nThe documents within a collection can have arbitrary schemas and you can query documents within a collection without providing any schema or secondary indices upfront. You can query the collection using the [DocumentDB SQL query language](https://msdn.microsoft.com/library/azure/dn782250.aspx), which provides rich hierarchical and relational operators and extensibility via JavaScript-based UDFs. JSON grammar allows for modeling JSON documents as trees with labels as the tree nodes. This is exploited both by DocumentDB’s automatic indexing techniques as well as DocumentDB's SQL query dialect. The DocumentDB query language consists of three main aspects:   \n\n1.  A small set of query operations that map naturally to the tree structure including hierarchical queries and projections. \n2.  A subset of relational operations including composition, filter, projections, aggregates and self joins. \n3.  Pure JavaScript based UDFs that work with (1) and (2).  \n\nThe DocumentDB query model attempts to strike a balance between functionality, efficiency and simplicity. The DocumentDB database engine natively compiles and executes the SQL query statements. You can query a collection using the [Azure DocumentDB REST APIs](https://msdn.microsoft.com/library/azure/dn781481.aspx) or any of the [client SDKs](https://msdn.microsoft.com/library/azure/dn781482.aspx). The .NET SDK comes with a LINQ provider.\n\nYou can try out DocumentDB and run SQL queries against our dataset in the [Query Playground](https://www.documentdb.com/sql/demo).\n\n###Multi-document transactions\nDatabase transactions provide a safe and predictable programming model for dealing with concurrent changes to the data. In RDBMS, the traditional way to write business logic is to write **stored-procedures** and/or **triggers** and ship it to the database server for transactional execution. In RDBMS, the application programmer is required to deal with two disparate programming languages: \n\n- The (non-transactional) application programming language (e.g. JavaScript, Python, C#, Java, etc.). \n- T-SQL, the transactional programming language which is natively executed by the database.\n\nBy virtue of its deep commitment to JavaScript and JSON directly within the database engine, DocumentDB provides an intuitive programming model for executing JavaScript based application logic directly on the collections in terms of stored procedures and triggers. This allows for both of the following:\n\n- Efficient implementation of concurrency control, recovery, automatic indexing of the JSON object graphs directly in the database engine. \n- Naturally expressing control flow, variable scoping, assignment and integration of exception handling primitives with database transactions directly in terms of the JavaScript programming language.   \n\nThe JavaScript logic registered at a collection level can then issue database operations on the documents of the given collection. DocumentDB implicitly wraps the JavaScript based stored procedures and triggers within an ambient ACID transactions with snapshot isolation across documents within a collection. During the course of its execution, if the JavaScript throws an exception, then the entire transaction is aborted. The resulting programming model is a very simple yet powerful. JavaScript developers get a “durable” programming model while still using their familiar language constructs and library primitives.   \n\nThe ability to execute JavaScript directly within the database engine in the same address space as the buffer pool enables performant and transactional execution of database operations against the documents of a collection. Further, because DocumentDB database engine makes a deep commitment to the JSON and JavaScript eliminates any impedance mismatch between the type systems of application and the database.   \n\nAfter creating a collection, you can register stored procedures, triggers and UDFs with a collection using the [Azure DocumentDB REST APIs](https://msdn.microsoft.com/library/azure/dn781481.aspx) or any of the [client SDKs](https://msdn.microsoft.com/library/azure/dn781482.aspx). After registration, you can reference and execute them. Consider the following stored procedure written entirely in JavaScript, takes two arguments (book name and author name) and creates a new document, queries for a document and then updates it – all within the auspices of an implicit ACID transaction. At any point during the execution, if a JavaScript exception is thrown, the entire transaction aborts.\n\n    function businessLogic(name, author) {\n        var context = getContext();\n        var collectionManager = context.getCollection();        \n        var collectionLink = collectionManager.getSelfLink()\n            \n        // create a new document.\n        collectionManager.createDocument(collectionLink,\n            {id: name, author: author},\n            function(err, documentCreated) {\n                if(err) throw new Error(err.message);\n                \n                // filter documents by author\n                var filterQuery = \"SELECT * from root r WHERE r.author = 'George R.'\";\n                collectionManager.queryDocuments(collectionLink,\n                    filterQuery,\n                    function(err, matchingDocuments) {\n                        if(err) throw new Error(err.message);\n                        \n                        context.getResponse().setBody(matchingDocuments.length);\n                       \n                        // Replace the author name for all documents that satisfied the query.\n                        for (var i = 0; i < matchingDocuments.length; i++) {\n                            matchingDocuments[i].author = \"George R. R. Martin\";\n                            // we don’t need to execute a callback because they are in parallel\n                            collectionManager.replaceDocument(matchingDocuments[i]._self,\n                                matchingDocuments[i]);   \n                        }\n                    })\n            })\n    };\n\nThe client can “ship” the above JavaScript logic to the database for transactional execution via HTTP POST. For more information about using HTTP methods, see [RESTful interactions with DocumentDB resources](documentdb-interactions-with-resources.md). \n\n    client.createStoredProcedureAsync(collection._self, {id: \"CRUDProc\", body: businessLogic})\n       .then(function(createdStoredProcedure) {\n            return client.executeStoredProcedureAsync(createdStoredProcedure.resource._self,\n                \"NoSQL Distilled\",\n                \"Martin Fowler\");\n        })\n        .then(function(result) {\n            console.log(result);\n        },\n        function(error) {\n            console.log(error);\n        });\n\n\nNotice that because the database natively understands JSON and JavaScript, there is no type system mismatch, no “OR mapping” or code generation magic required.   \n\nStored procedures and triggers interact with a collection and the documents in a collection through a well-defined object model which exposes the current collection context.  \n\nCollections in DocumentDB can be created, deleted, read or enumerated easily using either the [Azure DocumentDB REST APIs](https://msdn.microsoft.com/library/azure/dn781481.aspx) or any of the [client SDKs](https://msdn.microsoft.com/library/azure/dn781482.aspx). DocumentDB always provides strong consistency for reading or querying the metadata of a collection. Deleting a collection automatically ensures that you cannot access any of the documents, attachments, stored procedures, triggers, and UDFs contained within it.   \n \n##Stored procedures, triggers and UDFs\nAs described in the previous section, you can write application logic to run directly within a transaction inside of the database engine. The application logic can be written entirely in JavaScript and can be modeled as a stored procedure, trigger or a UDF. The JavaScript code within a stored procedure or a trigger can insert, replace, delete, read or query documents within a collection. On the other hand, the JavaScript within a UDF can only perform side effect free computation by enumerating the documents of the result set of the query and produce another result set. For multi-tenancy, DocumentDB enforces a strict reservation based resource governance. Each stored procedure, trigger or a UDF gets a fixed quantum of operating system resources to do its work. Further, stored procedures, triggers or UDFs cannot link against external JavaScript libraries and are blacklisted if they exceed the resource budgets allocated to them. You can register, unregister stored procedures, triggers or UDFs with a collection by using the REST APIs.  Upon registration a stored procedure, trigger, or a UDF is pre-compiled and stored as byte code which gets executed later. The following section illustrate how you can use the DocumentDB JavaScript SDK to register, execute, and unregister a stored procedure, trigger, and a UDF. The JavaScript SDK is a simple wrapper over the [DocumentDB REST APIs](https://msdn.microsoft.com/library/azure/dn781481.aspx). \n\n###Registering a stored procedure\nRegistration of a stored procedure creates a new stored procedure resource on a collection via HTTP POST.  \n\n    var storedProc = {\n        id: \"validateAndCreate\",\n        body: function (documentToCreate) {\n            documentToCreate.id = documentToCreate.id.toUpperCase();\n            \n            var collectionManager = getContext().getCollection();\n            collectionManager.createDocument(collectionManager.getSelfLink(),\n                documentToCreate,\n                function(err, documentCreated) {\n                    if(err) throw new Error('Error while creating document: ' + err.message;\n                    getContext().getResponse().setBody('success - created ' + \n                            documentCreated.name);\n                });\n        }\n    };\n    \n    client.createStoredProcedureAsync(collection._self, storedProc)\n        .then(function (createdStoredProcedure) {\n            console.log(\"Successfully created stored procedure\");\n        }, function(error) {\n            console.log(\"Error\");\n        });\n\n###Executing a stored procedure\nExecution of a stored procedure is done by issuing an HTTP POST against an existing stored procedure resource by passing parameters to the procedure in the request body.\n\n    var inputDocument = {id : \"document1\", author: \"G. G. Marquez\"};\n    client.executeStoredProcedureAsync(createdStoredProcedure.resource._self, inputDocument)\n        .then(function(executionResult) {\n            assert.equal(executionResult, \"success - created DOCUMENT1\");\n        }, function(error) {\n            console.log(\"Error\");\n        });\n\n###Unregistering a stored procedure\nUn-registering a stored procedure is simply done by issuing an HTTP DELETE against an existing stored procedure resource.   \n\n    client.deleteStoredProcedureAsync(createdStoredProcedure.resource._self)\n        .then(function (response) {\n            return;\n        }, function(error) {\n            console.log(\"Error\");\n        });\n\n\n###Registering a pre-trigger\nRegistration of a trigger is done by creating a new trigger resource on a collection via HTTP POST. You can specify if the trigger is a pre or a post trigger and the type of operation it can be associated with (e.g. Create, Replace, Delete, or All).   \n\n    var preTrigger = {\n        id: \"upperCaseId\",\n        body: function() {\n                var item = getContext().getRequest().getBody();\n                item.id = item.id.toUpperCase();\n                getContext().getRequest().setBody(item);\n        },\n        triggerType: TriggerType.Pre,\n        triggerOperation: TriggerOperation.All\n    }\n    \n    client.createTriggerAsync(collection._self, preTrigger)\n        .then(function (createdPreTrigger) {\n            console.log(\"Successfully created trigger\");\n        }, function(error) {\n            console.log(\"Error\");\n        });\n\n###Executing a pre-trigger\nExecution of a trigger is done by specifying the name of an existing trigger at the time of issuing the POST/PUT/DELETE request of a document resource via the request header.  \n \n    client.createDocumentAsync(collection._self, { id: \"doc1\", key: \"Love in the Time of Cholera\" }, { preTriggerInclude: \"upperCaseId\" })\n        .then(function(createdDocument) {\n            assert.equal(createdDocument.resource.id, \"DOC1\");\n        }, function(error) {\n            console.log(\"Error\");\n        });\n\n###Unregistering a pre-trigger\nUn-registering a trigger is simply done via issuing an HTTP DELETE against an existing trigger resource.  \n\n    client.deleteTriggerAsync(createdPreTrigger._self);\n        .then(function(response) {\n            return;\n        }, function(error) {\n            console.log(\"Error\");\n        });\n\n###Registering a UDF\nRegistration of a UDF is done by creating a new UDF resource on a collection via HTTP POST.  \n\n    var udf = { \n        id: \"mathSqrt\",\n        body: function(number) {\n                return Math.sqrt(number);\n        },\n    };\n    client.createUserDefinedFunctionAsync(collection._self, udf)\n        .then(function (createdUdf) {\n            console.log(\"Successfully created stored procedure\");\n        }, function(error) {\n            console.log(\"Error\");\n        });\n\n###Executing a UDF as part of the query\nA UDF can be specified as part of the SQL query and is used as a way to extend the core [SQL query language of DocumentDB](https://msdn.microsoft.com/library/azure/dn782250.aspx).\n\n    var filterQuery = \"SELECT udf.mathSqrt(r.Age) AS sqrtAge FROM root r WHERE r.FirstName='John'\";\n    client.queryDocuments(collection._self, filterQuery).toArrayAsync();\n        .then(function(queryResponse) {\n            var queryResponseDocuments = queryResponse.feed;\n        }, function(error) {\n            console.log(\"Error\");\n        });\n\n###Unregistering a UDF \nUn-registering a UDF is simply done by issuing an HTTP DELETE against an existing UDF resource.  \n\n    client.deleteUserDefinedFunctionAsync(createdUdf._self)\n        .then(function(response) {\n            return;\n        }, function(error) {\n            console.log(\"Error\");\n        });\n\nAlthough the snippets above showed the registration (POST), un-registration (PUT), read/list (GET) and execution (POST) via the [DocumentDB JavaScript SDK](https://github.com/Azure/azure-documentdb-js), you can also use the [REST APIs](https://msdn.microsoft.com/library/azure/dn781481.aspx) or other [client SDKs](https://msdn.microsoft.com/library/azure/dn781482.aspx). \n\n##Documents\nYou can insert, replace, delete, read, enumerate and query arbitrary JSON documents in a collection. DocumentDB does not mandate any schema and does not require secondary indexes in order to support querying over documents in a collection.   \n\nBeing a truly open database service, DocumentDB does not invent any specialized data types (e.g. date time) or specific encodings for JSON documents. Note that DocumentDB does not require any special JSON conventions to codify the relationships among various documents; the SQL query language of DocumentDB provides very powerful hierarchical and relational query operators to query and project documents without any special annotations or need to codify relationships among documents using distinguished properties.  \n \nAs with all other resources, documents can be created, replaced, deleted, read, enumerated and queried easily using either REST APIs or any of the [client SDKs](https://msdn.microsoft.com/library/azure/dn781482.aspx). Deleting a document instantly frees up the quota corresponding to all of the nested attachments. The read consistency level of documents follows the consistency policy on the database account. This policy can be overridden on a per-request basis depending on data consistency requirements of your application. When querying documents, the read consistency follows the indexing mode set on the collection. For “consistent”, this follows the account’s consistency policy. \n\n##Attachments and media\n>[AZURE.NOTE] Attachment and media resources are preview features.\n \nDocumentDB allows you to store binary blobs/media either with DocumentDB or to your own remote media store. It also allows you to represent the metadata of a media in terms of a special document called attachment. An attachment in DocumentDB is a special (JSON) document that references the media/blob stored elsewhere. An attachment is simply a special document that captures the metadata (e.g. location, author etc.) of a media stored in a remote media storage. \n\nConsider a social reading application which uses DocumentDB to store ink annotations, and metadata including comments, highlights, bookmarks, ratings, likes/dislikes etc. associated for an e-book of a given user.   \n\n-   The content of the book itself is stored in the media storage either available as part of DocumentDB database account or a remote media store. \n-   An application may store each user’s metadata as a distinct document -- e.g. Joe’s metadata for book1 is stored in a document referenced by /colls/joe/docs/book1. \n-   Attachments pointing to the content pages of a given book of a user are stored under the corresponding document e.g. /colls/joe/docs/book1/chapter1, /colls/joe/docs/book1/chapter2 etc. \n\nNote that the examples use friendly ids to convey the resource hierarchy. Resources are accessed via the REST APIs through unique resource ids. \n\nFor the media that is managed by DocumentDB, the _media property of the attachment will reference the media by its URI. DocumentDB will ensure to garbage collect the media when all of the outstanding references are dropped. DocumentDB automatically generates the attachment when you upload the new media and populates the _media to point to the newly added media. If you choose to store the media in a remote blob store managed by you (e.g. OneDrive, Azure Storage, DropBox etc), you can still use attachments to reference the media. In this case, you will create the attachment yourself and populate its _media property.   \n\nAs with all other resources, attachments can be created, replaced, deleted, read or enumerated easily using either REST APIs or any of the client SDKs. As with documents, the read consistency level of attachments follows the consistency policy on the database account. This policy can be overridden on a per-request basis depending on data consistency requirements of your application. When querying for attachments, the read consistency follows the indexing mode set on the collection. For “consistent”, this follows the account’s consistency policy. \n \n##Users\nA DocumentDB user represents a logical namespace for grouping permissions. A DocumentDB user may correspond to a user in an identity management system or a predefined application role. For DocumentDB, a user simply represents an abstraction to group a set of permissions under a database.   \n\nFor implementing multi-tenancy in your application, you can create users in DocumentDB which corresponds to your actual users or the tenants of your application. You can then create permissions for a given user that correspond to the access control over various collections, documents, attachments, etc.   \n\nAs your applications need to scale with your user growth, you can adopt various ways to shard your data. You can model each of your users as follows:   \n\n-   Each user maps to a database.\n-   Each user maps to a collection. \n-   Documents corresponding to multiple users go to a dedicated collection. \n-   Documents corresponding to multiple users go to a set of collections.   \n\nRegardless of the specific sharding strategy you choose, you can model your actual users as users in DocumentDB database and associate fine grained permissions to each user.  \n\n![][3]  \n**Sharding strategies and modeling users**\n\nLike all other resources, users in DocumentDB can be created, replaced, deleted, read or enumerated easily using either REST APIs or any of the client SDKs. DocumentDB always provides strong consistency for reading or querying the metadata of a user resource. It is worth pointing out that deleting a user automatically ensures that you cannot access any of the permissions contained within it. Even though the DocumentDB reclaims the quota of the permissions as part of the deleted user in the background, the deleted permissions is available instantly again for you to use.  \n\n##Permissions\nFrom the access control perspective, resources such as database accounts, databases, users and permission are considered *administrative* resources since these require administrative permissions. On the other hand, resources including the collections, documents, attachments, stored procedures, triggers, and UDFs are scoped under a given database and considered *application resources*. Corresponding to the two types of resources and the roles that access them (namely the administrator and user), the authorization model defines two types of *access keys*: *master key* and *resource key*. The master key is a part of the database account and is provided to the developer (or administrator) who is provisioning the database account. This master key has administrator semantics, in that it can be used to authorize access to both administrative and application resources. In contrast, a resource key is a granular access key that allows access to a *specific* application resource. Thus, it captures the relationship between the user of a database and the permissions the user has for a specific resource (e.g. collection, document, attachment, stored procedure, trigger, or UDF).   \n\nThe only way to obtain a resource key is by creating a permission resource under a given user. Note that In order to create or retrieve a permission, a master key must be presented in the authorization header. A permission resource ties the resource, its access and the user. After creating a permission resource, the user only needs to present the associated resource key in order to gain access to the relevant resource. Hence, a resource key can be viewed as a logical and compact representation of the permission resource.  \n\nAs with all other resources, permissions in DocumentDB can be created, replaced, deleted, read or enumerated easily using either REST APIs or any of the client SDKs. DocumentDB always provides strong consistency for reading or querying the metadata of a permission. \n\n##Next steps\nLearn more about working with resources by using HTTP commands in [RESTful interactions with DocumentDB resources](documentdb-interactions-with-resources.md).\n\n\n[1]: media/documentdb-resources/resources1.png\n[2]: media/documentdb-resources/resources2.png\n[3]: media/documentdb-resources/resources3.png\n \n\ntest\n"
}