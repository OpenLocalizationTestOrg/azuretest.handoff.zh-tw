<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Microsoft Azure Storage Performance and Scalability Checklist</source>
          <target state="new">Microsoft Azure Storage Performance and Scalability Checklist</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>A checklist of proven practices for use with Azure Storage in developing performant applications.</source>
          <target state="new">A checklist of proven practices for use with Azure Storage in developing performant applications.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Microsoft Azure Storage Performance and Scalability Checklist</source>
          <target state="new">Microsoft Azure Storage Performance and Scalability Checklist</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="new">Overview</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Since the release of the Microsoft Azure Storage services, Microsoft has developed a number of proven practices for using these services in a performant manner, and this article serves to consolidate the most important of them into a checklist-style list.</source>
          <target state="new">Since the release of the Microsoft Azure Storage services, Microsoft has developed a number of proven practices for using these services in a performant manner, and this article serves to consolidate the most important of them into a checklist-style list.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The intention of this article is to help application developers verify they are using proven practices with Azure Storage and to help them identify other proven practices they should consider adopting.</source>
          <target state="new">The intention of this article is to help application developers verify they are using proven practices with Azure Storage and to help them identify other proven practices they should consider adopting.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This article does not attempt to cover every possible performance and scalability optimization — it excludes those that are small in their impact or not broadly applicable.</source>
          <target state="new">This article does not attempt to cover every possible performance and scalability optimization — it excludes those that are small in their impact or not broadly applicable.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>To the extent that the application’s behavior can be predicted during design, it’s useful to keep these in mind early on to avoid designs that will run into performance problems.</source>
          <target state="new">To the extent that the application’s behavior can be predicted during design, it’s useful to keep these in mind early on to avoid designs that will run into performance problems.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Every application developer using Azure Storage should take the time to read this article, and check that his or her application follows each of the proven practices listed below.</source>
          <target state="new">Every application developer using Azure Storage should take the time to read this article, and check that his or her application follows each of the proven practices listed below.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Checklist</source>
          <target state="new">Checklist</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>This article organizes the proven practices into the following groups.</source>
          <target state="new">This article organizes the proven practices into the following groups.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Proven practices applicable to:</source>
          <target state="new">Proven practices applicable to:</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>All Azure Storage services (blobs, tables, queues, and files)</source>
          <target state="new">All Azure Storage services (blobs, tables, queues, and files)</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Blobs</source>
          <target state="new">Blobs</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Tables</source>
          <target state="new">Tables</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Queues</source>
          <target state="new">Queues</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The Azure Files service is currently in Preview, and we will add proven practices here in the future.</source>
          <target state="new">The Azure Files service is currently in Preview, and we will add proven practices here in the future.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Done</source>
          <target state="new">Done</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Area</source>
          <target state="new">Area</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Category</source>
          <target state="new">Category</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Question</source>
          <target state="new">Question</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>All Services</source>
          <target state="new">All Services</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Scalability Targets</source>
          <target state="new">Scalability Targets</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Is your application designed to avoid approaching the scalability targets?</source>
          <target state="new">Is your application designed to avoid approaching the scalability targets?</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>All Services</source>
          <target state="new">All Services</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Networking</source>
          <target state="new">Networking</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Do client side devices have sufficiently high bandwidth and low latency to achieve the performance needed?</source>
          <target state="new">Do client side devices have sufficiently high bandwidth and low latency to achieve the performance needed?</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>All Services</source>
          <target state="new">All Services</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Networking</source>
          <target state="new">Networking</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Do client side devices have a high enough quality link?</source>
          <target state="new">Do client side devices have a high enough quality link?</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>All Services</source>
          <target state="new">All Services</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Networking</source>
          <target state="new">Networking</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Is the client application located "near" the storage account?</source>
          <target state="new">Is the client application located "near" the storage account?</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>All Services</source>
          <target state="new">All Services</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Content Distribution</source>
          <target state="new">Content Distribution</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Are you using a CDN for content distribution?</source>
          <target state="new">Are you using a CDN for content distribution?</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>All Services</source>
          <target state="new">All Services</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Direct Client Access</source>
          <target state="new">Direct Client Access</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Are you using SAS and CORS to allow direct access to storage instead of proxy?</source>
          <target state="new">Are you using SAS and CORS to allow direct access to storage instead of proxy?</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>All Services</source>
          <target state="new">All Services</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Caching</source>
          <target state="new">Caching</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Is your application caching data that is repeatedly used and changes rarely?</source>
          <target state="new">Is your application caching data that is repeatedly used and changes rarely?</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>All Services</source>
          <target state="new">All Services</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Caching</source>
          <target state="new">Caching</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Is your application batching updates (caching them client side and then uploading in larger sets)?</source>
          <target state="new">Is your application batching updates (caching them client side and then uploading in larger sets)?</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>All Services</source>
          <target state="new">All Services</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>.NET Configuration</source>
          <target state="new">.NET Configuration</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Have you configured your client to use a sufficient number of concurrent connections?</source>
          <target state="new">Have you configured your client to use a sufficient number of concurrent connections?</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>All Services</source>
          <target state="new">All Services</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>.NET Configuration</source>
          <target state="new">.NET Configuration</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Have you configured .NET to use a sufficient number of threads?</source>
          <target state="new">Have you configured .NET to use a sufficient number of threads?</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>All Services</source>
          <target state="new">All Services</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>.NET Configuration</source>
          <target state="new">.NET Configuration</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Are you using .NET 4.5 or later, which has improved garbage collection?</source>
          <target state="new">Are you using .NET 4.5 or later, which has improved garbage collection?</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>All Services</source>
          <target state="new">All Services</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Parallelism</source>
          <target state="new">Parallelism</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Have you ensured that parallelism is bounded appropriately so that you don’t overload either your client capabilities or the scalability targets?</source>
          <target state="new">Have you ensured that parallelism is bounded appropriately so that you don’t overload either your client capabilities or the scalability targets?</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>All Services</source>
          <target state="new">All Services</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="new">Tools</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Are you using the latest version of Microsoft provided client libraries and tools?</source>
          <target state="new">Are you using the latest version of Microsoft provided client libraries and tools?</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>All Services</source>
          <target state="new">All Services</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Retries</source>
          <target state="new">Retries</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Are you using an exponential backoff retry policy for throttling errors and timeouts?</source>
          <target state="new">Are you using an exponential backoff retry policy for throttling errors and timeouts?</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>All Services</source>
          <target state="new">All Services</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Retries</source>
          <target state="new">Retries</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Is your application avoiding retries for non-retryable errors?</source>
          <target state="new">Is your application avoiding retries for non-retryable errors?</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Blobs</source>
          <target state="new">Blobs</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Scalability Targets</source>
          <target state="new">Scalability Targets</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Is your application staying within the bandwidth or operations scalability target for a single blob?</source>
          <target state="new">Is your application staying within the bandwidth or operations scalability target for a single blob?</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Blobs</source>
          <target state="new">Blobs</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Copying Blobs</source>
          <target state="new">Copying Blobs</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Are you copying blobs in an efficient manner?</source>
          <target state="new">Are you copying blobs in an efficient manner?</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Blobs</source>
          <target state="new">Blobs</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Copying Blobs</source>
          <target state="new">Copying Blobs</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Are you using AzCopy for bulk copies of blobs?</source>
          <target state="new">Are you using AzCopy for bulk copies of blobs?</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Blobs</source>
          <target state="new">Blobs</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Copying Blobs</source>
          <target state="new">Copying Blobs</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Are you using Azure Import/Export to transfer very large volumes of data?</source>
          <target state="new">Are you using Azure Import/Export to transfer very large volumes of data?</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Blobs</source>
          <target state="new">Blobs</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Use Metadata</source>
          <target state="new">Use Metadata</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Are you storing frequently used metadata about blobs in their metadata?</source>
          <target state="new">Are you storing frequently used metadata about blobs in their metadata?</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Blobs</source>
          <target state="new">Blobs</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Uploading Fast</source>
          <target state="new">Uploading Fast</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>When trying to upload one blob quickly, are you uploading blocks in parallel?</source>
          <target state="new">When trying to upload one blob quickly, are you uploading blocks in parallel?</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Blobs</source>
          <target state="new">Blobs</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Uploading Fast</source>
          <target state="new">Uploading Fast</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>When trying to upload many blobs quickly, are you uploading blobs in parallel?</source>
          <target state="new">When trying to upload many blobs quickly, are you uploading blobs in parallel?</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Blobs</source>
          <target state="new">Blobs</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Correct Blob Type</source>
          <target state="new">Correct Blob Type</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Are you using page blobs or block blobs when appropriate?</source>
          <target state="new">Are you using page blobs or block blobs when appropriate?</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Tables</source>
          <target state="new">Tables</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Scalability Targets</source>
          <target state="new">Scalability Targets</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Are you approaching the scalability targets for entities per second?</source>
          <target state="new">Are you approaching the scalability targets for entities per second?</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Tables</source>
          <target state="new">Tables</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Configuration</source>
          <target state="new">Configuration</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Are you using JSON for your table requests?</source>
          <target state="new">Are you using JSON for your table requests?</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Tables</source>
          <target state="new">Tables</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Configuration</source>
          <target state="new">Configuration</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Have you turned Nagle off to improve the performance of small requests?</source>
          <target state="new">Have you turned Nagle off to improve the performance of small requests?</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Tables</source>
          <target state="new">Tables</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Tables and Partitions</source>
          <target state="new">Tables and Partitions</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Have you properly partitioned your data?</source>
          <target state="new">Have you properly partitioned your data?</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Tables</source>
          <target state="new">Tables</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Hot Partitions</source>
          <target state="new">Hot Partitions</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Are you avoiding append-only and prepend-only patterns?</source>
          <target state="new">Are you avoiding append-only and prepend-only patterns?</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Tables</source>
          <target state="new">Tables</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Hot Partitions</source>
          <target state="new">Hot Partitions</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Are your inserts/updates spread across many partitions?</source>
          <target state="new">Are your inserts/updates spread across many partitions?</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Tables</source>
          <target state="new">Tables</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Query Scope</source>
          <target state="new">Query Scope</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Have you designed your schema to allow for point queries to be used in most cases, and table queries to be used sparingly?</source>
          <target state="new">Have you designed your schema to allow for point queries to be used in most cases, and table queries to be used sparingly?</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Tables</source>
          <target state="new">Tables</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Query Density</source>
          <target state="new">Query Density</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Do your queries typically only scan and return rows that your application will use?</source>
          <target state="new">Do your queries typically only scan and return rows that your application will use?</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Tables</source>
          <target state="new">Tables</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Limiting Returned Data</source>
          <target state="new">Limiting Returned Data</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Are you using filtering to avoid returning entities that are not needed?</source>
          <target state="new">Are you using filtering to avoid returning entities that are not needed?</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Tables</source>
          <target state="new">Tables</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Limiting Returned Data</source>
          <target state="new">Limiting Returned Data</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Are you using projection to avoid returning properties that are not needed?</source>
          <target state="new">Are you using projection to avoid returning properties that are not needed?</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Tables</source>
          <target state="new">Tables</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Denormalization</source>
          <target state="new">Denormalization</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Have you denormalized your data such that you avoid inefficient queries or multiple read requests when trying to get data?</source>
          <target state="new">Have you denormalized your data such that you avoid inefficient queries or multiple read requests when trying to get data?</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Tables</source>
          <target state="new">Tables</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Insert/Update/Delete</source>
          <target state="new">Insert/Update/Delete</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Are you batching requests that need to be transactional or can be done at the same time to reduce round-trips?</source>
          <target state="new">Are you batching requests that need to be transactional or can be done at the same time to reduce round-trips?</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Tables</source>
          <target state="new">Tables</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Insert/Update/Delete</source>
          <target state="new">Insert/Update/Delete</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Are you avoiding retrieving an entity just to determine whether to call insert or update?</source>
          <target state="new">Are you avoiding retrieving an entity just to determine whether to call insert or update?</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Tables</source>
          <target state="new">Tables</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Insert/Update/Delete</source>
          <target state="new">Insert/Update/Delete</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Have you considered storing series of data that will frequently be retrieved together in a single entity as properties instead of multiple entities?</source>
          <target state="new">Have you considered storing series of data that will frequently be retrieved together in a single entity as properties instead of multiple entities?</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Tables</source>
          <target state="new">Tables</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Insert/Update/Delete</source>
          <target state="new">Insert/Update/Delete</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>For entities that will always be retrieved together and can be written in batches (e.g. time series data), have you considered using blobs instead of tables?</source>
          <target state="new">For entities that will always be retrieved together and can be written in batches (e.g. time series data), have you considered using blobs instead of tables?</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Queues</source>
          <target state="new">Queues</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Scalability Targets</source>
          <target state="new">Scalability Targets</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Are you approaching the scalability targets for messages per second?</source>
          <target state="new">Are you approaching the scalability targets for messages per second?</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Queues</source>
          <target state="new">Queues</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Configuration</source>
          <target state="new">Configuration</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Have you turned Nagle off to improve the performance of small requests?</source>
          <target state="new">Have you turned Nagle off to improve the performance of small requests?</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Queues</source>
          <target state="new">Queues</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Message Size</source>
          <target state="new">Message Size</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Are your messages compact to improve the performance of the queue?</source>
          <target state="new">Are your messages compact to improve the performance of the queue?</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Queues</source>
          <target state="new">Queues</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Bulk Retrieve</source>
          <target state="new">Bulk Retrieve</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Are you retrieving multiple messages in a single "Get" operation?</source>
          <target state="new">Are you retrieving multiple messages in a single "Get" operation?</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Queues</source>
          <target state="new">Queues</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Polling Frequency</source>
          <target state="new">Polling Frequency</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Are you polling frequently enough to reduce the perceived latency of your application?</source>
          <target state="new">Are you polling frequently enough to reduce the perceived latency of your application?</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Queues</source>
          <target state="new">Queues</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Update Message</source>
          <target state="new">Update Message</target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Are you using UpdateMessage to store progress in processing messages, avoiding having to reprocess the entire message if an error occurs?</source>
          <target state="new">Are you using UpdateMessage to store progress in processing messages, avoiding having to reprocess the entire message if an error occurs?</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Queues</source>
          <target state="new">Queues</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Architecture</source>
          <target state="new">Architecture</target>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Are you using queues to make your entire application more scalable by keeping long-running workloads out of the critical path and scale then independently?</source>
          <target state="new">Are you using queues to make your entire application more scalable by keeping long-running workloads out of the critical path and scale then independently?</target>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="allservices"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>All Services</source>
          <target state="new"><ph id="ph1">&lt;a name="allservices"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>All Services</target>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>This section lists proven practices that are applicable to the use of any of the Azure Storage services (blobs, tables, queues, or files).</source>
          <target state="new">This section lists proven practices that are applicable to the use of any of the Azure Storage services (blobs, tables, queues, or files).</target>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading1"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Scalability Targets</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading1"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Scalability Targets</target>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Each of the Azure Storage services has scalability targets for capacity (GB), transaction rate, and bandwidth.</source>
          <target state="new">Each of the Azure Storage services has scalability targets for capacity (GB), transaction rate, and bandwidth.</target>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>If your application approaches or exceeds any of the scalability targets, it may encounter increased transaction latencies or throttling.</source>
          <target state="new">If your application approaches or exceeds any of the scalability targets, it may encounter increased transaction latencies or throttling.</target>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>When a Storage service throttles your application, the service begins to return “503 Server busy” or “500 Operation timeout” error codes for some storage transactions.</source>
          <target state="new">When a Storage service throttles your application, the service begins to return “503 Server busy” or “500 Operation timeout” error codes for some storage transactions.</target>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>This section discusses both the general approach to dealing with scalability targets and bandwidth scalability targets in particular.</source>
          <target state="new">This section discusses both the general approach to dealing with scalability targets and bandwidth scalability targets in particular.</target>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Later sections that deal with individual storage services discuss scalability targets in the context of that specific service:</source>
          <target state="new">Later sections that deal with individual storage services discuss scalability targets in the context of that specific service:</target>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Blob bandwidth and requests per second</source>
          <target state="new">Blob bandwidth and requests per second</target>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Table entities per second</source>
          <target state="new">Table entities per second</target>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Queue messages per second</source>
          <target state="new">Queue messages per second</target>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="sub1bandwidth"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Bandwidth Scalability Target for All Services</source>
          <target state="new"><ph id="ph1">&lt;a name="sub1bandwidth"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Bandwidth Scalability Target for All Services</target>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>At the time of writing, the bandwidth targets in the US for a geo-redundant storage (GRS) account are 10 gigabits per second (Gbps) for ingress (data sent to the storage account) and 20 Gbps for egress (data sent from the storage account).</source>
          <target state="new">At the time of writing, the bandwidth targets in the US for a geo-redundant storage (GRS) account are 10 gigabits per second (Gbps) for ingress (data sent to the storage account) and 20 Gbps for egress (data sent from the storage account).</target>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>For a locally redundant storage (LRS) account, the limits are higher – 20 Gbps for ingress and 30 Gbps for egress.</source>
          <target state="new">For a locally redundant storage (LRS) account, the limits are higher – 20 Gbps for ingress and 30 Gbps for egress.</target>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>International bandwidth limits may be lower and can be found on our <bpt id="p1">[</bpt>scalability targets page<ept id="p1">](http://msdn.microsoft.com/library/azure/dn249410.aspx)</ept>.</source>
          <target state="new">International bandwidth limits may be lower and can be found on our <bpt id="p1">[</bpt>scalability targets page<ept id="p1">](http://msdn.microsoft.com/library/azure/dn249410.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>For more information on the storage redundancy options, see the links in <bpt id="p1">[</bpt>Useful Resources<ept id="p1">](#sub1useful)</ept> below.</source>
          <target state="new">For more information on the storage redundancy options, see the links in <bpt id="p1">[</bpt>Useful Resources<ept id="p1">](#sub1useful)</ept> below.</target>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>What to do when approaching a scalability target</source>
          <target state="new">What to do when approaching a scalability target</target>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>If your application is approaching the scalability targets for a single storage account, consider adopting one of the following approaches:</source>
          <target state="new">If your application is approaching the scalability targets for a single storage account, consider adopting one of the following approaches:</target>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Reconsider the workload that causes your application to approach or exceed the scalability target.</source>
          <target state="new">Reconsider the workload that causes your application to approach or exceed the scalability target.</target>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Can you design it differently to use less bandwidth or capacity, or fewer transactions?</source>
          <target state="new">Can you design it differently to use less bandwidth or capacity, or fewer transactions?</target>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>If an application must exceed one of the scalability targets, you should create multiple storage accounts and partition your application data across those multiple storage accounts.</source>
          <target state="new">If an application must exceed one of the scalability targets, you should create multiple storage accounts and partition your application data across those multiple storage accounts.</target>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>If you use this pattern, then be sure to design your application so that you can add more storage accounts in the future for load balancing.</source>
          <target state="new">If you use this pattern, then be sure to design your application so that you can add more storage accounts in the future for load balancing.</target>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>At time of writing, each Azure subscription can have up to 100 storage accounts.</source>
          <target state="new">At time of writing, each Azure subscription can have up to 100 storage accounts.</target>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Storage accounts also have no cost other than your usage in terms of data stored, transactions made, or data transferred.</source>
          <target state="new">Storage accounts also have no cost other than your usage in terms of data stored, transactions made, or data transferred.</target>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>If your application hits the bandwidth targets, consider compressing data in the client to reduce the bandwidth required to send the data to the storage service.</source>
          <target state="new">If your application hits the bandwidth targets, consider compressing data in the client to reduce the bandwidth required to send the data to the storage service.</target>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Note that while this may save bandwidth and improve network performance, it can also have some negative impacts.</source>
          <target state="new">Note that while this may save bandwidth and improve network performance, it can also have some negative impacts.</target>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>You should evaluate the performance impact of this due to the additional processing requirements for compressing and decompressing data in the client.</source>
          <target state="new">You should evaluate the performance impact of this due to the additional processing requirements for compressing and decompressing data in the client.</target>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>In addition, storing compressed data can make it more difficult to troubleshoot issues since it could be more difficult to view stored data using standard tools.</source>
          <target state="new">In addition, storing compressed data can make it more difficult to troubleshoot issues since it could be more difficult to view stored data using standard tools.</target>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>If your application hits the scalability targets, then ensure that you are using an exponential backoff for retries (see <bpt id="p1">[</bpt>Retries<ept id="p1">](#subheading14)</ept>).</source>
          <target state="new">If your application hits the scalability targets, then ensure that you are using an exponential backoff for retries (see <bpt id="p1">[</bpt>Retries<ept id="p1">](#subheading14)</ept>).</target>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>It’s better to make sure you never approach the scalability targets (by using one of the above methods), but this will ensure your application won’t just keep retrying rapidly, making the throttling worse.</source>
          <target state="new">It’s better to make sure you never approach the scalability targets (by using one of the above methods), but this will ensure your application won’t just keep retrying rapidly, making the throttling worse.</target>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Useful Resources</source>
          <target state="new">Useful Resources</target>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>The following links provide additional detail on scalability targets:</source>
          <target state="new">The following links provide additional detail on scalability targets:</target>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>You can view the current scalability targets on the page <bpt id="p1">[</bpt>Azure Storage Scalability and Performance Targets on MSDN<ept id="p1">](http://msdn.microsoft.com/library/azure/dn249410.aspx)</ept>.</source>
          <target state="new">You can view the current scalability targets on the page <bpt id="p1">[</bpt>Azure Storage Scalability and Performance Targets on MSDN<ept id="p1">](http://msdn.microsoft.com/library/azure/dn249410.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>You can learn more about storage redundancy options in the blog post <bpt id="p1">[</bpt>Azure Storage Redundancy Options and Read Access Geo Redundant Storage<ept id="p1">](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx)</ept>– see the next section for more details.</source>
          <target state="new">You can learn more about storage redundancy options in the blog post <bpt id="p1">[</bpt>Azure Storage Redundancy Options and Read Access Geo Redundant Storage<ept id="p1">](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx)</ept>– see the next section for more details.</target>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>For current information about pricing for Azure services, see <bpt id="p1">[</bpt>Azure pricing at-a-glance<ept id="p1">](http://azure.microsoft.com/pricing/overview/)</ept>.</source>
          <target state="new">For current information about pricing for Azure services, see <bpt id="p1">[</bpt>Azure pricing at-a-glance<ept id="p1">](http://azure.microsoft.com/pricing/overview/)</ept>.</target>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Networking</source>
          <target state="new">Networking</target>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>While the API calls matter, often the physical network constraints of the application have a significant impact on performance.</source>
          <target state="new">While the API calls matter, often the physical network constraints of the application have a significant impact on performance.</target>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The following describe some of limitations users may encounter.</source>
          <target state="new">The following describe some of limitations users may encounter.</target>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Client Network Capability</source>
          <target state="new">Client Network Capability</target>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading2"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Throughput</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading2"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Throughput</target>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>For bandwidth, the problem is often the capabilities of the client.</source>
          <target state="new">For bandwidth, the problem is often the capabilities of the client.</target>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>For example, while a single storage account can handle 10 Gbps or more of ingress (see <bpt id="p1">[</bpt>bandwidth scalability targets<ept id="p1">](#sub1bandwidth)</ept>), the network speed in a “Small” Azure Worker Role instance is only capable of approximately 100 Mbps.</source>
          <target state="new">For example, while a single storage account can handle 10 Gbps or more of ingress (see <bpt id="p1">[</bpt>bandwidth scalability targets<ept id="p1">](#sub1bandwidth)</ept>), the network speed in a “Small” Azure Worker Role instance is only capable of approximately 100 Mbps.</target>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Larger Azure instances have NICs with greater capacity, so you should consider using a larger instance or more VM’s if you need higher network limits from a single machine.</source>
          <target state="new">Larger Azure instances have NICs with greater capacity, so you should consider using a larger instance or more VM’s if you need higher network limits from a single machine.</target>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>If you are accessing a Storage service from an on premises application, then the same rule applies: understand the network capabilities of the client device and the network connectivity to the Azure Storage location and either improve them as needed or design your application to work within their capabilities.</source>
          <target state="new">If you are accessing a Storage service from an on premises application, then the same rule applies: understand the network capabilities of the client device and the network connectivity to the Azure Storage location and either improve them as needed or design your application to work within their capabilities.</target>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading3"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Link Quality</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading3"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Link Quality</target>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>As with any network usage, be aware that network conditions resulting in errors and packet loss will slow effective throughput.</source>
          <target state="new">As with any network usage, be aware that network conditions resulting in errors and packet loss will slow effective throughput.</target>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Using WireShark or NetMon may help in diagnosing this issue.</source>
          <target state="new">Using WireShark or NetMon may help in diagnosing this issue.</target>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Useful Resources</source>
          <target state="new">Useful Resources</target>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>For more information about virtual machine sizes and allocated bandwidth, see <bpt id="p1">[</bpt>Best Practices for the Design of Large-Scale Services on Azure Cloud Services<ept id="p1">](http://msdn.microsoft.com/library/azure/dn197896.aspx)</ept> on MSDN.</source>
          <target state="new">For more information about virtual machine sizes and allocated bandwidth, see <bpt id="p1">[</bpt>Best Practices for the Design of Large-Scale Services on Azure Cloud Services<ept id="p1">](http://msdn.microsoft.com/library/azure/dn197896.aspx)</ept> on MSDN.</target>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading4"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Location</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading4"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Location</target>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>In any distributed environment, placing the client near to the server delivers in the best performance.</source>
          <target state="new">In any distributed environment, placing the client near to the server delivers in the best performance.</target>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>For accessing Azure Storage with the lowest latency, the best location for your client is within the same Azure region.</source>
          <target state="new">For accessing Azure Storage with the lowest latency, the best location for your client is within the same Azure region.</target>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>For example, if you have an Azure Web Site that uses Azure Storage, you should locate them both within a single region (for example, US West or Asia Southeast).</source>
          <target state="new">For example, if you have an Azure Web Site that uses Azure Storage, you should locate them both within a single region (for example, US West or Asia Southeast).</target>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>This reduces the latency and the cost — at the time of writing, bandwidth usage within a single region is free.</source>
          <target state="new">This reduces the latency and the cost — at the time of writing, bandwidth usage within a single region is free.</target>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>If your client applications are not hosted within Azure (such as mobile device apps or on premises enterprise services), then again placing the storage account in a region near to the devices that will access it, will generally reduce latency.</source>
          <target state="new">If your client applications are not hosted within Azure (such as mobile device apps or on premises enterprise services), then again placing the storage account in a region near to the devices that will access it, will generally reduce latency.</target>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>If your clients are broadly distributed (for example, some in North America, and some in Europe), then you should consider using multiple storage accounts: one located in a North American region and one in a European region.</source>
          <target state="new">If your clients are broadly distributed (for example, some in North America, and some in Europe), then you should consider using multiple storage accounts: one located in a North American region and one in a European region.</target>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>This will help to reduce latency for users in both regions.</source>
          <target state="new">This will help to reduce latency for users in both regions.</target>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>This approach is usually easier to implement if the data the application stores is specific to individual users, and does not require replicating data between storage accounts.</source>
          <target state="new">This approach is usually easier to implement if the data the application stores is specific to individual users, and does not require replicating data between storage accounts.</target>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>For broad content distribution, a CDN is recommended – see the next section for more details.</source>
          <target state="new">For broad content distribution, a CDN is recommended – see the next section for more details.</target>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading5"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Content Distribution</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading5"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Content Distribution</target>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Sometimes, an application needs to serve the same content to many users (e.g. a product demo video used in the home page of a website), located in either the same or multiple regions.</source>
          <target state="new">Sometimes, an application needs to serve the same content to many users (e.g. a product demo video used in the home page of a website), located in either the same or multiple regions.</target>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>In this scenario, you should use a Content Delivery Network (CDN) such as Azure CDN, and the CDN would use Azure storage as the origin of the data.</source>
          <target state="new">In this scenario, you should use a Content Delivery Network (CDN) such as Azure CDN, and the CDN would use Azure storage as the origin of the data.</target>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Unlike an Azure Storage account that exists in a single region and that cannot deliver content with low latency to other regions, Azure CDN uses servers in multiple data centers around the world.</source>
          <target state="new">Unlike an Azure Storage account that exists in a single region and that cannot deliver content with low latency to other regions, Azure CDN uses servers in multiple data centers around the world.</target>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Additionally, a CDN can typically supports much higher egress limits than a single storage account.</source>
          <target state="new">Additionally, a CDN can typically supports much higher egress limits than a single storage account.</target>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>For more information about Azure CDN, see <bpt id="p1">[</bpt>Azure CDN<ept id="p1">](http://azure.microsoft.com/services/cdn/)</ept>.</source>
          <target state="new">For more information about Azure CDN, see <bpt id="p1">[</bpt>Azure CDN<ept id="p1">](http://azure.microsoft.com/services/cdn/)</ept>.</target>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading6"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Using SAS and CORS</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading6"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Using SAS and CORS</target>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>When you need to authorize code such as JavaScript in a user’s web browser or a mobile phone app to access data in Azure Storage, one approach is to use an application in web role as a proxy: the user’s device authenticates with the web role, which in turn authenticates with the storage service.</source>
          <target state="new">When you need to authorize code such as JavaScript in a user’s web browser or a mobile phone app to access data in Azure Storage, one approach is to use an application in web role as a proxy: the user’s device authenticates with the web role, which in turn authenticates with the storage service.</target>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>In this way, you can avoid exposing your storage account keys on insecure devices.</source>
          <target state="new">In this way, you can avoid exposing your storage account keys on insecure devices.</target>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>However, this places a big overhead on the web role because all the data transferred between the user’s device and the storage service must pass through the web role.</source>
          <target state="new">However, this places a big overhead on the web role because all the data transferred between the user’s device and the storage service must pass through the web role.</target>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>You can avoid using a web role as a proxy for the storage service by using Shared Access Signatures (SAS), sometimes in conjunction with Cross-Origin Resource Sharing headers (CORS).</source>
          <target state="new">You can avoid using a web role as a proxy for the storage service by using Shared Access Signatures (SAS), sometimes in conjunction with Cross-Origin Resource Sharing headers (CORS).</target>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Using SAS, you can allow your user’s device to make requests directly to a storage service by means of a limited access token.</source>
          <target state="new">Using SAS, you can allow your user’s device to make requests directly to a storage service by means of a limited access token.</target>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>For example, if a user wants to upload a photo to your application, your web role can generate and send to the user’s device a SAS token that grants permission to write to a specific blob or container for the next 30 minutes (after which the SAS token expires).</source>
          <target state="new">For example, if a user wants to upload a photo to your application, your web role can generate and send to the user’s device a SAS token that grants permission to write to a specific blob or container for the next 30 minutes (after which the SAS token expires).</target>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Normally, a browser will not allow JavaScript in a page hosted by a website on one domain to perform specific operations such as a “PUT” to another domain.</source>
          <target state="new">Normally, a browser will not allow JavaScript in a page hosted by a website on one domain to perform specific operations such as a “PUT” to another domain.</target>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>For example, if you host a web role at “contosomarketing.cloudapp.net,” and want to use client side JavaScript to upload a blob to your storage account at “contosoproducts.blob.core.windows.net,” the browser’s “same origin policy” will forbid this operation.</source>
          <target state="new">For example, if you host a web role at “contosomarketing.cloudapp.net,” and want to use client side JavaScript to upload a blob to your storage account at “contosoproducts.blob.core.windows.net,” the browser’s “same origin policy” will forbid this operation.</target>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>CORS is a browser feature that allows the target domain (in this case the storage account) to communicate to the browser that it trusts requests originating in the source domain (in this case the web role).</source>
          <target state="new">CORS is a browser feature that allows the target domain (in this case the storage account) to communicate to the browser that it trusts requests originating in the source domain (in this case the web role).</target>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>Both of these technologies can help you avoid unnecessary load (and bottlenecks) on your web application.</source>
          <target state="new">Both of these technologies can help you avoid unnecessary load (and bottlenecks) on your web application.</target>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Useful Resources</source>
          <target state="new">Useful Resources</target>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>For more information about SAS, see <bpt id="p1">[</bpt>Shared Access Signatures, Part 1: Understanding the SAS Model<ept id="p1">](../storage-dotnet-shared-access-signature-part-1/)</ept>.</source>
          <target state="new">For more information about SAS, see <bpt id="p1">[</bpt>Shared Access Signatures, Part 1: Understanding the SAS Model<ept id="p1">](../storage-dotnet-shared-access-signature-part-1/)</ept>.</target>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>For more information about CORS, see <bpt id="p1">[</bpt>Cross-Origin Resource Sharing (CORS) Support for the Azure Storage Services on MSDN<ept id="p1">](http://msdn.microsoft.com/library/azure/dn535601.aspx)</ept>.</source>
          <target state="new">For more information about CORS, see <bpt id="p1">[</bpt>Cross-Origin Resource Sharing (CORS) Support for the Azure Storage Services on MSDN<ept id="p1">](http://msdn.microsoft.com/library/azure/dn535601.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Caching</source>
          <target state="new">Caching</target>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading7"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Getting Data</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading7"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Getting Data</target>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>In general, getting data from a service once is better than getting it twice.</source>
          <target state="new">In general, getting data from a service once is better than getting it twice.</target>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>Consider the example of an MVC web application running in a web role that has already retrieved a 50MB blob from the storage service to serve as content to a user.</source>
          <target state="new">Consider the example of an MVC web application running in a web role that has already retrieved a 50MB blob from the storage service to serve as content to a user.</target>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>The application could then retrieve that same blob every time a user requests it, or it could cache it locally to disk and reuse the cached version for subsequent user requests.</source>
          <target state="new">The application could then retrieve that same blob every time a user requests it, or it could cache it locally to disk and reuse the cached version for subsequent user requests.</target>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Furthermore, whenever a user requests the data, the application could issue GET with a conditional header for modification time, which would avoid getting the entire blob if it hasn’t been modified.</source>
          <target state="new">Furthermore, whenever a user requests the data, the application could issue GET with a conditional header for modification time, which would avoid getting the entire blob if it hasn’t been modified.</target>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>You can apply this same pattern to working with table entities.</source>
          <target state="new">You can apply this same pattern to working with table entities.</target>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>In some cases, you may decide that your application can assume that the blob remains valid for a short period after retrieving it, and that during this period the application does not need to check if the blob was modified.</source>
          <target state="new">In some cases, you may decide that your application can assume that the blob remains valid for a short period after retrieving it, and that during this period the application does not need to check if the blob was modified.</target>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Configuration, lookup, and other data that are always used by the application are great candidates for caching.</source>
          <target state="new">Configuration, lookup, and other data that are always used by the application are great candidates for caching.</target>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>For an example of how to get a blob’s properties to discover the last modified date using .NET, see <bpt id="p1">[</bpt>Set and Retrieve Properties and Metadata<ept id="p1">](http://msdn.microsoft.com/library/azure/hh225342.aspx)</ept> on MSDN.</source>
          <target state="new">For an example of how to get a blob’s properties to discover the last modified date using .NET, see <bpt id="p1">[</bpt>Set and Retrieve Properties and Metadata<ept id="p1">](http://msdn.microsoft.com/library/azure/hh225342.aspx)</ept> on MSDN.</target>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>For more information about conditional downloads, see <bpt id="p1">[</bpt>Conditionally Refresh a Local Copy of a Blob<ept id="p1">](http://msdn.microsoft.com/library/azure/dd179371.aspx)</ept> on MSDN.</source>
          <target state="new">For more information about conditional downloads, see <bpt id="p1">[</bpt>Conditionally Refresh a Local Copy of a Blob<ept id="p1">](http://msdn.microsoft.com/library/azure/dd179371.aspx)</ept> on MSDN.</target>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading8"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Uploading Data in Batches</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading8"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Uploading Data in Batches</target>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>In some application scenarios, you can aggregate data locally, and then periodically upload it in a batch instead of uploading each piece of data immediately.</source>
          <target state="new">In some application scenarios, you can aggregate data locally, and then periodically upload it in a batch instead of uploading each piece of data immediately.</target>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>For example, a web application might keep a log file of activities: the application could either upload details of every activity as it happens as a table entity (which requires many storage operations), or it could save activity details to a local log file, and then periodically upload all activity details as a delimited file to a blob.</source>
          <target state="new">For example, a web application might keep a log file of activities: the application could either upload details of every activity as it happens as a table entity (which requires many storage operations), or it could save activity details to a local log file, and then periodically upload all activity details as a delimited file to a blob.</target>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>If each log entry is 1KB in size, you can upload thousands in a single “Put Blob” transaction (you can upload a blob of up to 64MB in size in a single transaction).</source>
          <target state="new">If each log entry is 1KB in size, you can upload thousands in a single “Put Blob” transaction (you can upload a blob of up to 64MB in size in a single transaction).</target>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Of course, if the local machine crashes prior to the upload, you will potentially lose some log data: the application developer must design for the possibility of client device or upload failures.</source>
          <target state="new">Of course, if the local machine crashes prior to the upload, you will potentially lose some log data: the application developer must design for the possibility of client device or upload failures.</target>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>If the activity data needs to be downloaded for timespans (not just single activity), then blobs are recommended over tables.</source>
          <target state="new">If the activity data needs to be downloaded for timespans (not just single activity), then blobs are recommended over tables.</target>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>.NET Configuration</source>
          <target state="new">.NET Configuration</target>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>If using the .NET Framework, this section lists several quick configuration settings that you can use to make significant performance improvements.</source>
          <target state="new">If using the .NET Framework, this section lists several quick configuration settings that you can use to make significant performance improvements.</target>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>If using other languages, check to see if similar concepts apply in your chosen language.</source>
          <target state="new">If using other languages, check to see if similar concepts apply in your chosen language.</target>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading9"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Increase default connection limit</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading9"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Increase default connection limit</target>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>In .NET, the following code increases the default connection limit (which is usually 2 in a client environment or 10 in a server environment) to 100.</source>
          <target state="new">In .NET, the following code increases the default connection limit (which is usually 2 in a client environment or 10 in a server environment) to 100.</target>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>Typically, you should set the value to approximately the number of threads used by your application.</source>
          <target state="new">Typically, you should set the value to approximately the number of threads used by your application.</target>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>You must set the connection limit before opening any connections.</source>
          <target state="new">You must set the connection limit before opening any connections.</target>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>For other programming languages, see that language’s documentation to determine how to set the connection limit.</source>
          <target state="new">For other programming languages, see that language’s documentation to determine how to set the connection limit.</target>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>For additional information, see the post <bpt id="p1">[</bpt>Web Services: Concurrent Connections<ept id="p1">](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx)</ept> on MSDN.</source>
          <target state="new">For additional information, see the post <bpt id="p1">[</bpt>Web Services: Concurrent Connections<ept id="p1">](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx)</ept> on MSDN.</target>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading10"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Increase ThreadPool Min Threads if using synchronous code with Async Tasks</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading10"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Increase ThreadPool Min Threads if using synchronous code with Async Tasks</target>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>This code will increase the thread pool min threads:</source>
          <target state="new">This code will increase the thread pool min threads:</target>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>ThreadPool.SetMinThreads Method<ept id="p1">](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads(v=vs.110).aspx)</ept> on MSDN.</source>
          <target state="new">For more information, see <bpt id="p1">[</bpt>ThreadPool.SetMinThreads Method<ept id="p1">](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads(v=vs.110).aspx)</ept> on MSDN.</target>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading11"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Take advantage of .NET 4.5 Garbage Collection</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading11"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Take advantage of .NET 4.5 Garbage Collection</target>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>Use .NET 4.5 or later for the client application to take advantage of performance improvements in server garbage collection.</source>
          <target state="new">Use .NET 4.5 or later for the client application to take advantage of performance improvements in server garbage collection.</target>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>For more information, see the article <bpt id="p1">[</bpt>An Overview of Performance Improvements in .NET 4.5<ept id="p1">](http://msdn.microsoft.com/magazine/hh882452.aspx)</ept> on MSDN.</source>
          <target state="new">For more information, see the article <bpt id="p1">[</bpt>An Overview of Performance Improvements in .NET 4.5<ept id="p1">](http://msdn.microsoft.com/magazine/hh882452.aspx)</ept> on MSDN.</target>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading12"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Unbounded Parallelism</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading12"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Unbounded Parallelism</target>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>While parallelism can be great for performance, be careful about using unbounded parallelism (no limit on the number of threads and/or parallel requests) to upload or download data, using multiple workers to access multiple partitions (containers, queues, or table partitions) in the same storage account or to access multiple items in the same partition.</source>
          <target state="new">While parallelism can be great for performance, be careful about using unbounded parallelism (no limit on the number of threads and/or parallel requests) to upload or download data, using multiple workers to access multiple partitions (containers, queues, or table partitions) in the same storage account or to access multiple items in the same partition.</target>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>If the parallelism is unbounded, your application can exceed the client device’s capabilities or the storage account’s scalability targets resulting in longer latencies and throttling.</source>
          <target state="new">If the parallelism is unbounded, your application can exceed the client device’s capabilities or the storage account’s scalability targets resulting in longer latencies and throttling.</target>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading13"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Storage Client Libraries and Tools</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading13"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Storage Client Libraries and Tools</target>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>Always use the latest Microsoft provided client libraries and tools.</source>
          <target state="new">Always use the latest Microsoft provided client libraries and tools.</target>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>At the time of writing, there are RTM libraries available for .NET, Windows Phone, Windows Runtime, and Java, as well as preview libraries in other languages like node.js and C++.</source>
          <target state="new">At the time of writing, there are RTM libraries available for .NET, Windows Phone, Windows Runtime, and Java, as well as preview libraries in other languages like node.js and C++.</target>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>In addition, Microsoft has released PowerShell cmdlets and Azure CLI commands for working with Azure Storage.</source>
          <target state="new">In addition, Microsoft has released PowerShell cmdlets and Azure CLI commands for working with Azure Storage.</target>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Microsoft actively develops these tools with performance in mind, keeps them up to date with the latest service versions, and ensures they handle many of the proven performance practices internally.</source>
          <target state="new">Microsoft actively develops these tools with performance in mind, keeps them up to date with the latest service versions, and ensures they handle many of the proven performance practices internally.</target>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Retries</source>
          <target state="new">Retries</target>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading14"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Throttling/ServerBusy</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading14"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Throttling/ServerBusy</target>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>In some cases, the storage service may throttle your application or may simply be unable to serve the request due to some transient condition and return a “503 Server busy” message or “500 Timeout”.</source>
          <target state="new">In some cases, the storage service may throttle your application or may simply be unable to serve the request due to some transient condition and return a “503 Server busy” message or “500 Timeout”.</target>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>This can happen if your application is approaching any of the scalability targets, or if the system is rebalancing your partitioned data to allow for higher throughput.</source>
          <target state="new">This can happen if your application is approaching any of the scalability targets, or if the system is rebalancing your partitioned data to allow for higher throughput.</target>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>The client application should typically retry the operation that causes such an error: attempting the same request later can succeed.</source>
          <target state="new">The client application should typically retry the operation that causes such an error: attempting the same request later can succeed.</target>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>However, if the storage service is throttling your application because it is exceeding scalability targets, or even if the service was unable to serve the request for some other reason, aggressive retries usually make the problem worse.</source>
          <target state="new">However, if the storage service is throttling your application because it is exceeding scalability targets, or even if the service was unable to serve the request for some other reason, aggressive retries usually make the problem worse.</target>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>For this reason, you should use an exponential back off (the client libraries default to this behavior).</source>
          <target state="new">For this reason, you should use an exponential back off (the client libraries default to this behavior).</target>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>For example, your application may retry after 2 seconds, then 4 seconds, then 10 seconds, then 30 seconds, and then give up completely.</source>
          <target state="new">For example, your application may retry after 2 seconds, then 4 seconds, then 10 seconds, then 30 seconds, and then give up completely.</target>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>This behavior results in your application significantly reducing its load on the service rather than exacerbating any problems.</source>
          <target state="new">This behavior results in your application significantly reducing its load on the service rather than exacerbating any problems.</target>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Note that connectivity errors can be retried immediately, because they are not the result of throttling and are expected to be transient.</source>
          <target state="new">Note that connectivity errors can be retried immediately, because they are not the result of throttling and are expected to be transient.</target>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading15"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Non-Retryable Errors</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading15"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Non-Retryable Errors</target>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>The client libraries are aware of which errors are retry-able and which are not.</source>
          <target state="new">The client libraries are aware of which errors are retry-able and which are not.</target>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>However, if you are writing your own code against the storage REST API, remember there are some errors that you should not retry: for example, a 400 (Bad Request) response indicates that the client application sent a request that could not be processed because it was not in an expected form.</source>
          <target state="new">However, if you are writing your own code against the storage REST API, remember there are some errors that you should not retry: for example, a 400 (Bad Request) response indicates that the client application sent a request that could not be processed because it was not in an expected form.</target>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>Resending this request will result the same response every time, so there is no point in retrying it.</source>
          <target state="new">Resending this request will result the same response every time, so there is no point in retrying it.</target>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>If you are writing your own code against the storage REST API, be aware of what the error codes mean and the proper way to retry (or not) for each of them.</source>
          <target state="new">If you are writing your own code against the storage REST API, be aware of what the error codes mean and the proper way to retry (or not) for each of them.</target>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>Useful Resources</source>
          <target state="new">Useful Resources</target>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>For more information about storage error codes, see <bpt id="p1">[</bpt>Status and Error Codes<ept id="p1">](http://msdn.microsoft.com/library/azure/dd179382.aspx)</ept> on the Microsoft Azure web site.</source>
          <target state="new">For more information about storage error codes, see <bpt id="p1">[</bpt>Status and Error Codes<ept id="p1">](http://msdn.microsoft.com/library/azure/dd179382.aspx)</ept> on the Microsoft Azure web site.</target>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>Blobs</source>
          <target state="new">Blobs</target>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>In addition to the proven practices for <bpt id="p1">[</bpt>All Services<ept id="p1">](#allservices)</ept> described previously, the following proven practices apply specifically to the blob service.</source>
          <target state="new">In addition to the proven practices for <bpt id="p1">[</bpt>All Services<ept id="p1">](#allservices)</ept> described previously, the following proven practices apply specifically to the blob service.</target>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Blob-Specific Scalability Targets</source>
          <target state="new">Blob-Specific Scalability Targets</target>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading16"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Bandwidth and operations per Blob</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading16"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Bandwidth and operations per Blob</target>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>You can read or write to a single blob at up to a maximum of 60 MB/second (this is approximately 480 Mbps which exceeds the capabilities of many client side networks (including the physical NIC on the client device).</source>
          <target state="new">You can read or write to a single blob at up to a maximum of 60 MB/second (this is approximately 480 Mbps which exceeds the capabilities of many client side networks (including the physical NIC on the client device).</target>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>In addition, a single blob supports up to 500 requests per second.</source>
          <target state="new">In addition, a single blob supports up to 500 requests per second.</target>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>If you have multiple clients that need to read the same blob and you might exceed these limits, you should consider using a CDN for distributing the blob.</source>
          <target state="new">If you have multiple clients that need to read the same blob and you might exceed these limits, you should consider using a CDN for distributing the blob.</target>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>For more information about target throughput for blobs, see <bpt id="p1">[</bpt>Azure Storage Scalability and Performance Targets<ept id="p1">](http://msdn.microsoft.com/library/azure/dn249410.aspx)</ept> on MSDN.</source>
          <target state="new">For more information about target throughput for blobs, see <bpt id="p1">[</bpt>Azure Storage Scalability and Performance Targets<ept id="p1">](http://msdn.microsoft.com/library/azure/dn249410.aspx)</ept> on MSDN.</target>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>Copying and Moving Blobs</source>
          <target state="new">Copying and Moving Blobs</target>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading17"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Copy Blob</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading17"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Copy Blob</target>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>The storage REST API version 2012-02-12 introduced the useful ability to copy blobs across accounts: a client application can instruct the storage service to copy a blob from another source (possibly in a different storage account), and then let the service perform the copy asynchronously.</source>
          <target state="new">The storage REST API version 2012-02-12 introduced the useful ability to copy blobs across accounts: a client application can instruct the storage service to copy a blob from another source (possibly in a different storage account), and then let the service perform the copy asynchronously.</target>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>This can significantly reduce the bandwidth needed for the application when you are migrating data from other storage accounts because you do not need to download and upload the data.</source>
          <target state="new">This can significantly reduce the bandwidth needed for the application when you are migrating data from other storage accounts because you do not need to download and upload the data.</target>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>One consideration, however, is that, when copying between storage accounts, there is no time guarantee on when the copy will complete.</source>
          <target state="new">One consideration, however, is that, when copying between storage accounts, there is no time guarantee on when the copy will complete.</target>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>If your application needs to complete a blob copy quickly under your control, it may be better to copy the blob by downloading it to a VM and then uploading it to the destination.</source>
          <target state="new">If your application needs to complete a blob copy quickly under your control, it may be better to copy the blob by downloading it to a VM and then uploading it to the destination.</target>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>For full predictability in that situation, ensure that the copy is performed by a VM running in the same Azure region, or else network conditions may (and probably will) affect your copy performance.</source>
          <target state="new">For full predictability in that situation, ensure that the copy is performed by a VM running in the same Azure region, or else network conditions may (and probably will) affect your copy performance.</target>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>In addition, you can monitor the progress of an asynchronous copy programmatically.</source>
          <target state="new">In addition, you can monitor the progress of an asynchronous copy programmatically.</target>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>Note that copies within the same storage account itself are generally completed quickly.</source>
          <target state="new">Note that copies within the same storage account itself are generally completed quickly.</target>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Copy Blob on MSDN<ept id="p1">](http://msdn.microsoft.com/library/azure/dd894037.aspx)</ept>.</source>
          <target state="new">For more information, see <bpt id="p1">[</bpt>Copy Blob on MSDN<ept id="p1">](http://msdn.microsoft.com/library/azure/dd894037.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading18"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Use AzCopy</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading18"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Use AzCopy</target>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>The Azure Storage team has released a command line tool “AzCopy” that is meant to help with bulk transferring many blobs to, from, and across storage accounts.</source>
          <target state="new">The Azure Storage team has released a command line tool “AzCopy” that is meant to help with bulk transferring many blobs to, from, and across storage accounts.</target>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>This tool is optimized for this scenario, and can achieve high transfer rates.</source>
          <target state="new">This tool is optimized for this scenario, and can achieve high transfer rates.</target>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>Its use is encouraged for bulk upload, download, and copy scenarios.</source>
          <target state="new">Its use is encouraged for bulk upload, download, and copy scenarios.</target>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>You can learn more about it and download it <bpt id="p1">[</bpt>here<ept id="p1">](storage-use-azcopy.md)</ept>.</source>
          <target state="new">You can learn more about it and download it <bpt id="p1">[</bpt>here<ept id="p1">](storage-use-azcopy.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading19"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Azure Import/Export Service</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading19"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Azure Import/Export Service</target>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>For very large volumes of data (more than 1TB), the Azure Storage offers the Import/Export service, which allows for uploading and downloading from blob storage by shipping hard drives.</source>
          <target state="new">For very large volumes of data (more than 1TB), the Azure Storage offers the Import/Export service, which allows for uploading and downloading from blob storage by shipping hard drives.</target>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>You can put your data on a hard drive and send it to Microsoft for upload, or send a blank hard drive to Microsoft to download data.</source>
          <target state="new">You can put your data on a hard drive and send it to Microsoft for upload, or send a blank hard drive to Microsoft to download data.</target>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>You can read more about it <bpt id="p1">[</bpt>here<ept id="p1">](storage-import-export-service.md)</ept>.</source>
          <target state="new">You can read more about it <bpt id="p1">[</bpt>here<ept id="p1">](storage-import-export-service.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>This can be much more efficient than uploading/downloading this volume of data over the network.</source>
          <target state="new">This can be much more efficient than uploading/downloading this volume of data over the network.</target>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading20"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Use metadata</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading20"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Use metadata</target>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>The blob service supports head requests, which can include metadata about the blob.</source>
          <target state="new">The blob service supports head requests, which can include metadata about the blob.</target>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>For example, if your application needed the EXIF data out of a photo, it could retrieve the photo and extract it.</source>
          <target state="new">For example, if your application needed the EXIF data out of a photo, it could retrieve the photo and extract it.</target>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>To save bandwidth and improve performance, your application could store the EXIF data in the blob’s metadata when the application uploaded the photo: you can then retrieve the EXIF data in metadata using only a HEAD request, saving significant bandwidth and the processing time needed to extract the EXIF data each time the blob is read.</source>
          <target state="new">To save bandwidth and improve performance, your application could store the EXIF data in the blob’s metadata when the application uploaded the photo: you can then retrieve the EXIF data in metadata using only a HEAD request, saving significant bandwidth and the processing time needed to extract the EXIF data each time the blob is read.</target>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>This would be useful in scenarios where you only need the metadata, and not the full content of a blob.</source>
          <target state="new">This would be useful in scenarios where you only need the metadata, and not the full content of a blob.</target>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>Note that only 8KB of metadata can be stored per blob (the service will not accept a request to store more than that), so if the data does not fit in that size, you may not be able to use this approach.</source>
          <target state="new">Note that only 8KB of metadata can be stored per blob (the service will not accept a request to store more than that), so if the data does not fit in that size, you may not be able to use this approach.</target>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>For an example of how to get a blob’s metadata using .NET, see <bpt id="p1">[</bpt>Set and Retrieve Properties and Metadata<ept id="p1">](http://msdn.microsoft.com/library/azure/hh225342.aspx)</ept> on MSDN.</source>
          <target state="new">For an example of how to get a blob’s metadata using .NET, see <bpt id="p1">[</bpt>Set and Retrieve Properties and Metadata<ept id="p1">](http://msdn.microsoft.com/library/azure/hh225342.aspx)</ept> on MSDN.</target>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>Uploading Fast</source>
          <target state="new">Uploading Fast</target>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>To upload blobs fast, the first question to answer is: are you uploading one blob or many?</source>
          <target state="new">To upload blobs fast, the first question to answer is: are you uploading one blob or many?</target>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>Use the below guidance to determine the correct method to use depending on your scenario.</source>
          <target state="new">Use the below guidance to determine the correct method to use depending on your scenario.</target>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading21"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Uploading one large blob quickly</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading21"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Uploading one large blob quickly</target>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>To upload a single large blob quickly, your client application should upload its blocks or pages in parallel (being mindful of the scalability targets for individual blobs and the storage account as a whole).</source>
          <target state="new">To upload a single large blob quickly, your client application should upload its blocks or pages in parallel (being mindful of the scalability targets for individual blobs and the storage account as a whole).</target>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Note that the official Microsoft-provided RTM Storage Client libraries (.NET, Java) have the ability to do this.</source>
          <target state="new">Note that the official Microsoft-provided RTM Storage Client libraries (.NET, Java) have the ability to do this.</target>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>For each of the libraries, use the below specified object/property to set the level of concurrency:</source>
          <target state="new">For each of the libraries, use the below specified object/property to set the level of concurrency:</target>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>.NET: Set ParallelOperationThreadCount on a BlobRequestOptions object to be used.</source>
          <target state="new">.NET: Set ParallelOperationThreadCount on a BlobRequestOptions object to be used.</target>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>Java/Android: Use BlobRequestOptions.setConcurrentRequestCount()</source>
          <target state="new">Java/Android: Use BlobRequestOptions.setConcurrentRequestCount()</target>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>Node.js: Use parallelOperationThreadCount on either the request options or on the blob service.</source>
          <target state="new">Node.js: Use parallelOperationThreadCount on either the request options or on the blob service.</target>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>C++: Use the blob_request_options::set_parallelism_factor method.</source>
          <target state="new">C++: Use the blob_request_options::set_parallelism_factor method.</target>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading22"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Uploading many blobs quickly</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading22"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Uploading many blobs quickly</target>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>To upload many blobs quickly, upload blobs in parallel.</source>
          <target state="new">To upload many blobs quickly, upload blobs in parallel.</target>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>This is faster than uploading single blobs at a time with parallel block uploads because it spreads the upload across multiple partitions of the storage service.</source>
          <target state="new">This is faster than uploading single blobs at a time with parallel block uploads because it spreads the upload across multiple partitions of the storage service.</target>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>A single blob only supports a throughput of 60 MB/second (approximately 480 Mbps).</source>
          <target state="new">A single blob only supports a throughput of 60 MB/second (approximately 480 Mbps).</target>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>At the time of writing, a US based LRS account supports up to 20 Gbps ingress which is far more than the throughput supported by an individual blob.</source>
          <target state="new">At the time of writing, a US based LRS account supports up to 20 Gbps ingress which is far more than the throughput supported by an individual blob.</target>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>AzCopy<ept id="p1">](#subheading18)</ept> performs uploads in parallel by default, and is recommended for this scenario.</source>
          <target state="new"><bpt id="p1">[</bpt>AzCopy<ept id="p1">](#subheading18)</ept> performs uploads in parallel by default, and is recommended for this scenario.</target>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading23"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Choosing the correct type of blob</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading23"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Choosing the correct type of blob</target>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>Azure Storage supports two types of blob: <bpt id="p1">*</bpt>page<ept id="p1">*</ept> blobs and <bpt id="p2">*</bpt>block<ept id="p2">*</ept> blobs.</source>
          <target state="new">Azure Storage supports two types of blob: <bpt id="p1">*</bpt>page<ept id="p1">*</ept> blobs and <bpt id="p2">*</bpt>block<ept id="p2">*</ept> blobs.</target>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>For a given usage scenario, your choice of blob type will affect the performance and scalability of your solution.</source>
          <target state="new">For a given usage scenario, your choice of blob type will affect the performance and scalability of your solution.</target>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>Block blobs are appropriate when you want to upload large amounts of data efficiently: for example, a client application may need to upload photos or video to blob storage.</source>
          <target state="new">Block blobs are appropriate when you want to upload large amounts of data efficiently: for example, a client application may need to upload photos or video to blob storage.</target>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>Page blobs are appropriate if the application needs to perform random writes on the data: for example, Azure VHDs are stored as page blobs.</source>
          <target state="new">Page blobs are appropriate if the application needs to perform random writes on the data: for example, Azure VHDs are stored as page blobs.</target>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Understanding Block Blobs and Page Blobs<ept id="p1">](http://msdn.microsoft.com/library/azure/ee691964.aspx)</ept> on MSDN.</source>
          <target state="new">For more information, see <bpt id="p1">[</bpt>Understanding Block Blobs and Page Blobs<ept id="p1">](http://msdn.microsoft.com/library/azure/ee691964.aspx)</ept> on MSDN.</target>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>Tables</source>
          <target state="new">Tables</target>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>In addition to the proven practices for <bpt id="p1">[</bpt>All Services<ept id="p1">](#allservices)</ept> described previously, the following proven practices apply specifically to the table service.</source>
          <target state="new">In addition to the proven practices for <bpt id="p1">[</bpt>All Services<ept id="p1">](#allservices)</ept> described previously, the following proven practices apply specifically to the table service.</target>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading24"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Table-Specific Scalability Targets</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading24"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Table-Specific Scalability Targets</target>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>In addition to the bandwidth limitations of an entire storage account, tables have the following specific scalability limit.</source>
          <target state="new">In addition to the bandwidth limitations of an entire storage account, tables have the following specific scalability limit.</target>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>Note that the system will load balance as your traffic increases, but if your traffic has sudden bursts, you may not be able to get this volume of throughput immediately.</source>
          <target state="new">Note that the system will load balance as your traffic increases, but if your traffic has sudden bursts, you may not be able to get this volume of throughput immediately.</target>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>If your pattern has bursts, you should expect to see throttling and/or timeouts during the burst as the storage service automatically load balances out your table.</source>
          <target state="new">If your pattern has bursts, you should expect to see throttling and/or timeouts during the burst as the storage service automatically load balances out your table.</target>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>Ramping up slowly generally has better results as it gives the system time to load balance appropriately.</source>
          <target state="new">Ramping up slowly generally has better results as it gives the system time to load balance appropriately.</target>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>Entities per Second (Account)</source>
          <target state="new">Entities per Second (Account)</target>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>The scalability limit for accessing tables is up to 20,000 entities (1KB each) per second for an account.</source>
          <target state="new">The scalability limit for accessing tables is up to 20,000 entities (1KB each) per second for an account.</target>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>In general, each entity that is inserted, updated, deleted, or scanned counts toward this target.</source>
          <target state="new">In general, each entity that is inserted, updated, deleted, or scanned counts toward this target.</target>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>So a batch insert that contains 100 entities would count as 100 entities.</source>
          <target state="new">So a batch insert that contains 100 entities would count as 100 entities.</target>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>A query that scans 1000 entities and returns 5 would count as 1000 entities.</source>
          <target state="new">A query that scans 1000 entities and returns 5 would count as 1000 entities.</target>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>Entities per Second (Partition)</source>
          <target state="new">Entities per Second (Partition)</target>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>Within a single partition, the scalability target for accessing tables is 2,000 entities (1KB each) per second, using the same counting as described in the previous section.</source>
          <target state="new">Within a single partition, the scalability target for accessing tables is 2,000 entities (1KB each) per second, using the same counting as described in the previous section.</target>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>Configuration</source>
          <target state="new">Configuration</target>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>This section lists several quick configuration settings that you can use to make significant performance improvements in the table service:</source>
          <target state="new">This section lists several quick configuration settings that you can use to make significant performance improvements in the table service:</target>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading25"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Use JSON</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading25"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Use JSON</target>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>Beginning with storage service version 2013-08-15, the table service supports using JSON instead of the XML-based AtomPub format for transferring table data.</source>
          <target state="new">Beginning with storage service version 2013-08-15, the table service supports using JSON instead of the XML-based AtomPub format for transferring table data.</target>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>This can reduce payload sizes by as much as 75% and can significantly improve the performance of your application.</source>
          <target state="new">This can reduce payload sizes by as much as 75% and can significantly improve the performance of your application.</target>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>For more information, see the post <bpt id="p1">[</bpt>Microsoft Azure Tables: Introducing JSON<ept id="p1">](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx)</ept> and <bpt id="p2">[</bpt>Payload Format for Table Service Operations<ept id="p2">](http://msdn.microsoft.com/library/azure/dn535600.aspx)</ept> on MSDN.</source>
          <target state="new">For more information, see the post <bpt id="p1">[</bpt>Microsoft Azure Tables: Introducing JSON<ept id="p1">](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx)</ept> and <bpt id="p2">[</bpt>Payload Format for Table Service Operations<ept id="p2">](http://msdn.microsoft.com/library/azure/dn535600.aspx)</ept> on MSDN.</target>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading26"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Nagle Off</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading26"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Nagle Off</target>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>Nagle’s algorithm is widely implemented across TCP/IP networks as a means to improve network performance.</source>
          <target state="new">Nagle’s algorithm is widely implemented across TCP/IP networks as a means to improve network performance.</target>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>However, it is not optimal in all circumstances (such as highly interactive environments).</source>
          <target state="new">However, it is not optimal in all circumstances (such as highly interactive environments).</target>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>For Azure Storage, Nagle’s algorithm has a negative impact on the performance of requests to the table and queue services, and you should disable it if possible.</source>
          <target state="new">For Azure Storage, Nagle’s algorithm has a negative impact on the performance of requests to the table and queue services, and you should disable it if possible.</target>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>For more information, see our blog post <bpt id="p1">[</bpt>Nagle’s Algorithm is Not Friendly towards Small Requests<ept id="p1">](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx)</ept>, which explains why Nagle’s algorithm interacts poorly with table and queue requests, and shows how to disable it in your client application.</source>
          <target state="new">For more information, see our blog post <bpt id="p1">[</bpt>Nagle’s Algorithm is Not Friendly towards Small Requests<ept id="p1">](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx)</ept>, which explains why Nagle’s algorithm interacts poorly with table and queue requests, and shows how to disable it in your client application.</target>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>Schema</source>
          <target state="new">Schema</target>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>How you represent and query your data is the biggest single factor that affects the performance of the table service.</source>
          <target state="new">How you represent and query your data is the biggest single factor that affects the performance of the table service.</target>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>While every application is different, this section outlines some general proven practices that relate to:</source>
          <target state="new">While every application is different, this section outlines some general proven practices that relate to:</target>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>Table design</source>
          <target state="new">Table design</target>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>Efficient queries</source>
          <target state="new">Efficient queries</target>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>Efficient data updates</source>
          <target state="new">Efficient data updates</target>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading27"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Tables and partitions</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading27"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Tables and partitions</target>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>Tables are divided into partitions.</source>
          <target state="new">Tables are divided into partitions.</target>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>Every entity stored in a partition shares the same partition key and has a unique row key to identify it within that partition.</source>
          <target state="new">Every entity stored in a partition shares the same partition key and has a unique row key to identify it within that partition.</target>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>Partitions provide benefits but also introduce scalability limits.</source>
          <target state="new">Partitions provide benefits but also introduce scalability limits.</target>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>Benefits: You can update entities in the same partition in a single, atomic, batch transaction that contains up to 100 separate storage operations (limit of 4MB total size).</source>
          <target state="new">Benefits: You can update entities in the same partition in a single, atomic, batch transaction that contains up to 100 separate storage operations (limit of 4MB total size).</target>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>Assuming the same number of entities to be retrieved, you can also query data within a single partition more efficiently than data that spans partitions (though read on for further recommendations on querying table data).</source>
          <target state="new">Assuming the same number of entities to be retrieved, you can also query data within a single partition more efficiently than data that spans partitions (though read on for further recommendations on querying table data).</target>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>Scalability limit: Access to entities stored in a single partition cannot be load-balanced because partitions support atomic batch transactions.</source>
          <target state="new">Scalability limit: Access to entities stored in a single partition cannot be load-balanced because partitions support atomic batch transactions.</target>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>For this reason, the scalability target for an individual table partition is lower than for the table service as a whole.</source>
          <target state="new">For this reason, the scalability target for an individual table partition is lower than for the table service as a whole.</target>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>Because of these characteristics of tables and partitions, you should adopt the following design principles:</source>
          <target state="new">Because of these characteristics of tables and partitions, you should adopt the following design principles:</target>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>Data that your client application frequently updated or queried in the same logical unit of work should be located in the same partition.</source>
          <target state="new">Data that your client application frequently updated or queried in the same logical unit of work should be located in the same partition.</target>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>This may be because your application is aggregating writes, or because you want to take advantage of atomic batch operations.</source>
          <target state="new">This may be because your application is aggregating writes, or because you want to take advantage of atomic batch operations.</target>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>Also, data in a single partition can be more efficiently queried in a single query than data across partitions.</source>
          <target state="new">Also, data in a single partition can be more efficiently queried in a single query than data across partitions.</target>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>Data that your client application does not insert/update or query in the same logical unit of work (single query or batch update) should be located in separate partitions.</source>
          <target state="new">Data that your client application does not insert/update or query in the same logical unit of work (single query or batch update) should be located in separate partitions.</target>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>One important note is that there is no limit to the number of partition keys in a single table, so having millions of partition keys is not a problem and will not impact performance.</source>
          <target state="new">One important note is that there is no limit to the number of partition keys in a single table, so having millions of partition keys is not a problem and will not impact performance.</target>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>For example, if your application is a popular website with user login, using the User Id as the partition key could be a good choice.</source>
          <target state="new">For example, if your application is a popular website with user login, using the User Id as the partition key could be a good choice.</target>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>Hot Partitions</source>
          <target state="new">Hot Partitions</target>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>A hot partition is one that is receiving a disproportionate percentage of the traffic to an account, and cannot be load balanced because it is a single partition.</source>
          <target state="new">A hot partition is one that is receiving a disproportionate percentage of the traffic to an account, and cannot be load balanced because it is a single partition.</target>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>In general, hot partitions are created one of two ways:</source>
          <target state="new">In general, hot partitions are created one of two ways:</target>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading28"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Append Only and Prepend Only patterns</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading28"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Append Only and Prepend Only patterns</target>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>The “Append Only” pattern is one where all (or nearly all) of the traffic to a given PK increases and decreases according to the current time.</source>
          <target state="new">The “Append Only” pattern is one where all (or nearly all) of the traffic to a given PK increases and decreases according to the current time.</target>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>An example is if your application used the current date as a partition key for log data.</source>
          <target state="new">An example is if your application used the current date as a partition key for log data.</target>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>This results in all of the inserts going to the last partition in your table, and the system cannot load balance because all of the writes are going to the end of your table.</source>
          <target state="new">This results in all of the inserts going to the last partition in your table, and the system cannot load balance because all of the writes are going to the end of your table.</target>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>If the volume of traffic to that partition exceeds the partition-level scalability target, then it will result in throttling.</source>
          <target state="new">If the volume of traffic to that partition exceeds the partition-level scalability target, then it will result in throttling.</target>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>It’s better to ensure that traffic is sent to multiple partitions, to enable load balance the requests across your table.</source>
          <target state="new">It’s better to ensure that traffic is sent to multiple partitions, to enable load balance the requests across your table.</target>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading29"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>High-Traffic Data</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading29"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>High-Traffic Data</target>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>If your partitioning scheme results in a single partition that just has data that is far more used than other partitions, you may also see throttling as that partition approaches the scalability target for a single partition.</source>
          <target state="new">If your partitioning scheme results in a single partition that just has data that is far more used than other partitions, you may also see throttling as that partition approaches the scalability target for a single partition.</target>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>It’s better to make sure that your partition scheme results in no single partition approaching the scalability targets.</source>
          <target state="new">It’s better to make sure that your partition scheme results in no single partition approaching the scalability targets.</target>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>Querying</source>
          <target state="new">Querying</target>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>This section describes proven practices for querying the table service.</source>
          <target state="new">This section describes proven practices for querying the table service.</target>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading30"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Query Scope</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading30"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Query Scope</target>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>There are several ways to specify the range of entities to query.</source>
          <target state="new">There are several ways to specify the range of entities to query.</target>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>The following is a discussion of the uses of each.</source>
          <target state="new">The following is a discussion of the uses of each.</target>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>In general, avoid scans (queries larger than a single entity), but if you must scan, try to organize your data so that your scans retrieve the data you need without scanning or returning significant amounts of entities you don’t need.</source>
          <target state="new">In general, avoid scans (queries larger than a single entity), but if you must scan, try to organize your data so that your scans retrieve the data you need without scanning or returning significant amounts of entities you don’t need.</target>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>Point Queries</source>
          <target state="new">Point Queries</target>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>A point query retrieves exactly one entity.</source>
          <target state="new">A point query retrieves exactly one entity.</target>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>It does this by specifying both the partition key and row key of the entity to retrieve.</source>
          <target state="new">It does this by specifying both the partition key and row key of the entity to retrieve.</target>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>These queries are very efficient, and you should use them wherever possible.</source>
          <target state="new">These queries are very efficient, and you should use them wherever possible.</target>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>Partition Queries</source>
          <target state="new">Partition Queries</target>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>A partition query is a query that retrieves a set of data that shares a common partition key.</source>
          <target state="new">A partition query is a query that retrieves a set of data that shares a common partition key.</target>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>Typically, the query specifies a range of row key values or a range of values for some entity property in addition to a partition key.</source>
          <target state="new">Typically, the query specifies a range of row key values or a range of values for some entity property in addition to a partition key.</target>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>These are less efficient than point queries, and should be used sparingly.</source>
          <target state="new">These are less efficient than point queries, and should be used sparingly.</target>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>Table Queries</source>
          <target state="new">Table Queries</target>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>A table query is a query that retrieves a set of entities that does not share a common partition key.</source>
          <target state="new">A table query is a query that retrieves a set of entities that does not share a common partition key.</target>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>These queries are not efficient and you should avoid them if possible.</source>
          <target state="new">These queries are not efficient and you should avoid them if possible.</target>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading31"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Query Density</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading31"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Query Density</target>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>Another key factor in query efficiency is the number of entities returned as compared to the number of entities scanned to find the returned set.</source>
          <target state="new">Another key factor in query efficiency is the number of entities returned as compared to the number of entities scanned to find the returned set.</target>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>If your application performs a table query with a filter for a property value that only 1% of the data shares, the query will scan 100 entities for every one entity it returns.</source>
          <target state="new">If your application performs a table query with a filter for a property value that only 1% of the data shares, the query will scan 100 entities for every one entity it returns.</target>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>The table scalability targets discussed previously all relate to the number of entities scanned, and not the number of entities returned: a low query density can easily cause the table service to throttle your application because it must scan so many entities to retrieve the entity you are looking for.</source>
          <target state="new">The table scalability targets discussed previously all relate to the number of entities scanned, and not the number of entities returned: a low query density can easily cause the table service to throttle your application because it must scan so many entities to retrieve the entity you are looking for.</target>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>See the section below on <bpt id="p1">[</bpt>denormalization<ept id="p1">](#subheading34)</ept> for more information on how to avoid this.</source>
          <target state="new">See the section below on <bpt id="p1">[</bpt>denormalization<ept id="p1">](#subheading34)</ept> for more information on how to avoid this.</target>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source>Limiting the Amount of Data Returned</source>
          <target state="new">Limiting the Amount of Data Returned</target>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading32"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Filtering</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading32"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Filtering</target>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>Where you know that a query will return entities that you don’t need in the client application, consider using a filter to reduce the size of the returned set.</source>
          <target state="new">Where you know that a query will return entities that you don’t need in the client application, consider using a filter to reduce the size of the returned set.</target>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>While the entities not returned to the client still count toward the scalability limits, your application performance will improve because of the reduced network payload size and the reduced number of entities that your client application must process.</source>
          <target state="new">While the entities not returned to the client still count toward the scalability limits, your application performance will improve because of the reduced network payload size and the reduced number of entities that your client application must process.</target>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source>See above note on <bpt id="p1">[</bpt>Query Density<ept id="p1">](#subheading31)</ept>, however – the scalability targets relate to the number of entities scanned, so a query that filters out many entities may still result in throttling, even if few entities are returned.</source>
          <target state="new">See above note on <bpt id="p1">[</bpt>Query Density<ept id="p1">](#subheading31)</ept>, however – the scalability targets relate to the number of entities scanned, so a query that filters out many entities may still result in throttling, even if few entities are returned.</target>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading33"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Projection</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading33"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Projection</target>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>If your client application needs only a limited set of properties from the entities in your table, you can use projection to limit the size of the returned data set.</source>
          <target state="new">If your client application needs only a limited set of properties from the entities in your table, you can use projection to limit the size of the returned data set.</target>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>As with filtering, this helps to reduce network load and client processing.</source>
          <target state="new">As with filtering, this helps to reduce network load and client processing.</target>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading34"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Denormalization</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading34"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Denormalization</target>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>Unlike working with relational databases, the proven practices for efficiently querying table data lead to denormalizing your data.</source>
          <target state="new">Unlike working with relational databases, the proven practices for efficiently querying table data lead to denormalizing your data.</target>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>That is, duplicating the same data in multiple entities (one for each key you may use to find the data) to minimize the number of entities that a query must scan to find the data the client needs, rather than having to scan large numbers of entities to find the data your application needs.</source>
          <target state="new">That is, duplicating the same data in multiple entities (one for each key you may use to find the data) to minimize the number of entities that a query must scan to find the data the client needs, rather than having to scan large numbers of entities to find the data your application needs.</target>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>For example, in an e-commerce website, you may want to find an order both by the customer ID (give me this customer’s orders) and by the date (give me orders on a date).</source>
          <target state="new">For example, in an e-commerce website, you may want to find an order both by the customer ID (give me this customer’s orders) and by the date (give me orders on a date).</target>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>In Table Storage, it is best to store the entity (or a reference to it) twice – once with Table Name, PK, and RK to facilitate finding by customer ID, once to facilitate finding it by the date.</source>
          <target state="new">In Table Storage, it is best to store the entity (or a reference to it) twice – once with Table Name, PK, and RK to facilitate finding by customer ID, once to facilitate finding it by the date.</target>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>Insert/Update/Delete</source>
          <target state="new">Insert/Update/Delete</target>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>This section describes proven practices for modifying entities stored in the table service.</source>
          <target state="new">This section describes proven practices for modifying entities stored in the table service.</target>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading35"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Batching</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading35"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Batching</target>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source>Batch transactions are known as Entity Group Transactions (ETG) in Azure Storage; all the operations within an ETG must be on a single partition in a single table.</source>
          <target state="new">Batch transactions are known as Entity Group Transactions (ETG) in Azure Storage; all the operations within an ETG must be on a single partition in a single table.</target>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source>Where possible, use ETGs to perform inserts, updates, and deletes in batches.</source>
          <target state="new">Where possible, use ETGs to perform inserts, updates, and deletes in batches.</target>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>This reduces the number of round trips from your client application to the server, reduces the number of billable transaction (an ETG counts as a single transaction for billing purposes and can contain up to 100 storage operations), and enables atomic updates (all operations succeed or all fail within an ETG).</source>
          <target state="new">This reduces the number of round trips from your client application to the server, reduces the number of billable transaction (an ETG counts as a single transaction for billing purposes and can contain up to 100 storage operations), and enables atomic updates (all operations succeed or all fail within an ETG).</target>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>Environments with high latencies such as mobile devices will benefit greatly from using ETGs.</source>
          <target state="new">Environments with high latencies such as mobile devices will benefit greatly from using ETGs.</target>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading36"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Upsert</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading36"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Upsert</target>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>Use table <bpt id="p1">**</bpt>Upsert<ept id="p1">**</ept> operations wherever possible.</source>
          <target state="new">Use table <bpt id="p1">**</bpt>Upsert<ept id="p1">**</ept> operations wherever possible.</target>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>There are two types of <bpt id="p1">**</bpt>Upsert<ept id="p1">**</ept>, both of which can be more efficient than a traditional <bpt id="p2">**</bpt>Insert<ept id="p2">**</ept> and <bpt id="p3">**</bpt>Update<ept id="p3">**</ept> operations:</source>
          <target state="new">There are two types of <bpt id="p1">**</bpt>Upsert<ept id="p1">**</ept>, both of which can be more efficient than a traditional <bpt id="p2">**</bpt>Insert<ept id="p2">**</ept> and <bpt id="p3">**</bpt>Update<ept id="p3">**</ept> operations:</target>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>InsertOrMerge<ept id="p1">**</ept>: Use this when you want to upload a subset of the entity’s properties, but aren’t sure whether the entity already exists.</source>
          <target state="new"><bpt id="p1">**</bpt>InsertOrMerge<ept id="p1">**</ept>: Use this when you want to upload a subset of the entity’s properties, but aren’t sure whether the entity already exists.</target>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>If the entity exists, this call updates the properties included in the <bpt id="p1">**</bpt>Upsert<ept id="p1">**</ept> operation, and leaves all existing properties as they are, if the entity does not exist, it inserts the new entity.</source>
          <target state="new">If the entity exists, this call updates the properties included in the <bpt id="p1">**</bpt>Upsert<ept id="p1">**</ept> operation, and leaves all existing properties as they are, if the entity does not exist, it inserts the new entity.</target>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>This is similar to using projection in a query, in that you only need to upload the properties that are changing.</source>
          <target state="new">This is similar to using projection in a query, in that you only need to upload the properties that are changing.</target>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>InsertOrReplace<ept id="p1">**</ept>: Use this when you want to upload an entirely new entity, but you aren’t sure whether it already exists.</source>
          <target state="new"><bpt id="p1">**</bpt>InsertOrReplace<ept id="p1">**</ept>: Use this when you want to upload an entirely new entity, but you aren’t sure whether it already exists.</target>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>You should only use this when you know that the newly uploaded entity is entirely correct because it completely overwrites the old entity.</source>
          <target state="new">You should only use this when you know that the newly uploaded entity is entirely correct because it completely overwrites the old entity.</target>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>For example, you want to update the entity that stores a user’s current location regardless of whether or not the application has previously stored location data for the user; the new location entity is complete, and you do not need any information from any previous entity.</source>
          <target state="new">For example, you want to update the entity that stores a user’s current location regardless of whether or not the application has previously stored location data for the user; the new location entity is complete, and you do not need any information from any previous entity.</target>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading37"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Storing Data Series in a Single Entity</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading37"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Storing Data Series in a Single Entity</target>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>Sometimes, an application stores a series of data that it frequently needs to retrieve all at once: for example, an application might track CPU usage over time in order to plot a rolling chart of the data from the last 24 hours.</source>
          <target state="new">Sometimes, an application stores a series of data that it frequently needs to retrieve all at once: for example, an application might track CPU usage over time in order to plot a rolling chart of the data from the last 24 hours.</target>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>One approach is to have one table entity per hour, with each entity representing a specific hour and storing the CPU usage for that hour.</source>
          <target state="new">One approach is to have one table entity per hour, with each entity representing a specific hour and storing the CPU usage for that hour.</target>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>To plot this data, the application needs to retrieve the entities holding the data from the 24 most recent hours.</source>
          <target state="new">To plot this data, the application needs to retrieve the entities holding the data from the 24 most recent hours.</target>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>Alternatively, your application could store the CPU usage for each hour as a separate property of a single entity: to update each hour, your application can use a single <bpt id="p1">**</bpt>InsertOrMerge Upsert<ept id="p1">**</ept> call to update the value for the most recent hour.</source>
          <target state="new">Alternatively, your application could store the CPU usage for each hour as a separate property of a single entity: to update each hour, your application can use a single <bpt id="p1">**</bpt>InsertOrMerge Upsert<ept id="p1">**</ept> call to update the value for the most recent hour.</target>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>To plot the data, the application only needs to retrieve a single entity instead of 24, making for a very efficient query (see above discussion on <bpt id="p1">[</bpt>query scope<ept id="p1">](#subheading30)</ept>).</source>
          <target state="new">To plot the data, the application only needs to retrieve a single entity instead of 24, making for a very efficient query (see above discussion on <bpt id="p1">[</bpt>query scope<ept id="p1">](#subheading30)</ept>).</target>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="subheading38"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Storing structured data in blobs</source>
          <target state="new"><ph id="ph1">&lt;a name="subheading38"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Storing structured data in blobs</target>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>Sometimes structured data feels like it should go in tables, but ranges of entities are always retrieved together and can be batch inserted.</source>
          <target state="new">Sometimes structured data feels like it should go in tables, but ranges of entities are always retrieved together and can be batch inserted.</target>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>A good example of this is a log file.</source>
          <target state="new">A good example of this is a log file.</target>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>In this case, you can batch several minutes of logs, insert them, and then you are always retrieving several minutes of logs at a time as well.</source>
          <target state="new">In this case, you can batch several minutes of logs, insert them, and then you are always retrieving several minutes of logs at a time as well.</target>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>In this case, for performance, it’s better to use blobs instead of tables, since you can significantly reduce the number of objects written/returned, as well as usually the number of requests that need made.</source>
          <target state="new">In this case, for performance, it’s better to use blobs instead of tables, since you can significantly reduce the number of objects written/returned, as well as usually the number of requests that need made.</target>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>Queues</source>
          <target state="new">Queues</target>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source>&lt;a name=subheading39"&gt;<ph id="ph1">&lt;/a&gt;</ph>Scalability Limits</source>
          <target state="new">&lt;a name=subheading39"&gt;<ph id="ph1">&lt;/a&gt;</ph>Scalability Limits</target>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>A single queue can process approximately 2,000 messages (1KB each) per second (each AddMessage, GetMessage, and DeleteMessage count as a message here).</source>
          <target state="new">A single queue can process approximately 2,000 messages (1KB each) per second (each AddMessage, GetMessage, and DeleteMessage count as a message here).</target>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>If this is insufficient for your application, you should use multiple queues and spread the messages across them.</source>
          <target state="new">If this is insufficient for your application, you should use multiple queues and spread the messages across them.</target>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>You can view the current scalability targets on the page <bpt id="p1">[</bpt>Azure Storage Scalability and Performance Targets<ept id="p1">](http://msdn.microsoft.com/library/azure/dn249410.aspx)</ept> on MSDN.</source>
          <target state="new">You can view the current scalability targets on the page <bpt id="p1">[</bpt>Azure Storage Scalability and Performance Targets<ept id="p1">](http://msdn.microsoft.com/library/azure/dn249410.aspx)</ept> on MSDN.</target>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>&lt;a name=subheading40"&gt;<ph id="ph1">&lt;/a&gt;</ph>Nagle Off</source>
          <target state="new">&lt;a name=subheading40"&gt;<ph id="ph1">&lt;/a&gt;</ph>Nagle Off</target>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>See the section on table configuration that discusses the Nagle algorithm — the Nagle algorithm is generally bad for the performance of queue requests, and you should disable it.</source>
          <target state="new">See the section on table configuration that discusses the Nagle algorithm — the Nagle algorithm is generally bad for the performance of queue requests, and you should disable it.</target>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source>&lt;a name=subheading41"&gt;<ph id="ph1">&lt;/a&gt;</ph>Message Size</source>
          <target state="new">&lt;a name=subheading41"&gt;<ph id="ph1">&lt;/a&gt;</ph>Message Size</target>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>Queue performance and scalability decreases as message size increases.</source>
          <target state="new">Queue performance and scalability decreases as message size increases.</target>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>You should place only the information the receiver needs in a message.</source>
          <target state="new">You should place only the information the receiver needs in a message.</target>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>&lt;a name=subheading42"&gt;<ph id="ph1">&lt;/a&gt;</ph>Batch Retrieval</source>
          <target state="new">&lt;a name=subheading42"&gt;<ph id="ph1">&lt;/a&gt;</ph>Batch Retrieval</target>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>You can retrieve up to 32 messages from a queue in a single operation.</source>
          <target state="new">You can retrieve up to 32 messages from a queue in a single operation.</target>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>This can reduce the number of roundtrips from the client application, which is especially useful for environments, such as mobile devices, with high latency.</source>
          <target state="new">This can reduce the number of roundtrips from the client application, which is especially useful for environments, such as mobile devices, with high latency.</target>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>&lt;a name=subheading43"&gt;<ph id="ph1">&lt;/a&gt;</ph>Queue Polling Interval</source>
          <target state="new">&lt;a name=subheading43"&gt;<ph id="ph1">&lt;/a&gt;</ph>Queue Polling Interval</target>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>Most applications poll for messages from a queue, which can be one of the largest sources of transactions for that application.</source>
          <target state="new">Most applications poll for messages from a queue, which can be one of the largest sources of transactions for that application.</target>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>Select your polling interval wisely: polling too frequently could cause your application to approach the scalability targets for the queue.</source>
          <target state="new">Select your polling interval wisely: polling too frequently could cause your application to approach the scalability targets for the queue.</target>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>However, at 200,000 transactions for $0.01 (at the time of writing), a single processor polling once every second for a month would cost less than 15 cents so cost is not typically a factor that affects your choice of polling interval.</source>
          <target state="new">However, at 200,000 transactions for $0.01 (at the time of writing), a single processor polling once every second for a month would cost less than 15 cents so cost is not typically a factor that affects your choice of polling interval.</target>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>For up to date cost information, see <bpt id="p1">[</bpt>Storage Pricing Details<ept id="p1">](http://azure.microsoft.com/pricing/details/storage/)</ept>.</source>
          <target state="new">For up to date cost information, see <bpt id="p1">[</bpt>Storage Pricing Details<ept id="p1">](http://azure.microsoft.com/pricing/details/storage/)</ept>.</target>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>&lt;a name=subheading44"&gt;<ph id="ph1">&lt;/a&gt;</ph>UpdateMessage</source>
          <target state="new">&lt;a name=subheading44"&gt;<ph id="ph1">&lt;/a&gt;</ph>UpdateMessage</target>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>You can use <bpt id="p1">**</bpt>UpdateMessage<ept id="p1">**</ept> to increase the invisibility timeout or to update state information of a message.</source>
          <target state="new">You can use <bpt id="p1">**</bpt>UpdateMessage<ept id="p1">**</ept> to increase the invisibility timeout or to update state information of a message.</target>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>While this is powerful, remember that each <bpt id="p1">**</bpt>UpdateMessage<ept id="p1">**</ept> operation counts towards the scalability target.</source>
          <target state="new">While this is powerful, remember that each <bpt id="p1">**</bpt>UpdateMessage<ept id="p1">**</ept> operation counts towards the scalability target.</target>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>However, this can be a much more efficient approach than having a workflow that passes a job from one queue to the next, as each step of the job is completed.</source>
          <target state="new">However, this can be a much more efficient approach than having a workflow that passes a job from one queue to the next, as each step of the job is completed.</target>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>Using the <bpt id="p1">**</bpt>UpdateMessage<ept id="p1">**</ept> operation allows your application to save the job state to the message and then continue working, instead of re-queuing the message for the next step of the job every time a step completes.</source>
          <target state="new">Using the <bpt id="p1">**</bpt>UpdateMessage<ept id="p1">**</ept> operation allows your application to save the job state to the message and then continue working, instead of re-queuing the message for the next step of the job every time a step completes.</target>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>For more information, see the article <bpt id="p1">[</bpt>How to: Change the contents of a queued message<ept id="p1">](../storage-dotnet-how-to-use-queues/#change-contents)</ept>.</source>
          <target state="new">For more information, see the article <bpt id="p1">[</bpt>How to: Change the contents of a queued message<ept id="p1">](../storage-dotnet-how-to-use-queues/#change-contents)</ept>.</target>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>&lt;a name=subheading45"&gt;<ph id="ph1">&lt;/a&gt;</ph>Application architecture</source>
          <target state="new">&lt;a name=subheading45"&gt;<ph id="ph1">&lt;/a&gt;</ph>Application architecture</target>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>You should use queues to make your application architecture scalable.</source>
          <target state="new">You should use queues to make your application architecture scalable.</target>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>The following lists some ways you can use queues to make your application more scalable:</source>
          <target state="new">The following lists some ways you can use queues to make your application more scalable:</target>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>You can use queues to create backlogs of work for processing and smooth out workloads in your application.</source>
          <target state="new">You can use queues to create backlogs of work for processing and smooth out workloads in your application.</target>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>For example, you could queue up requests from users to perform processor intensive work such as resizing uploaded images.</source>
          <target state="new">For example, you could queue up requests from users to perform processor intensive work such as resizing uploaded images.</target>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>You can use queues to decouple parts of your application so that you can scale them independently.</source>
          <target state="new">You can use queues to decouple parts of your application so that you can scale them independently.</target>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>For example, a web front-end could place survey results from users into a queue for later analysis and storage.</source>
          <target state="new">For example, a web front-end could place survey results from users into a queue for later analysis and storage.</target>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>You could add more worker role instances to process the queue data as required.</source>
          <target state="new">You could add more worker role instances to process the queue data as required.</target>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="new">Conclusion</target>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>This article discussed some of the most common, proven practices for optimizing performance when using Azure Storage.</source>
          <target state="new">This article discussed some of the most common, proven practices for optimizing performance when using Azure Storage.</target>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>We encourage every application developer to assess their application against each of the above practices and consider acting on the recommendations to get great performance for their applications that use Azure Storage.</source>
          <target state="new">We encourage every application developer to assess their application against each of the above practices and consider acting on the recommendations to get great performance for their applications that use Azure Storage.</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8d6d42512ada324416692f978d6051892ff23706</xliffext:olfilehash>
  </header>
</xliff>