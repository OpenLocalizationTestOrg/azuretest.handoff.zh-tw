{
  "nodes": [
    {
      "content": "How to use Azure queue storage with the WebJobs SDK",
      "pos": [
        28,
        79
      ]
    },
    {
      "content": "Learn how to use Azure queue storage with the WebJobs SDK.",
      "pos": [
        99,
        157
      ]
    },
    {
      "content": "Create and delete queues; insert, peek, get, and delete queue messages, and more.",
      "pos": [
        158,
        239
      ]
    },
    {
      "content": "How to use Azure queue storage with the WebJobs SDK",
      "pos": [
        578,
        629
      ]
    },
    {
      "content": "Overview",
      "pos": [
        634,
        642
      ]
    },
    {
      "content": "This guide provides C# code samples that show how to use the Azure WebJobs SDK version 1.x with the Azure queue storage service.",
      "pos": [
        644,
        772
      ]
    },
    {
      "pos": [
        774,
        954
      ],
      "content": "The guide assumes you know <bpt id=\"p1\">[</bpt>how to create a WebJob project in Visual Studio with connection strings that point to your storage account<ept id=\"p1\">](websites-dotnet-webjobs-sdk-get-started.md)</ept>."
    },
    {
      "pos": [
        956,
        1069
      ],
      "content": "Most of the code snippets only show functions, not the code that creates the <ph id=\"ph1\">`JobHost`</ph> object as in this example:"
    },
    {
      "content": "The guide includes the following topics:",
      "pos": [
        1214,
        1254
      ]
    },
    {
      "content": "How to trigger a function when a queue message is received",
      "pos": [
        1261,
        1319
      ]
    },
    {
      "content": "String queue messages",
      "pos": [
        1337,
        1358
      ]
    },
    {
      "content": "POCO queue messages",
      "pos": [
        1365,
        1384
      ]
    },
    {
      "content": "Async functions",
      "pos": [
        1391,
        1406
      ]
    },
    {
      "content": "Types the QueueTrigger attribute works with",
      "pos": [
        1413,
        1456
      ]
    },
    {
      "content": "Polling algorithm",
      "pos": [
        1463,
        1480
      ]
    },
    {
      "content": "Multiple instances",
      "pos": [
        1487,
        1505
      ]
    },
    {
      "content": "Parallel execution",
      "pos": [
        1512,
        1530
      ]
    },
    {
      "content": "Get queue or queue message metadata",
      "pos": [
        1537,
        1572
      ]
    },
    {
      "content": "Graceful shutdown",
      "pos": [
        1579,
        1596
      ]
    },
    {
      "content": "How to create a queue message while processing a queue message",
      "pos": [
        1602,
        1664
      ]
    },
    {
      "content": "String queue messages",
      "pos": [
        1686,
        1707
      ]
    },
    {
      "content": "POCO queue messages",
      "pos": [
        1714,
        1733
      ]
    },
    {
      "content": "Create multiple messages or in async functions",
      "pos": [
        1740,
        1786
      ]
    },
    {
      "content": "Types the Queue attribute works with",
      "pos": [
        1793,
        1829
      ]
    },
    {
      "content": "Use WebJobs SDK attributes in the body of a function",
      "pos": [
        1836,
        1888
      ]
    },
    {
      "content": "How to read and write blobs while processing a queue message",
      "pos": [
        1894,
        1954
      ]
    },
    {
      "content": "String queue messages",
      "pos": [
        1970,
        1991
      ]
    },
    {
      "content": "POCO queue messages",
      "pos": [
        1998,
        2017
      ]
    },
    {
      "content": "Types the Blob attribute works with",
      "pos": [
        2024,
        2059
      ]
    },
    {
      "content": "How to handle poison messages",
      "pos": [
        2065,
        2094
      ]
    },
    {
      "content": "Automatic poison message handling",
      "pos": [
        2111,
        2144
      ]
    },
    {
      "content": "Manual poison message handling",
      "pos": [
        2151,
        2181
      ]
    },
    {
      "content": "How to set configuration options",
      "pos": [
        2187,
        2219
      ]
    },
    {
      "content": "Set SDK connection strings in code",
      "pos": [
        2236,
        2270
      ]
    },
    {
      "content": "Configure QueueTrigger settings",
      "pos": [
        2277,
        2308
      ]
    },
    {
      "content": "Set values for WebJobs SDK constructor parameters in code",
      "pos": [
        2315,
        2372
      ]
    },
    {
      "content": "How to trigger a function manually",
      "pos": [
        2378,
        2412
      ]
    },
    {
      "content": "How to write logs",
      "pos": [
        2428,
        2445
      ]
    },
    {
      "content": "Next steps",
      "pos": [
        2459,
        2469
      ]
    },
    {
      "pos": [
        2487,
        2566
      ],
      "content": "<ph id=\"ph1\">&lt;a id=\"trigger\"&gt;</ph><ph id=\"ph2\">&lt;/a&gt;</ph> How to trigger a function when a queue message is received"
    },
    {
      "content": "To write a function that the WebJobs SDK calls when a queue message is received, use the <ph id=\"ph1\">`QueueTrigger`</ph> attribute.",
      "pos": [
        2568,
        2682
      ]
    },
    {
      "content": "The attribute constructor takes a string parameter that specifies the name of the queue to poll.",
      "pos": [
        2683,
        2779
      ]
    },
    {
      "content": "You can also <bpt id=\"p1\">[</bpt>set the queue name dynamically<ept id=\"p1\">](#config)</ept>.",
      "pos": [
        2780,
        2835
      ]
    },
    {
      "content": "String queue messages",
      "pos": [
        2841,
        2862
      ]
    },
    {
      "content": "In the following example, the queue contains a string message, so <ph id=\"ph1\">`QueueTrigger`</ph> is applied to a string parameter named <ph id=\"ph2\">`logMessage`</ph> which contains the content of the queue message.",
      "pos": [
        2864,
        3045
      ]
    },
    {
      "content": "The function <bpt id=\"p1\">[</bpt>writes a log message to the Dashboard<ept id=\"p1\">](#logs)</ept>.",
      "pos": [
        3046,
        3106
      ]
    },
    {
      "pos": [
        3285,
        3395
      ],
      "content": "Besides <ph id=\"ph1\">`string`</ph>, the parameter may be a byte array, a <ph id=\"ph2\">`CloudQueueMessage`</ph> object, or a POCO  that you define."
    },
    {
      "pos": [
        3401,
        3496
      ],
      "content": "POCO <bpt id=\"p1\">[</bpt>(Plain Old CLR Object<ept id=\"p1\">](http://en.wikipedia.org/wiki/Plain_Old_CLR_Object)</ept>) queue messages"
    },
    {
      "content": "In the following example, the queue message contains JSON for a <ph id=\"ph1\">`BlobInformation`</ph> object which includes a <ph id=\"ph2\">`BlobName`</ph> property.",
      "pos": [
        3498,
        3624
      ]
    },
    {
      "content": "The SDK automatically deserializes the object.",
      "pos": [
        3625,
        3671
      ]
    },
    {
      "content": "The SDK uses the <bpt id=\"p1\">[</bpt>Newtonsoft.Json NuGet package<ept id=\"p1\">](http://www.nuget.org/packages/Newtonsoft.Json)</ept> to serialize and deserialize messages.",
      "pos": [
        3890,
        4024
      ]
    },
    {
      "content": "If you create queue messages in a program that doesn't use the WebJobs SDK, you can write code like the following example to create a POCO queue message that the SDK can parse.",
      "pos": [
        4025,
        4201
      ]
    },
    {
      "content": "Async functions",
      "pos": [
        4424,
        4439
      ]
    },
    {
      "pos": [
        4441,
        4509
      ],
      "content": "The following async function <bpt id=\"p1\">[</bpt>writes a log to the Dashboard<ept id=\"p1\">](#logs)</ept>."
    },
    {
      "content": "Async functions may take a <bpt id=\"p1\">[</bpt>cancellation token<ept id=\"p1\">](http://www.asp.net/mvc/overview/performance/using-asynchronous-methods-in-aspnet-mvc-4#CancelToken)</ept>, as shown in the following example which copies a blob.",
      "pos": [
        4708,
        4911
      ]
    },
    {
      "content": "(For an explanation of the <ph id=\"ph1\">`queueTrigger`</ph> placeholder, see the <bpt id=\"p1\">[</bpt>Blobs<ept id=\"p1\">](#blobs)</ept> section.)",
      "pos": [
        4912,
        5000
      ]
    },
    {
      "pos": [
        5436,
        5509
      ],
      "content": "<ph id=\"ph1\">&lt;a id=\"qtattributetypes\"&gt;</ph><ph id=\"ph2\">&lt;/a&gt;</ph> Types the QueueTrigger attribute works with"
    },
    {
      "pos": [
        5511,
        5563
      ],
      "content": "You can use <ph id=\"ph1\">`QueueTrigger`</ph> with the following types:"
    },
    {
      "content": "A POCO type serialized as JSON",
      "pos": [
        5578,
        5608
      ]
    },
    {
      "pos": [
        5647,
        5685
      ],
      "content": "<ph id=\"ph1\">&lt;a id=\"polling\"&gt;</ph><ph id=\"ph2\">&lt;/a&gt;</ph> Polling algorithm"
    },
    {
      "content": "The SDK implements a random exponential back-off algorithm to reduce the effect of idle-queue polling on storage transaction costs.",
      "pos": [
        5687,
        5818
      ]
    },
    {
      "content": "When a message is found, the SDK waits two seconds and then checks for another message; when no message is found it waits about four seconds before trying again.",
      "pos": [
        5820,
        5981
      ]
    },
    {
      "content": "After subsequent failed attempts to get a queue message, the wait time continues to increase until it reaches the maximum wait time, which defaults to one minute.",
      "pos": [
        5982,
        6144
      ]
    },
    {
      "content": "<bpt id=\"p1\">[</bpt>The maximum wait time is configurable<ept id=\"p1\">](#config)</ept>.",
      "pos": [
        6145,
        6194
      ]
    },
    {
      "pos": [
        6200,
        6241
      ],
      "content": "<ph id=\"ph1\">&lt;a id=\"instances\"&gt;</ph><ph id=\"ph2\">&lt;/a&gt;</ph> Multiple instances"
    },
    {
      "content": "If your web app runs on multiple instances, a continuous WebJobs runs on each machine, and each machine will wait for triggers and attempt to run functions.",
      "pos": [
        6243,
        6399
      ]
    },
    {
      "content": "In some scenarios this can lead to some functions processing the same data twice, so functions should be idempotent (written so that calling them repeatedly with the same input data doesn't produce duplicate results).",
      "pos": [
        6400,
        6617
      ]
    },
    {
      "pos": [
        6625,
        6665
      ],
      "content": "<ph id=\"ph1\">&lt;a id=\"parallel\"&gt;</ph><ph id=\"ph2\">&lt;/a&gt;</ph> Parallel execution"
    },
    {
      "content": "If you have multiple functions listening on different queues, the SDK will call them in parallel when messages are received simultaneously.",
      "pos": [
        6667,
        6806
      ]
    },
    {
      "content": "The same is true when multiple messages are received for a single queue.",
      "pos": [
        6809,
        6881
      ]
    },
    {
      "content": "By default, the SDK gets a batch of 16 queue messages at a time and executes the function that processes them in parallel.",
      "pos": [
        6882,
        7004
      ]
    },
    {
      "content": "<bpt id=\"p1\">[</bpt>The batch size is configurable<ept id=\"p1\">](#config)</ept>.",
      "pos": [
        7005,
        7047
      ]
    },
    {
      "content": "When the number being processed gets down to half of the batch size, the SDK gets another batch and starts processing those messages.",
      "pos": [
        7048,
        7181
      ]
    },
    {
      "content": "Therefore the maximum number of concurrent messages being processed per function is one and a half times the batch size.",
      "pos": [
        7182,
        7302
      ]
    },
    {
      "content": "This limit applies separately to each function that has a <ph id=\"ph1\">`QueueTrigger`</ph> attribute.",
      "pos": [
        7303,
        7386
      ]
    },
    {
      "content": "If you don't want parallel execution for messages received on one queue, set the batch size to 1.",
      "pos": [
        7387,
        7484
      ]
    },
    {
      "pos": [
        7490,
        7551
      ],
      "content": "<ph id=\"ph1\">&lt;a id=\"queuemetadata\"&gt;</ph><ph id=\"ph2\">&lt;/a&gt;</ph>Get queue or queue message metadata"
    },
    {
      "content": "You can get the following message properties by adding parameters to the method signature:",
      "pos": [
        7553,
        7643
      ]
    },
    {
      "pos": [
        7647,
        7678
      ],
      "content": "<ph id=\"ph1\">`DateTimeOffset`</ph> expirationTime"
    },
    {
      "pos": [
        7681,
        7711
      ],
      "content": "<ph id=\"ph1\">`DateTimeOffset`</ph> insertionTime"
    },
    {
      "pos": [
        7714,
        7746
      ],
      "content": "<ph id=\"ph1\">`DateTimeOffset`</ph> nextVisibleTime"
    },
    {
      "pos": [
        7749,
        7794
      ],
      "content": "<ph id=\"ph1\">`string`</ph> queueTrigger (contains message text)"
    },
    {
      "pos": [
        7797,
        7808
      ],
      "content": "<ph id=\"ph1\">`string`</ph> id"
    },
    {
      "pos": [
        7811,
        7830
      ],
      "content": "<ph id=\"ph1\">`string`</ph> popReceipt"
    },
    {
      "pos": [
        7833,
        7851
      ],
      "content": "<ph id=\"ph1\">`int`</ph> dequeueCount"
    },
    {
      "pos": [
        7853,
        7961
      ],
      "content": "If you want to work directly with the Azure storage API, you can also add a <ph id=\"ph1\">`CloudStorageAccount`</ph> parameter."
    },
    {
      "content": "The following example writes all of this metadata to an INFO application log.",
      "pos": [
        7963,
        8040
      ]
    },
    {
      "content": "In the example, both logMessage and queueTrigger contain the content of the queue message.",
      "pos": [
        8041,
        8131
      ]
    },
    {
      "content": "Here is a sample log written by the sample code:",
      "pos": [
        9085,
        9133
      ]
    },
    {
      "pos": [
        9548,
        9586
      ],
      "content": "<ph id=\"ph1\">&lt;a id=\"graceful\"&gt;</ph><ph id=\"ph2\">&lt;/a&gt;</ph>Graceful shutdown"
    },
    {
      "content": "A function that runs in a continuous WebJob can accept a <ph id=\"ph1\">`CancellationToken`</ph> parameter which enables the operating system to notify the function when the WebJob is about to be terminated.",
      "pos": [
        9588,
        9775
      ]
    },
    {
      "content": "You can use this notification to make sure the function doesn't terminate unexpectedly in a way that leaves data in an inconsistent state.",
      "pos": [
        9776,
        9914
      ]
    },
    {
      "content": "The following example shows how to check for impending WebJob termination in a function.",
      "pos": [
        9916,
        10004
      ]
    },
    {
      "pos": [
        10555,
        10664
      ],
      "content": "<bpt id=\"p1\">**</bpt>Note:<ept id=\"p1\">**</ept> The Dashboard might not correctly show the status and output of functions that have been shut down."
    },
    {
      "pos": [
        10667,
        10801
      ],
      "content": "For more information, see <bpt id=\"p1\">[</bpt>WebJobs Graceful Shutdown<ept id=\"p1\">](http://blog.amitapple.com/post/2014/05/webjobs-graceful-shutdown/#.VCt1GXl0wpR)</ept>."
    },
    {
      "pos": [
        10809,
        10896
      ],
      "content": "<ph id=\"ph1\">&lt;a id=\"createqueue\"&gt;</ph><ph id=\"ph2\">&lt;/a&gt;</ph> How to create a queue message while processing a queue message"
    },
    {
      "content": "To write a function that creates a new queue message, use the <ph id=\"ph1\">`Queue`</ph> attribute.",
      "pos": [
        10898,
        10978
      ]
    },
    {
      "content": "Like <ph id=\"ph1\">`QueueTrigger`</ph>, you pass in the queue name as a string or you can <bpt id=\"p1\">[</bpt>set the queue name dynamically<ept id=\"p1\">](#config)</ept>.",
      "pos": [
        10979,
        11092
      ]
    },
    {
      "content": "String queue messages",
      "pos": [
        11098,
        11119
      ]
    },
    {
      "content": "The following non-async code sample creates a new queue message in the queue named \"outputqueue\" with the same content as the queue message received in the queue named \"inputqueue\".",
      "pos": [
        11121,
        11302
      ]
    },
    {
      "content": "(For async functions use <ph id=\"ph1\">`IAsyncCollector&lt;T&gt;`</ph> as shown later in this section.)",
      "pos": [
        11303,
        11381
      ]
    },
    {
      "pos": [
        11634,
        11729
      ],
      "content": "POCO <bpt id=\"p1\">[</bpt>(Plain Old CLR Object<ept id=\"p1\">](http://en.wikipedia.org/wiki/Plain_Old_CLR_Object)</ept>) queue messages"
    },
    {
      "pos": [
        11731,
        11879
      ],
      "content": "To create a queue message that contains a POCO rather than a string, pass the POCO type as an output parameter to the <ph id=\"ph1\">`Queue`</ph> attribute constructor."
    },
    {
      "content": "The SDK automatically serializes the object to JSON.",
      "pos": [
        12138,
        12190
      ]
    },
    {
      "content": "A queue message is always created, even if the object is null.",
      "pos": [
        12191,
        12253
      ]
    },
    {
      "content": "Create multiple messages or in async functions",
      "pos": [
        12259,
        12305
      ]
    },
    {
      "pos": [
        12307,
        12456
      ],
      "content": "To create multiple messages, make the parameter type for the output queue <ph id=\"ph1\">`ICollector&lt;T&gt;`</ph> or <ph id=\"ph2\">`IAsyncCollector&lt;T&gt;`</ph>, as shown in the following example."
    },
    {
      "pos": [
        12874,
        12948
      ],
      "content": "Each queue message is created immediately when the <ph id=\"ph1\">`Add`</ph> method is called."
    },
    {
      "content": "Types that the Queue attribute works with",
      "pos": [
        12954,
        12995
      ]
    },
    {
      "pos": [
        12997,
        13064
      ],
      "content": "You can use the <ph id=\"ph1\">`Queue`</ph> attribute on the following parameter types:"
    },
    {
      "pos": [
        13068,
        13158
      ],
      "content": "<ph id=\"ph1\">`out string`</ph> (creates queue message if parameter value is non-null when the function ends)"
    },
    {
      "pos": [
        13161,
        13195
      ],
      "content": "<ph id=\"ph1\">`out byte[]`</ph> (works like <ph id=\"ph2\">`string`</ph>)"
    },
    {
      "pos": [
        13199,
        13244
      ],
      "content": "<ph id=\"ph1\">`out CloudQueueMessage`</ph> (works like <ph id=\"ph2\">`string`</ph>)"
    },
    {
      "pos": [
        13248,
        13365
      ],
      "content": "<ph id=\"ph1\">`out POCO`</ph> (a serializable type, creates a message with a null object if the paramter is null when the function ends)"
    },
    {
      "pos": [
        13403,
        13485
      ],
      "content": "<ph id=\"ph1\">`CloudQueue`</ph> (for creating messages manually using the Azure Storage API directly)"
    },
    {
      "pos": [
        13491,
        13563
      ],
      "content": "<ph id=\"ph1\">&lt;a id=\"ibinder\"&gt;</ph><ph id=\"ph2\">&lt;/a&gt;</ph>Use WebJobs SDK attributes in the body of a function"
    },
    {
      "pos": [
        13565,
        13720
      ],
      "content": "If you need to do some work in your function before using a WebJobs SDK attribute such as <ph id=\"ph1\">`Queue`</ph>, <ph id=\"ph2\">`Blob`</ph>, or <ph id=\"ph3\">`Table`</ph>, you can use the <ph id=\"ph4\">`IBinder`</ph> interface."
    },
    {
      "content": "The following example takes an input queue message and creates a new message with the same content in an output queue.",
      "pos": [
        13722,
        13840
      ]
    },
    {
      "content": "The output queue name is set by code in the body of the function.",
      "pos": [
        13841,
        13906
      ]
    },
    {
      "pos": [
        14382,
        14462
      ],
      "content": "The <ph id=\"ph1\">`IBinder`</ph> interface can also be used with the <ph id=\"ph2\">`Table`</ph> and <ph id=\"ph3\">`Blob`</ph> attributes."
    },
    {
      "pos": [
        14467,
        14557
      ],
      "content": "<ph id=\"ph1\">&lt;a id=\"blobs\"&gt;</ph><ph id=\"ph2\">&lt;/a&gt;</ph> How to read and write blobs and tables while processing a queue message"
    },
    {
      "content": "The <ph id=\"ph1\">`Blob`</ph> and <ph id=\"ph2\">`Table`</ph> attributes enable you to read and write blobs and tables.",
      "pos": [
        14559,
        14639
      ]
    },
    {
      "content": "The samples in this section apply to blobs.",
      "pos": [
        14640,
        14683
      ]
    },
    {
      "content": "For code samples that show how to trigger processes when blobs are created or updated, see <bpt id=\"p1\">[</bpt>How to use Azure blob storage with the WebJobs SDK<ept id=\"p1\">](websites-dotnet-webjobs-sdk-storage-blobs-how-to.md)</ept>, and for code samples that read and write tables, see <bpt id=\"p2\">[</bpt>How to use Azure table storage with the WebJobs SDK<ept id=\"p2\">](websites-dotnet-webjobs-sdk-storage-tables-how-to.md)</ept>.",
      "pos": [
        14684,
        15043
      ]
    },
    {
      "content": "String queue messages triggering blob operations",
      "pos": [
        15049,
        15097
      ]
    },
    {
      "pos": [
        15099,
        15276
      ],
      "content": "For a queue message that contains a string, <ph id=\"ph1\">`queueTrigger`</ph> is a placeholder you can use in the <ph id=\"ph2\">`Blob`</ph> attribute's <ph id=\"ph3\">`blobPath`</ph> parameter that contains the contents of the message."
    },
    {
      "content": "The following example uses <ph id=\"ph1\">`Stream`</ph> objects to read and write blobs.",
      "pos": [
        15279,
        15347
      ]
    },
    {
      "content": "The queue message is the name of a blob located in the textblobs container.",
      "pos": [
        15348,
        15423
      ]
    },
    {
      "content": "A copy of the blob with \"-new\" appended to the name is created in the same container.",
      "pos": [
        15424,
        15509
      ]
    },
    {
      "content": "The <ph id=\"ph1\">`Blob`</ph> attribute constructor takes a <ph id=\"ph2\">`blobPath`</ph> parameter that specifies the container and blob name.",
      "pos": [
        15859,
        15964
      ]
    },
    {
      "content": "For more information about this placeholder, see <bpt id=\"p1\">[</bpt>How to use Azure blob storage with the WebJobs SDK<ept id=\"p1\">](websites-dotnet-webjobs-sdk-storage-blobs-how-to.md)</ept>,",
      "pos": [
        15965,
        16120
      ]
    },
    {
      "pos": [
        16123,
        16263
      ],
      "content": "When the attribute decorates a <ph id=\"ph1\">`Stream`</ph> object, another constructor parameter specifies the <ph id=\"ph2\">`FileAccess`</ph> mode as read, write, or read/write."
    },
    {
      "content": "The following example uses a <ph id=\"ph1\">`CloudBlockBlob`</ph> object to delete a blob.",
      "pos": [
        16266,
        16336
      ]
    },
    {
      "content": "The queue message is the name of the blob.",
      "pos": [
        16337,
        16379
      ]
    },
    {
      "pos": [
        16619,
        16737
      ],
      "content": "<ph id=\"ph1\">&lt;a id=\"pocoblobs\"&gt;</ph><ph id=\"ph2\">&lt;/a&gt;</ph> POCO <bpt id=\"p1\">[</bpt>(Plain Old CLR Object<ept id=\"p1\">](http://en.wikipedia.org/wiki/Plain_Old_CLR_Object)</ept>) queue messages"
    },
    {
      "content": "For a POCO stored as JSON in the queue message, you can use placeholders that name properties of the object in the <ph id=\"ph1\">`Queue`</ph> attribute's <ph id=\"ph2\">`blobPath`</ph> parameter.",
      "pos": [
        16739,
        16895
      ]
    },
    {
      "content": "You can also use <bpt id=\"p1\">[</bpt>queue metadata property names<ept id=\"p1\">](#queuemetadata)</ept> as placeholders.",
      "pos": [
        16896,
        16977
      ]
    },
    {
      "content": "The following example copies a blob to a new blob with a different extension.",
      "pos": [
        16980,
        17057
      ]
    },
    {
      "content": "The queue message is a <ph id=\"ph1\">`BlobInformation`</ph> object that includes <ph id=\"ph2\">`BlobName`</ph> and <ph id=\"ph3\">`BlobNameWithoutExtension`</ph> properties.",
      "pos": [
        17058,
        17173
      ]
    },
    {
      "content": "The property names are used as placeholders in the blob path for the <ph id=\"ph1\">`Blob`</ph> attributes.",
      "pos": [
        17174,
        17261
      ]
    },
    {
      "content": "The SDK uses the <bpt id=\"p1\">[</bpt>Newtonsoft.Json NuGet package<ept id=\"p1\">](http://www.nuget.org/packages/Newtonsoft.Json)</ept> to serialize and deserialize messages.",
      "pos": [
        17623,
        17757
      ]
    },
    {
      "content": "If you create queue messages in a program that doesn't use the WebJobs SDK, you can write code like the following example to create a POCO queue message that the SDK can parse.",
      "pos": [
        17758,
        17934
      ]
    },
    {
      "pos": [
        18188,
        18377
      ],
      "content": "If you need to do some work in your function before binding a blob to an object, you can use the attribute in the body of the function, <bpt id=\"p1\">[</bpt>as shown earlier for the Queue attribute<ept id=\"p1\">](#ibinder)</ept>."
    },
    {
      "pos": [
        18383,
        18456
      ],
      "content": "<ph id=\"ph1\">&lt;a id=\"blobattributetypes\"&gt;</ph><ph id=\"ph2\">&lt;/a&gt;</ph> Types you can use the Blob attribute with"
    },
    {
      "pos": [
        18459,
        18517
      ],
      "content": "The <ph id=\"ph1\">`Blob`</ph> attribute can be used with the following types:"
    },
    {
      "pos": [
        18521,
        18602
      ],
      "content": "<ph id=\"ph1\">`Stream`</ph> (read or write, specified by using the FileAccess constructor parameter)"
    },
    {
      "pos": [
        18635,
        18650
      ],
      "content": "<ph id=\"ph1\">`string`</ph> (read)"
    },
    {
      "pos": [
        18653,
        18756
      ],
      "content": "<ph id=\"ph1\">`out string`</ph> (write; creates a blob only if the string parameter is non-null when the function returns)"
    },
    {
      "content": "POCO (read)",
      "pos": [
        18759,
        18770
      ]
    },
    {
      "content": "out POCO (write; always creates a blob, creates as null object if POCO parameter is null when the function returns)",
      "pos": [
        18773,
        18888
      ]
    },
    {
      "pos": [
        18891,
        18916
      ],
      "content": "<ph id=\"ph1\">`CloudBlobStream`</ph> (write)"
    },
    {
      "pos": [
        18919,
        18947
      ],
      "content": "<ph id=\"ph1\">`ICloudBlob`</ph> (read or write)"
    },
    {
      "pos": [
        18950,
        18982
      ],
      "content": "<ph id=\"ph1\">`CloudBlockBlob`</ph> (read or write)"
    },
    {
      "pos": [
        18986,
        19017
      ],
      "content": "<ph id=\"ph1\">`CloudPageBlob`</ph> (read or write)"
    },
    {
      "pos": [
        19023,
        19072
      ],
      "content": "<ph id=\"ph1\">&lt;a id=\"poison\"&gt;</ph><ph id=\"ph2\">&lt;/a&gt;</ph> How to handle poison messages"
    },
    {
      "content": "Messages whose content causes a function to fail are called <bpt id=\"p1\">*</bpt>poison messages<ept id=\"p1\">*</ept>.",
      "pos": [
        19074,
        19152
      ]
    },
    {
      "content": "When the function fails, the queue message is not deleted and eventually is picked up again, causing the cycle to be repeated.",
      "pos": [
        19153,
        19279
      ]
    },
    {
      "content": "The SDK can automatically interrupt the cycle after a limited number of iterations, or you can do it manually.",
      "pos": [
        19280,
        19390
      ]
    },
    {
      "content": "Automatic poison message handling",
      "pos": [
        19396,
        19429
      ]
    },
    {
      "content": "The SDK will call a function up to 5 times to process a queue message.",
      "pos": [
        19431,
        19501
      ]
    },
    {
      "content": "If the fifth try fails, the message is moved to a poison queue.",
      "pos": [
        19502,
        19565
      ]
    },
    {
      "content": "<bpt id=\"p1\">[</bpt>The maximum number of retries is configurable<ept id=\"p1\">](#config)</ept>.",
      "pos": [
        19566,
        19623
      ]
    },
    {
      "content": "The poison queue is named <bpt id=\"p1\">*</bpt>{originalqueuename}<ept id=\"p1\">*</ept>-poison.",
      "pos": [
        19626,
        19681
      ]
    },
    {
      "content": "You can write a function to process messages from the poison queue by logging them or sending a notification that manual attention is needed.",
      "pos": [
        19682,
        19823
      ]
    },
    {
      "content": "In the following example the <ph id=\"ph1\">`CopyBlob`</ph> function will fail when a queue message contains the name of a blob that doesn't exist.",
      "pos": [
        19826,
        19953
      ]
    },
    {
      "content": "When that happens, the message is moved from the copyblobqueue queue to the copyblobqueue-poison queue.",
      "pos": [
        19954,
        20057
      ]
    },
    {
      "content": "The <ph id=\"ph1\">`ProcessPoisonMessage`</ph> then logs the poison message.",
      "pos": [
        20058,
        20114
      ]
    },
    {
      "content": "The following illustration shows console output from these functions when a poison message is processed.",
      "pos": [
        20689,
        20793
      ]
    },
    {
      "content": "Console output for poison message handling",
      "pos": [
        20797,
        20839
      ]
    },
    {
      "content": "Manual poison message handling",
      "pos": [
        20916,
        20946
      ]
    },
    {
      "content": "You can get the number of times a message has been picked up for processing by adding an <ph id=\"ph1\">`int`</ph> parameter named <ph id=\"ph2\">`dequeueCount`</ph> to your function.",
      "pos": [
        20948,
        21091
      ]
    },
    {
      "content": "You can then check the dequeue count in function code and perform your own poison message handling when the number exceeds a threshold, as shown in the following example.",
      "pos": [
        21092,
        21262
      ]
    },
    {
      "pos": [
        21835,
        21887
      ],
      "content": "<ph id=\"ph1\">&lt;a id=\"config\"&gt;</ph><ph id=\"ph2\">&lt;/a&gt;</ph> How to set configuration options"
    },
    {
      "pos": [
        21889,
        21976
      ],
      "content": "You can use the <ph id=\"ph1\">`JobHostConfiguration`</ph> type to set the following configuration options:"
    },
    {
      "content": "Set the SDK connection strings in code.",
      "pos": [
        21980,
        22019
      ]
    },
    {
      "pos": [
        22022,
        22086
      ],
      "content": "Configure <ph id=\"ph1\">`QueueTrigger`</ph> settings such as maximum dequeue count."
    },
    {
      "content": "Get queue names from configuration.",
      "pos": [
        22089,
        22124
      ]
    },
    {
      "pos": [
        22130,
        22187
      ],
      "content": "<ph id=\"ph1\">&lt;a id=\"setconnstr\"&gt;</ph><ph id=\"ph2\">&lt;/a&gt;</ph>Set SDK connection strings in code"
    },
    {
      "content": "Setting the SDK connection strings in code enables you to use your own connection string names in configuration files or environment variables, as shown in the following example.",
      "pos": [
        22189,
        22367
      ]
    },
    {
      "pos": [
        23192,
        23248
      ],
      "content": "<ph id=\"ph1\">&lt;a id=\"configqueue\"&gt;</ph><ph id=\"ph2\">&lt;/a&gt;</ph>Configure QueueTrigger  settings"
    },
    {
      "content": "You can configure the following settings that apply to the queue message processing:",
      "pos": [
        23250,
        23334
      ]
    },
    {
      "content": "The maximum number of queue messages that are picked up simultaneously to be executed in parallel (default is 16).",
      "pos": [
        23338,
        23452
      ]
    },
    {
      "content": "The maximum number of retries before a queue message is sent to a poison queue (default is 5).",
      "pos": [
        23455,
        23549
      ]
    },
    {
      "content": "The maximum wait time before polling again when a queue is empty (default is 1 minute).",
      "pos": [
        23552,
        23639
      ]
    },
    {
      "content": "The following example shows how to configure these settings:",
      "pos": [
        23641,
        23701
      ]
    },
    {
      "pos": [
        24079,
        24163
      ],
      "content": "<ph id=\"ph1\">&lt;a id=\"setnamesincode\"&gt;</ph><ph id=\"ph2\">&lt;/a&gt;</ph>Set values for WebJobs SDK constructor parameters in code"
    },
    {
      "content": "Sometimes you want to specify a queue name, a blob name or container, or a table name in code rather than hard-code it.",
      "pos": [
        24165,
        24284
      ]
    },
    {
      "content": "For example, you might want to specify the queue name for <ph id=\"ph1\">`QueueTrigger`</ph> in a configuration file or environment variable.",
      "pos": [
        24285,
        24406
      ]
    },
    {
      "content": "You can do that by passing in a <ph id=\"ph1\">`NameResolver`</ph> object to the <ph id=\"ph2\">`JobHostConfiguration`</ph> type.",
      "pos": [
        24409,
        24498
      ]
    },
    {
      "content": "You include special placeholders surrounded by percent (%) signs in WebJobs SDK attribute constructor parameters, and your <ph id=\"ph1\">`NameResolver`</ph> code specifies the actual values to be used in place of those placeholders.",
      "pos": [
        24499,
        24712
      ]
    },
    {
      "content": "For example, suppose you want to use a queue named logqueuetest in the test environment and one named logqueueprod in production.",
      "pos": [
        24714,
        24843
      ]
    },
    {
      "content": "Instead of a hard-coded queue name, you want to specify the name of an entry in the <ph id=\"ph1\">`appSettings`</ph> collection that would have the actual queue name.",
      "pos": [
        24844,
        24991
      ]
    },
    {
      "content": "If the <ph id=\"ph1\">`appSettings`</ph> key is logqueue, your function could look like the following example.",
      "pos": [
        24992,
        25082
      ]
    },
    {
      "pos": [
        25232,
        25341
      ],
      "content": "Your <ph id=\"ph1\">`NameResolver`</ph> class could then get the queue name from <ph id=\"ph2\">`appSettings`</ph> as shown in the following example:"
    },
    {
      "pos": [
        25568,
        25663
      ],
      "content": "You pass the <ph id=\"ph1\">`NameResolver`</ph> class in to the <ph id=\"ph2\">`JobHost`</ph> object as shown in the following example."
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Note:<ept id=\"p1\">**</ept> Queue, table, and blob names are resolved each time a function is called, but blob container names are resolved only when the application starts.",
      "pos": [
        25936,
        26091
      ]
    },
    {
      "content": "You can't change blob container name while the job is running.",
      "pos": [
        26092,
        26154
      ]
    },
    {
      "pos": [
        26160,
        26213
      ],
      "content": "<ph id=\"ph1\">&lt;a id=\"manual\"&gt;</ph><ph id=\"ph2\">&lt;/a&gt;</ph>How to trigger a function manually"
    },
    {
      "pos": [
        26215,
        26398
      ],
      "content": "To trigger a function manually, use the <ph id=\"ph1\">`Call`</ph> or <ph id=\"ph2\">`CallAsync`</ph> method on the <ph id=\"ph3\">`JobHost`</ph> object and the <ph id=\"ph4\">`NoAutomaticTrigger`</ph> attribute on the function, as shown in the following example."
    },
    {
      "pos": [
        27031,
        27065
      ],
      "content": "<ph id=\"ph1\">&lt;a id=\"logs\"&gt;</ph><ph id=\"ph2\">&lt;/a&gt;</ph>How to write logs"
    },
    {
      "content": "The Dashboard shows logs in two places: the page for the WebJob, and the page for a particular WebJob invocation.",
      "pos": [
        27067,
        27180
      ]
    },
    {
      "content": "Logs in WebJob page",
      "pos": [
        27185,
        27204
      ]
    },
    {
      "content": "Logs in function invocation page",
      "pos": [
        27289,
        27321
      ]
    },
    {
      "content": "Output from Console methods that you call in a function or in the <ph id=\"ph1\">`Main()`</ph> method appears in the Dashboard page for the WebJob, not in the page for a particular method invocation.",
      "pos": [
        27401,
        27580
      ]
    },
    {
      "content": "Output from the TextWriter object that you get from a parameter in your method signature appears in the Dashboard page for a method invocation.",
      "pos": [
        27581,
        27724
      ]
    },
    {
      "content": "Console output can't be linked to a particular method invocation because the Console is single-threaded, while many job functions may be running at the same time.",
      "pos": [
        27726,
        27888
      ]
    },
    {
      "content": "That's why the  SDK provides each function invocation with its own unique log writer object.",
      "pos": [
        27889,
        27981
      ]
    },
    {
      "content": "To write <bpt id=\"p1\">[</bpt>application tracing logs<ept id=\"p1\">](web-sites-dotnet-troubleshoot-visual-studio.md#logsoverview)</ept>, use <ph id=\"ph1\">`Console.Out`</ph> (creates logs marked as INFO) and <ph id=\"ph2\">`Console.Error`</ph> (creates logs marked as ERROR).",
      "pos": [
        27983,
        28180
      ]
    },
    {
      "content": "An alternative is to use <bpt id=\"p1\">[</bpt>Trace or TraceSource<ept id=\"p1\">](http://blogs.msdn.com/b/mcsuksoldev/archive/2014/09/04/adding-trace-to-azure-web-sites-and-web-jobs.aspx)</ept>, which provides Verbose, Warning, and Critical levels in addition to Info and Error.",
      "pos": [
        28181,
        28419
      ]
    },
    {
      "content": "Application tracing logs appear in the web app log files, Azure tables, or Azure blobs depending on how you configure your Azure web app.",
      "pos": [
        28420,
        28557
      ]
    },
    {
      "content": "As is true of all Console output, the most recent 100 application logs also appear in the Dashboard page for the WebJob, not the page for a function invocation.",
      "pos": [
        28558,
        28718
      ]
    },
    {
      "content": "Console output appears in the Dashboard only if the program is running in an Azure WebJob, not if the program is running locally or in some other environment.",
      "pos": [
        28721,
        28879
      ]
    },
    {
      "content": "Disable dashboard logging for high throughput scenarios.",
      "pos": [
        28881,
        28937
      ]
    },
    {
      "content": "By default, the SDK writes logs to storage, and this activity could degrade performance when you are processing many messages.",
      "pos": [
        28938,
        29064
      ]
    },
    {
      "content": "To disable logging, set the dashboard connection string to null as shown in the following example.",
      "pos": [
        29065,
        29163
      ]
    },
    {
      "content": "The following example shows several ways to write logs:",
      "pos": [
        29366,
        29421
      ]
    },
    {
      "pos": [
        29830,
        29998
      ],
      "content": "In the WebJobs SDK Dashboard, the output from the <ph id=\"ph1\">`TextWriter`</ph> object shows up when you go to the page for a particular function invocation and click <bpt id=\"p1\">**</bpt>Toggle Output<ept id=\"p1\">**</ept>:"
    },
    {
      "content": "Click function invocation link",
      "pos": [
        30002,
        30032
      ]
    },
    {
      "content": "Logs in function invocation page",
      "pos": [
        30121,
        30153
      ]
    },
    {
      "pos": [
        30233,
        30416
      ],
      "content": "In the WebJobs SDK Dashboard, the most recent 100 lines of Console output show up when you go to the page for the WebJob (not for the function invocation) and click <bpt id=\"p1\">**</bpt>Toggle Output<ept id=\"p1\">**</ept>."
    },
    {
      "content": "Click Toggle Output",
      "pos": [
        30421,
        30440
      ]
    },
    {
      "pos": [
        30523,
        30651
      ],
      "content": "In a continuous WebJob, application logs show up in /data/jobs/continuous/<bpt id=\"p1\">*</bpt>{webjobname}<ept id=\"p1\">*</ept>/job_log.txt in the web app file system."
    },
    {
      "content": "In an Azure blob the application logs look like this:",
      "pos": [
        30874,
        30927
      ]
    },
    {
      "content": "2014-09-26T21:01:13,Information,contosoadsnew,491e54,635473620738373502,0,17404,17,Console.Write - Hello world!,",
      "pos": [
        30936,
        31048
      ]
    },
    {
      "content": "2014-09-26T21:01:13,Error,contosoadsnew,491e54,635473620738373502,0,17404,19,Console.Error - Hello world!,",
      "pos": [
        31057,
        31163
      ]
    },
    {
      "content": "2014-09-26T21:01:13,Information,contosoadsnew,491e54,635473620738529920,0,17404,17,Console.Out - Hello world!,",
      "pos": [
        31172,
        31282
      ]
    },
    {
      "pos": [
        31284,
        31364
      ],
      "content": "And in an Azure table the <ph id=\"ph1\">`Console.Out`</ph> and <ph id=\"ph2\">`Console.Error`</ph> logs look like this:"
    },
    {
      "content": "Info log in table",
      "pos": [
        31368,
        31385
      ]
    },
    {
      "content": "Error log in table",
      "pos": [
        31463,
        31481
      ]
    },
    {
      "pos": [
        31561,
        31594
      ],
      "content": "<ph id=\"ph1\">&lt;a id=\"nextsteps\"&gt;</ph><ph id=\"ph2\">&lt;/a&gt;</ph> Next steps"
    },
    {
      "content": "This guide has provided code samples that show how to handle common scenarios for working with Azure queues.",
      "pos": [
        31596,
        31704
      ]
    },
    {
      "content": "For more information about how to use Azure WebJobs and the WebJobs SDK, see <bpt id=\"p1\">[</bpt>Azure WebJobs Recommended Resources<ept id=\"p1\">](http://go.microsoft.com/fwlink/?linkid=390226)</ept>.",
      "pos": [
        31705,
        31867
      ]
    },
    {
      "content": "test",
      "pos": [
        31871,
        31875
      ]
    }
  ],
  "content": "<properties \n    pageTitle=\"How to use Azure queue storage with the WebJobs SDK\" \n    description=\"Learn how to use Azure queue storage with the WebJobs SDK. Create and delete queues; insert, peek, get, and delete queue messages, and more.\" \n    services=\"app-service\\web, storage\" \n    documentationCenter=\".net\" \n    authors=\"tdykstra\" \n    manager=\"wpickett\" \n    editor=\"jimbe\"/>\n\n<tags \n    ms.service=\"app-service-web\" \n    ms.workload=\"web\" \n    ms.tgt_pltfrm=\"na\" \n    ms.devlang=\"dotnet\" \n    ms.topic=\"article\" \n    ms.date=\"06/29/2015\" \n    ms.author=\"tdykstra\"/>\n\n# How to use Azure queue storage with the WebJobs SDK\n\n## Overview\n\nThis guide provides C# code samples that show how to use the Azure WebJobs SDK version 1.x with the Azure queue storage service.\n\nThe guide assumes you know [how to create a WebJob project in Visual Studio with connection strings that point to your storage account](websites-dotnet-webjobs-sdk-get-started.md).\n\nMost of the code snippets only show functions, not the code that creates the `JobHost` object as in this example:\n\n        static void Main(string[] args)\n        {\n            JobHost host = new JobHost();\n            host.RunAndBlock();\n        }\n        \nThe guide includes the following topics:\n\n-   [How to trigger a function when a queue message is received](#trigger)\n    - String queue messages\n    - POCO queue messages\n    - Async functions\n    - Types the QueueTrigger attribute works with\n    - Polling algorithm\n    - Multiple instances\n    - Parallel execution\n    - Get queue or queue message metadata\n    - Graceful shutdown\n-   [How to create a queue message while processing a queue message](#createqueue)\n    - String queue messages\n    - POCO queue messages\n    - Create multiple messages or in async functions\n    - Types the Queue attribute works with\n    - Use WebJobs SDK attributes in the body of a function\n-   [How to read and write blobs while processing a queue message](#blobs)\n    - String queue messages\n    - POCO queue messages\n    - Types the Blob attribute works with\n-   [How to handle poison messages](#poison)\n    - Automatic poison message handling\n    - Manual poison message handling\n-   [How to set configuration options](#config)\n    - Set SDK connection strings in code\n    - Configure QueueTrigger settings\n    - Set values for WebJobs SDK constructor parameters in code\n-   [How to trigger a function manually](#manual)\n-   [How to write logs](#logs)\n-   [Next steps](#nextsteps)\n\n## <a id=\"trigger\"></a> How to trigger a function when a queue message is received\n\nTo write a function that the WebJobs SDK calls when a queue message is received, use the `QueueTrigger` attribute. The attribute constructor takes a string parameter that specifies the name of the queue to poll. You can also [set the queue name dynamically](#config).\n\n### String queue messages\n\nIn the following example, the queue contains a string message, so `QueueTrigger` is applied to a string parameter named `logMessage` which contains the content of the queue message. The function [writes a log message to the Dashboard](#logs).\n \n\n        public static void ProcessQueueMessage([QueueTrigger(\"logqueue\")] string logMessage, TextWriter logger)\n        {\n            logger.WriteLine(logMessage);\n        }\n\nBesides `string`, the parameter may be a byte array, a `CloudQueueMessage` object, or a POCO  that you define.\n\n### POCO [(Plain Old CLR Object](http://en.wikipedia.org/wiki/Plain_Old_CLR_Object)) queue messages\n\nIn the following example, the queue message contains JSON for a `BlobInformation` object which includes a `BlobName` property. The SDK automatically deserializes the object.\n\n        public static void WriteLogPOCO([QueueTrigger(\"logqueue\")] BlobInformation blobInfo, TextWriter logger)\n        {\n            logger.WriteLine(\"Queue message refers to blob: \" + blobInfo.BlobName);\n        }\n\nThe SDK uses the [Newtonsoft.Json NuGet package](http://www.nuget.org/packages/Newtonsoft.Json) to serialize and deserialize messages. If you create queue messages in a program that doesn't use the WebJobs SDK, you can write code like the following example to create a POCO queue message that the SDK can parse. \n\n        BlobInformation blobInfo = new BlobInformation() { BlobName = \"log.txt\" };\n        var queueMessage = new CloudQueueMessage(JsonConvert.SerializeObject(blobInfo));\n        logQueue.AddMessage(queueMessage);\n\n### Async functions\n\nThe following async function [writes a log to the Dashboard](#logs).\n\n        public async static Task ProcessQueueMessageAsync([QueueTrigger(\"logqueue\")] string logMessage, TextWriter logger)\n        {\n            await logger.WriteLineAsync(logMessage);\n        }\n\nAsync functions may take a [cancellation token](http://www.asp.net/mvc/overview/performance/using-asynchronous-methods-in-aspnet-mvc-4#CancelToken), as shown in the following example which copies a blob. (For an explanation of the `queueTrigger` placeholder, see the [Blobs](#blobs) section.)\n\n        public async static Task ProcessQueueMessageAsyncCancellationToken(\n            [QueueTrigger(\"blobcopyqueue\")] string blobName, \n            [Blob(\"textblobs/{queueTrigger}\",FileAccess.Read)] Stream blobInput,\n            [Blob(\"textblobs/{queueTrigger}-new\",FileAccess.Write)] Stream blobOutput,\n            CancellationToken token)\n        {\n            await blobInput.CopyToAsync(blobOutput, 4096, token);\n        }\n\n### <a id=\"qtattributetypes\"></a> Types the QueueTrigger attribute works with\n\nYou can use `QueueTrigger` with the following types:\n\n* `string`\n* A POCO type serialized as JSON\n* `byte[]`\n* `CloudQueueMessage`\n\n### <a id=\"polling\"></a> Polling algorithm\n\nThe SDK implements a random exponential back-off algorithm to reduce the effect of idle-queue polling on storage transaction costs.  When a message is found, the SDK waits two seconds and then checks for another message; when no message is found it waits about four seconds before trying again. After subsequent failed attempts to get a queue message, the wait time continues to increase until it reaches the maximum wait time, which defaults to one minute. [The maximum wait time is configurable](#config).\n\n### <a id=\"instances\"></a> Multiple instances\n\nIf your web app runs on multiple instances, a continuous WebJobs runs on each machine, and each machine will wait for triggers and attempt to run functions. In some scenarios this can lead to some functions processing the same data twice, so functions should be idempotent (written so that calling them repeatedly with the same input data doesn't produce duplicate results).  \n\n### <a id=\"parallel\"></a> Parallel execution\n\nIf you have multiple functions listening on different queues, the SDK will call them in parallel when messages are received simultaneously. \n\nThe same is true when multiple messages are received for a single queue. By default, the SDK gets a batch of 16 queue messages at a time and executes the function that processes them in parallel. [The batch size is configurable](#config). When the number being processed gets down to half of the batch size, the SDK gets another batch and starts processing those messages. Therefore the maximum number of concurrent messages being processed per function is one and a half times the batch size. This limit applies separately to each function that has a `QueueTrigger` attribute. If you don't want parallel execution for messages received on one queue, set the batch size to 1.\n\n### <a id=\"queuemetadata\"></a>Get queue or queue message metadata\n\nYou can get the following message properties by adding parameters to the method signature:\n\n* `DateTimeOffset` expirationTime\n* `DateTimeOffset` insertionTime\n* `DateTimeOffset` nextVisibleTime\n* `string` queueTrigger (contains message text)\n* `string` id\n* `string` popReceipt\n* `int` dequeueCount\n\nIf you want to work directly with the Azure storage API, you can also add a `CloudStorageAccount` parameter.\n\nThe following example writes all of this metadata to an INFO application log. In the example, both logMessage and queueTrigger contain the content of the queue message.\n\n        public static void WriteLog([QueueTrigger(\"logqueue\")] string logMessage,\n            DateTimeOffset expirationTime,\n            DateTimeOffset insertionTime,\n            DateTimeOffset nextVisibleTime,\n            string id,\n            string popReceipt,\n            int dequeueCount,\n            string queueTrigger,\n            CloudStorageAccount cloudStorageAccount,\n            TextWriter logger)\n        {\n            logger.WriteLine(\n                \"logMessage={0}\\n\" +\n            \"expirationTime={1}\\ninsertionTime={2}\\n\" +\n                \"nextVisibleTime={3}\\n\" +\n                \"id={4}\\npopReceipt={5}\\ndequeueCount={6}\\n\" +\n                \"queue endpoint={7} queueTrigger={8}\",\n                logMessage, expirationTime,\n                insertionTime,\n                nextVisibleTime, id,\n                popReceipt, dequeueCount,\n                cloudStorageAccount.QueueEndpoint,\n                queueTrigger);\n        }\n\nHere is a sample log written by the sample code:\n\n        logMessage=Hello world!\n        expirationTime=10/14/2014 10:31:04 PM +00:00\n        insertionTime=10/7/2014 10:31:04 PM +00:00\n        nextVisibleTime=10/7/2014 10:41:23 PM +00:00\n        id=262e49cd-26d3-4303-ae88-33baf8796d91\n        popReceipt=AgAAAAMAAAAAAAAAfc9H0n/izwE=\n        dequeueCount=1\n        queue endpoint=https://contosoads.queue.core.windows.net/\n        queueTrigger=Hello world!\n\n### <a id=\"graceful\"></a>Graceful shutdown\n\nA function that runs in a continuous WebJob can accept a `CancellationToken` parameter which enables the operating system to notify the function when the WebJob is about to be terminated. You can use this notification to make sure the function doesn't terminate unexpectedly in a way that leaves data in an inconsistent state.\n\nThe following example shows how to check for impending WebJob termination in a function.\n\n    public static void GracefulShutdownDemo(\n                [QueueTrigger(\"inputqueue\")] string inputText,\n                TextWriter logger,\n                CancellationToken token)\n    {\n        for (int i = 0; i < 100; i++)\n        {\n            if (token.IsCancellationRequested)\n            {\n                logger.WriteLine(\"Function was cancelled at iteration {0}\", i);\n                break;\n            }\n            Thread.Sleep(1000);\n            logger.WriteLine(\"Normal processing for queue message={0}\", inputText);\n        }\n    }\n\n**Note:** The Dashboard might not correctly show the status and output of functions that have been shut down.\n \nFor more information, see [WebJobs Graceful Shutdown](http://blog.amitapple.com/post/2014/05/webjobs-graceful-shutdown/#.VCt1GXl0wpR).   \n\n## <a id=\"createqueue\"></a> How to create a queue message while processing a queue message\n\nTo write a function that creates a new queue message, use the `Queue` attribute. Like `QueueTrigger`, you pass in the queue name as a string or you can [set the queue name dynamically](#config).\n\n### String queue messages\n\nThe following non-async code sample creates a new queue message in the queue named \"outputqueue\" with the same content as the queue message received in the queue named \"inputqueue\". (For async functions use `IAsyncCollector<T>` as shown later in this section.)\n\n\n        public static void CreateQueueMessage(\n            [QueueTrigger(\"inputqueue\")] string queueMessage,\n            [Queue(\"outputqueue\")] out string outputQueueMessage )\n        {\n            outputQueueMessage = queueMessage;\n        }\n  \n### POCO [(Plain Old CLR Object](http://en.wikipedia.org/wiki/Plain_Old_CLR_Object)) queue messages\n\nTo create a queue message that contains a POCO rather than a string, pass the POCO type as an output parameter to the `Queue` attribute constructor.\n \n        public static void CreateQueueMessage(\n            [QueueTrigger(\"inputqueue\")] BlobInformation blobInfoInput,\n            [Queue(\"outputqueue\")] out BlobInformation blobInfoOutput )\n        {\n            blobInfoOutput = blobInfoInput;\n        }\n\nThe SDK automatically serializes the object to JSON. A queue message is always created, even if the object is null.\n\n### Create multiple messages or in async functions\n\nTo create multiple messages, make the parameter type for the output queue `ICollector<T>` or `IAsyncCollector<T>`, as shown in the following example.\n\n        public static void CreateQueueMessages(\n            [QueueTrigger(\"inputqueue\")] string queueMessage,\n            [Queue(\"outputqueue\")] ICollector<string> outputQueueMessage,\n            TextWriter logger)\n        {\n            logger.WriteLine(\"Creating 2 messages in outputqueue\");\n            outputQueueMessage.Add(queueMessage + \"1\");\n            outputQueueMessage.Add(queueMessage + \"2\");\n        }\n\nEach queue message is created immediately when the `Add` method is called.\n\n### Types that the Queue attribute works with\n\nYou can use the `Queue` attribute on the following parameter types:\n\n* `out string` (creates queue message if parameter value is non-null when the function ends)\n* `out byte[]` (works like `string`) \n* `out CloudQueueMessage` (works like `string`) \n* `out POCO` (a serializable type, creates a message with a null object if the paramter is null when the function ends)\n* `ICollector`\n* `IAsyncCollector`\n* `CloudQueue` (for creating messages manually using the Azure Storage API directly)\n\n### <a id=\"ibinder\"></a>Use WebJobs SDK attributes in the body of a function\n\nIf you need to do some work in your function before using a WebJobs SDK attribute such as `Queue`, `Blob`, or `Table`, you can use the `IBinder` interface.\n\nThe following example takes an input queue message and creates a new message with the same content in an output queue. The output queue name is set by code in the body of the function.\n\n        public static void CreateQueueMessage(\n            [QueueTrigger(\"inputqueue\")] string queueMessage,\n            IBinder binder)\n        {\n            string outputQueueName = \"outputqueue\" + DateTime.Now.Month.ToString();\n            QueueAttribute queueAttribute = new QueueAttribute(outputQueueName);\n            CloudQueue outputQueue = binder.Bind<CloudQueue>(queueAttribute);\n            outputQueue.AddMessage(new CloudQueueMessage(queueMessage));\n        }\n\nThe `IBinder` interface can also be used with the `Table` and `Blob` attributes.\n\n## <a id=\"blobs\"></a> How to read and write blobs and tables while processing a queue message\n\nThe `Blob` and `Table` attributes enable you to read and write blobs and tables. The samples in this section apply to blobs. For code samples that show how to trigger processes when blobs are created or updated, see [How to use Azure blob storage with the WebJobs SDK](websites-dotnet-webjobs-sdk-storage-blobs-how-to.md), and for code samples that read and write tables, see [How to use Azure table storage with the WebJobs SDK](websites-dotnet-webjobs-sdk-storage-tables-how-to.md).\n\n### String queue messages triggering blob operations\n\nFor a queue message that contains a string, `queueTrigger` is a placeholder you can use in the `Blob` attribute's `blobPath` parameter that contains the contents of the message. \n\nThe following example uses `Stream` objects to read and write blobs. The queue message is the name of a blob located in the textblobs container. A copy of the blob with \"-new\" appended to the name is created in the same container. \n\n        public static void ProcessQueueMessage(\n            [QueueTrigger(\"blobcopyqueue\")] string blobName, \n            [Blob(\"textblobs/{queueTrigger}\",FileAccess.Read)] Stream blobInput,\n            [Blob(\"textblobs/{queueTrigger}-new\",FileAccess.Write)] Stream blobOutput)\n        {\n            blobInput.CopyTo(blobOutput, 4096);\n        }\n\nThe `Blob` attribute constructor takes a `blobPath` parameter that specifies the container and blob name. For more information about this placeholder, see [How to use Azure blob storage with the WebJobs SDK](websites-dotnet-webjobs-sdk-storage-blobs-how-to.md), \n\nWhen the attribute decorates a `Stream` object, another constructor parameter specifies the `FileAccess` mode as read, write, or read/write. \n\nThe following example uses a `CloudBlockBlob` object to delete a blob. The queue message is the name of the blob.\n\n        public static void DeleteBlob(\n            [QueueTrigger(\"deleteblobqueue\")] string blobName,\n            [Blob(\"textblobs/{queueTrigger}\")] CloudBlockBlob blobToDelete)\n        {\n            blobToDelete.Delete();\n        }\n\n### <a id=\"pocoblobs\"></a> POCO [(Plain Old CLR Object](http://en.wikipedia.org/wiki/Plain_Old_CLR_Object)) queue messages\n\nFor a POCO stored as JSON in the queue message, you can use placeholders that name properties of the object in the `Queue` attribute's `blobPath` parameter. You can also use [queue metadata property names](#queuemetadata) as placeholders. \n\nThe following example copies a blob to a new blob with a different extension. The queue message is a `BlobInformation` object that includes `BlobName` and `BlobNameWithoutExtension` properties. The property names are used as placeholders in the blob path for the `Blob` attributes. \n \n        public static void CopyBlobPOCO(\n            [QueueTrigger(\"copyblobqueue\")] BlobInformation blobInfo,\n            [Blob(\"textblobs/{BlobName}\", FileAccess.Read)] Stream blobInput,\n            [Blob(\"textblobs/{BlobNameWithoutExtension}.txt\", FileAccess.Write)] Stream blobOutput)\n        {\n            blobInput.CopyTo(blobOutput, 4096);\n        }\n\nThe SDK uses the [Newtonsoft.Json NuGet package](http://www.nuget.org/packages/Newtonsoft.Json) to serialize and deserialize messages. If you create queue messages in a program that doesn't use the WebJobs SDK, you can write code like the following example to create a POCO queue message that the SDK can parse.\n\n        BlobInformation blobInfo = new BlobInformation() { BlobName = \"boot.log\", BlobNameWithoutExtension = \"boot\" };\n        var queueMessage = new CloudQueueMessage(JsonConvert.SerializeObject(blobInfo));\n        logQueue.AddMessage(queueMessage);\n\nIf you need to do some work in your function before binding a blob to an object, you can use the attribute in the body of the function, [as shown earlier for the Queue attribute](#ibinder).\n\n### <a id=\"blobattributetypes\"></a> Types you can use the Blob attribute with\n \nThe `Blob` attribute can be used with the following types:\n\n* `Stream` (read or write, specified by using the FileAccess constructor parameter)\n* `TextReader`\n* `TextWriter`\n* `string` (read)\n* `out string` (write; creates a blob only if the string parameter is non-null when the function returns)\n* POCO (read)\n* out POCO (write; always creates a blob, creates as null object if POCO parameter is null when the function returns)\n* `CloudBlobStream` (write)\n* `ICloudBlob` (read or write)\n* `CloudBlockBlob` (read or write) \n* `CloudPageBlob` (read or write) \n\n## <a id=\"poison\"></a> How to handle poison messages\n\nMessages whose content causes a function to fail are called *poison messages*. When the function fails, the queue message is not deleted and eventually is picked up again, causing the cycle to be repeated. The SDK can automatically interrupt the cycle after a limited number of iterations, or you can do it manually.\n\n### Automatic poison message handling\n\nThe SDK will call a function up to 5 times to process a queue message. If the fifth try fails, the message is moved to a poison queue. [The maximum number of retries is configurable](#config). \n\nThe poison queue is named *{originalqueuename}*-poison. You can write a function to process messages from the poison queue by logging them or sending a notification that manual attention is needed. \n\nIn the following example the `CopyBlob` function will fail when a queue message contains the name of a blob that doesn't exist. When that happens, the message is moved from the copyblobqueue queue to the copyblobqueue-poison queue. The `ProcessPoisonMessage` then logs the poison message.\n\n        public static void CopyBlob(\n            [QueueTrigger(\"copyblobqueue\")] string blobName,\n            [Blob(\"textblobs/{queueTrigger}\", FileAccess.Read)] Stream blobInput,\n            [Blob(\"textblobs/{queueTrigger}-new\", FileAccess.Write)] Stream blobOutput)\n        {\n            blobInput.CopyTo(blobOutput, 4096);\n        }\n        \n        public static void ProcessPoisonMessage(\n            [QueueTrigger(\"copyblobqueue-poison\")] string blobName, TextWriter logger)\n        {\n            logger.WriteLine(\"Failed to copy blob, name=\" + blobName);\n        }\n\nThe following illustration shows console output from these functions when a poison message is processed.\n\n![Console output for poison message handling](./media/websites-dotnet-webjobs-sdk-storage-queues-how-to/poison.png)\n\n### Manual poison message handling\n\nYou can get the number of times a message has been picked up for processing by adding an `int` parameter named `dequeueCount` to your function. You can then check the dequeue count in function code and perform your own poison message handling when the number exceeds a threshold, as shown in the following example.\n\n        public static void CopyBlob(\n            [QueueTrigger(\"copyblobqueue\")] string blobName, int dequeueCount,\n            [Blob(\"textblobs/{queueTrigger}\", FileAccess.Read)] Stream blobInput,\n            [Blob(\"textblobs/{queueTrigger}-new\", FileAccess.Write)] Stream blobOutput,\n            TextWriter logger)\n        {\n            if (dequeueCount > 3)\n            {\n                logger.WriteLine(\"Failed to copy blob, name=\" + blobName);\n            }\n            else\n            {\n            blobInput.CopyTo(blobOutput, 4096);\n            }\n        }\n\n## <a id=\"config\"></a> How to set configuration options\n\nYou can use the `JobHostConfiguration` type to set the following configuration options:\n\n* Set the SDK connection strings in code.\n* Configure `QueueTrigger` settings such as maximum dequeue count.\n* Get queue names from configuration.\n\n### <a id=\"setconnstr\"></a>Set SDK connection strings in code\n\nSetting the SDK connection strings in code enables you to use your own connection string names in configuration files or environment variables, as shown in the following example.\n\n        static void Main(string[] args)\n        {\n            var _storageConn = ConfigurationManager\n                .ConnectionStrings[\"MyStorageConnection\"].ConnectionString;\n        \n            var _dashboardConn = ConfigurationManager\n                .ConnectionStrings[\"MyDashboardConnection\"].ConnectionString;\n        \n            var _serviceBusConn = ConfigurationManager\n                .ConnectionStrings[\"MyServiceBusConnection\"].ConnectionString;\n        \n            JobHostConfiguration config = new JobHostConfiguration();\n            config.StorageConnectionString = _storageConn;\n            config.DashboardConnectionString = _dashboardConn;\n            config.ServiceBusConnectionString = _serviceBusConn;\n            JobHost host = new JobHost(config);\n            host.RunAndBlock();\n        }\n\n### <a id=\"configqueue\"></a>Configure QueueTrigger  settings\n\nYou can configure the following settings that apply to the queue message processing:\n\n- The maximum number of queue messages that are picked up simultaneously to be executed in parallel (default is 16).\n- The maximum number of retries before a queue message is sent to a poison queue (default is 5).\n- The maximum wait time before polling again when a queue is empty (default is 1 minute).\n\nThe following example shows how to configure these settings:\n\n        static void Main(string[] args)\n        {\n            JobHostConfiguration config = new JobHostConfiguration();\n            config.Queues.BatchSize = 8;\n            config.Queues.MaxDequeueCount = 4;\n            config.Queues.MaxPollingInterval = TimeSpan.FromSeconds(15);\n            JobHost host = new JobHost(config);\n            host.RunAndBlock();\n        }\n\n### <a id=\"setnamesincode\"></a>Set values for WebJobs SDK constructor parameters in code\n\nSometimes you want to specify a queue name, a blob name or container, or a table name in code rather than hard-code it. For example, you might want to specify the queue name for `QueueTrigger` in a configuration file or environment variable. \n\nYou can do that by passing in a `NameResolver` object to the `JobHostConfiguration` type. You include special placeholders surrounded by percent (%) signs in WebJobs SDK attribute constructor parameters, and your `NameResolver` code specifies the actual values to be used in place of those placeholders.\n\nFor example, suppose you want to use a queue named logqueuetest in the test environment and one named logqueueprod in production. Instead of a hard-coded queue name, you want to specify the name of an entry in the `appSettings` collection that would have the actual queue name. If the `appSettings` key is logqueue, your function could look like the following example.\n\n        public static void WriteLog([QueueTrigger(\"%logqueue%\")] string logMessage)\n        {\n            Console.WriteLine(logMessage);\n        }\n\nYour `NameResolver` class could then get the queue name from `appSettings` as shown in the following example:\n\n        public class QueueNameResolver : INameResolver\n        {\n            public string Resolve(string name)\n            {\n                return ConfigurationManager.AppSettings[name].ToString();\n            }\n        }\n\nYou pass the `NameResolver` class in to the `JobHost` object as shown in the following example.\n\n        static void Main(string[] args)\n        {\n            JobHostConfiguration config = new JobHostConfiguration();\n            config.NameResolver = new QueueNameResolver();\n            JobHost host = new JobHost(config);\n            host.RunAndBlock();\n        }\n \n**Note:** Queue, table, and blob names are resolved each time a function is called, but blob container names are resolved only when the application starts. You can't change blob container name while the job is running. \n\n## <a id=\"manual\"></a>How to trigger a function manually\n\nTo trigger a function manually, use the `Call` or `CallAsync` method on the `JobHost` object and the `NoAutomaticTrigger` attribute on the function, as shown in the following example. \n\n        public class Program\n        {\n            static void Main(string[] args)\n            {\n                JobHost host = new JobHost();\n                host.Call(typeof(Program).GetMethod(\"CreateQueueMessage\"), new { value = \"Hello world!\" });\n            }\n        \n            [NoAutomaticTrigger]\n            public static void CreateQueueMessage(\n                TextWriter logger, \n                string value, \n                [Queue(\"outputqueue\")] out string message)\n            {\n                message = value;\n                logger.WriteLine(\"Creating queue message: \", message);\n            }\n        }\n\n## <a id=\"logs\"></a>How to write logs\n\nThe Dashboard shows logs in two places: the page for the WebJob, and the page for a particular WebJob invocation. \n\n![Logs in WebJob page](./media/websites-dotnet-webjobs-sdk-storage-queues-how-to/dashboardapplogs.png)\n\n![Logs in function invocation page](./media/websites-dotnet-webjobs-sdk-storage-queues-how-to/dashboardlogs.png)\n\nOutput from Console methods that you call in a function or in the `Main()` method appears in the Dashboard page for the WebJob, not in the page for a particular method invocation. Output from the TextWriter object that you get from a parameter in your method signature appears in the Dashboard page for a method invocation.\n\nConsole output can't be linked to a particular method invocation because the Console is single-threaded, while many job functions may be running at the same time. That's why the  SDK provides each function invocation with its own unique log writer object.\n\nTo write [application tracing logs](web-sites-dotnet-troubleshoot-visual-studio.md#logsoverview), use `Console.Out` (creates logs marked as INFO) and `Console.Error` (creates logs marked as ERROR). An alternative is to use [Trace or TraceSource](http://blogs.msdn.com/b/mcsuksoldev/archive/2014/09/04/adding-trace-to-azure-web-sites-and-web-jobs.aspx), which provides Verbose, Warning, and Critical levels in addition to Info and Error. Application tracing logs appear in the web app log files, Azure tables, or Azure blobs depending on how you configure your Azure web app. As is true of all Console output, the most recent 100 application logs also appear in the Dashboard page for the WebJob, not the page for a function invocation. \n\nConsole output appears in the Dashboard only if the program is running in an Azure WebJob, not if the program is running locally or in some other environment.\n\nDisable dashboard logging for high throughput scenarios. By default, the SDK writes logs to storage, and this activity could degrade performance when you are processing many messages. To disable logging, set the dashboard connection string to null as shown in the following example.\n\n        JobHostConfiguration config = new JobHostConfiguration();       \n        config.DashboardConnectionString = “”;        \n        JobHost host = new JobHost(config);\n        host.RunAndBlock();\n\nThe following example shows several ways to write logs:\n\n        public static void WriteLog(\n            [QueueTrigger(\"logqueue\")] string logMessage,\n            TextWriter logger)\n        {\n            Console.WriteLine(\"Console.Write - \" + logMessage);\n            Console.Out.WriteLine(\"Console.Out - \" + logMessage);\n            Console.Error.WriteLine(\"Console.Error - \" + logMessage);\n            logger.WriteLine(\"TextWriter - \" + logMessage);\n        }\n\nIn the WebJobs SDK Dashboard, the output from the `TextWriter` object shows up when you go to the page for a particular function invocation and click **Toggle Output**:\n\n![Click function invocation link](./media/websites-dotnet-webjobs-sdk-storage-queues-how-to/dashboardinvocations.png)\n\n![Logs in function invocation page](./media/websites-dotnet-webjobs-sdk-storage-queues-how-to/dashboardlogs.png)\n\nIn the WebJobs SDK Dashboard, the most recent 100 lines of Console output show up when you go to the page for the WebJob (not for the function invocation) and click **Toggle Output**.\n \n![Click Toggle Output](./media/websites-dotnet-webjobs-sdk-storage-queues-how-to/dashboardapplogs.png)\n\nIn a continuous WebJob, application logs show up in /data/jobs/continuous/*{webjobname}*/job_log.txt in the web app file system.\n\n        [09/26/2014 21:01:13 > 491e54: INFO] Console.Write - Hello world!\n        [09/26/2014 21:01:13 > 491e54: ERR ] Console.Error - Hello world!\n        [09/26/2014 21:01:13 > 491e54: INFO] Console.Out - Hello world!\n\nIn an Azure blob the application logs look like this:\n        2014-09-26T21:01:13,Information,contosoadsnew,491e54,635473620738373502,0,17404,17,Console.Write - Hello world!,\n        2014-09-26T21:01:13,Error,contosoadsnew,491e54,635473620738373502,0,17404,19,Console.Error - Hello world!,\n        2014-09-26T21:01:13,Information,contosoadsnew,491e54,635473620738529920,0,17404,17,Console.Out - Hello world!,\n\nAnd in an Azure table the `Console.Out` and `Console.Error` logs look like this:\n\n![Info log in table](./media/websites-dotnet-webjobs-sdk-storage-queues-how-to/tableinfo.png)\n\n![Error log in table](./media/websites-dotnet-webjobs-sdk-storage-queues-how-to/tableerror.png)\n\n## <a id=\"nextsteps\"></a> Next steps\n\nThis guide has provided code samples that show how to handle common scenarios for working with Azure queues. For more information about how to use Azure WebJobs and the WebJobs SDK, see [Azure WebJobs Recommended Resources](http://go.microsoft.com/fwlink/?linkid=390226).\n \n\ntest\n"
}