<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Reliable Actors stateful service composition design pattern</source>
          <target state="new">Reliable Actors stateful service composition design pattern</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Service Fabric Reliable Actors design pattern that uses Stateful actors to maintain state between service calls as well as cache previous service results.</source>
          <target state="new">Service Fabric Reliable Actors design pattern that uses Stateful actors to maintain state between service calls as well as cache previous service results.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>State can be persisted or transient.</source>
          <target state="new">State can be persisted or transient.</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Reliable Actors design pattern: stateful service composition</source>
          <target state="new">Reliable Actors design pattern: stateful service composition</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Developers spent the last decade and a half building N-Tier stateless services in the enterprise.</source>
          <target state="new">Developers spent the last decade and a half building N-Tier stateless services in the enterprise.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>They built services on top of databases, they built high order services on top of other services, and they built orchestration engines and message oriented middleware to coordinate these services.</source>
          <target state="new">They built services on top of databases, they built high order services on top of other services, and they built orchestration engines and message oriented middleware to coordinate these services.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>As the user workloads evolve, whether demanding more interactivity or scale, stateless service-oriented architecture began to show its weaknesses.</source>
          <target state="new">As the user workloads evolve, whether demanding more interactivity or scale, stateless service-oriented architecture began to show its weaknesses.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The old way: SOA Services</source>
          <target state="new">The old way: SOA Services</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>While SOA services scaled horizontally seamlessly due to their stateless nature, they created a bottleneck in the storage tier—concurrency and throughput.</source>
          <target state="new">While SOA services scaled horizontally seamlessly due to their stateless nature, they created a bottleneck in the storage tier—concurrency and throughput.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Accessing storage became more and more expensive.</source>
          <target state="new">Accessing storage became more and more expensive.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>As a common practice most developers introduced caching to their solution to reduce the demand on storage but that solution was not without its drawbacks—another tier to manage, concurrent access to cache, semantic limitations and changes, and finally consistency.</source>
          <target state="new">As a common practice most developers introduced caching to their solution to reduce the demand on storage but that solution was not without its drawbacks—another tier to manage, concurrent access to cache, semantic limitations and changes, and finally consistency.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>As detailed earlier in the Smart Cache pattern, the virtual actor model provides a perfect solution for this.</source>
          <target state="new">As detailed earlier in the Smart Cache pattern, the virtual actor model provides a perfect solution for this.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Some developers tried to solve the problem by replicating their storage tier.</source>
          <target state="new">Some developers tried to solve the problem by replicating their storage tier.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>However, this approach didn’t scale well and quickly hits CAP boundaries.</source>
          <target state="new">However, this approach didn’t scale well and quickly hits CAP boundaries.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The second challenge has evolved around changing requirements; both end-users and businesses are demanding interactive services—responding to requests in milliseconds rather than seconds as the norm.</source>
          <target state="new">The second challenge has evolved around changing requirements; both end-users and businesses are demanding interactive services—responding to requests in milliseconds rather than seconds as the norm.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>To respond, developers started building façade services on top of other services, in some cases 10s of services to create user-centric services.</source>
          <target state="new">To respond, developers started building façade services on top of other services, in some cases 10s of services to create user-centric services.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>However composing multiple downstream services quickly showed latency issues.</source>
          <target state="new">However composing multiple downstream services quickly showed latency issues.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Once again developers turned to caches and in-memory object stores, in some cases different implementations to meet performance requirements.</source>
          <target state="new">Once again developers turned to caches and in-memory object stores, in some cases different implementations to meet performance requirements.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>They started building backend worker processes to build the cache periodically to minimize expensive on-demand cache population.</source>
          <target state="new">They started building backend worker processes to build the cache periodically to minimize expensive on-demand cache population.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Finally, they started deconstructing their workloads to isolate asynchronous operations from synchronous ones to gain more room for interactive operations to react to changes in state, which is particularly hard in SOA.</source>
          <target state="new">Finally, they started deconstructing their workloads to isolate asynchronous operations from synchronous ones to gain more room for interactive operations to react to changes in state, which is particularly hard in SOA.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>They introduced further tiers such as queues and workers adding more complexity to their solutions.</source>
          <target state="new">They introduced further tiers such as queues and workers adding more complexity to their solutions.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Essentially, developers started looking for solutions to build “stateful services,” in other words, collocate “state” and “service behaviour” to address user centric and interactive experiences.</source>
          <target state="new">Essentially, developers started looking for solutions to build “stateful services,” in other words, collocate “state” and “service behaviour” to address user centric and interactive experiences.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>And this is where Azure Service Fabric Actors as a service composition tier comes in, not as a replacement for these services.</source>
          <target state="new">And this is where Azure Service Fabric Actors as a service composition tier comes in, not as a replacement for these services.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The diagram below illustrates the point:</source>
          <target state="new">The diagram below illustrates the point:</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>![][1]</source>
          <target state="new">![][1]</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Better solution with Actors</source>
          <target state="new">Better solution with Actors</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>In the case of composing services, actors can be either stateless or stateful.</source>
          <target state="new">In the case of composing services, actors can be either stateless or stateful.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Stateless Actors can used as proxies to the underlying services.</source>
          <target state="new">Stateless Actors can used as proxies to the underlying services.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>These actors can dynamically scale across the Azure Service Fabric cluster and can cache certain information related to the service, such as its endpoint once it is discovered.</source>
          <target state="new">These actors can dynamically scale across the Azure Service Fabric cluster and can cache certain information related to the service, such as its endpoint once it is discovered.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Stateful actor can maintain state between service calls as well as cache previous service results.</source>
          <target state="new">Stateful actor can maintain state between service calls as well as cache previous service results.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>State can be persisted or transient.</source>
          <target state="new">State can be persisted or transient.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>This pattern is also applicable across many scenarios; in most cases, actors need to make external calls to invoke an operation on a particular service.</source>
          <target state="new">This pattern is also applicable across many scenarios; in most cases, actors need to make external calls to invoke an operation on a particular service.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Let’s illustrate with an example using modern ecommerce applications.</source>
          <target state="new">Let’s illustrate with an example using modern ecommerce applications.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>These applications are built on services that provides various functionality such as User Profile Management, Recommendations, Basket Management, Wish List Management, Purchasing, and many more.</source>
          <target state="new">These applications are built on services that provides various functionality such as User Profile Management, Recommendations, Basket Management, Wish List Management, Purchasing, and many more.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Most developers wish to take a user-centric approach to their architecture, very similar to those developing social experiences since ecommerce experiences primarily revolve around users and products.</source>
          <target state="new">Most developers wish to take a user-centric approach to their architecture, very similar to those developing social experiences since ecommerce experiences primarily revolve around users and products.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>This is usually achieved by shipping a façade of services most likely supported by a cache for performance reasons.</source>
          <target state="new">This is usually achieved by shipping a façade of services most likely supported by a cache for performance reasons.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Now let’s talk about an actor based approach.</source>
          <target state="new">Now let’s talk about an actor based approach.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>A user actor can represent both the behaviour of the user (browsing the catalogue, liking a product, adding an item to basket, recommending a product to a friend) as well as the its composed state—their profile, items in the basket, list of items recommended by their friends, their purchase history, current geo-location, and so on.</source>
          <target state="new">A user actor can represent both the behaviour of the user (browsing the catalogue, liking a product, adding an item to basket, recommending a product to a friend) as well as the its composed state—their profile, items in the basket, list of items recommended by their friends, their purchase history, current geo-location, and so on.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Using stateful Actors</source>
          <target state="new">Using stateful Actors</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>First let’s look at an example where the user actor needs to populate its state from multiple services.</source>
          <target state="new">First let’s look at an example where the user actor needs to populate its state from multiple services.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>We are not going to provide a code sample for this one because everything we have discussed in the Smart Cache pattern is also applicable here.</source>
          <target state="new">We are not going to provide a code sample for this one because everything we have discussed in the Smart Cache pattern is also applicable here.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>We can activate the user actor at login time, populating it with sufficient data from back-end services.</source>
          <target state="new">We can activate the user actor at login time, populating it with sufficient data from back-end services.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Of course, as we have seen on many occasions earlier in this paper, whole and partial state can be prepopulated on demand, on a timer, or a bit of both and cached in the actor.</source>
          <target state="new">Of course, as we have seen on many occasions earlier in this paper, whole and partial state can be prepopulated on demand, on a timer, or a bit of both and cached in the actor.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>For this example, Profile and Wish List is illustrated below:</source>
          <target state="new">For this example, Profile and Wish List is illustrated below:</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>![][2]</source>
          <target state="new">![][2]</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>For instance we can prepopulate frequent users’ state and make it ready when they login or populate it at login time for users who visit the service every month.</source>
          <target state="new">For instance we can prepopulate frequent users’ state and make it ready when they login or populate it at login time for users who visit the service every month.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>We saw these patterns in the Smart Cache section.</source>
          <target state="new">We saw these patterns in the Smart Cache section.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>When User 23 logs in, if not already activated, the user actor (23) is activated and fetches the relevant user profile information and wish list from back-end services.</source>
          <target state="new">When User 23 logs in, if not already activated, the user actor (23) is activated and fetches the relevant user profile information and wish list from back-end services.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The user actor likely caches the information for subsequent calls.</source>
          <target state="new">The user actor likely caches the information for subsequent calls.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>And if, for example, we need to add an item to the wish list we can write-behind or write-through as discussed earlier.</source>
          <target state="new">And if, for example, we need to add an item to the wish list we can write-behind or write-through as discussed earlier.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Secondly, let’s have a look at an example where the user clicks on the “like” button and likes a product.</source>
          <target state="new">Secondly, let’s have a look at an example where the user clicks on the “like” button and likes a product.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>This action may require multiple invocations to multiple services as illustrated below: Send a “like” to catalogue service, trigger the next set of recommendations, and perhaps post an update to a social network.</source>
          <target state="new">This action may require multiple invocations to multiple services as illustrated below: Send a “like” to catalogue service, trigger the next set of recommendations, and perhaps post an update to a social network.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>This is illustrated below:</source>
          <target state="new">This is illustrated below:</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>![][3]</source>
          <target state="new">![][3]</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>How Actors composition &amp; Async communication can help</source>
          <target state="new">How Actors composition &amp; Async communication can help</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>In fact, Azure Service Fabric Actors shines when we want to compose request/response style operations together with asynchronous operations.</source>
          <target state="new">In fact, Azure Service Fabric Actors shines when we want to compose request/response style operations together with asynchronous operations.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>For instance, while “Like Product” immediately puts the liked item into the user’s wish list, posting to social networks and triggering the next set of recommendations can be asynchronous operations using buffers and timers.</source>
          <target state="new">For instance, while “Like Product” immediately puts the liked item into the user’s wish list, posting to social networks and triggering the next set of recommendations can be asynchronous operations using buffers and timers.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>One other key benefit of using a user actor with services is actors provide a natural place for cached state and most importantly react to changes in its state asynchronously.</source>
          <target state="new">One other key benefit of using a user actor with services is actors provide a natural place for cached state and most importantly react to changes in its state asynchronously.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>This is a particularly challenging scenario with stateless services.</source>
          <target state="new">This is a particularly challenging scenario with stateless services.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>For example, a user carries out a series of actions, perhaps part of a "user journey."</source>
          <target state="new">For example, a user carries out a series of actions, perhaps part of a "user journey."</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>These events can be captured in real time in the actor and we can assemble a stream, which we can query at event time or asynchronously on a timer to change the behaviour of the actor.</source>
          <target state="new">These events can be captured in real time in the actor and we can assemble a stream, which we can query at event time or asynchronously on a timer to change the behaviour of the actor.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>At this point SOA purists will no doubt have noticed that these are not services in the sense of actors as endpoints exposed over a language independent protocol.</source>
          <target state="new">At this point SOA purists will no doubt have noticed that these are not services in the sense of actors as endpoints exposed over a language independent protocol.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Azure Service Fabric Actors is neither an interoperation component nor a platform for service interoperation.</source>
          <target state="new">Azure Service Fabric Actors is neither an interoperation component nor a platform for service interoperation.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Nevertheless, there really is nothing preventing us from thinking in terms of the granularity of SOA-style services when we model our actors or in modelling separation of concerns in the same way.</source>
          <target state="new">Nevertheless, there really is nothing preventing us from thinking in terms of the granularity of SOA-style services when we model our actors or in modelling separation of concerns in the same way.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Such services are known as “microservices.”</source>
          <target state="new">Such services are known as “microservices.”</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Likewise, there is absolutely nothing preventing us from putting a REST endpoint or a SOAP endpoint as an interop layer in front of Azure Service Fabric Actors.</source>
          <target state="new">Likewise, there is absolutely nothing preventing us from putting a REST endpoint or a SOAP endpoint as an interop layer in front of Azure Service Fabric Actors.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Stateful service composition also applies to workflows and not just transactional scenarios such as ecommerce.</source>
          <target state="new">Stateful service composition also applies to workflows and not just transactional scenarios such as ecommerce.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Azure Service Fabric is designed as a workflow/orchestration engine so it can be used to model workflows involving service interactions and maintain the state of these interactions.</source>
          <target state="new">Azure Service Fabric is designed as a workflow/orchestration engine so it can be used to model workflows involving service interactions and maintain the state of these interactions.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>We see drawbacks of “stateless service” in building scalable services to provide dynamic experiences.</source>
          <target state="new">We see drawbacks of “stateless service” in building scalable services to provide dynamic experiences.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Azure Service Fabric Actors, essentially by bringing state and behaviour together, helps developers build scalable and interactive experiences on top of their existing investments.</source>
          <target state="new">Azure Service Fabric Actors, essentially by bringing state and behaviour together, helps developers build scalable and interactive experiences on top of their existing investments.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="new">Next Steps</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Pattern: Smart Cache</source>
          <target state="new">Pattern: Smart Cache</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Pattern: Distributed Networks and Graphs</source>
          <target state="new">Pattern: Distributed Networks and Graphs</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Pattern: Resource Governance</source>
          <target state="new">Pattern: Resource Governance</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Pattern: Internet of Things</source>
          <target state="new">Pattern: Internet of Things</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Pattern: Distributed Computation</source>
          <target state="new">Pattern: Distributed Computation</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Some Anti-patterns</source>
          <target state="new">Some Anti-patterns</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Introduction to Service Fabric Actors</source>
          <target state="new">Introduction to Service Fabric Actors</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">59847b40d755024d0fa45d0a9ef255d782925131</xliffext:olfilehash>
  </header>
</xliff>