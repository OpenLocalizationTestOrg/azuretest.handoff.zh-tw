{
  "nodes": [
    {
      "content": "Scale mobile services backed by Azure SQL Database | Microsoft Azure",
      "pos": [
        28,
        96
      ]
    },
    {
      "content": "Learn how to diagnose and fix scalability issues in your mobile services backed by SQL Database",
      "pos": [
        116,
        211
      ]
    },
    {
      "content": "Scale mobile services backed by Azure SQL Database",
      "pos": [
        551,
        601
      ]
    },
    {
      "content": "Azure Mobile Services makes it very easy to get started and build an app that connects to a cloud-hosted backend that stores data in a SQL database.",
      "pos": [
        603,
        751
      ]
    },
    {
      "content": "As your app grows, scaling your service instances is as simple as adjusting scale settings in the portal to add more computational and networking capacity.",
      "pos": [
        752,
        907
      ]
    },
    {
      "content": "However, scaling the SQL database backing your service requires some proactive planning and monitoring as the service receives more load.",
      "pos": [
        908,
        1045
      ]
    },
    {
      "content": "This document will walk you through a set of best practices to ensure continued great performance of your SQL-backed mobile services.",
      "pos": [
        1046,
        1179
      ]
    },
    {
      "content": "This topic walks you through these basic sections:",
      "pos": [
        1181,
        1231
      ]
    },
    {
      "content": "Diagnosing Problems",
      "pos": [
        1237,
        1256
      ]
    },
    {
      "content": "Indexing",
      "pos": [
        1275,
        1283
      ]
    },
    {
      "content": "Schema Design",
      "pos": [
        1300,
        1313
      ]
    },
    {
      "content": "Query Design",
      "pos": [
        1328,
        1340
      ]
    },
    {
      "content": "Service Architecture",
      "pos": [
        1354,
        1374
      ]
    },
    {
      "content": "Advanced Troubleshooting",
      "pos": [
        1395,
        1419
      ]
    },
    {
      "content": "Diagnosing Problems",
      "pos": [
        1462,
        1481
      ]
    },
    {
      "content": "If you suspect your mobile service is experiencing problems under load, the first place to check is the <bpt id=\"p1\">**</bpt>Dashboard<ept id=\"p1\">**</ept> tab for your service in the <bpt id=\"p2\">[</bpt>Azure Management Portal<ept id=\"p2\">][]</ept>.",
      "pos": [
        1483,
        1657
      ]
    },
    {
      "content": "Some of the things to verify here:",
      "pos": [
        1658,
        1692
      ]
    },
    {
      "pos": [
        1696,
        1786
      ],
      "content": "Your usage meters including <bpt id=\"p1\">**</bpt>API Calls<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>Active Devices<ept id=\"p2\">**</ept> meters are not over quota"
    },
    {
      "pos": [
        1789,
        1933
      ],
      "content": "<bpt id=\"p1\">**</bpt>Endpoint Monitoring<ept id=\"p1\">**</ept> status indicates service is up (only available if service is using the Standard tier and Endpoint Monitoring is enabled)"
    },
    {
      "content": "If any of the above is not true, consider adjusting your scale settings on the <bpt id=\"p1\">*</bpt>Scale<ept id=\"p1\">*</ept> tab.",
      "pos": [
        1936,
        2027
      ]
    },
    {
      "content": "If that does not address the issue, you can proceed and investigate whether Azure SQL Database may be the source of the issue.",
      "pos": [
        2028,
        2154
      ]
    },
    {
      "content": "The next few sections cover a few different approaches to diagnose what may be going wrong.",
      "pos": [
        2155,
        2246
      ]
    },
    {
      "content": "Choosing the Right SQL Database Tier",
      "pos": [
        2252,
        2288
      ]
    },
    {
      "content": "It is important to understand the different database tiers you have at your disposal to ensure you've picked the right tier given your app's needs.",
      "pos": [
        2291,
        2438
      ]
    },
    {
      "content": "Azure SQL Database offers two different database editions and three different service tiers:",
      "pos": [
        2439,
        2531
      ]
    },
    {
      "content": "Web and Business Editions (retired)",
      "pos": [
        2535,
        2570
      ]
    },
    {
      "content": "Basic, Standard, and Premium service tiers",
      "pos": [
        2573,
        2615
      ]
    },
    {
      "content": "While the Web and Business Editions are fully supported, they will be retired on September 12, 2015 as discussed in <bpt id=\"p1\">[</bpt>Web and Business Edition Sunset FAQ<ept id=\"p1\">](http://msdn.microsoft.com/library/azure/dn741330.aspx)</ept>.",
      "pos": [
        2617,
        2826
      ]
    },
    {
      "content": "We encourage new customers to start using the Basic, Standard, and Premium service tiers in preparation for this change.",
      "pos": [
        2827,
        2947
      ]
    },
    {
      "content": "They provide a variety of monitoring capabilities that make it even easier to understand and troubleshoot database performance.",
      "pos": [
        2948,
        3075
      ]
    },
    {
      "content": "All new mobile services are created using one of the new service tiers.",
      "pos": [
        3076,
        3147
      ]
    },
    {
      "content": "To convert a mobile service using the Web and Business Edition to the Basic, Standard, and Premium service tiers, follow these steps.",
      "pos": [
        3149,
        3282
      ]
    },
    {
      "pos": [
        3287,
        3326
      ],
      "content": "Launch the <bpt id=\"p1\">[</bpt>Azure Management Portal<ept id=\"p1\">][]</ept>."
    },
    {
      "pos": [
        3330,
        3429
      ],
      "content": "Select <bpt id=\"p1\">**</bpt>+NEW<ept id=\"p1\">**</ept> in the toolbar and then pick <bpt id=\"p2\">**</bpt>Data Services<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>SQL Database<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>Quick Create<ept id=\"p4\">**</ept>."
    },
    {
      "content": "Enter a database name and then select <bpt id=\"p1\">**</bpt>New SQL database server<ept id=\"p1\">**</ept> in the <bpt id=\"p2\">**</bpt>Server<ept id=\"p2\">**</ept> field.",
      "pos": [
        3433,
        3523
      ]
    },
    {
      "content": "This will create a server that is using the new Basic, Standard, or Premium service tier.",
      "pos": [
        3524,
        3613
      ]
    },
    {
      "content": "Fill out the rest of the fields and select <bpt id=\"p1\">**</bpt>Create SQL Database<ept id=\"p1\">**</ept>.",
      "pos": [
        3618,
        3685
      ]
    },
    {
      "content": "This will create a 100MB database using the Basic tier.",
      "pos": [
        3686,
        3741
      ]
    },
    {
      "content": "Configure your mobile service to use the database you just created.",
      "pos": [
        3745,
        3812
      ]
    },
    {
      "content": "Navigate to the <bpt id=\"p1\">**</bpt>Configure<ept id=\"p1\">**</ept> tab for that service and select <bpt id=\"p2\">**</bpt>Change Database<ept id=\"p2\">**</ept> in the toolbar.",
      "pos": [
        3813,
        3910
      ]
    },
    {
      "content": "On the next screen, select <bpt id=\"p1\">**</bpt>Use an existing SQL database<ept id=\"p1\">**</ept> in the <bpt id=\"p2\">**</bpt>SQL Database<ept id=\"p2\">**</ept> field and then select <bpt id=\"p3\">**</bpt>Next<ept id=\"p3\">**</ept>.",
      "pos": [
        3911,
        4026
      ]
    },
    {
      "content": "On the next screen be sure to pick the database you created in step 5, then select <bpt id=\"p1\">**</bpt>OK<ept id=\"p1\">**</ept>.",
      "pos": [
        4027,
        4117
      ]
    },
    {
      "content": "Here are some recommendations on selecting the right tier for your database:",
      "pos": [
        4119,
        4195
      ]
    },
    {
      "pos": [
        4199,
        4331
      ],
      "content": "<bpt id=\"p1\">**</bpt>Basic<ept id=\"p1\">**</ept> - use at development time or for small production services where you only expect to make a single database query at a time"
    },
    {
      "pos": [
        4334,
        4430
      ],
      "content": "<bpt id=\"p1\">**</bpt>Standard<ept id=\"p1\">**</ept> - use for production services where you expect multiple concurrent database queries"
    },
    {
      "pos": [
        4433,
        4576
      ],
      "content": "<bpt id=\"p1\">**</bpt>Premium<ept id=\"p1\">**</ept> - use for large scale production services with many concurrent queries, high peak load, and expected low latency for every request."
    },
    {
      "pos": [
        4578,
        4730
      ],
      "content": "For more information on when to use each tier, see <bpt id=\"p1\">[</bpt>Reasons to Use the New Service Tiers<ept id=\"p1\">](http://msdn.microsoft.com/library/azure/dn369873.aspx#Reasons)</ept>"
    },
    {
      "content": "Analyzing Database Metrics",
      "pos": [
        4736,
        4762
      ]
    },
    {
      "content": "Once you are familiar with the different database tiers, we can explore database performance metrics to help us reason about scaling within and among the tiers.",
      "pos": [
        4764,
        4924
      ]
    },
    {
      "pos": [
        4929,
        4968
      ],
      "content": "Launch the <bpt id=\"p1\">[</bpt>Azure Management Portal<ept id=\"p1\">][]</ept>."
    },
    {
      "content": "On the Mobile Services tab, select the service you want to work with.",
      "pos": [
        4972,
        5041
      ]
    },
    {
      "pos": [
        5045,
        5074
      ],
      "content": "Select the <bpt id=\"p1\">**</bpt>Configure<ept id=\"p1\">**</ept> tab."
    },
    {
      "content": "Select the <bpt id=\"p1\">**</bpt>SQL Database<ept id=\"p1\">**</ept> name in the <bpt id=\"p2\">**</bpt>Database Settings<ept id=\"p2\">**</ept> section.",
      "pos": [
        5078,
        5148
      ]
    },
    {
      "content": "This will navigate to the Azure SQL Database tab in the portal.",
      "pos": [
        5149,
        5212
      ]
    },
    {
      "pos": [
        5216,
        5247
      ],
      "content": "Navigate to the <bpt id=\"p1\">**</bpt>Monitor<ept id=\"p1\">**</ept> tab"
    },
    {
      "content": "Ensure the relevant metrics are displayed by using the <bpt id=\"p1\">**</bpt>Add Metrics<ept id=\"p1\">**</ept> button.",
      "pos": [
        5251,
        5329
      ]
    },
    {
      "content": "Include the following",
      "pos": [
        5330,
        5351
      ]
    },
    {
      "pos": [
        5358,
        5423
      ],
      "content": "<bpt id=\"p1\">*</bpt>CPU Percentage<ept id=\"p1\">*</ept> (available only in Basic/Standard/Premium tiers)"
    },
    {
      "pos": [
        5430,
        5511
      ],
      "content": "<bpt id=\"p1\">*</bpt>Physical Data Reads Percentage<ept id=\"p1\">*</ept> (available only in Basic/Standard/Premium tiers)"
    },
    {
      "pos": [
        5519,
        5591
      ],
      "content": "<bpt id=\"p1\">*</bpt>Log Writes Percentage<ept id=\"p1\">*</ept> (available only in Basic/Standard/Premium tiers)"
    },
    {
      "content": "Storage",
      "pos": [
        5599,
        5606
      ]
    },
    {
      "content": "Inspect the metrics over the time window when your service was experiencing issues.",
      "pos": [
        5612,
        5695
      ]
    },
    {
      "content": "![Azure Management Portal - SQL Database Metrics][PortalSqlMetrics]",
      "pos": [
        5702,
        5769
      ]
    },
    {
      "content": "If any metric exceeds 80% utilization for an extended period of time, this could indicate a performance problem.",
      "pos": [
        5771,
        5883
      ]
    },
    {
      "content": "For more detailed information on understanding database utilization, see <bpt id=\"p1\">[</bpt>Understanding Resource Use<ept id=\"p1\">](http://msdn.microsoft.com/library/azure/dn369873.aspx#Resource)</ept>.",
      "pos": [
        5884,
        6050
      ]
    },
    {
      "content": "If the metrics indicate your database is incurring high utilization, consider <bpt id=\"p1\">**</bpt>scaling up the database to a higher service tier<ept id=\"p1\">**</ept> as a first mitigation step.",
      "pos": [
        6052,
        6210
      ]
    },
    {
      "content": "To immediately resolve issues, consider using the <bpt id=\"p1\">**</bpt>Scale<ept id=\"p1\">**</ept> tab for your database to scale up your database.",
      "pos": [
        6211,
        6319
      ]
    },
    {
      "content": "This will result in an increase in your bill.",
      "pos": [
        6320,
        6365
      ]
    },
    {
      "content": "![Azure Management Portal - SQL Database Scale][PortalSqlScale]",
      "pos": [
        6366,
        6429
      ]
    },
    {
      "content": "As soon as possible, consider these additional mitigation steps:",
      "pos": [
        6431,
        6495
      ]
    },
    {
      "pos": [
        6499,
        6653
      ],
      "content": "**Tune your database.**\nIt is frequently possible to reduce database utilization and avoid having to scale to a higher tier by optimizing your database.",
      "leadings": [
        "",
        "  "
      ],
      "nodes": [
        {
          "content": "**Tune your database.**",
          "pos": [
            0,
            23
          ],
          "nodes": [
            {
              "content": "Tune your database.",
              "pos": [
                2,
                21
              ]
            },
            {
              "content": "**",
              "pos": [
                21,
                23
              ]
            }
          ]
        },
        {
          "content": "It is frequently possible to reduce database utilization and avoid having to scale to a higher tier by optimizing your database.",
          "pos": [
            24,
            152
          ]
        }
      ]
    },
    {
      "pos": [
        6657,
        7053
      ],
      "content": "**Consider your service architecture.**\nFrequently your service load is not distributed evenly over time but contains \"spikes\" of high demand. Instead of scaling the database up to handle the spikes, and having it go underutilized during periods of low demand, it is frequently possible to adjust the service architecture to avoid such spikes, or to handle them without incurring database hits.",
      "leadings": [
        "",
        "  "
      ],
      "nodes": [
        {
          "content": "**Consider your service architecture.**",
          "pos": [
            0,
            39
          ],
          "nodes": [
            {
              "content": "Consider your service architecture.",
              "pos": [
                2,
                37
              ]
            },
            {
              "content": "**",
              "pos": [
                37,
                39
              ]
            }
          ]
        },
        {
          "content": "Frequently your service load is not distributed evenly over time but contains \"spikes\" of high demand. Instead of scaling the database up to handle the spikes, and having it go underutilized during periods of low demand, it is frequently possible to adjust the service architecture to avoid such spikes, or to handle them without incurring database hits.",
          "pos": [
            40,
            394
          ],
          "nodes": [
            {
              "content": "Frequently your service load is not distributed evenly over time but contains \"spikes\" of high demand.",
              "pos": [
                0,
                102
              ]
            },
            {
              "content": "Instead of scaling the database up to handle the spikes, and having it go underutilized during periods of low demand, it is frequently possible to adjust the service architecture to avoid such spikes, or to handle them without incurring database hits.",
              "pos": [
                103,
                354
              ]
            }
          ]
        }
      ]
    },
    {
      "content": "The remaining sections of this document contain tailored guidance to help with implementing these mitigations.",
      "pos": [
        7055,
        7165
      ]
    },
    {
      "content": "Configuring Alerts",
      "pos": [
        7172,
        7190
      ]
    },
    {
      "content": "It is frequently useful to configure alerts for key database metrics as a proactive step to ensure you have plenty of time to react in case of resource exhaustion.",
      "pos": [
        7192,
        7355
      ]
    },
    {
      "pos": [
        7361,
        7442
      ],
      "content": "Navigate to the <bpt id=\"p1\">**</bpt>Monitoring<ept id=\"p1\">**</ept> tab for the database you want to set up alerts for"
    },
    {
      "content": "Ensure the relevant metrics are displayed as described in the previous section",
      "pos": [
        7446,
        7524
      ]
    },
    {
      "pos": [
        7528,
        7660
      ],
      "content": "Select the metric you want to set an alert for and select **Add Rule**\n ![Azure Management Portal - SQL Alert][PortalSqlAddAlert]",
      "leadings": [
        "",
        "   "
      ],
      "nodes": [
        {
          "content": "Select the metric you want to set an alert for and select <bpt id=\"p1\">**</bpt>Add Rule<ept id=\"p1\">**</ept>",
          "pos": [
            0,
            70
          ]
        },
        {
          "content": "![Azure Management Portal - SQL Alert][PortalSqlAddAlert]",
          "pos": [
            72,
            129
          ]
        }
      ]
    },
    {
      "pos": [
        7664,
        7792
      ],
      "content": "Provide a name and description for the alert\n ![Azure Management Portal - SQL Alert Name and Description][PortalSqlAddAlert2]",
      "leadings": [
        "",
        "   "
      ],
      "nodes": [
        {
          "content": "Provide a name and description for the alert",
          "pos": [
            0,
            44
          ]
        },
        {
          "content": "![Azure Management Portal - SQL Alert Name and Description][PortalSqlAddAlert2]",
          "pos": [
            46,
            125
          ]
        }
      ]
    },
    {
      "pos": [
        7796,
        8052
      ],
      "content": "Specify the value to use as the alert threshold. Consider using **80%** to allow for some reaction time. Also be sure to specify an email address that you actively monitor. \n ![Azure Management Portal - SQL Alert Threshold and Email][PortalSqlAddAlert3]",
      "leadings": [
        "",
        "   "
      ],
      "nodes": [
        {
          "content": "Specify the value to use as the alert threshold. Consider using **80%** to allow for some reaction time. Also be sure to specify an email address that you actively monitor.",
          "pos": [
            0,
            172
          ],
          "nodes": [
            {
              "content": "Specify the value to use as the alert threshold.",
              "pos": [
                0,
                48
              ]
            },
            {
              "content": "Consider using <bpt id=\"p1\">**</bpt>80%<ept id=\"p1\">**</ept> to allow for some reaction time.",
              "pos": [
                49,
                104
              ]
            },
            {
              "content": "Also be sure to specify an email address that you actively monitor.",
              "pos": [
                105,
                172
              ]
            }
          ]
        },
        {
          "content": "![Azure Management Portal - SQL Alert Threshold and Email][PortalSqlAddAlert3]",
          "pos": [
            175,
            253
          ]
        }
      ]
    },
    {
      "pos": [
        8054,
        8180
      ],
      "content": "For more information on diagnosing SQL issues, see <bpt id=\"p1\">[</bpt>Advanced Diagnostics<ept id=\"p1\">](#AdvancedDiagnosing)</ept> at the bottom of this document."
    },
    {
      "content": "Indexing",
      "pos": [
        8209,
        8217
      ]
    },
    {
      "content": "When you start to see problems with your query performance, the first thing you should investigate is the design of your indexes.",
      "pos": [
        8219,
        8348
      ]
    },
    {
      "content": "Indexes are important because they directly affect how the SQL engine executes a query.",
      "pos": [
        8349,
        8436
      ]
    },
    {
      "content": "For instance, if you often need to look up an element by a certain field, you should consider adding an index for that column.",
      "pos": [
        8439,
        8565
      ]
    },
    {
      "content": "Otherwise, the SQL engine will be forced to perform a table scan and read each physical record (or at least the query column) and the records could be substantially spread out on disk.",
      "pos": [
        8566,
        8750
      ]
    },
    {
      "content": "So, if you are frequently doing WHERE or JOIN statements on particular columns, you should make sure you index them.",
      "pos": [
        8752,
        8868
      ]
    },
    {
      "content": "See the section <bpt id=\"p1\">[</bpt>Creating Indexes<ept id=\"p1\">](#CreatingIndexes)</ept> for more information.",
      "pos": [
        8869,
        8943
      ]
    },
    {
      "content": "If indexes are so great and table scans are so bad, does that mean you should index every column in your table, just to be safe?",
      "pos": [
        8945,
        9073
      ]
    },
    {
      "content": "The short answer is, \"probably not.\"",
      "pos": [
        9075,
        9111
      ]
    },
    {
      "content": "Indexes take up space and have overhead themselves: every time there is an insert in a table, the index structures for each of the indexed columns need to be updated.",
      "pos": [
        9112,
        9278
      ]
    },
    {
      "content": "See below for guidelines on how to choose your column indexes.",
      "pos": [
        9279,
        9341
      ]
    },
    {
      "content": "Index Design Guidelines",
      "pos": [
        9347,
        9370
      ]
    },
    {
      "content": "As mentioned above, it's not always better to add more indexes to a table, because indexes themselves can be costly, both in terms of performance and storage overhead.",
      "pos": [
        9372,
        9539
      ]
    },
    {
      "content": "Query considerations",
      "pos": [
        9546,
        9566
      ]
    },
    {
      "content": "Consider adding indexes to columns that are frequently used in predicates (e.g., WHERE clauses) and join conditions, while balancing the database considerations below.",
      "pos": [
        9570,
        9737
      ]
    },
    {
      "content": "Write queries that insert or modify as many rows as possible in a single statement, instead of using multiple queries to update the same rows.",
      "pos": [
        9740,
        9882
      ]
    },
    {
      "content": "When there is only one statement, the database engine can better optimize how it maintains indexes.",
      "pos": [
        9883,
        9982
      ]
    },
    {
      "content": "Database considerations",
      "pos": [
        9993,
        10016
      ]
    },
    {
      "content": "Large numbers of indexes on a table affect the performance of INSERT, UPDATE, DELETE, and MERGE statements because all indexes must be adjusted appropriately as data in the table changes.",
      "pos": [
        10018,
        10205
      ]
    },
    {
      "pos": [
        10209,
        10280
      ],
      "content": "For <bpt id=\"p1\">**</bpt>heavily updated<ept id=\"p1\">**</ept> tables, avoid indexing heavily updated columns."
    },
    {
      "content": "For tables that are <bpt id=\"p1\">**</bpt>not frequently updated<ept id=\"p1\">**</ept> but that have large volumes of data, use many indexes.",
      "pos": [
        10283,
        10384
      ]
    },
    {
      "content": "This can improve the performance of queries that do not modify data (such as SELECT statements) because the query optimizer will have more options for finding the best access method.",
      "pos": [
        10385,
        10567
      ]
    },
    {
      "content": "Indexing small tables may not be optimal because it can take the query optimizer longer to traverse the index searching for data than to perform a simple table scan.",
      "pos": [
        10569,
        10734
      ]
    },
    {
      "content": "Therefore, indexes on small tables might never be used, but must still be maintained as data in the table changes.",
      "pos": [
        10735,
        10849
      ]
    },
    {
      "content": "Creating Indexes",
      "pos": [
        10887,
        10903
      ]
    },
    {
      "content": "JavaScript backend",
      "pos": [
        10910,
        10928
      ]
    },
    {
      "content": "To set the index for a column in the JavaScript backend, do the following:",
      "pos": [
        10930,
        11004
      ]
    },
    {
      "pos": [
        11009,
        11069
      ],
      "content": "Open your mobile service in the <bpt id=\"p1\">[</bpt>Azure Management Portal<ept id=\"p1\">][]</ept>."
    },
    {
      "pos": [
        11073,
        11096
      ],
      "content": "Click the <bpt id=\"p1\">**</bpt>Data<ept id=\"p1\">**</ept> tab."
    },
    {
      "content": "Select the table you want to modify.",
      "pos": [
        11100,
        11136
      ]
    },
    {
      "pos": [
        11140,
        11166
      ],
      "content": "Click the <bpt id=\"p1\">**</bpt>Columns<ept id=\"p1\">**</ept> tab."
    },
    {
      "content": "Select the column.",
      "pos": [
        11170,
        11188
      ]
    },
    {
      "content": "In the command bar, click <bpt id=\"p1\">**</bpt>Set Index<ept id=\"p1\">**</ept>:",
      "pos": [
        11189,
        11229
      ]
    },
    {
      "content": "![Mobile Services Portal - Set Index][SetIndexJavaScriptPortal]",
      "pos": [
        11235,
        11298
      ]
    },
    {
      "content": "You can also remove indexes within this view.",
      "pos": [
        11300,
        11345
      ]
    },
    {
      "content": ".NET backend",
      "pos": [
        11352,
        11364
      ]
    },
    {
      "content": "To define an index in Entity Framework, use the attribute <ph id=\"ph1\">`[Index]`</ph> on the fields that you want to index.",
      "pos": [
        11366,
        11471
      ]
    },
    {
      "content": "For example:",
      "pos": [
        11472,
        11484
      ]
    },
    {
      "content": "For more information on indexes, see <bpt id=\"p1\">[</bpt>Index Annotations in Entity Framework<ept id=\"p1\">][]</ept>.",
      "pos": [
        11648,
        11727
      ]
    },
    {
      "content": "For further tips on optimizing indexes, see <bpt id=\"p1\">[</bpt>Advanced Indexing<ept id=\"p1\">](#AdvancedIndexing)</ept> at the bottom of this document.",
      "pos": [
        11728,
        11842
      ]
    },
    {
      "content": "Schema Design",
      "pos": [
        11869,
        11882
      ]
    },
    {
      "content": "Here are a few issues to be aware of when picking the data types for your objects, which in turn translates to the schema of your SQL database.",
      "pos": [
        11884,
        12027
      ]
    },
    {
      "content": "Tuning the schema can frequently bring significant performance improvements since SQL has custom optimized ways of handling indexing and storage for different data types:",
      "pos": [
        12028,
        12198
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Use the provided ID column<ept id=\"p1\">**</ept>.",
      "pos": [
        12202,
        12233
      ]
    },
    {
      "content": "Every mobile service table comes with a default ID column configured as the primary key and has an index set on it.",
      "pos": [
        12234,
        12349
      ]
    },
    {
      "content": "There is no need to create an additional ID column.",
      "pos": [
        12350,
        12401
      ]
    },
    {
      "content": "Use the correct datatypes in your model.",
      "pos": [
        12406,
        12446
      ]
    },
    {
      "content": "If you know a certain property of your model will be a numeric or boolean, be sure to define it that way in your model instead of as a string.",
      "pos": [
        12449,
        12591
      ]
    },
    {
      "content": "In the JavaScript backend, use literals such as <ph id=\"ph1\">`true`</ph> instead of <ph id=\"ph2\">`\"true\"`</ph> and <ph id=\"ph3\">`5`</ph> instead of <ph id=\"ph4\">`\"5\"`</ph>.",
      "pos": [
        12592,
        12692
      ]
    },
    {
      "content": "In the .NET backend, use the <ph id=\"ph1\">`int`</ph> and <ph id=\"ph2\">`bool`</ph> types when you declare the properties of your model.",
      "pos": [
        12693,
        12791
      ]
    },
    {
      "content": "This enables SQL to create the correct schema for those types, which makes queries more efficient.",
      "pos": [
        12792,
        12890
      ]
    },
    {
      "content": "Query Design",
      "pos": [
        12918,
        12930
      ]
    },
    {
      "content": "Here are some guidelines to consider when querying the database:",
      "pos": [
        12932,
        12996
      ]
    },
    {
      "content": "Always execute join operations in the database.",
      "pos": [
        13002,
        13049
      ]
    },
    {
      "content": "Frequently you will need to combine records from two or more tables where the records being combined share a common field (also known as a <bpt id=\"p1\">*</bpt>join<ept id=\"p1\">*</ept>).",
      "pos": [
        13052,
        13199
      ]
    },
    {
      "content": "This operation can be inefficient if performed incorrectly since it may involve pulling down all the entities from both tables and then iterating through all of them.",
      "pos": [
        13200,
        13366
      ]
    },
    {
      "content": "This kind of operation is best left to the database itself, but it is sometimes easy to mistakenly perform it on the client or in the mobile service code.",
      "pos": [
        13367,
        13521
      ]
    },
    {
      "content": "Don't perform joins in your app code",
      "pos": [
        13528,
        13564
      ]
    },
    {
      "content": "Don't perform joins in your mobile service code.",
      "pos": [
        13571,
        13619
      ]
    },
    {
      "content": "When using the JavaScript backend, be aware that the <bpt id=\"p1\">[</bpt>table object<ept id=\"p1\">](http://msdn.microsoft.com/library/windowsazure/jj554210.aspx)</ept> does not handle joins.",
      "pos": [
        13620,
        13772
      ]
    },
    {
      "content": "Be sure to use the <bpt id=\"p1\">[</bpt>mssql object<ept id=\"p1\">](http://msdn.microsoft.com/library/windowsazure/jj554212.aspx)</ept> directly to ensure the join happens in the database.",
      "pos": [
        13773,
        13921
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Join relational tables<ept id=\"p1\">](mobile-services-how-to-use-server-scripts.md#joins)</ept>.",
      "pos": [
        13922,
        14025
      ]
    },
    {
      "content": "If using the .NET backend and querying via LINQ, joins are automatically handled at the database level by Entity Framework.",
      "pos": [
        14026,
        14149
      ]
    },
    {
      "content": "Implement paging.",
      "pos": [
        14154,
        14171
      ]
    },
    {
      "content": "Querying the database can sometimes result in a large number of records being returned to the client.",
      "pos": [
        14174,
        14275
      ]
    },
    {
      "content": "To minimize the size and latency of operations, consider implementing paging.",
      "pos": [
        14276,
        14353
      ]
    },
    {
      "content": "By default your mobile service will limit any incoming queries to a page size of 50, and you can manually request up to 1,000 records.",
      "pos": [
        14360,
        14494
      ]
    },
    {
      "content": "For more information, see \"Return data in pages\" for <bpt id=\"p1\">[</bpt>Windows Store<ept id=\"p1\">](mobile-services-windows-dotnet-how-to-use-client-library.md#paging)</ept>, <bpt id=\"p2\">[</bpt>iOS<ept id=\"p2\">](mobile-services-ios-how-to-use-client-library.md#paging)</ept>, <bpt id=\"p3\">[</bpt>Android<ept id=\"p3\">](mobile-services-android-how-to-use-client-library.md#paging)</ept>, <bpt id=\"p4\">[</bpt>HTML/JavaScript<ept id=\"p4\">](mobile-services-html-how-to-use-client-library/#paging)</ept>, and <bpt id=\"p5\">[</bpt>Xamarin<ept id=\"p5\">](partner-xamarin-mobile-services-how-to-use-client-library.md#paging)</ept>.",
      "pos": [
        14495,
        14927
      ]
    },
    {
      "content": "There is no default page size for queries made from your mobile service code.",
      "pos": [
        14934,
        15011
      ]
    },
    {
      "content": "If your app does not implement paging, or as a defensive measure, consider applying default limits to your queries.",
      "pos": [
        15012,
        15127
      ]
    },
    {
      "content": "In the JavaScript backend, use the <bpt id=\"p1\">**</bpt>take<ept id=\"p1\">**</ept> operator on the <bpt id=\"p2\">[</bpt>query object<ept id=\"p2\">](http://msdn.microsoft.com/library/azure/jj613353.aspx)</ept>.",
      "pos": [
        15128,
        15258
      ]
    },
    {
      "content": "If using the .NET backend, consider using the <bpt id=\"p1\">[</bpt>Take method<ept id=\"p1\">](http://msdn.microsoft.com/library/vstudio/bb503062(v=vs.110).aspx)</ept> as part of your LINQ query.",
      "pos": [
        15259,
        15413
      ]
    },
    {
      "pos": [
        15417,
        15578
      ],
      "content": "For more information on improving query design, including how to analyze query plans, see <bpt id=\"p1\">[</bpt>Advanced Query Design<ept id=\"p1\">](#AdvancedQuery)</ept> at the bottom of this document."
    },
    {
      "content": "Service Architecture",
      "pos": [
        15611,
        15631
      ]
    },
    {
      "content": "Imagine a scenario where you are about to send a push notification to all your customers to check out some new content in your app.",
      "pos": [
        15633,
        15764
      ]
    },
    {
      "content": "As they tap on the notification, the app launches, which possibly triggers a call to your mobile service and a query execution against your SQL database.",
      "pos": [
        15765,
        15918
      ]
    },
    {
      "content": "As potentially millions of customers take this action over the span of just a few minutes, this will generate a surge of SQL load, which may be orders of magnitude higher than your app's steady state load.",
      "pos": [
        15919,
        16124
      ]
    },
    {
      "content": "This could be addressed by scaling your app to a higher SQL tier during the spike and then scaling it back down, however that solution requires manual intervention and comes with increased cost.",
      "pos": [
        16125,
        16319
      ]
    },
    {
      "content": "Frequently slight tweaks in your mobile service architecture can significantly balance out the load clients drive to your SQL database and eliminate problematic spikes in demand.",
      "pos": [
        16320,
        16498
      ]
    },
    {
      "content": "These modifications can often be implemented easily with minimal impact to your customer's experience.",
      "pos": [
        16499,
        16601
      ]
    },
    {
      "content": "Here are some examples:",
      "pos": [
        16602,
        16625
      ]
    },
    {
      "content": "Spread out the load over time.",
      "pos": [
        16631,
        16661
      ]
    },
    {
      "content": "If you control the timing of certain events (for example, a broadcast push notification), which are expected to generate a spike in demand, and the timing of those events is not critical, consider spreading them out over time.",
      "pos": [
        16664,
        16890
      ]
    },
    {
      "content": "In the example above, perhaps it is acceptable for your app customers to get notified of the new app content in batches over the span of a day instead of nearly simultaneously.",
      "pos": [
        16891,
        17067
      ]
    },
    {
      "content": "Consider batching up your customers into groups which will allow staggered delivery to each batch.",
      "pos": [
        17068,
        17166
      ]
    },
    {
      "content": "If using Notification Hubs, applying an additional tag to track the batch, and then delivering a push notification to that tag provides an easy way to implement this strategy.",
      "pos": [
        17167,
        17342
      ]
    },
    {
      "content": "For more information on tags, see <bpt id=\"p1\">[</bpt>Use Notification Hubs to send breaking news<ept id=\"p1\">](../notification-hubs-windows-store-dotnet-send-breaking-news.md)</ept>.",
      "pos": [
        17343,
        17488
      ]
    },
    {
      "content": "Use Blob and Table Storage whenever appropriate.",
      "pos": [
        17493,
        17541
      ]
    },
    {
      "content": "Frequently the content that the customers will view during the spike is fairly static and doesn't need to be stored in a SQL database since you are unlikely to need relational querying capabilities over that content.",
      "pos": [
        17544,
        17760
      ]
    },
    {
      "content": "In that case, consider storing the content in Blob or Table Storage.",
      "pos": [
        17761,
        17829
      ]
    },
    {
      "content": "You can access public blobs in Blob Storage directly from the device.",
      "pos": [
        17830,
        17899
      ]
    },
    {
      "content": "To access blobs in a secure way or use Table Storage, you will need to go through a Mobile Services Custom API in order to protect your storage access key.",
      "pos": [
        17900,
        18055
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Upload images to Azure Storage by using Mobile Services<ept id=\"p1\">](mobile-services-dotnet-backend-windows-store-dotnet-upload-data-blob-storage.md)</ept>.",
      "pos": [
        18056,
        18221
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Use an in-memory cache<ept id=\"p1\">**</ept>.",
      "pos": [
        18224,
        18251
      ]
    },
    {
      "content": "Another alternative is to store data, which would commonly be accessed during a traffic spike, in an in-memory cache such as <bpt id=\"p1\">[</bpt>Azure Cache<ept id=\"p1\">](http://azure.microsoft.com/services/cache/)</ept>.",
      "pos": [
        18252,
        18435
      ]
    },
    {
      "content": "This means incoming requests would be able to fetch the information they need from memory, instead of repeatedly querying the database.",
      "pos": [
        18436,
        18571
      ]
    },
    {
      "content": "Advanced Troubleshooting",
      "pos": [
        18600,
        18624
      ]
    },
    {
      "content": "This section covers some more advanced diagnostic tasks, which may be useful if the steps so far have not addressed the issue fully.",
      "pos": [
        18625,
        18757
      ]
    },
    {
      "content": "Prerequisites",
      "pos": [
        18763,
        18776
      ]
    },
    {
      "pos": [
        18777,
        19005
      ],
      "content": "To perform some of the diagnostic tasks in this section, you need access to a management tool for SQL databases such as <bpt id=\"p1\">**</bpt>SQL Server Management Studio<ept id=\"p1\">**</ept> or the management functionality built into the <bpt id=\"p2\">**</bpt>Azure Management Portal<ept id=\"p2\">**</ept>."
    },
    {
      "content": "SQL Server Management Studio is a free Windows application, which offers the most advanced capabilities.",
      "pos": [
        19007,
        19111
      ]
    },
    {
      "content": "If you do not have access to a Windows machine (for example if you are using a Mac), consider provisioning a Virtual Machine in Azure as shown in <bpt id=\"p1\">[</bpt>Create a Virtual Machine Running Windows Server<ept id=\"p1\">](../virtual-machines-windows-tutorial.md)</ept> and then connecting remotely to it.",
      "pos": [
        19112,
        19384
      ]
    },
    {
      "content": "If you intend to use the VM primarily for the purpose of running SQL Server Management Studio, a <bpt id=\"p1\">**</bpt>Basic A0<ept id=\"p1\">**</ept> (formerly \"Extra Small\") instance should be sufficient.",
      "pos": [
        19385,
        19550
      ]
    },
    {
      "content": "The Azure Management Portal offers a built-in management experience, which is more limited, but is available without a local install.",
      "pos": [
        19553,
        19686
      ]
    },
    {
      "content": "The following steps walk you through obtaining the connection information for the SQL database backing your mobile service and then using either of the two tools to connect to it.",
      "pos": [
        19688,
        19867
      ]
    },
    {
      "content": "You may pick whichever tool you prefer.",
      "pos": [
        19868,
        19907
      ]
    },
    {
      "content": "Obtain SQL connection information",
      "pos": [
        19914,
        19947
      ]
    },
    {
      "pos": [
        19952,
        19991
      ],
      "content": "Launch the <bpt id=\"p1\">[</bpt>Azure Management Portal<ept id=\"p1\">][]</ept>."
    },
    {
      "content": "On the Mobile Services tab, select the service you want to work with.",
      "pos": [
        19995,
        20064
      ]
    },
    {
      "pos": [
        20068,
        20097
      ],
      "content": "Select the <bpt id=\"p1\">**</bpt>Configure<ept id=\"p1\">**</ept> tab."
    },
    {
      "content": "Select the <bpt id=\"p1\">**</bpt>SQL Database<ept id=\"p1\">**</ept> name in the <bpt id=\"p2\">**</bpt>Database Settings<ept id=\"p2\">**</ept> section.",
      "pos": [
        20101,
        20171
      ]
    },
    {
      "content": "This will navigate to the Azure SQL Database tab in the portal.",
      "pos": [
        20172,
        20235
      ]
    },
    {
      "pos": [
        20239,
        20298
      ],
      "content": "Select <bpt id=\"p1\">**</bpt>Set up Azure firewall rules for this IP address<ept id=\"p1\">**</ept>."
    },
    {
      "pos": [
        20302,
        20428
      ],
      "content": "Make a note of the server address in the <bpt id=\"p1\">**</bpt>Connect to your database<ept id=\"p1\">**</ept> section, for example: <bpt id=\"p2\">*</bpt>mcml4otbb9.database.windows.net<ept id=\"p2\">*</ept>."
    },
    {
      "content": "SQL Server Management Studio",
      "pos": [
        20435,
        20463
      ]
    },
    {
      "pos": [
        20467,
        20602
      ],
      "content": "Navigate to <bpt id=\"p1\">[</bpt>SQL Server Editions - Express<ept id=\"p1\">](http://www.microsoft.com/server-cloud/products/sql-server-editions/sql-server-express.aspx)</ept>"
    },
    {
      "pos": [
        20606,
        20702
      ],
      "content": "Find the <bpt id=\"p1\">**</bpt>SQL Server Management Studio<ept id=\"p1\">**</ept> section and select the <bpt id=\"p2\">**</bpt>Download<ept id=\"p2\">**</ept> button underneath."
    },
    {
      "content": "Complete the setup steps until you can successfully run the application:",
      "pos": [
        20706,
        20778
      ]
    },
    {
      "content": "![SQL Server Management Studio][SSMS]",
      "pos": [
        20784,
        20821
      ]
    },
    {
      "pos": [
        20826,
        20888
      ],
      "content": "In the <bpt id=\"p1\">**</bpt>Connect to Server<ept id=\"p1\">**</ept> dialog enter the following values"
    },
    {
      "pos": [
        20895,
        20945
      ],
      "content": "Server name: <bpt id=\"p1\">*</bpt>server address you obtained earlier<ept id=\"p1\">*</ept>"
    },
    {
      "pos": [
        20952,
        20995
      ],
      "content": "Authentication: <bpt id=\"p1\">*</bpt>SQL Server Authentication<ept id=\"p1\">*</ept>"
    },
    {
      "pos": [
        21002,
        21048
      ],
      "content": "Login: <bpt id=\"p1\">*</bpt>login you picked when creating server<ept id=\"p1\">*</ept>"
    },
    {
      "pos": [
        21055,
        21107
      ],
      "content": "Password: <bpt id=\"p1\">*</bpt>password you picked when creating server<ept id=\"p1\">*</ept>"
    },
    {
      "content": "You should now be connected.",
      "pos": [
        21111,
        21139
      ]
    },
    {
      "content": "SQL Database Management Portal",
      "pos": [
        21146,
        21176
      ]
    },
    {
      "pos": [
        21180,
        21253
      ],
      "content": "On Azure SQL Database tab for your database, select the <bpt id=\"p1\">**</bpt>Manage<ept id=\"p1\">**</ept> button"
    },
    {
      "content": "Configure the connection with the following values",
      "pos": [
        21258,
        21308
      ]
    },
    {
      "pos": [
        21315,
        21361
      ],
      "content": "Server: <bpt id=\"p1\">*</bpt>should be pre-set to the right value<ept id=\"p1\">*</ept>"
    },
    {
      "pos": [
        21368,
        21391
      ],
      "content": "Database: <bpt id=\"p1\">*</bpt>leave blank<ept id=\"p1\">*</ept>"
    },
    {
      "pos": [
        21398,
        21447
      ],
      "content": "Username: <bpt id=\"p1\">*</bpt>login you picked when creating server<ept id=\"p1\">*</ept>"
    },
    {
      "pos": [
        21454,
        21506
      ],
      "content": "Password: <bpt id=\"p1\">*</bpt>password you picked when creating server<ept id=\"p1\">*</ept>"
    },
    {
      "content": "You should now be connected.",
      "pos": [
        21510,
        21538
      ]
    },
    {
      "content": "![Azure Management Portal - SQL Database][PortalSqlManagement]",
      "pos": [
        21544,
        21606
      ]
    },
    {
      "content": "Advanced Diagnostics",
      "pos": [
        21644,
        21664
      ]
    },
    {
      "content": "A lot of diagnostic tasks can be completed easily right in the <bpt id=\"p1\">**</bpt>Azure Management Portal<ept id=\"p1\">**</ept>, however some advanced diagnostic tasks are only possible via <bpt id=\"p2\">**</bpt>SQL Server Management Studio<ept id=\"p2\">**</ept> or the <bpt id=\"p3\">**</bpt>SQL Database Management Portal<ept id=\"p3\">**</ept>.",
      "pos": [
        21666,
        21894
      ]
    },
    {
      "content": "We will take advantage of dynamic management views, a set of views populated automatically with diagnostic information about your database.",
      "pos": [
        21896,
        22035
      ]
    },
    {
      "content": "This section provides a set of queries we can run against these views to examine various metrics.",
      "pos": [
        22036,
        22133
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Monitoring SQL Database Using Dynamic Management Views<ept id=\"p1\">][]</ept>.",
      "pos": [
        22134,
        22219
      ]
    },
    {
      "content": "After completing the steps in the previous section to connect to your database in SQL Server Management Studio, select your database in <bpt id=\"p1\">**</bpt>Object Explorer<ept id=\"p1\">**</ept>.",
      "pos": [
        22221,
        22377
      ]
    },
    {
      "content": "Expanding <bpt id=\"p1\">**</bpt>Views<ept id=\"p1\">**</ept> and then <bpt id=\"p2\">**</bpt>System Views<ept id=\"p2\">**</ept> reveals a list of the management views.",
      "pos": [
        22378,
        22463
      ]
    },
    {
      "content": "To execute the queries below, select <bpt id=\"p1\">**</bpt>New Query<ept id=\"p1\">**</ept>, while you have selected your database in <bpt id=\"p2\">**</bpt>Object Explorer<ept id=\"p2\">**</ept>, then paste the query and select <bpt id=\"p3\">**</bpt>Execute<ept id=\"p3\">**</ept>.",
      "pos": [
        22464,
        22622
      ]
    },
    {
      "content": "![SQL Server management Studio - dynamic management views][SSMSDMVs]",
      "pos": [
        22624,
        22692
      ]
    },
    {
      "pos": [
        22694,
        22816
      ],
      "content": "Alternatively if you are using the SQL Database Management Portal, first select your database and then pick <bpt id=\"p1\">**</bpt>New Query<ept id=\"p1\">**</ept>."
    },
    {
      "content": "![SQL Database Management Portal - new query][PortalSqlManagementNewQuery]",
      "pos": [
        22818,
        22892
      ]
    },
    {
      "pos": [
        22894,
        22974
      ],
      "content": "To execute any of the queries below, past it into the window and select <bpt id=\"p1\">**</bpt>Run<ept id=\"p1\">**</ept>."
    },
    {
      "content": "![SQL Database Management Portal - run query][PortalSqlManagementRunQuery]",
      "pos": [
        22976,
        23050
      ]
    },
    {
      "content": "Advanced Metrics",
      "pos": [
        23057,
        23073
      ]
    },
    {
      "content": "The management portal makes certain metrics readily available if using the Basic, Standard, and Premium tiers.",
      "pos": [
        23075,
        23185
      ]
    },
    {
      "content": "However if using the Web and Business tiers, only the Storage metric is available via the portal.",
      "pos": [
        23186,
        23283
      ]
    },
    {
      "content": "Fortunately, it is easy to obtain these and other metrics using the <bpt id=\"p1\">**</bpt><bpt id=\"p2\">[</bpt>sys.resource\\_stats<ept id=\"p2\">](http://msdn.microsoft.com/library/dn269979.aspx)</ept><ept id=\"p1\">**</ept> management view, regardless of what tier you're using.",
      "pos": [
        23284,
        23481
      ]
    },
    {
      "content": "Consider the following query:",
      "pos": [
        23482,
        23511
      ]
    },
    {
      "pos": [
        23636,
        23787
      ],
      "content": "[AZURE.NOTE] \nPlease execute this query on the **master** database on your server, the **sys.resource\\_stats** view is only present on that database.",
      "leadings": [
        "",
        "> "
      ],
      "nodes": [
        {
          "content": "Please execute this query on the <bpt id=\"p1\">**</bpt>master<ept id=\"p1\">**</ept> database on your server, the <bpt id=\"p2\">**</bpt>sys.resource\\_stats<ept id=\"p2\">**</ept> view is only present on that database.",
          "pos": [
            14,
            149
          ]
        }
      ]
    },
    {
      "content": "The result will contain the following useful metrics: CPU (% of tier limit), Storage (megabytes), Physical Data Reads (% of tier limit), Log Writes (% of tier limit), Memory (% of tier limit), Worker Count, Session Count, etc.",
      "pos": [
        23789,
        24015
      ]
    },
    {
      "content": "SQL connectivity events",
      "pos": [
        24023,
        24046
      ]
    },
    {
      "pos": [
        24048,
        24185
      ],
      "content": "The <bpt id=\"p1\">**</bpt><bpt id=\"p2\">[</bpt>sys.event\\_log<ept id=\"p2\">](http://msdn.microsoft.com/library/azure/jj819229.aspx)</ept><ept id=\"p1\">**</ept> view contains the details of connectivity-related events."
    },
    {
      "pos": [
        24330,
        24476
      ],
      "content": "[AZURE.NOTE] \nPlease execute this query on the **master** database on your server, the **sys.event\\_log** view is only present on that database.",
      "leadings": [
        "",
        "> "
      ],
      "nodes": [
        {
          "content": "Please execute this query on the <bpt id=\"p1\">**</bpt>master<ept id=\"p1\">**</ept> database on your server, the <bpt id=\"p2\">**</bpt>sys.event\\_log<ept id=\"p2\">**</ept> view is only present on that database.",
          "pos": [
            14,
            144
          ]
        }
      ]
    },
    {
      "content": "Advanced Indexing",
      "pos": [
        24512,
        24529
      ]
    },
    {
      "content": "A table or view can contain the following types of indexes:",
      "pos": [
        24531,
        24590
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Clustered<ept id=\"p1\">**</ept>.",
      "pos": [
        24594,
        24608
      ]
    },
    {
      "content": "A clustered index specifies how records are physically stored on disk.",
      "pos": [
        24609,
        24679
      ]
    },
    {
      "content": "There must be only one clustered index per table, because the data rows themselves can be sorted in only one order.",
      "pos": [
        24680,
        24795
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Nonclustered<ept id=\"p1\">**</ept>.",
      "pos": [
        24799,
        24816
      ]
    },
    {
      "content": "Nonclustered indexes are stored separately from data rows and are used to do a lookup based on the index value.",
      "pos": [
        24817,
        24928
      ]
    },
    {
      "content": "All nonclustered indexes on a table use the key values from the clustered index as lookup key.",
      "pos": [
        24929,
        25023
      ]
    },
    {
      "content": "To provide a real-world analogy: consider a book or a technical manual.",
      "pos": [
        25025,
        25096
      ]
    },
    {
      "content": "The contents of each page are a record, the page number is the clustered index, and the topic index in the back of the book is a nonclustered index.",
      "pos": [
        25097,
        25245
      ]
    },
    {
      "content": "Each entry in the topic index points to the clustered index, the page number.",
      "pos": [
        25246,
        25323
      ]
    },
    {
      "pos": [
        25327,
        25739
      ],
      "content": "[AZURE.NOTE] \nBy default, the JavaScript backend of Azure Mobile Services sets **\\_createdAt** as the clustered index. If you remove this column, or if you want a different clustered index, be sure to follow the [clustered index design guidelines](#ClusteredIndexes) below. In the .NET backend, the class `EntityData` defines `CreatedAt` as a clustered index using the annotation `[Index(IsClustered = true)]`.",
      "leadings": [
        "",
        "> "
      ],
      "nodes": [
        {
          "content": "By default, the JavaScript backend of Azure Mobile Services sets **\\_createdAt** as the clustered index. If you remove this column, or if you want a different clustered index, be sure to follow the [clustered index design guidelines](#ClusteredIndexes) below. In the .NET backend, the class `EntityData` defines `CreatedAt` as a clustered index using the annotation `[Index(IsClustered = true)]`.",
          "pos": [
            14,
            410
          ],
          "nodes": [
            {
              "content": "By default, the JavaScript backend of Azure Mobile Services sets <bpt id=\"p1\">**</bpt>\\_createdAt<ept id=\"p1\">**</ept> as the clustered index.",
              "pos": [
                0,
                104
              ]
            },
            {
              "content": "If you remove this column, or if you want a different clustered index, be sure to follow the <bpt id=\"p1\">[</bpt>clustered index design guidelines<ept id=\"p1\">](#ClusteredIndexes)</ept> below.",
              "pos": [
                105,
                259
              ]
            },
            {
              "content": "In the .NET backend, the class <ph id=\"ph1\">`EntityData`</ph> defines <ph id=\"ph2\">`CreatedAt`</ph> as a clustered index using the annotation <ph id=\"ph3\">`[Index(IsClustered = true)]`</ph>.",
              "pos": [
                260,
                396
              ]
            }
          ]
        }
      ]
    },
    {
      "content": "Clustered index design guidelines",
      "pos": [
        25778,
        25811
      ]
    },
    {
      "content": "Every table should have a clustered index on the column (or columns, in the case of a composite key) with the following properties:",
      "pos": [
        25813,
        25944
      ]
    },
    {
      "content": "Narrow - uses a small datatype, or is a [composite key][Primary and Foreign Key Constraints] of a small number of narrow columns",
      "pos": [
        25948,
        26076
      ]
    },
    {
      "content": "Unique, or mostly unique",
      "pos": [
        26079,
        26103
      ]
    },
    {
      "content": "Static - value is not frequently changed",
      "pos": [
        26106,
        26146
      ]
    },
    {
      "content": "Ever-increasing",
      "pos": [
        26149,
        26164
      ]
    },
    {
      "content": "(Optional) Fixed-width",
      "pos": [
        26168,
        26190
      ]
    },
    {
      "content": "(Optional) nonnull",
      "pos": [
        26193,
        26211
      ]
    },
    {
      "content": "The reason for the <bpt id=\"p1\">**</bpt>narrow<ept id=\"p1\">**</ept> property is that all other indexes on a table use the key values from the clustered index as lookup keys.",
      "pos": [
        26213,
        26348
      ]
    },
    {
      "content": "In the example of a topic index at the back of a book, the clustered index is a page number and is a small number.",
      "pos": [
        26349,
        26463
      ]
    },
    {
      "content": "If the chapter title were instead included in the clustered index, then the topic index would itself be much longer, because the key value would then be (chapter name, page number).",
      "pos": [
        26464,
        26645
      ]
    },
    {
      "pos": [
        26647,
        26900
      ],
      "content": "The key should be <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>ever-increasing<ept id=\"p2\">**</ept> to avoid having to maintain the physical location of the records (which means either moving records physically, or potentially fragmenting storage by splitting the pages where the records are stored)."
    },
    {
      "content": "The clustered index will be most valuable for queries that do the following:",
      "pos": [
        26903,
        26979
      ]
    },
    {
      "content": "Return a range of values by using operators such as BETWEEN, &gt;, &gt;=, &lt;, and &lt;=.",
      "pos": [
        26983,
        27061
      ]
    },
    {
      "content": "After the row with the first value is found by using the clustered index, rows with subsequent indexed values are guaranteed to be physically adjacent.",
      "pos": [
        27069,
        27220
      ]
    },
    {
      "content": "Use JOIN clauses; typically these are foreign key columns.",
      "pos": [
        27224,
        27282
      ]
    },
    {
      "content": "Use ORDER BY, or GROUP BY clauses.",
      "pos": [
        27285,
        27319
      ]
    },
    {
      "content": "An index on the columns specified in the ORDER BY or GROUP BY clause may remove the need for the Database Engine to sort the data, because the rows are already sorted.",
      "pos": [
        27326,
        27493
      ]
    },
    {
      "content": "This improves query performance.",
      "pos": [
        27494,
        27526
      ]
    },
    {
      "content": "Creating clustered indexes in Entity Framework",
      "pos": [
        27533,
        27579
      ]
    },
    {
      "content": "To set the clustered index in the .NET backend using Entity Framework, set the <ph id=\"ph1\">`IsClustered`</ph> property of the annotation.",
      "pos": [
        27581,
        27701
      ]
    },
    {
      "content": "For example, this is the definition of <ph id=\"ph1\">`CreatedAt`</ph> in <ph id=\"ph2\">`Microsoft.WindowsAzure.Mobile.Service.EntityData`</ph>:",
      "pos": [
        27702,
        27807
      ]
    },
    {
      "content": "Creating indexes in the database schema",
      "pos": [
        28010,
        28049
      ]
    },
    {
      "content": "For the JavaScript backend, you can only modify the clustered index of a table by changing the database schema directly, either through SQL Server Management Studio or the Azure SQL Database Portal.",
      "pos": [
        28051,
        28249
      ]
    },
    {
      "content": "The following guides describe how to set a clustered or nonclustered index by modifying the database schema directly:",
      "pos": [
        28251,
        28368
      ]
    },
    {
      "content": "[Creating and Modifying PRIMARY KEY Constraints][]",
      "pos": [
        28374,
        28424
      ]
    },
    {
      "content": "[Create Nonclustered Indexes][]",
      "pos": [
        28427,
        28458
      ]
    },
    {
      "content": "[Create Clustered Indexes][]",
      "pos": [
        28461,
        28489
      ]
    },
    {
      "content": "[Create Unique Indexes][]",
      "pos": [
        28492,
        28517
      ]
    },
    {
      "content": "Find top N missing indexes",
      "pos": [
        28524,
        28550
      ]
    },
    {
      "content": "You can write SQL queries on dynamic management views that will tell you more detailed information about the resource usage of individual queries or give you heuristics on what indexes to add.",
      "pos": [
        28552,
        28744
      ]
    },
    {
      "content": "The following query determines which 10 missing indexes would produce the highest anticipated cumulative improvement, in descending order, for user queries.",
      "pos": [
        28745,
        28901
      ]
    },
    {
      "content": "The following example query runs a join across these tables to get a list of the columns that should be part of each missing index and calculates an 'index advantage' to determine if the given index should be considered:",
      "pos": [
        29058,
        29278
      ]
    },
    {
      "pos": [
        29780,
        29935
      ],
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Monitoring SQL Database Using Dynamic Management Views<ept id=\"p1\">][]</ept> and <bpt id=\"p2\">[</bpt>Missing Index Dynamic Management Views<ept id=\"p2\">](sys-missing-index-stats)</ept>."
    },
    {
      "content": "Advanced Query Design",
      "pos": [
        29968,
        29989
      ]
    },
    {
      "content": "Frequently it's difficult to diagnose what queries queres are most expensive for the database.",
      "pos": [
        29992,
        30086
      ]
    },
    {
      "content": "Finding top N queries",
      "pos": [
        30094,
        30115
      ]
    },
    {
      "content": "The following example returns information about the top five queries ranked by average CPU time.",
      "pos": [
        30117,
        30213
      ]
    },
    {
      "content": "This example aggregates the queries according to their query hash, so that logically equivalent queries are grouped by their cumulative resource consumption.",
      "pos": [
        30214,
        30371
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Monitoring SQL Database Using Dynamic Management Views<ept id=\"p1\">][]</ept>.",
      "pos": [
        31063,
        31148
      ]
    },
    {
      "content": "In addition to executing the query, the <bpt id=\"p1\">**</bpt>SQL Database Management Portal<ept id=\"p1\">**</ept> gives you a nice shortcut to see this data, by slecting <bpt id=\"p2\">**</bpt>Summary<ept id=\"p2\">**</ept> for your database and then selecting <bpt id=\"p3\">**</bpt>Query Performance<ept id=\"p3\">**</ept>:",
      "pos": [
        31149,
        31351
      ]
    },
    {
      "content": "![SQL Database Management Portal - query performance][PortalSqlManagementQueryPerformance]",
      "pos": [
        31353,
        31443
      ]
    },
    {
      "content": "Analyzing the query plan",
      "pos": [
        31450,
        31474
      ]
    },
    {
      "content": "Once you have identified expensive queries or if you are about to deploy code using new queries and you would like to investigate their performance, the tooling offers great support for analyzing the <bpt id=\"p1\">**</bpt>query plan<ept id=\"p1\">**</ept>.",
      "pos": [
        31476,
        31691
      ]
    },
    {
      "content": "The query plan enables you to see what operations take up the builk of CPU time and IO resources when a given SQL query runs.",
      "pos": [
        31692,
        31817
      ]
    },
    {
      "content": "To analyze the query plan in <bpt id=\"p1\">**</bpt>SQL Server Management Studio<ept id=\"p1\">**</ept>, use the highlighted toolbar buttons.",
      "pos": [
        31818,
        31917
      ]
    },
    {
      "content": "![SQL Server Management Studio - query plan][SSMSQueryPlan]",
      "pos": [
        31919,
        31978
      ]
    },
    {
      "pos": [
        31980,
        32084
      ],
      "content": "To analyze the query plan in the <bpt id=\"p1\">**</bpt>SQL Database Management Portal<ept id=\"p1\">**</ept>, use the highlightd toolbar buttons."
    },
    {
      "content": "![SQL Database Management Portal - query plan][PortalSqlManagementQueryPlan]",
      "pos": [
        32086,
        32162
      ]
    },
    {
      "content": "See Also",
      "pos": [
        32167,
        32175
      ]
    },
    {
      "content": "Azure SQL Database Documentation",
      "pos": [
        32180,
        32212
      ]
    },
    {
      "content": "Azure SQL Database performance and scaling",
      "pos": [
        32219,
        32261
      ]
    },
    {
      "content": "Troubleshooting Azure SQL Database",
      "pos": [
        32268,
        32302
      ]
    },
    {
      "content": "Indexing",
      "pos": [
        32311,
        32319
      ]
    },
    {
      "content": "[Index Basics][]",
      "pos": [
        32323,
        32339
      ]
    },
    {
      "content": "[General Index Design Guidelines][]",
      "pos": [
        32342,
        32377
      ]
    },
    {
      "content": "[Unique Index Design Guidelines][]",
      "pos": [
        32380,
        32414
      ]
    },
    {
      "content": "[Clustered Index Design Guidelines][]",
      "pos": [
        32417,
        32454
      ]
    },
    {
      "content": "[Primary and Foreign Key Constraints][]",
      "pos": [
        32457,
        32496
      ]
    },
    {
      "content": "[How much does that key cost?][]",
      "pos": [
        32499,
        32531
      ]
    },
    {
      "content": "Entity Framework",
      "pos": [
        32537,
        32553
      ]
    },
    {
      "content": "Performance Considerations for Entity Framework 5",
      "pos": [
        32557,
        32606
      ]
    },
    {
      "content": "Code First Data Annotations",
      "pos": [
        32613,
        32640
      ]
    }
  ],
  "content": "<properties \n    pageTitle=\"Scale mobile services backed by Azure SQL Database | Microsoft Azure\" \n    description=\"Learn how to diagnose and fix scalability issues in your mobile services backed by SQL Database\" \n    services=\"mobile-services\" \n    documentationCenter=\"\" \n    authors=\"lindydonna\" \n    manager=\"dwrede\" \n    editor=\"mollybos\"/>\n\n<tags \n    ms.service=\"mobile-services\" \n    ms.workload=\"mobile\" \n    ms.tgt_pltfrm=\"na\" \n    ms.devlang=\"multiple\" \n    ms.topic=\"article\" \n    ms.date=\"08/08/2015\" \n    ms.author=\"donnam;ricksal\"/>\n\n# Scale mobile services backed by Azure SQL Database\n\nAzure Mobile Services makes it very easy to get started and build an app that connects to a cloud-hosted backend that stores data in a SQL database. As your app grows, scaling your service instances is as simple as adjusting scale settings in the portal to add more computational and networking capacity. However, scaling the SQL database backing your service requires some proactive planning and monitoring as the service receives more load. This document will walk you through a set of best practices to ensure continued great performance of your SQL-backed mobile services.\n\nThis topic walks you through these basic sections:\n\n1. [Diagnosing Problems](#Diagnosing)\n2. [Indexing](#Indexing)\n3. [Schema Design](#Schema)\n4. [Query Design](#Query)\n5. [Service Architecture](#Architecture)\n6. [Advanced Troubleshooting](#Advanced)\n\n<a name=\"Diagnosing\"></a>\n## Diagnosing Problems\n\nIf you suspect your mobile service is experiencing problems under load, the first place to check is the **Dashboard** tab for your service in the [Azure Management Portal][]. Some of the things to verify here:\n\n- Your usage meters including **API Calls** and **Active Devices** meters are not over quota\n- **Endpoint Monitoring** status indicates service is up (only available if service is using the Standard tier and Endpoint Monitoring is enabled) \n\nIf any of the above is not true, consider adjusting your scale settings on the *Scale* tab. If that does not address the issue, you can proceed and investigate whether Azure SQL Database may be the source of the issue. The next few sections cover a few different approaches to diagnose what may be going wrong.\n\n### Choosing the Right SQL Database Tier \n\nIt is important to understand the different database tiers you have at your disposal to ensure you've picked the right tier given your app's needs. Azure SQL Database offers two different database editions and three different service tiers:\n\n- Web and Business Editions (retired)\n- Basic, Standard, and Premium service tiers\n\nWhile the Web and Business Editions are fully supported, they will be retired on September 12, 2015 as discussed in [Web and Business Edition Sunset FAQ](http://msdn.microsoft.com/library/azure/dn741330.aspx). We encourage new customers to start using the Basic, Standard, and Premium service tiers in preparation for this change. They provide a variety of monitoring capabilities that make it even easier to understand and troubleshoot database performance. All new mobile services are created using one of the new service tiers.\n\nTo convert a mobile service using the Web and Business Edition to the Basic, Standard, and Premium service tiers, follow these steps.\n\n1. Launch the [Azure Management Portal][].\n2. Select **+NEW** in the toolbar and then pick **Data Services**, **SQL Database**, **Quick Create**.\n3. Enter a database name and then select **New SQL database server** in the **Server** field. This will create a server that is using the new Basic, Standard, or Premium service tier. \n4. Fill out the rest of the fields and select **Create SQL Database**. This will create a 100MB database using the Basic tier.\n5. Configure your mobile service to use the database you just created. Navigate to the **Configure** tab for that service and select **Change Database** in the toolbar. On the next screen, select **Use an existing SQL database** in the **SQL Database** field and then select **Next**. On the next screen be sure to pick the database you created in step 5, then select **OK**.\n\nHere are some recommendations on selecting the right tier for your database:\n\n- **Basic** - use at development time or for small production services where you only expect to make a single database query at a time\n- **Standard** - use for production services where you expect multiple concurrent database queries\n- **Premium** - use for large scale production services with many concurrent queries, high peak load, and expected low latency for every request.\n\nFor more information on when to use each tier, see [Reasons to Use the New Service Tiers](http://msdn.microsoft.com/library/azure/dn369873.aspx#Reasons)\n\n### Analyzing Database Metrics\n\nOnce you are familiar with the different database tiers, we can explore database performance metrics to help us reason about scaling within and among the tiers.\n\n1. Launch the [Azure Management Portal][].\n2. On the Mobile Services tab, select the service you want to work with.\n3. Select the **Configure** tab.\n4. Select the **SQL Database** name in the **Database Settings** section. This will navigate to the Azure SQL Database tab in the portal.\n5. Navigate to the **Monitor** tab\n6. Ensure the relevant metrics are displayed by using the **Add Metrics** button. Include the following\n    - *CPU Percentage* (available only in Basic/Standard/Premium tiers)\n    - *Physical Data Reads Percentage* (available only in Basic/Standard/Premium tiers) \n    - *Log Writes Percentage* (available only in Basic/Standard/Premium tiers)\n    - *Storage* \n7. Inspect the metrics over the time window when your service was experiencing issues. \n\n    ![Azure Management Portal - SQL Database Metrics][PortalSqlMetrics]\n\nIf any metric exceeds 80% utilization for an extended period of time, this could indicate a performance problem. For more detailed information on understanding database utilization, see [Understanding Resource Use](http://msdn.microsoft.com/library/azure/dn369873.aspx#Resource).\n\nIf the metrics indicate your database is incurring high utilization, consider **scaling up the database to a higher service tier** as a first mitigation step. To immediately resolve issues, consider using the **Scale** tab for your database to scale up your database. This will result in an increase in your bill.\n![Azure Management Portal - SQL Database Scale][PortalSqlScale]\n\nAs soon as possible, consider these additional mitigation steps:\n\n- **Tune your database.**\n  It is frequently possible to reduce database utilization and avoid having to scale to a higher tier by optimizing your database. \n- **Consider your service architecture.**\n  Frequently your service load is not distributed evenly over time but contains \"spikes\" of high demand. Instead of scaling the database up to handle the spikes, and having it go underutilized during periods of low demand, it is frequently possible to adjust the service architecture to avoid such spikes, or to handle them without incurring database hits.\n\nThe remaining sections of this document contain tailored guidance to help with implementing these mitigations.\n\n\n### Configuring Alerts\n\nIt is frequently useful to configure alerts for key database metrics as a proactive step to ensure you have plenty of time to react in case of resource exhaustion. \n\n1. Navigate to the **Monitoring** tab for the database you want to set up alerts for\n2. Ensure the relevant metrics are displayed as described in the previous section\n3. Select the metric you want to set an alert for and select **Add Rule**\n    ![Azure Management Portal - SQL Alert][PortalSqlAddAlert]\n4. Provide a name and description for the alert\n    ![Azure Management Portal - SQL Alert Name and Description][PortalSqlAddAlert2]\n5. Specify the value to use as the alert threshold. Consider using **80%** to allow for some reaction time. Also be sure to specify an email address that you actively monitor. \n    ![Azure Management Portal - SQL Alert Threshold and Email][PortalSqlAddAlert3]\n\nFor more information on diagnosing SQL issues, see [Advanced Diagnostics](#AdvancedDiagnosing) at the bottom of this document.\n\n<a name=\"Indexing\"></a>\n## Indexing\n\nWhen you start to see problems with your query performance, the first thing you should investigate is the design of your indexes. Indexes are important because they directly affect how the SQL engine executes a query. \n\nFor instance, if you often need to look up an element by a certain field, you should consider adding an index for that column. Otherwise, the SQL engine will be forced to perform a table scan and read each physical record (or at least the query column) and the records could be substantially spread out on disk.\n\nSo, if you are frequently doing WHERE or JOIN statements on particular columns, you should make sure you index them. See the section [Creating Indexes](#CreatingIndexes) for more information.\n\nIf indexes are so great and table scans are so bad, does that mean you should index every column in your table, just to be safe?  The short answer is, \"probably not.\" Indexes take up space and have overhead themselves: every time there is an insert in a table, the index structures for each of the indexed columns need to be updated. See below for guidelines on how to choose your column indexes.\n\n### Index Design Guidelines\n\nAs mentioned above, it's not always better to add more indexes to a table, because indexes themselves can be costly, both in terms of performance and storage overhead.\n\n#### Query considerations\n\n- Consider adding indexes to columns that are frequently used in predicates (e.g., WHERE clauses) and join conditions, while balancing the database considerations below.\n- Write queries that insert or modify as many rows as possible in a single statement, instead of using multiple queries to update the same rows. When there is only one statement, the database engine can better optimize how it maintains indexes.\n    \n#### Database considerations\n\nLarge numbers of indexes on a table affect the performance of INSERT, UPDATE, DELETE, and MERGE statements because all indexes must be adjusted appropriately as data in the table changes.\n\n- For **heavily updated** tables, avoid indexing heavily updated columns.\n- For tables that are **not frequently updated** but that have large volumes of data, use many indexes. This can improve the performance of queries that do not modify data (such as SELECT statements) because the query optimizer will have more options for finding the best access method.\n\nIndexing small tables may not be optimal because it can take the query optimizer longer to traverse the index searching for data than to perform a simple table scan. Therefore, indexes on small tables might never be used, but must still be maintained as data in the table changes.\n\n\n<a name=\"CreatingIndexes\"></a>\n### Creating Indexes\n\n#### JavaScript backend\n\nTo set the index for a column in the JavaScript backend, do the following:\n\n1. Open your mobile service in the [Azure Management Portal][].\n2. Click the **Data** tab.\n3. Select the table you want to modify.\n4. Click the **Columns** tab.\n5. Select the column. In the command bar, click **Set Index**:\n\n    ![Mobile Services Portal - Set Index][SetIndexJavaScriptPortal]\n\nYou can also remove indexes within this view.\n\n#### .NET backend\n\nTo define an index in Entity Framework, use the attribute `[Index]` on the fields that you want to index. For example:\n\n    public class TodoItem : EntityData\n    {\n        public string Text { get; set; }\n\n        [Index]\n        public bool Complete { get; set; }\n    }\n         \nFor more information on indexes, see [Index Annotations in Entity Framework][]. For further tips on optimizing indexes, see [Advanced Indexing](#AdvancedIndexing) at the bottom of this document.\n\n<a name=\"Schema\"></a>\n## Schema Design\n\nHere are a few issues to be aware of when picking the data types for your objects, which in turn translates to the schema of your SQL database. Tuning the schema can frequently bring significant performance improvements since SQL has custom optimized ways of handling indexing and storage for different data types:\n\n- **Use the provided ID column**. Every mobile service table comes with a default ID column configured as the primary key and has an index set on it. There is no need to create an additional ID column.\n- **Use the correct datatypes in your model.** If you know a certain property of your model will be a numeric or boolean, be sure to define it that way in your model instead of as a string. In the JavaScript backend, use literals such as `true` instead of `\"true\"` and `5` instead of `\"5\"`. In the .NET backend, use the `int` and `bool` types when you declare the properties of your model. This enables SQL to create the correct schema for those types, which makes queries more efficient.  \n\n<a name=\"Query\"></a>\n## Query Design\n\nHere are some guidelines to consider when querying the database:\n\n- **Always execute join operations in the database.** Frequently you will need to combine records from two or more tables where the records being combined share a common field (also known as a *join*). This operation can be inefficient if performed incorrectly since it may involve pulling down all the entities from both tables and then iterating through all of them. This kind of operation is best left to the database itself, but it is sometimes easy to mistakenly perform it on the client or in the mobile service code.\n    - Don't perform joins in your app code\n    - Don't perform joins in your mobile service code. When using the JavaScript backend, be aware that the [table object](http://msdn.microsoft.com/library/windowsazure/jj554210.aspx) does not handle joins. Be sure to use the [mssql object](http://msdn.microsoft.com/library/windowsazure/jj554212.aspx) directly to ensure the join happens in the database. For more information, see [Join relational tables](mobile-services-how-to-use-server-scripts.md#joins). If using the .NET backend and querying via LINQ, joins are automatically handled at the database level by Entity Framework.\n- **Implement paging.** Querying the database can sometimes result in a large number of records being returned to the client. To minimize the size and latency of operations, consider implementing paging.\n    - By default your mobile service will limit any incoming queries to a page size of 50, and you can manually request up to 1,000 records. For more information, see \"Return data in pages\" for [Windows Store](mobile-services-windows-dotnet-how-to-use-client-library.md#paging), [iOS](mobile-services-ios-how-to-use-client-library.md#paging), [Android](mobile-services-android-how-to-use-client-library.md#paging), [HTML/JavaScript](mobile-services-html-how-to-use-client-library/#paging), and [Xamarin](partner-xamarin-mobile-services-how-to-use-client-library.md#paging).\n    - There is no default page size for queries made from your mobile service code. If your app does not implement paging, or as a defensive measure, consider applying default limits to your queries. In the JavaScript backend, use the **take** operator on the [query object](http://msdn.microsoft.com/library/azure/jj613353.aspx). If using the .NET backend, consider using the [Take method](http://msdn.microsoft.com/library/vstudio/bb503062(v=vs.110).aspx) as part of your LINQ query.  \n\nFor more information on improving query design, including how to analyze query plans, see [Advanced Query Design](#AdvancedQuery) at the bottom of this document.\n\n<a name=\"Architecture\"></a>\n## Service Architecture\n\nImagine a scenario where you are about to send a push notification to all your customers to check out some new content in your app. As they tap on the notification, the app launches, which possibly triggers a call to your mobile service and a query execution against your SQL database. As potentially millions of customers take this action over the span of just a few minutes, this will generate a surge of SQL load, which may be orders of magnitude higher than your app's steady state load. This could be addressed by scaling your app to a higher SQL tier during the spike and then scaling it back down, however that solution requires manual intervention and comes with increased cost. Frequently slight tweaks in your mobile service architecture can significantly balance out the load clients drive to your SQL database and eliminate problematic spikes in demand. These modifications can often be implemented easily with minimal impact to your customer's experience. Here are some examples:\n\n- **Spread out the load over time.** If you control the timing of certain events (for example, a broadcast push notification), which are expected to generate a spike in demand, and the timing of those events is not critical, consider spreading them out over time. In the example above, perhaps it is acceptable for your app customers to get notified of the new app content in batches over the span of a day instead of nearly simultaneously. Consider batching up your customers into groups which will allow staggered delivery to each batch. If using Notification Hubs, applying an additional tag to track the batch, and then delivering a push notification to that tag provides an easy way to implement this strategy. For more information on tags, see [Use Notification Hubs to send breaking news](../notification-hubs-windows-store-dotnet-send-breaking-news.md).\n- **Use Blob and Table Storage whenever appropriate.** Frequently the content that the customers will view during the spike is fairly static and doesn't need to be stored in a SQL database since you are unlikely to need relational querying capabilities over that content. In that case, consider storing the content in Blob or Table Storage. You can access public blobs in Blob Storage directly from the device. To access blobs in a secure way or use Table Storage, you will need to go through a Mobile Services Custom API in order to protect your storage access key. For more information, see [Upload images to Azure Storage by using Mobile Services](mobile-services-dotnet-backend-windows-store-dotnet-upload-data-blob-storage.md).\n- **Use an in-memory cache**. Another alternative is to store data, which would commonly be accessed during a traffic spike, in an in-memory cache such as [Azure Cache](http://azure.microsoft.com/services/cache/). This means incoming requests would be able to fetch the information they need from memory, instead of repeatedly querying the database.\n\n<a name=\"Advanced\"></a>\n## Advanced Troubleshooting\nThis section covers some more advanced diagnostic tasks, which may be useful if the steps so far have not addressed the issue fully.\n\n### Prerequisites\nTo perform some of the diagnostic tasks in this section, you need access to a management tool for SQL databases such as **SQL Server Management Studio** or the management functionality built into the **Azure Management Portal**.\n\nSQL Server Management Studio is a free Windows application, which offers the most advanced capabilities. If you do not have access to a Windows machine (for example if you are using a Mac), consider provisioning a Virtual Machine in Azure as shown in [Create a Virtual Machine Running Windows Server](../virtual-machines-windows-tutorial.md) and then connecting remotely to it. If you intend to use the VM primarily for the purpose of running SQL Server Management Studio, a **Basic A0** (formerly \"Extra Small\") instance should be sufficient. \n\nThe Azure Management Portal offers a built-in management experience, which is more limited, but is available without a local install.\n\nThe following steps walk you through obtaining the connection information for the SQL database backing your mobile service and then using either of the two tools to connect to it. You may pick whichever tool you prefer.\n\n#### Obtain SQL connection information \n1. Launch the [Azure Management Portal][].\n2. On the Mobile Services tab, select the service you want to work with.\n3. Select the **Configure** tab.\n4. Select the **SQL Database** name in the **Database Settings** section. This will navigate to the Azure SQL Database tab in the portal.\n5. Select **Set up Azure firewall rules for this IP address**.\n6. Make a note of the server address in the **Connect to your database** section, for example: *mcml4otbb9.database.windows.net*.\n\n#### SQL Server Management Studio\n1. Navigate to [SQL Server Editions - Express](http://www.microsoft.com/server-cloud/products/sql-server-editions/sql-server-express.aspx)\n2. Find the **SQL Server Management Studio** section and select the **Download** button underneath.\n3. Complete the setup steps until you can successfully run the application:\n\n    ![SQL Server Management Studio][SSMS]\n\n4. In the **Connect to Server** dialog enter the following values\n    - Server name: *server address you obtained earlier*\n    - Authentication: *SQL Server Authentication*\n    - Login: *login you picked when creating server*\n    - Password: *password you picked when creating server*\n5. You should now be connected.\n\n#### SQL Database Management Portal\n1. On Azure SQL Database tab for your database, select the **Manage** button \n2. Configure the connection with the following values\n    - Server: *should be pre-set to the right value*\n    - Database: *leave blank*\n    - Username: *login you picked when creating server*\n    - Password: *password you picked when creating server*\n3. You should now be connected.\n\n    ![Azure Management Portal - SQL Database][PortalSqlManagement]\n\n<a name=\"AdvancedDiagnosing\" />\n### Advanced Diagnostics\n\nA lot of diagnostic tasks can be completed easily right in the **Azure Management Portal**, however some advanced diagnostic tasks are only possible via **SQL Server Management Studio** or the **SQL Database Management Portal**.  We will take advantage of dynamic management views, a set of views populated automatically with diagnostic information about your database. This section provides a set of queries we can run against these views to examine various metrics. For more information, see [Monitoring SQL Database Using Dynamic Management Views][].\n\nAfter completing the steps in the previous section to connect to your database in SQL Server Management Studio, select your database in **Object Explorer**. Expanding **Views** and then **System Views** reveals a list of the management views. To execute the queries below, select **New Query**, while you have selected your database in **Object Explorer**, then paste the query and select **Execute**.\n\n![SQL Server management Studio - dynamic management views][SSMSDMVs]\n\nAlternatively if you are using the SQL Database Management Portal, first select your database and then pick **New Query**.\n\n![SQL Database Management Portal - new query][PortalSqlManagementNewQuery]\n\nTo execute any of the queries below, past it into the window and select **Run**.\n\n![SQL Database Management Portal - run query][PortalSqlManagementRunQuery]\n\n#### Advanced Metrics\n\nThe management portal makes certain metrics readily available if using the Basic, Standard, and Premium tiers. However if using the Web and Business tiers, only the Storage metric is available via the portal. Fortunately, it is easy to obtain these and other metrics using the **[sys.resource\\_stats](http://msdn.microsoft.com/library/dn269979.aspx)** management view, regardless of what tier you're using. Consider the following query:\n\n    SELECT TOP 10 * \n    FROM sys.resource_stats \n    WHERE database_name = 'todoitem_db' \n    ORDER BY start_time DESC\n\n> [AZURE.NOTE] \n> Please execute this query on the **master** database on your server, the **sys.resource\\_stats** view is only present on that database.\n\nThe result will contain the following useful metrics: CPU (% of tier limit), Storage (megabytes), Physical Data Reads (% of tier limit), Log Writes (% of tier limit), Memory (% of tier limit), Worker Count, Session Count, etc. \n\n#### SQL connectivity events\n\nThe **[sys.event\\_log](http://msdn.microsoft.com/library/azure/jj819229.aspx)** view contains the details of connectivity-related events.\n\n    select * from sys.event_log \n    where database_name = 'todoitem_db'\n    and event_type like 'throttling%'\n    order by start_time desc\n\n> [AZURE.NOTE] \n> Please execute this query on the **master** database on your server, the **sys.event\\_log** view is only present on that database.\n\n<a name=\"AdvancedIndexing\" />\n### Advanced Indexing\n\nA table or view can contain the following types of indexes:\n\n- **Clustered**. A clustered index specifies how records are physically stored on disk. There must be only one clustered index per table, because the data rows themselves can be sorted in only one order.\n\n- **Nonclustered**. Nonclustered indexes are stored separately from data rows and are used to do a lookup based on the index value. All nonclustered indexes on a table use the key values from the clustered index as lookup key.\n\nTo provide a real-world analogy: consider a book or a technical manual. The contents of each page are a record, the page number is the clustered index, and the topic index in the back of the book is a nonclustered index. Each entry in the topic index points to the clustered index, the page number.\n\n> [AZURE.NOTE] \n> By default, the JavaScript backend of Azure Mobile Services sets **\\_createdAt** as the clustered index. If you remove this column, or if you want a different clustered index, be sure to follow the [clustered index design guidelines](#ClusteredIndexes) below. In the .NET backend, the class `EntityData` defines `CreatedAt` as a clustered index using the annotation `[Index(IsClustered = true)]`.\n\n<a name=\"ClusteredIndexes\"></a>\n#### Clustered index design guidelines\n\nEvery table should have a clustered index on the column (or columns, in the case of a composite key) with the following properties:\n\n- Narrow - uses a small datatype, or is a [composite key][Primary and Foreign Key Constraints] of a small number of narrow columns\n- Unique, or mostly unique\n- Static - value is not frequently changed\n- Ever-increasing \n- (Optional) Fixed-width\n- (Optional) nonnull\n\nThe reason for the **narrow** property is that all other indexes on a table use the key values from the clustered index as lookup keys. In the example of a topic index at the back of a book, the clustered index is a page number and is a small number. If the chapter title were instead included in the clustered index, then the topic index would itself be much longer, because the key value would then be (chapter name, page number).\n\nThe key should be **static** and **ever-increasing** to avoid having to maintain the physical location of the records (which means either moving records physically, or potentially fragmenting storage by splitting the pages where the records are stored). \n\nThe clustered index will be most valuable for queries that do the following:\n\n- Return a range of values by using operators such as BETWEEN, >, >=, <, and <=. \n    - After the row with the first value is found by using the clustered index, rows with subsequent indexed values are guaranteed to be physically adjacent. \n- Use JOIN clauses; typically these are foreign key columns.\n- Use ORDER BY, or GROUP BY clauses.\n    - An index on the columns specified in the ORDER BY or GROUP BY clause may remove the need for the Database Engine to sort the data, because the rows are already sorted. This improves query performance.\n\n#### Creating clustered indexes in Entity Framework\n\nTo set the clustered index in the .NET backend using Entity Framework, set the `IsClustered` property of the annotation. For example, this is the definition of `CreatedAt` in `Microsoft.WindowsAzure.Mobile.Service.EntityData`:\n\n    [Index(IsClustered = true)]\n    [DatabaseGenerated(DatabaseGeneratedOption.Identity)]\n    [TableColumnAttribute(TableColumnType.CreatedAt)]\n    public DateTimeOffset? CreatedAt { get; set; }\n\n#### Creating indexes in the database schema\n\nFor the JavaScript backend, you can only modify the clustered index of a table by changing the database schema directly, either through SQL Server Management Studio or the Azure SQL Database Portal.\n\nThe following guides describe how to set a clustered or nonclustered index by modifying the database schema directly:  \n\n- [Creating and Modifying PRIMARY KEY Constraints][]\n- [Create Nonclustered Indexes][]\n- [Create Clustered Indexes][]\n- [Create Unique Indexes][]\n\n#### Find top N missing indexes \nYou can write SQL queries on dynamic management views that will tell you more detailed information about the resource usage of individual queries or give you heuristics on what indexes to add. The following query determines which 10 missing indexes would produce the highest anticipated cumulative improvement, in descending order, for user queries.\n\n    SELECT TOP 10 *\n    FROM sys.dm_db_missing_index_group_stats\n    ORDER BY avg_total_user_cost * avg_user_impact * (user_seeks + user_scans)\n    DESC;\n\nThe following example query runs a join across these tables to get a list of the columns that should be part of each missing index and calculates an 'index advantage' to determine if the given index should be considered:\n\n    SELECT * from \n    (\n        SELECT \n        (user_seeks+user_scans) * avg_total_user_cost * (avg_user_impact * 0.01) AS index_advantage, migs.*\n        FROM sys.dm_db_missing_index_group_stats migs\n    ) AS migs_adv,\n      sys.dm_db_missing_index_groups mig,\n      sys.dm_db_missing_index_details mid\n    WHERE\n      migs_adv.group_handle = mig.index_group_handle and\n      mig.index_handle = mid.index_handle\n      AND migs_adv.index_advantage > 10\n    ORDER BY migs_adv.index_advantage DESC;\n\nFor more information, see [Monitoring SQL Database Using Dynamic Management Views][] and [Missing Index Dynamic Management Views](sys-missing-index-stats).\n\n<a name=\"AdvancedQuery\" />\n### Advanced Query Design \n\nFrequently it's difficult to diagnose what queries queres are most expensive for the database. \n\n#### Finding top N queries\n\nThe following example returns information about the top five queries ranked by average CPU time. This example aggregates the queries according to their query hash, so that logically equivalent queries are grouped by their cumulative resource consumption.\n\n    SELECT TOP 5 query_stats.query_hash AS \"Query Hash\", \n        SUM(query_stats.total_worker_time) / SUM(query_stats.execution_count) AS \"Avg CPU Time\",\n        MIN(query_stats.statement_text) AS \"Statement Text\"\n    FROM \n        (SELECT QS.*, \n        SUBSTRING(ST.text, (QS.statement_start_offset/2) + 1,\n        ((CASE statement_end_offset \n            WHEN -1 THEN DATALENGTH(st.text)\n            ELSE QS.statement_end_offset END \n                - QS.statement_start_offset)/2) + 1) AS statement_text\n         FROM sys.dm_exec_query_stats AS QS\n         CROSS APPLY sys.dm_exec_sql_text(QS.sql_handle) as ST) as query_stats\n    GROUP BY query_stats.query_hash\n    ORDER BY 2 DESC;\n\nFor more information, see [Monitoring SQL Database Using Dynamic Management Views][]. In addition to executing the query, the **SQL Database Management Portal** gives you a nice shortcut to see this data, by slecting **Summary** for your database and then selecting **Query Performance**:\n\n![SQL Database Management Portal - query performance][PortalSqlManagementQueryPerformance]\n\n#### Analyzing the query plan\n\nOnce you have identified expensive queries or if you are about to deploy code using new queries and you would like to investigate their performance, the tooling offers great support for analyzing the **query plan**. The query plan enables you to see what operations take up the builk of CPU time and IO resources when a given SQL query runs. To analyze the query plan in **SQL Server Management Studio**, use the highlighted toolbar buttons.\n\n![SQL Server Management Studio - query plan][SSMSQueryPlan]\n\nTo analyze the query plan in the **SQL Database Management Portal**, use the highlightd toolbar buttons.\n\n![SQL Database Management Portal - query plan][PortalSqlManagementQueryPlan]\n\n## See Also\n\n- [Azure SQL Database Documentation][]\n- [Azure SQL Database performance and scaling][]\n- [Troubleshooting Azure SQL Database][]\n\n### Indexing\n\n- [Index Basics][]\n- [General Index Design Guidelines][]\n- [Unique Index Design Guidelines][]\n- [Clustered Index Design Guidelines][]\n- [Primary and Foreign Key Constraints][]\n- [How much does that key cost?][]\n\n### Entity Framework\n- [Performance Considerations for Entity Framework 5][]\n- [Code First Data Annotations][]\n\n<!-- IMAGES -->\n \n[SSMS]: ./media/mobile-services-sql-scale-guidance/1.png\n[PortalSqlManagement]: ./media/mobile-services-sql-scale-guidance/2.png\n[PortalSqlMetrics]: ./media/mobile-services-sql-scale-guidance/3.png\n[PortalSqlScale]: ./media/mobile-services-sql-scale-guidance/4.png\n[PortalSqlAddAlert]: ./media/mobile-services-sql-scale-guidance/5.png\n[PortalSqlAddAlert2]: ./media/mobile-services-sql-scale-guidance/6.png\n[PortalSqlAddAlert3]: ./media/mobile-services-sql-scale-guidance/7.png\n[SetIndexJavaScriptPortal]: ./media/mobile-services-sql-scale-guidance/set-index-portal-ui.png\n[SSMSDMVs]: ./media/mobile-services-sql-scale-guidance/8.png\n[PortalSqlManagementNewQuery]: ./media/mobile-services-sql-scale-guidance/9.png\n[PortalSqlManagementRunQuery]: ./media/mobile-services-sql-scale-guidance/10.png\n[PortalSqlManagementQueryPerformance]: ./media/mobile-services-sql-scale-guidance/11.png\n[SSMSQueryPlan]: ./media/mobile-services-sql-scale-guidance/12.png\n[PortalSqlManagementQueryPlan]: ./media/mobile-services-sql-scale-guidance/13.png\n\n<!-- LINKS -->\n\n[Azure Management Portal]: http://manage.windowsazure.com\n\n[Azure SQL Database Documentation]: http://azure.microsoft.com/documentation/services/sql-database/\n[Managing SQL Database using SQL Server Management Studio]: http://go.microsoft.com/fwlink/p/?linkid=309723&clcid=0x409\n[Monitoring SQL Database Using Dynamic Management Views]: http://go.microsoft.com/fwlink/p/?linkid=309725&clcid=0x409\n[Azure SQL Database performance and scaling]: http://go.microsoft.com/fwlink/p/?linkid=397217&clcid=0x409\n[Troubleshooting Azure SQL Database]: http://msdn.microsoft.com/library/azure/ee730906.aspx\n\n<!-- MSDN -->\n[Creating and Modifying PRIMARY KEY Constraints]: http://technet.microsoft.com/library/ms181043(v=sql.105).aspx\n[Create Clustered Indexes]: http://technet.microsoft.com/library/ms186342(v=sql.120).aspx\n[Create Unique Indexes]: http://technet.microsoft.com/library/ms187019.aspx\n[Create Nonclustered Indexes]: http://technet.microsoft.com/library/ms189280.aspx\n\n[Primary and Foreign Key Constraints]: http://msdn.microsoft.com/library/ms179610(v=sql.120).aspx\n[Index Basics]: http://technet.microsoft.com/library/ms190457(v=sql.105).aspx\n[General Index Design Guidelines]: http://technet.microsoft.com/library/ms191195(v=sql.105).aspx \n[Unique Index Design Guidelines]: http://technet.microsoft.com/library/ms187019(v=sql.105).aspx\n[Clustered Index Design Guidelines]: http://technet.microsoft.com/library/ms190639(v=sql.105).aspx\n\n[sys-missing-index-stats]: http://technet.microsoft.com/library/ms345421.aspx\n\n<!-- EF -->\n[Performance Considerations for Entity Framework 5]: http://msdn.microsoft.com/data/hh949853\n[Code First Data Annotations]: http://msdn.microsoft.com/data/jj591583.aspx\n[Index Annotations in Entity Framework]:http://msdn.microsoft.com/data/jj591583.aspx#Index\n\n<!-- BLOG LINKS -->\n[How much does that key cost?]: http://www.sqlskills.com/blogs/kimberly/how-much-does-that-key-cost-plus-sp_helpindex9/\n \n"
}