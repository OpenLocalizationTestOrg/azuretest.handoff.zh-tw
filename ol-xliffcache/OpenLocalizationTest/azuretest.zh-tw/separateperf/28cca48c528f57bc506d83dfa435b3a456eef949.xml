{
  "nodes": [
    {
      "content": "Azure Storage Table Design Guide | Microsoft Azure",
      "pos": [
        26,
        76
      ]
    },
    {
      "content": "Design Scalable and Performant Tables in Azure Table Storage",
      "pos": [
        94,
        154
      ]
    },
    {
      "content": "Azure Storage Table Design Guide: Designing Scalable and Performant Tables",
      "pos": [
        432,
        506
      ]
    },
    {
      "content": "Overview",
      "pos": [
        511,
        519
      ]
    },
    {
      "content": "To design scalable and performant tables you must consider a number of factors such as performance, scalability, and cost.",
      "pos": [
        521,
        643
      ]
    },
    {
      "content": "If you have previously designed schemas for relational databases, these considerations will be familiar to you, but while there are some similarities between the Azure Table service storage model and relational models, there are also many important differences.",
      "pos": [
        644,
        905
      ]
    },
    {
      "content": "These differences typically lead to very different designs that may look counter-intuitive or wrong to someone familiar with relational databases, but which do make good sense if you are designing for a NoSQL key/value store such as the Azure Table service.",
      "pos": [
        906,
        1163
      ]
    },
    {
      "content": "Many of your design differences will reflect the fact that the Table service is designed to support cloud-scale applications that can contain billions of entities (rows in relational database terminology) of data or for datasets that must support very high transaction volumes: therefore, you need to think differently about how you store your data and understand how the Table service works.",
      "pos": [
        1164,
        1556
      ]
    },
    {
      "content": "A well designed NoSQL data store can enable your solution to scale much further (and at a lower cost) than a solution that uses a relational database.",
      "pos": [
        1557,
        1707
      ]
    },
    {
      "content": "This guide helps you with these topics.",
      "pos": [
        1708,
        1747
      ]
    },
    {
      "content": "About the Azure Table service",
      "pos": [
        1754,
        1783
      ]
    },
    {
      "content": "This section highlights some of the key features of the Table service that are especially relevant to designing for performance and scalability.",
      "pos": [
        1785,
        1929
      ]
    },
    {
      "content": "If you are new to Azure Storage and the Table service, first read <bpt id=\"p1\">[</bpt>Introduction to Microsoft Azure Storage<ept id=\"p1\">](storage-introduction.md)</ept> and <bpt id=\"p2\">[</bpt>How to use Table Storage from .NET<ept id=\"p2\">](storage-dotnet-how-to-use-tables.md)</ept> before reading the remainder of this article.",
      "pos": [
        1930,
        2186
      ]
    },
    {
      "content": "Although the focus of this guide is on the Table service, it will include some discussion of the Azure Queue and Blob services, and how you might use them along with the Table service in a solution.",
      "pos": [
        2187,
        2385
      ]
    },
    {
      "content": "What is the Table service?",
      "pos": [
        2389,
        2415
      ]
    },
    {
      "content": "As you might expect from the name, the Table service uses a tabular format to store data.",
      "pos": [
        2416,
        2505
      ]
    },
    {
      "content": "In the standard terminology, each row of the table represents an entity, and the columns store the various properties of that entity.",
      "pos": [
        2506,
        2639
      ]
    },
    {
      "content": "Every entity has a pair of keys to uniquely identify it, and a timestamp column that the Table service uses to track when the entity was last updated (this happens automatically and you cannot manually overwrite the timestamp with an arbitrary value).",
      "pos": [
        2640,
        2891
      ]
    },
    {
      "content": "The Table service uses this last-modified timestamp (LMT) to manage optimistic concurrency.",
      "pos": [
        2892,
        2983
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> The Table service REST API operations also return an <bpt id=\"p1\">**</bpt>ETag<ept id=\"p1\">**</ept> value that it derives from the last-modified timestamp (LMT).",
      "pos": [
        2988,
        3124
      ]
    },
    {
      "content": "In this document we will use the terms ETag and LMT interchangeably because they refer to the same underlying data.",
      "pos": [
        3125,
        3240
      ]
    },
    {
      "content": "The following example shows a simple table design to store employee and department entities.",
      "pos": [
        3244,
        3336
      ]
    },
    {
      "content": "Many of the examples shown later in this guide are based on this simple design.",
      "pos": [
        3337,
        3416
      ]
    },
    {
      "content": "PartitionKey",
      "pos": [
        3437,
        3449
      ]
    },
    {
      "content": "RowKey",
      "pos": [
        3459,
        3465
      ]
    },
    {
      "content": "Timestamp",
      "pos": [
        3475,
        3484
      ]
    },
    {
      "content": "Marketing",
      "pos": [
        3515,
        3524
      ]
    },
    {
      "content": "00001",
      "pos": [
        3534,
        3539
      ]
    },
    {
      "content": "2014-08-22T00:50:32Z",
      "pos": [
        3549,
        3569
      ]
    },
    {
      "content": "FirstName",
      "pos": [
        3597,
        3606
      ]
    },
    {
      "content": "LastName",
      "pos": [
        3616,
        3624
      ]
    },
    {
      "content": "Age",
      "pos": [
        3634,
        3637
      ]
    },
    {
      "content": "Email",
      "pos": [
        3647,
        3652
      ]
    },
    {
      "content": "Don",
      "pos": [
        3673,
        3676
      ]
    },
    {
      "content": "Hall",
      "pos": [
        3686,
        3690
      ]
    },
    {
      "content": "34",
      "pos": [
        3700,
        3702
      ]
    },
    {
      "content": "donh@contoso.com",
      "pos": [
        3712,
        3728
      ]
    },
    {
      "content": "Marketing",
      "pos": [
        3764,
        3773
      ]
    },
    {
      "content": "00002",
      "pos": [
        3783,
        3788
      ]
    },
    {
      "content": "2014-08-22T00:50:34Z",
      "pos": [
        3798,
        3818
      ]
    },
    {
      "content": "FirstName",
      "pos": [
        3846,
        3855
      ]
    },
    {
      "content": "LastName",
      "pos": [
        3865,
        3873
      ]
    },
    {
      "content": "Age",
      "pos": [
        3883,
        3886
      ]
    },
    {
      "content": "Email",
      "pos": [
        3896,
        3901
      ]
    },
    {
      "content": "Jun",
      "pos": [
        3922,
        3925
      ]
    },
    {
      "content": "Cao",
      "pos": [
        3935,
        3938
      ]
    },
    {
      "content": "47",
      "pos": [
        3948,
        3950
      ]
    },
    {
      "content": "junc@contoso.com",
      "pos": [
        3960,
        3976
      ]
    },
    {
      "content": "Marketing",
      "pos": [
        4012,
        4021
      ]
    },
    {
      "content": "Department",
      "pos": [
        4031,
        4041
      ]
    },
    {
      "content": "2014-08-22T00:50:30Z",
      "pos": [
        4051,
        4071
      ]
    },
    {
      "content": "DepartmentName",
      "pos": [
        4099,
        4113
      ]
    },
    {
      "content": "EmployeeCount",
      "pos": [
        4123,
        4136
      ]
    },
    {
      "content": "Marketing",
      "pos": [
        4157,
        4166
      ]
    },
    {
      "content": "153",
      "pos": [
        4176,
        4179
      ]
    },
    {
      "content": "Sales",
      "pos": [
        4221,
        4226
      ]
    },
    {
      "content": "00010",
      "pos": [
        4236,
        4241
      ]
    },
    {
      "content": "2014-08-22T00:50:44Z",
      "pos": [
        4251,
        4271
      ]
    },
    {
      "content": "FirstName",
      "pos": [
        4299,
        4308
      ]
    },
    {
      "content": "LastName",
      "pos": [
        4318,
        4326
      ]
    },
    {
      "content": "Age",
      "pos": [
        4336,
        4339
      ]
    },
    {
      "content": "Email",
      "pos": [
        4349,
        4354
      ]
    },
    {
      "content": "Ken",
      "pos": [
        4375,
        4378
      ]
    },
    {
      "content": "Kwok",
      "pos": [
        4388,
        4392
      ]
    },
    {
      "content": "23",
      "pos": [
        4402,
        4404
      ]
    },
    {
      "content": "kenk@contoso.com",
      "pos": [
        4414,
        4430
      ]
    },
    {
      "content": "So far, this looks very similar to a table in a relational database with the key differences being the mandatory columns, and the ability to store multiple entity types in the same table.",
      "pos": [
        4474,
        4661
      ]
    },
    {
      "content": "In addition, each of the user-defined properties such as <bpt id=\"p1\">**</bpt>FirstName<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>Age<ept id=\"p2\">**</ept> has a data type, such as integer or string, just like a column in a relational database.",
      "pos": [
        4662,
        4832
      ]
    },
    {
      "content": "Although unlike in a relational database, the schema-less nature of the Table service means that a property need not have the same data type on each entity.",
      "pos": [
        4833,
        4989
      ]
    },
    {
      "content": "To store complex data types in a single property, you must use a serialized format such as JSON or XML.",
      "pos": [
        4990,
        5093
      ]
    },
    {
      "content": "For more information about the table service such as supported data types, supported date ranges, naming rules, and size constraints, see <bpt id=\"p1\">[</bpt>Understanding the Table Service Data Model<ept id=\"p1\">](http://msdn.microsoft.com/library/azure/dd179338.aspx)</ept> on MSDN.",
      "pos": [
        5094,
        5340
      ]
    },
    {
      "content": "As you will see, your choice of <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> is fundamental to good table design.",
      "pos": [
        5342,
        5442
      ]
    },
    {
      "content": "Every entity stored in a table must have a unique combination of <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept>.",
      "pos": [
        5443,
        5540
      ]
    },
    {
      "content": "As with keys in a relational database table, the <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> values are indexed to create a clustered index that enables fast look-ups; however, the Table service does not create any secondary indexes so these are the only two indexed properties (some of the patterns described later show how you can work around this apparent limitation).",
      "pos": [
        5541,
        5900
      ]
    },
    {
      "content": "A table is made up of one or more partitions, and as you will see, many of the design decisions you make will be around choosing a suitable <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> to optimize your solution.",
      "pos": [
        5904,
        6102
      ]
    },
    {
      "content": "A solution could consist of just a single table that contains all your entities organized into partitions, but typically a solution will have multiple tables.",
      "pos": [
        6103,
        6261
      ]
    },
    {
      "content": "Tables help you to logically organize your entities, help you manage access to the data using access control lists, and you can drop an entire table using a single storage operation.",
      "pos": [
        6262,
        6444
      ]
    },
    {
      "content": "Table partitions",
      "pos": [
        6452,
        6468
      ]
    },
    {
      "content": "The account name, table name and <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> together identify the partition within the storage service where the table service stores the entity.",
      "pos": [
        6471,
        6622
      ]
    },
    {
      "content": "As well as being part of the addressing scheme for entities, partitions define a scope for transactions (see <bpt id=\"p1\">[</bpt>Entity Group Transactions<ept id=\"p1\">](#entity-group-transactions)</ept> below), and form the basis of how the table service scales.",
      "pos": [
        6623,
        6847
      ]
    },
    {
      "content": "For more information on partitions see <bpt id=\"p1\">[</bpt>Azure Storage Scalability and Performance Targets<ept id=\"p1\">](http://msdn.microsoft.com/library/azure/dn249410.aspx)</ept>.",
      "pos": [
        6848,
        6994
      ]
    },
    {
      "content": "In the Table service, an individual node services one or more complete partitions and the service scales by dynamically load-balancing partitions across nodes.",
      "pos": [
        6998,
        7157
      ]
    },
    {
      "content": "If a node is under load, the table service can <bpt id=\"p1\">*</bpt>split<ept id=\"p1\">*</ept> the range of partitions serviced by that node onto different nodes; when traffic subsides, the service can <bpt id=\"p2\">*</bpt>merge<ept id=\"p2\">*</ept> the partition ranges from quiet nodes back onto a single node.",
      "pos": [
        7158,
        7390
      ]
    },
    {
      "pos": [
        7394,
        7780
      ],
      "content": "For more information about the internal details of the Table service, and in particular how the service manages partitions, see the paper <bpt id=\"p1\">[</bpt>Microsoft Azure Storage: A Highly Available\nCloud Storage Service with Strong Consistency<ept id=\"p1\">](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)</ept>."
    },
    {
      "content": "Entity Group Transactions",
      "pos": [
        7788,
        7813
      ]
    },
    {
      "content": "In the Table service, Entity Group Transactions (EGTs) are the only built-in mechanism for performing atomic updates across multiple entities.",
      "pos": [
        7814,
        7956
      ]
    },
    {
      "content": "EGTs are also referred to as <bpt id=\"p1\">*</bpt>batch transactions<ept id=\"p1\">*</ept> in some documentation.",
      "pos": [
        7957,
        8029
      ]
    },
    {
      "content": "EGTs can only operate on entities stored in the same partition (share the same partition key in a given table), so anytime you need atomic transactional behavior across multiple entities you need to ensure that those entities are in the same partition.",
      "pos": [
        8030,
        8282
      ]
    },
    {
      "content": "This is often a reason for keeping multiple entity types in the same table (and partition) and not using multiple tables for different entity types.",
      "pos": [
        8283,
        8431
      ]
    },
    {
      "content": "A single EGT can operate on at most 100 entities.",
      "pos": [
        8432,
        8481
      ]
    },
    {
      "content": "If you submit multiple concurrent EGTs for processing it is important to ensure  those EGTs do not operate on entities that are common across EGTs as otherwise processing can be delayed.",
      "pos": [
        8483,
        8669
      ]
    },
    {
      "content": "EGTs also introduce a potential trade-off for you to evaluate in your design: using more partitions will increase the scalability of your application because Azure has more opportunities for load balancing requests across nodes, but this might limit the ability of your application to perform atomic transactions and maintain strong consistency for your data.",
      "pos": [
        8671,
        9030
      ]
    },
    {
      "content": "Furthermore, there are specific scalability targets at the level of a partition that might limit the throughput of transactions you can expect for a single node: for more information about the scalability targets for Azure storage accounts and the table service, see <bpt id=\"p1\">[</bpt>Azure Storage Scalability and Performance Targets<ept id=\"p1\">](http://msdn.microsoft.com/library/azure/dd179338.aspx)</ept> on MSDN.",
      "pos": [
        9031,
        9413
      ]
    },
    {
      "content": "Later sections of this guide discuss various design strategies that help you manage trade-offs such as this one, and discuss how best to choose your partition key based on the specific requirements of your client application.",
      "pos": [
        9414,
        9639
      ]
    },
    {
      "content": "Capacity considerations",
      "pos": [
        9647,
        9670
      ]
    },
    {
      "content": "The following table includes some of the key values to be aware of when you are designing a Table service solution:",
      "pos": [
        9671,
        9786
      ]
    },
    {
      "content": "Total capacity of an Azure storage account",
      "pos": [
        9791,
        9833
      ]
    },
    {
      "content": "500 TB",
      "pos": [
        9834,
        9840
      ]
    },
    {
      "content": "Number of tables in an Azure storage account",
      "pos": [
        9895,
        9939
      ]
    },
    {
      "content": "Limited only by the capacity of the storage account",
      "pos": [
        9942,
        9993
      ]
    },
    {
      "content": "Number of partitions in a table",
      "pos": [
        9997,
        10028
      ]
    },
    {
      "content": "Limited only by the capacity of the storage account",
      "pos": [
        10031,
        10082
      ]
    },
    {
      "content": "Number of entities in a partition",
      "pos": [
        10086,
        10119
      ]
    },
    {
      "content": "Limited only by the capacity of the storage account",
      "pos": [
        10122,
        10173
      ]
    },
    {
      "content": "Size of an individual entity",
      "pos": [
        10176,
        10204
      ]
    },
    {
      "pos": [
        10207,
        10314
      ],
      "content": "Up to 1 MB with a maximum of 255 properties (including the <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>Timestamp<ept id=\"p3\">**</ept>)"
    },
    {
      "pos": [
        10318,
        10346
      ],
      "content": "Size of the <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept>"
    },
    {
      "content": "A string up to 1 KB in size",
      "pos": [
        10349,
        10376
      ]
    },
    {
      "pos": [
        10381,
        10403
      ],
      "content": "Size of the <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept>"
    },
    {
      "content": "A string up to 1 KB in size",
      "pos": [
        10406,
        10433
      ]
    },
    {
      "content": "Size of an Entity Group Transaction",
      "pos": [
        10437,
        10472
      ]
    },
    {
      "content": "A transaction can include at most 100 entities and the payload must be less than 4 MB in size.",
      "pos": [
        10475,
        10569
      ]
    },
    {
      "content": "An EGT can only update an entity once.",
      "pos": [
        10570,
        10608
      ]
    },
    {
      "pos": [
        10612,
        10746
      ],
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Understanding the Table Service Data Model<ept id=\"p1\">](http://msdn.microsoft.com/library/azure/dd179338.aspx)</ept> on MSDN."
    },
    {
      "content": "Cost considerations",
      "pos": [
        10754,
        10773
      ]
    },
    {
      "content": "Table storage is relatively inexpensive, but you should include cost estimates for both capacity usage and the quantity of transactions as part of your evaluation of any solution that uses the Table service.",
      "pos": [
        10776,
        10983
      ]
    },
    {
      "content": "However, in many scenarios storing denormalized or duplicate data in order to improve the performance or scalability of your solution is a valid approach to take.",
      "pos": [
        10984,
        11146
      ]
    },
    {
      "content": "For more information about pricing, see <bpt id=\"p1\">[</bpt>Storage Pricing Details<ept id=\"p1\">](http://azure.microsoft.com/pricing/details/storage/)</ept>.",
      "pos": [
        11147,
        11266
      ]
    },
    {
      "content": "Comparing Azure Tables and SQL Azure",
      "pos": [
        11274,
        11310
      ]
    },
    {
      "pos": [
        11313,
        11570
      ],
      "content": "For a comparison between Azure SQL Database (a relational database service) and the Table service, see <bpt id=\"p1\">[</bpt>Microsoft Azure Table Storage and Microsoft Azure SQL Database - Compared and Contrasted<ept id=\"p1\">](http://msdn.microsoft.com/library/azure/jj553018.aspx)</ept> on MSDN."
    },
    {
      "content": "Guidelines for table design",
      "pos": [
        11577,
        11604
      ]
    },
    {
      "content": "These lists summarize some of the key guidelines you should keep in mind when you are designing your tables, and this guide will address them all in more detail later in.",
      "pos": [
        11607,
        11777
      ]
    },
    {
      "content": "These guidelines are very different from the guidelines you would typically follow for relational database design.",
      "pos": [
        11778,
        11892
      ]
    },
    {
      "pos": [
        11896,
        11957
      ],
      "content": "Designing your Table service solution to be <bpt id=\"p1\">*</bpt>read<ept id=\"p1\">*</ept> efficient:"
    },
    {
      "content": "Design for querying in read-heavy applications.",
      "pos": [
        11966,
        12013
      ]
    },
    {
      "content": "When you are designing your tables, think about the queries (especially the latency sensitive ones) that you will execute before you think about how you will update your entities.",
      "pos": [
        12017,
        12196
      ]
    },
    {
      "content": "This typically results in an efficient and performant solution.",
      "pos": [
        12197,
        12260
      ]
    },
    {
      "content": "Specify both PartitionKey and RowKey in your queries.",
      "pos": [
        12270,
        12323
      ]
    },
    {
      "content": "<bpt id=\"p1\">*</bpt>Point queries<ept id=\"p1\">*</ept> such as these are the most efficient table service queries.",
      "pos": [
        12327,
        12402
      ]
    },
    {
      "content": "Consider storing duplicate copies of entities.",
      "pos": [
        12412,
        12458
      ]
    },
    {
      "content": "Table storage is cheap so consider storing the same entity multiple times (with different keys) to enable more efficient queries.",
      "pos": [
        12462,
        12591
      ]
    },
    {
      "content": "Consider denormalizing your data.",
      "pos": [
        12601,
        12634
      ]
    },
    {
      "content": "Table storage is cheap so consider denormalizing your data.",
      "pos": [
        12638,
        12697
      ]
    },
    {
      "content": "For example, store summary entities so that queries for aggregate data only need to access a single entity.",
      "pos": [
        12698,
        12805
      ]
    },
    {
      "content": "Use compound key values.",
      "pos": [
        12815,
        12839
      ]
    },
    {
      "content": "The only keys you have are <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept>.",
      "pos": [
        12843,
        12902
      ]
    },
    {
      "content": "For example, use compound key values to enable alternate keyed access paths to entities.",
      "pos": [
        12903,
        12991
      ]
    },
    {
      "content": "Use query projection.",
      "pos": [
        13001,
        13022
      ]
    },
    {
      "content": "You can reduce the amount of data that you transfer over the network by using queries that select just the fields you need.",
      "pos": [
        13026,
        13149
      ]
    },
    {
      "pos": [
        13153,
        13215
      ],
      "content": "Designing your Table service solution to be <bpt id=\"p1\">*</bpt>write<ept id=\"p1\">*</ept> efficient:"
    },
    {
      "content": "Do not create hot partitions.",
      "pos": [
        13226,
        13255
      ]
    },
    {
      "content": "Choose keys that enable you to spread your requests across multiple partitions at any point of time.",
      "pos": [
        13259,
        13359
      ]
    },
    {
      "content": "Avoid spikes in traffic.",
      "pos": [
        13369,
        13393
      ]
    },
    {
      "content": "Smooth the traffic over a reasonable period of time and avoid spikes in traffic.",
      "pos": [
        13397,
        13477
      ]
    },
    {
      "content": "Don’t necessarily create a separate table for each type of entity.",
      "pos": [
        13485,
        13551
      ]
    },
    {
      "content": "When you require atomic transactions across entity types, you can store these multiple entity types in the same partition in the same table.",
      "pos": [
        13555,
        13695
      ]
    },
    {
      "content": "Consider the maximum throughput you must achieve.",
      "pos": [
        13703,
        13752
      ]
    },
    {
      "content": "You must be aware of the scalability targets for the Table service and ensure that your design will not cause you to exceed them.",
      "pos": [
        13756,
        13885
      ]
    },
    {
      "content": "As you read this guide, you will see examples that put all of these principles into practice.",
      "pos": [
        13889,
        13982
      ]
    },
    {
      "content": "Design for querying",
      "pos": [
        13989,
        14008
      ]
    },
    {
      "content": "Table service solutions may be read intensive, write intensive, or a mix of the two.",
      "pos": [
        14011,
        14095
      ]
    },
    {
      "content": "This section focuses on the things to bear in mind when you are designing your Table service to support read operations efficiently.",
      "pos": [
        14096,
        14228
      ]
    },
    {
      "content": "Typically, a design that supports read operations efficiently is also efficient for write operations.",
      "pos": [
        14229,
        14330
      ]
    },
    {
      "content": "However, there are additional considerations to bear in mind when designing to support write operations, which the next section, <bpt id=\"p1\">[</bpt>Design for data modification<ept id=\"p1\">](#design-for-data-modification)</ept>, discusses.",
      "pos": [
        14331,
        14533
      ]
    },
    {
      "content": "A good starting point for designing your Table service solution to enable you to read data efficiently is to ask \"What queries will my application need to execute to retrieve the data it needs from the Table service?\"",
      "pos": [
        14535,
        14752
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> With the Table service, it’s important to get the design correct up front because it’s difficult and expensive to change it later.",
      "pos": [
        14757,
        14900
      ]
    },
    {
      "content": "For example, in a relational database it’s often possible to address performance issues simply by adding indexes to an existing database: this is not an option with the Table service.",
      "pos": [
        14901,
        15084
      ]
    },
    {
      "content": "This section focuses on the key issues you must address when you design your tables for querying.",
      "pos": [
        15088,
        15185
      ]
    },
    {
      "content": "The topics covered in this section include:",
      "pos": [
        15186,
        15229
      ]
    },
    {
      "content": "How your choice of PartitionKey and RowKey impacts query performance",
      "pos": [
        15234,
        15302
      ]
    },
    {
      "content": "Choosing an appropriate PartitionKey",
      "pos": [
        15378,
        15414
      ]
    },
    {
      "content": "Optimizing queries with a key value store for the Table service",
      "pos": [
        15458,
        15521
      ]
    },
    {
      "content": "Sorting data in a key value store in the Table service",
      "pos": [
        15592,
        15646
      ]
    },
    {
      "content": "How your choice of PartitionKey and RowKey impacts query performance",
      "pos": [
        15710,
        15778
      ]
    },
    {
      "pos": [
        15782,
        15955
      ],
      "content": "The following examples assume the table service is storing employee entities with the following structure (most of the examples omit the <bpt id=\"p1\">**</bpt>Timestamp<ept id=\"p1\">**</ept> property for clarity):"
    },
    {
      "content": "Column name",
      "pos": [
        15961,
        15972
      ]
    },
    {
      "content": "Data type",
      "pos": [
        15976,
        15985
      ]
    },
    {
      "pos": [
        16018,
        16052
      ],
      "content": "<bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> (Department Name)"
    },
    {
      "content": "String",
      "pos": [
        16053,
        16059
      ]
    },
    {
      "pos": [
        16062,
        16086
      ],
      "content": "<bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> (Employee Id)"
    },
    {
      "content": "String",
      "pos": [
        16087,
        16093
      ]
    },
    {
      "content": "FirstName",
      "pos": [
        16098,
        16107
      ]
    },
    {
      "content": "String",
      "pos": [
        16110,
        16116
      ]
    },
    {
      "content": "LastName",
      "pos": [
        16121,
        16129
      ]
    },
    {
      "content": "String",
      "pos": [
        16132,
        16138
      ]
    },
    {
      "content": "Age",
      "pos": [
        16143,
        16146
      ]
    },
    {
      "content": "Integer",
      "pos": [
        16149,
        16156
      ]
    },
    {
      "content": "EmailAddress",
      "pos": [
        16161,
        16173
      ]
    },
    {
      "content": "String",
      "pos": [
        16176,
        16182
      ]
    },
    {
      "content": "The earlier section <bpt id=\"p1\">[</bpt>Azure Table service overview<ept id=\"p1\">](#azure-table-service-overview)</ept> describes some of the key features of the Azure Table service that have a direct influence on designing for query.",
      "pos": [
        16185,
        16381
      ]
    },
    {
      "content": "These result in the following general guidelines for designing Table service queries.",
      "pos": [
        16382,
        16467
      ]
    },
    {
      "content": "Note that the filter syntax used in the examples below is from the Table service REST API, for more information see <bpt id=\"p1\">[</bpt>Query Entities<ept id=\"p1\">](http://msdn.microsoft.com/library/azure/dd179421.aspx)</ept> on MSDN.",
      "pos": [
        16468,
        16664
      ]
    },
    {
      "content": "A <bpt id=\"p1\">***</bpt>Point Query<ept id=\"p1\">***</ept> is the most efficient lookup to use and is recommended to be used for high-volume lookups or lookups requiring lowest latency.",
      "pos": [
        16672,
        16818
      ]
    },
    {
      "content": "Such a query can use the indexes to locate an individual entity very efficiently by specifying both the <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> values.",
      "pos": [
        16819,
        16962
      ]
    },
    {
      "content": "For example:",
      "pos": [
        16963,
        16975
      ]
    },
    {
      "content": "$filter=(PartitionKey eq 'Sales') and (RowKey eq '2')",
      "pos": [
        16976,
        17029
      ]
    },
    {
      "content": "Second best is a <bpt id=\"p1\">***</bpt>Range Query<ept id=\"p1\">***</ept> that uses the <bpt id=\"p2\">**</bpt>PartitionKey<ept id=\"p2\">**</ept> and filters on a range of <bpt id=\"p3\">**</bpt>RowKey<ept id=\"p3\">**</ept> values to return more than one entity.",
      "pos": [
        17036,
        17177
      ]
    },
    {
      "content": "The <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> value identifies a specific partition, and the <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> values identify a subset of the entities in that partition.",
      "pos": [
        17178,
        17316
      ]
    },
    {
      "content": "For example:",
      "pos": [
        17317,
        17329
      ]
    },
    {
      "content": "$filter=PartitionKey eq 'Sales' and RowKey ge 'S' and RowKey lt 'T'",
      "pos": [
        17330,
        17397
      ]
    },
    {
      "content": "Third best is a <bpt id=\"p1\">***</bpt>Partition Scan<ept id=\"p1\">***</ept> that uses the <bpt id=\"p2\">**</bpt>PartitionKey<ept id=\"p2\">**</ept> and filters on another non-key property and that may return more than one entity.",
      "pos": [
        17404,
        17553
      ]
    },
    {
      "content": "The <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> value identifies a specific partition, and the property values select for a subset of the entities in that partition.",
      "pos": [
        17554,
        17692
      ]
    },
    {
      "content": "For example:",
      "pos": [
        17693,
        17705
      ]
    },
    {
      "content": "$filter=PartitionKey eq 'Sales' and LastName eq 'Smith'",
      "pos": [
        17706,
        17761
      ]
    },
    {
      "content": "A <bpt id=\"p1\">***</bpt>Table Scan<ept id=\"p1\">***</ept> does not include the <bpt id=\"p2\">**</bpt>PartitionKey<ept id=\"p2\">**</ept> and is very inefficient because it searches all of the partitions that make up your table in turn for any matching entities.",
      "pos": [
        17768,
        17949
      ]
    },
    {
      "content": "It will perform a table scan regardless of whether or not your filter uses the <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept>.",
      "pos": [
        17950,
        18040
      ]
    },
    {
      "content": "For example:",
      "pos": [
        18041,
        18053
      ]
    },
    {
      "content": "$filter=LastName eq 'Jones'",
      "pos": [
        18054,
        18081
      ]
    },
    {
      "content": "Queries that return multiple entities return them sorted in <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> order.",
      "pos": [
        18088,
        18186
      ]
    },
    {
      "content": "To avoid resorting the entities in the client chose a <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> that defines the most common sort order.",
      "pos": [
        18187,
        18292
      ]
    },
    {
      "content": "Note that using an \"<bpt id=\"p1\">**</bpt>or<ept id=\"p1\">**</ept>\" to specify a filter based on <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> values results in a partition scan and is not treated as a range query.",
      "pos": [
        18296,
        18435
      ]
    },
    {
      "content": "Therefore, you should avoid queries that use filters such as:",
      "pos": [
        18436,
        18497
      ]
    },
    {
      "content": "$filter=PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322')",
      "pos": [
        18498,
        18570
      ]
    },
    {
      "content": "For examples of client-side code that use the Storage Client Library to execute efficient queries, see:",
      "pos": [
        18574,
        18677
      ]
    },
    {
      "content": "Retrieving a single entity using the Storage Client Library",
      "pos": [
        18686,
        18745
      ]
    },
    {
      "content": "Retrieving multiple entities using LINQ",
      "pos": [
        18814,
        18853
      ]
    },
    {
      "content": "Server-side projection",
      "pos": [
        18902,
        18924
      ]
    },
    {
      "content": "For examples of client-side code that can handle multiple entity types stored in the same table, see:",
      "pos": [
        18954,
        19055
      ]
    },
    {
      "content": "Working with heterogeneous entity types",
      "pos": [
        19064,
        19103
      ]
    },
    {
      "content": "Choosing an appropriate PartitionKey",
      "pos": [
        19154,
        19190
      ]
    },
    {
      "pos": [
        19194,
        19412
      ],
      "content": "Your choice of <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> should balance the need to enables the use of EGTs (to ensure consistency) against the requirement to distribute your entities across multiple partitions (to ensure a scalable solution)."
    },
    {
      "content": "At one extreme, you could store all your entities in a single partition, but this may limit the scalability of your solution and would prevent the table service from being able to load-balance requests.",
      "pos": [
        19416,
        19618
      ]
    },
    {
      "content": "At the other extreme, you could store one entity per partition, which would be highly scalable and which enables the table service to load-balance requests, but which would prevent you from using entity group transactions.",
      "pos": [
        19619,
        19841
      ]
    },
    {
      "content": "An ideal <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> is one that enables you to use efficient queries and that has sufficient partitions to ensure your solution is scalable.",
      "pos": [
        19845,
        19991
      ]
    },
    {
      "content": "Typically, you will find that your entities will have a suitable property that distributes your entities across sufficient partitions.",
      "pos": [
        19992,
        20126
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> For example, in a system that stores information about users or employees, UserID may be a good PartitionKey.",
      "pos": [
        20129,
        20251
      ]
    },
    {
      "content": "You may have several entities that use a given UserID as the partition key.",
      "pos": [
        20252,
        20327
      ]
    },
    {
      "content": "Each entity that stores data about a user is grouped into a single partition, and so these entities are accessible via entity group transactions, while still being highly scalable.",
      "pos": [
        20328,
        20508
      ]
    },
    {
      "pos": [
        20510,
        20730
      ],
      "content": "There are additional considerations in your choice of <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> that relate to how you will insert, update, and delete entities: see the section <bpt id=\"p2\">[</bpt>Design for data modification<ept id=\"p2\">](#design-for-data-modification)</ept> below."
    },
    {
      "content": "Optimizing queries for the Table service",
      "pos": [
        20738,
        20778
      ]
    },
    {
      "content": "The Table service automatically indexes your entities using the <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> values in a single clustered index, hence the reason that point queries are the most efficient to use.",
      "pos": [
        20782,
        20980
      ]
    },
    {
      "content": "However, there are no indexes other than that on the clustered index on the <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept>.",
      "pos": [
        20981,
        21089
      ]
    },
    {
      "content": "Many designs must meet requirements to enable lookup of entities based on multiple criteria.",
      "pos": [
        21091,
        21183
      ]
    },
    {
      "content": "For example, locating employee entities based on email, employee id, or last name.",
      "pos": [
        21184,
        21266
      ]
    },
    {
      "content": "The following patterns in the section <bpt id=\"p1\">[</bpt>Table Design Patterns<ept id=\"p1\">](#table-design-patterns)</ept> address these types of requirement and describe ways of working around the fact that the Table service does not provide secondary indexes:",
      "pos": [
        21267,
        21491
      ]
    },
    {
      "pos": [
        21499,
        21780
      ],
      "content": "<bpt id=\"p1\">[</bpt>Intra-partition secondary index pattern<ept id=\"p1\">](#intra-partition-secondary-index-pattern)</ept> - Store multiple copies of each entity using different <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different <bpt id=\"p3\">**</bpt>RowKey<ept id=\"p3\">**</ept> values."
    },
    {
      "pos": [
        21787,
        22085
      ],
      "content": "<bpt id=\"p1\">[</bpt>Inter-partition secondary index pattern<ept id=\"p1\">](#inter-partition-secondary-index-pattern)</ept> - Store multiple copies of each entity using different RowKey values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> values."
    },
    {
      "pos": [
        22092,
        22227
      ],
      "content": "<bpt id=\"p1\">[</bpt>Index Entities Pattern<ept id=\"p1\">](#index-entities-pattern)</ept> - Maintain index entities to enable efficient searches that return lists of entities."
    },
    {
      "content": "Sorting data in in the Table service",
      "pos": [
        22235,
        22271
      ]
    },
    {
      "content": "The Table service returns entities sorted in ascending order based on <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> and then by <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept>.",
      "pos": [
        22275,
        22385
      ]
    },
    {
      "content": "These keys are string values and to ensure that numeric values sort correctly, you should convert them to a fixed length and pad them with zeroes.",
      "pos": [
        22386,
        22532
      ]
    },
    {
      "content": "For example, if the employee id value you use as the <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> is an integer value, you should convert employee id <bpt id=\"p2\">**</bpt>123<ept id=\"p2\">**</ept> to <bpt id=\"p3\">**</bpt>00000123<ept id=\"p3\">**</ept>.",
      "pos": [
        22533,
        22673
      ]
    },
    {
      "content": "Many applications have requirements to use data sorted in different orders: for example, sorting employees by name, or by joining date.",
      "pos": [
        22677,
        22812
      ]
    },
    {
      "content": "The following patterns in the section <bpt id=\"p1\">[</bpt>Table Design Patterns<ept id=\"p1\">](#table-design-patterns)</ept> address how to alternate sort orders for your entities:",
      "pos": [
        22813,
        22954
      ]
    },
    {
      "pos": [
        22962,
        23235
      ],
      "content": "<bpt id=\"p1\">[</bpt>Intra-partition secondary index pattern<ept id=\"p1\">](#intra-partition-secondary-index-pattern)</ept> - Store multiple copies of each entity using different RowKey values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different RowKey values."
    },
    {
      "pos": [
        23242,
        23533
      ],
      "content": "<bpt id=\"p1\">[</bpt>Inter-partition secondary index pattern<ept id=\"p1\">](#inter-partition-secondary-index-pattern)</ept> - Store multiple copies of each entity using different RowKey values in separate partitions in separate tables to enable fast and efficient lookups and alternate sort orders by using different RowKey values."
    },
    {
      "pos": [
        23538,
        23709
      ],
      "content": "<bpt id=\"p1\">[</bpt>Log tail pattern<ept id=\"p1\">](#log-tail-pattern)</ept> - Retrieve the <bpt id=\"p2\">*</bpt>n<ept id=\"p2\">*</ept> entities most recently added to a partition by using a <bpt id=\"p3\">**</bpt>RowKey<ept id=\"p3\">**</ept> value that sorts in reverse date and time order."
    },
    {
      "content": "Design for data modification",
      "pos": [
        23716,
        23744
      ]
    },
    {
      "content": "This section focuses on the design considerations for optimizing inserts, updates, and deletes.",
      "pos": [
        23745,
        23840
      ]
    },
    {
      "content": "In some cases, you will need to evaluate the trade-off between designs that optimize for querying against designs that optimize for data modification just as you do in designs for relational databases (although the techniques for managing the design trade-offs are different in a relational database).",
      "pos": [
        23841,
        24142
      ]
    },
    {
      "content": "The section <bpt id=\"p1\">[</bpt>Table Design Patterns<ept id=\"p1\">](#table-design-patterns)</ept> describes some detailed design patterns for the Table service and highlights some these trade-offs.",
      "pos": [
        24143,
        24302
      ]
    },
    {
      "content": "In practice, you will find that many designs optimized for querying entities also work well for modifying entities.",
      "pos": [
        24303,
        24418
      ]
    },
    {
      "content": "Optimizing the performance of insert, update, and delete operations",
      "pos": [
        24426,
        24493
      ]
    },
    {
      "content": "To update or delete an entity, you must be able to identify it by using the <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> values.",
      "pos": [
        24497,
        24612
      ]
    },
    {
      "content": "In this respect, your choice of <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> for modifying entities should follow similar criteria to your choice to support point queries because you want to identify entities as efficiently as possible.",
      "pos": [
        24613,
        24836
      ]
    },
    {
      "content": "You do not want to use an inefficient partition or table scan to locate an entity in order to discover the <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> values you need to update or delete it.",
      "pos": [
        24837,
        25015
      ]
    },
    {
      "pos": [
        25019,
        25186
      ],
      "content": "The following patterns in the section <bpt id=\"p1\">[</bpt>Table Design Patterns<ept id=\"p1\">](#table-design-patterns)</ept> address optimizing the performance or your insert, update, and delete operations:"
    },
    {
      "pos": [
        25194,
        25432
      ],
      "content": "<bpt id=\"p1\">[</bpt>High volume delete pattern<ept id=\"p1\">](#high-volume-delete-pattern)</ept> - Enable the deletion of a high volume of entities by storing all the entities for simultaneous deletion in their own separate table; you delete the entities by deleting the table."
    },
    {
      "pos": [
        25439,
        25575
      ],
      "content": "<bpt id=\"p1\">[</bpt>Data series pattern<ept id=\"p1\">](#data-series-pattern)</ept> - Store complete data series in a single entity to minimize the number of requests you make."
    },
    {
      "pos": [
        25582,
        25719
      ],
      "content": "<bpt id=\"p1\">[</bpt>Wide entities pattern<ept id=\"p1\">](#wide-entities-pattern)</ept> - Use multiple physical entities to store logical entities with more than 252 properties."
    },
    {
      "pos": [
        25726,
        25826
      ],
      "content": "<bpt id=\"p1\">[</bpt>Large entities pattern<ept id=\"p1\">](#large-entities-pattern)</ept> - Use blob storage to store large property values."
    },
    {
      "content": "Ensuring consistency in your stored entities",
      "pos": [
        25834,
        25878
      ]
    },
    {
      "content": "The other key factor that influences your choice of keys for optimizing data modifications is how to ensure consistency by using atomic transactions.",
      "pos": [
        25882,
        26031
      ]
    },
    {
      "content": "You can only use an EGT to operate on entities stored in the same partition.",
      "pos": [
        26032,
        26108
      ]
    },
    {
      "pos": [
        26112,
        26227
      ],
      "content": "The following patterns in the section <bpt id=\"p1\">[</bpt>Table Design Patterns<ept id=\"p1\">](#table-design-patterns)</ept> address managing consistency:"
    },
    {
      "pos": [
        26235,
        26516
      ],
      "content": "<bpt id=\"p1\">[</bpt>Intra-partition secondary index pattern<ept id=\"p1\">](#intra-partition-secondary-index-pattern)</ept> - Store multiple copies of each entity using different <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different <bpt id=\"p3\">**</bpt>RowKey<ept id=\"p3\">**</ept> values."
    },
    {
      "pos": [
        26523,
        26821
      ],
      "content": "<bpt id=\"p1\">[</bpt>Inter-partition secondary index pattern<ept id=\"p1\">](#inter-partition-secondary-index-pattern)</ept> - Store multiple copies of each entity using different RowKey values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> values."
    },
    {
      "pos": [
        26828,
        27037
      ],
      "content": "<bpt id=\"p1\">[</bpt>Eventually consistent transactions pattern<ept id=\"p1\">](#eventually-consistent-transactions-pattern)</ept> - Enable eventually consistent behavior across partition boundaries or storage system boundaries by using Azure queues."
    },
    {
      "pos": [
        27042,
        27177
      ],
      "content": "<bpt id=\"p1\">[</bpt>Index Entities Pattern<ept id=\"p1\">](#index-entities-pattern)</ept> - Maintain index entities to enable efficient searches that return lists of entities."
    },
    {
      "pos": [
        27184,
        27361
      ],
      "content": "<bpt id=\"p1\">[</bpt>Denormalization pattern<ept id=\"p1\">](#denormalization-pattern)</ept> - Combine related data together in a single entity to enable you to retrieve all the data you need with a single point query."
    },
    {
      "pos": [
        27368,
        27504
      ],
      "content": "<bpt id=\"p1\">[</bpt>Data series pattern<ept id=\"p1\">](#data-series-pattern)</ept> - Store complete data series in a single entity to minimize the number of requests you make."
    },
    {
      "pos": [
        27508,
        27629
      ],
      "content": "For information about entity group transactions, see the section <bpt id=\"p1\">[</bpt>Entity Group Transactions<ept id=\"p1\">](#entity-group-transactions)</ept>."
    },
    {
      "content": "Ensuring your design for efficient modifications facilitates efficient queries",
      "pos": [
        27637,
        27715
      ]
    },
    {
      "content": "In many cases, a design for efficient querying results in efficient modifications, but you should always evaluate whether this is the case for your specific scenario.",
      "pos": [
        27719,
        27885
      ]
    },
    {
      "content": "Some of the patterns in the section <bpt id=\"p1\">[</bpt>Table Design Patterns<ept id=\"p1\">](#table-design-patterns)</ept> explicitly evaluate trade-offs between querying and modifying entities, and you should always take into account the number of each type of operation.",
      "pos": [
        27886,
        28119
      ]
    },
    {
      "pos": [
        28123,
        28314
      ],
      "content": "The following patterns in the section <bpt id=\"p1\">[</bpt>Table Design Patterns<ept id=\"p1\">](#table-design-patterns)</ept> address trade-offs between designing for efficient queries and designing for efficient data modification:"
    },
    {
      "pos": [
        28322,
        28469
      ],
      "content": "<bpt id=\"p1\">[</bpt>Compound key pattern<ept id=\"p1\">](#compound-key-pattern)</ept> - Use compound <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> values to enable a client to lookup related data with a single point query."
    },
    {
      "pos": [
        28476,
        28647
      ],
      "content": "<bpt id=\"p1\">[</bpt>Log tail pattern<ept id=\"p1\">](#log-tail-pattern)</ept> - Retrieve the <bpt id=\"p2\">*</bpt>n<ept id=\"p2\">*</ept> entities most recently added to a partition by using a <bpt id=\"p3\">**</bpt>RowKey<ept id=\"p3\">**</ept> value that sorts in reverse date and time order."
    },
    {
      "content": "Modelling relationships",
      "pos": [
        28654,
        28677
      ]
    },
    {
      "content": "Building domain models is a key step in the design of complex systems.",
      "pos": [
        28681,
        28751
      ]
    },
    {
      "content": "Typically, you use the modelling process to identify entities and the relationships between them as a way to understand the business domain and inform the design of your system.",
      "pos": [
        28752,
        28929
      ]
    },
    {
      "content": "This section focuses on how you can translate some of the common relationship types found in domain models to designs for the Table service.",
      "pos": [
        28930,
        29070
      ]
    },
    {
      "content": "The process of mapping from a logical data-model to a physical NoSQL based data-model is very different from that used when designing a relational database.",
      "pos": [
        29071,
        29227
      ]
    },
    {
      "content": "Relational databases design typically assumes a data normalization process optimized for minimizing redundancy – and a declarative querying capability that abstracts how the implementation of how the database works.",
      "pos": [
        29228,
        29443
      ]
    },
    {
      "content": "One-to-many relationships",
      "pos": [
        29451,
        29476
      ]
    },
    {
      "content": "One-to-many relationships between business domain objects occur very frequently: for example, one department has many employees.",
      "pos": [
        29480,
        29608
      ]
    },
    {
      "content": "There are several ways to implement one-to-many relationships in the Table service each with pros and cons that may be relevant to the particular scenario.",
      "pos": [
        29609,
        29764
      ]
    },
    {
      "content": "Consider the example of a large multi-national corporation with tens of thousands of departments and employee entities where every department has many employees and each employee as associated with one specific department.",
      "pos": [
        29768,
        29990
      ]
    },
    {
      "content": "One approach is to store separate department and employee entities such as these:",
      "pos": [
        29991,
        30072
      ]
    },
    {
      "content": "This example shows an implicit one-to-many relationship between the types based on the <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> value.",
      "pos": [
        30084,
        30194
      ]
    },
    {
      "content": "Each department can have many employees.",
      "pos": [
        30195,
        30235
      ]
    },
    {
      "content": "This example also shows a department entity and its related employee entities in the same partition.",
      "pos": [
        30239,
        30339
      ]
    },
    {
      "content": "You could choose to use different partitions, tables, or even storage accounts for the different entity types.",
      "pos": [
        30340,
        30450
      ]
    },
    {
      "content": "An alternative approach is to denormalize your data and store only employee entities with denormalized department data as shown in the following example.",
      "pos": [
        30454,
        30607
      ]
    },
    {
      "content": "In this particular scenario, this denormalized approach may not be the best if you have a requirement to be able to change the details of a department manager because to do this you need to update every employee in the department.",
      "pos": [
        30608,
        30838
      ]
    },
    {
      "pos": [
        30850,
        30952
      ],
      "content": "For more information, see the <bpt id=\"p1\">[</bpt>Denormalization pattern<ept id=\"p1\">](#denormalization-pattern)</ept> later in this guide."
    },
    {
      "content": "The following table summarizes the pros and cons of each of the approaches outlined above for storing employee and department entities that have a one-to-many relationship.",
      "pos": [
        30956,
        31128
      ]
    },
    {
      "content": "You should also consider how often you expect to perform various operations: it may be acceptable to have a design that includes an expensive operation if that operation only happens infrequently.",
      "pos": [
        31129,
        31325
      ]
    },
    {
      "content": "Approach",
      "pos": [
        31346,
        31354
      ]
    },
    {
      "content": "Pros",
      "pos": [
        31364,
        31368
      ]
    },
    {
      "content": "Cons",
      "pos": [
        31378,
        31382
      ]
    },
    {
      "content": "Separate entity types, same partition, same table",
      "pos": [
        31403,
        31452
      ]
    },
    {
      "content": "You can update a department entity with a single operation.",
      "pos": [
        31472,
        31531
      ]
    },
    {
      "content": "You can use an EGT to maintain consistency if you have a requirement to modify a department entity whenever you update/insert/delete an employee entity.",
      "pos": [
        31541,
        31693
      ]
    },
    {
      "content": "For example if you maintain a departmental employee count for each department.",
      "pos": [
        31694,
        31772
      ]
    },
    {
      "content": "You may need to retrieve both an employee and a department entity for some client activities.",
      "pos": [
        31804,
        31897
      ]
    },
    {
      "content": "Storage operations happen in the same partition.",
      "pos": [
        31907,
        31955
      ]
    },
    {
      "content": "At high transaction volumes, this may result in a hotspot.",
      "pos": [
        31956,
        32014
      ]
    },
    {
      "content": "You cannot move an employee to a new department using an EGT.",
      "pos": [
        32024,
        32085
      ]
    },
    {
      "content": "Separate entity types, different partitions or tables or storage accounts",
      "pos": [
        32118,
        32191
      ]
    },
    {
      "content": "You can update a department entity or employee entity with a single operation.",
      "pos": [
        32211,
        32289
      ]
    },
    {
      "content": "At high transaction volumes, this may help spread the load across more partitions.",
      "pos": [
        32299,
        32381
      ]
    },
    {
      "content": "You may need to retrieve both an employee and a department entity for some client activities.",
      "pos": [
        32413,
        32506
      ]
    },
    {
      "content": "You cannot use EGTs to maintain consistency when you update/insert/delete an employee and update a department.",
      "pos": [
        32516,
        32626
      ]
    },
    {
      "content": "For example, updating an employee count in a department entity.",
      "pos": [
        32627,
        32690
      ]
    },
    {
      "content": "You cannot move an employee to a new department using an EGT.",
      "pos": [
        32700,
        32761
      ]
    },
    {
      "content": "Denormalize into single entity type",
      "pos": [
        32794,
        32829
      ]
    },
    {
      "content": "You can retrieve all the information you need with a single request.",
      "pos": [
        32849,
        32917
      ]
    },
    {
      "content": "It may be expensive to maintain consistency if you need to update department information (this would require you to update all the employees in a department).",
      "pos": [
        32949,
        33107
      ]
    },
    {
      "content": "How you choose between these options, and which of the pros and cons are most significant, depends on your specific application scenarios.",
      "pos": [
        33141,
        33279
      ]
    },
    {
      "content": "For example, how often do you modify department entities; do all your employee queries need the additional departmental information; how close are you to the scalability limits on your partitions or your storage account?",
      "pos": [
        33280,
        33500
      ]
    },
    {
      "content": "One-to-one relationships",
      "pos": [
        33508,
        33532
      ]
    },
    {
      "content": "Domain models may include one-to-one relationships between entities.",
      "pos": [
        33536,
        33604
      ]
    },
    {
      "content": "If you need to implement a one-to-one relationship in the Table service, you must also choose how to link the two related entities when you need to retrieve them both.",
      "pos": [
        33605,
        33772
      ]
    },
    {
      "content": "This link can be either implicit, based on a convention in the key values, or explicit by storing a link in the form of <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> values in each entity to its related entity.",
      "pos": [
        33773,
        33969
      ]
    },
    {
      "content": "For a discussion of whether you should store the related entities in the same partition, see the section <bpt id=\"p1\">[</bpt>One-to-many relationships<ept id=\"p1\">](#one-to-many-relationships)</ept>.",
      "pos": [
        33970,
        34131
      ]
    },
    {
      "content": "Note that there are also implementation considerations that might lead you to implement one-to-one relationships in the Table service:",
      "pos": [
        34135,
        34269
      ]
    },
    {
      "pos": [
        34277,
        34389
      ],
      "content": "Handling large entities (for more information, see <bpt id=\"p1\">[</bpt>Working with large entities<ept id=\"p1\">](#working-with-large-entities)</ept>)."
    },
    {
      "pos": [
        34396,
        34555
      ],
      "content": "Implementing access controls (for more information, see <bpt id=\"p1\">[</bpt>Controlling access with Shared Access Signatures<ept id=\"p1\">](#controlling-access-with-shared-access-signatures)</ept>)."
    },
    {
      "content": "Join in the client",
      "pos": [
        34563,
        34581
      ]
    },
    {
      "content": "Although there are ways to model relationships in the Table service, you should not forget that the two prime reasons for using the Table service are scalability and performance.",
      "pos": [
        34585,
        34763
      ]
    },
    {
      "content": "If you find you are modelling many relationships that compromise the performance and scalability of your solution, you should ask yourself if it is necessary to build all the data relationships into your table design.",
      "pos": [
        34764,
        34981
      ]
    },
    {
      "content": "You may be able to simplify the design and improve the scalability and performance of your solution if you let your client application perform any necessary joins.",
      "pos": [
        34982,
        35145
      ]
    },
    {
      "content": "For example, if you have small tables that contain data that does not change very often, then you can retrieve this data once and cache it on the client.",
      "pos": [
        35149,
        35302
      ]
    },
    {
      "content": "This can avoid repeated roundtrips to retrieve the same data.",
      "pos": [
        35303,
        35364
      ]
    },
    {
      "content": "In the examples we have looked at in this guide, the set of departments in a small organization is likely to be small and change infrequently making it a good candidate for data that client application can download once and cache as look up data.",
      "pos": [
        35365,
        35611
      ]
    },
    {
      "content": "Inheritance relationships",
      "pos": [
        35619,
        35644
      ]
    },
    {
      "content": "If your client application uses a set of classes that form part of an inheritance relationship to represent business entities, you can easily persist those entities in the Table service.",
      "pos": [
        35648,
        35834
      ]
    },
    {
      "content": "For example, you might have the following set of classes defined in your client application where <bpt id=\"p1\">**</bpt>Person<ept id=\"p1\">**</ept> is an abstract class.",
      "pos": [
        35835,
        35965
      ]
    },
    {
      "content": "You can persist instances of the two concrete classes in the Table service using a single Person table using entities in that look like this:",
      "pos": [
        35975,
        36116
      ]
    },
    {
      "content": "For more information about working with multiple entity types in the same table in client code, see the section <bpt id=\"p1\">[</bpt>Working with heterogeneous entity types<ept id=\"p1\">](#working-with-heterogeneous-entity-types)</ept> later in this guide.",
      "pos": [
        36128,
        36344
      ]
    },
    {
      "content": "This provides examples of how to recognize the entity type in client code.",
      "pos": [
        36345,
        36419
      ]
    },
    {
      "content": "Table Design Patterns",
      "pos": [
        36426,
        36447
      ]
    },
    {
      "content": "In previous sections, you have seen some detailed discussions about how to optimize your table design for both retrieving entity data using queries and for inserting, updating, and deleting entity data.",
      "pos": [
        36448,
        36650
      ]
    },
    {
      "content": "This section describes some patterns appropriate for use with Table service solutions.",
      "pos": [
        36651,
        36737
      ]
    },
    {
      "content": "In addition, you will see how you can practically address some of the issues and trade-offs raised previously in this guide.",
      "pos": [
        36738,
        36862
      ]
    },
    {
      "content": "The following diagram summarizes the relationships between the different patterns:",
      "pos": [
        36863,
        36945
      ]
    },
    {
      "content": "The pattern map above highlights some relationships between patterns (blue) and anti-patterns (orange) that are documented in this guide.",
      "pos": [
        36957,
        37094
      ]
    },
    {
      "content": "There are of course many other patterns that are worth considering.",
      "pos": [
        37095,
        37162
      ]
    },
    {
      "content": "For example, one of the key scenarios for Table Service is to store <bpt id=\"p1\">[</bpt>Materialized Views<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn589782.aspx)</ept> from the <bpt id=\"p2\">[</bpt>Command Query Responsibility Segregation<ept id=\"p2\">](https://msdn.microsoft.com/library/azure/jj554200.aspx)</ept> (CQRS) pattern.",
      "pos": [
        37163,
        37431
      ]
    },
    {
      "content": "Intra-partition secondary index pattern",
      "pos": [
        37439,
        37478
      ]
    },
    {
      "content": "Store multiple copies of each entity using different <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> values.",
      "pos": [
        37479,
        37674
      ]
    },
    {
      "content": "Updates between copies can be kept consistent using EGT’s.",
      "pos": [
        37675,
        37733
      ]
    },
    {
      "content": "Context and problem",
      "pos": [
        37742,
        37761
      ]
    },
    {
      "content": "The Table service automatically indexes entities using the <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> values.",
      "pos": [
        37762,
        37860
      ]
    },
    {
      "content": "This enables a client application to retrieve an entity efficiently using these values.",
      "pos": [
        37861,
        37948
      ]
    },
    {
      "content": "For example, using the table structure shown below, a client application can use a point query to retrieve an individual employee entity by using the department name and the employee id (the <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> values).",
      "pos": [
        37949,
        38180
      ]
    },
    {
      "content": "A client can also retrieve entities sorted by employee id within each department.",
      "pos": [
        38181,
        38262
      ]
    },
    {
      "content": "If you also want to be able to find an employee entity based on the value of another property, such as email address, you must use a less efficient partition scan to find a match.",
      "pos": [
        38272,
        38451
      ]
    },
    {
      "content": "This is because the table service does not provide secondary indexes.",
      "pos": [
        38452,
        38521
      ]
    },
    {
      "content": "In addition, there is no option to request a list of employees sorted in a different order than <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> order.",
      "pos": [
        38522,
        38635
      ]
    },
    {
      "content": "Solution",
      "pos": [
        38644,
        38652
      ]
    },
    {
      "content": "To work around the lack of secondary indexes, you can store multiple copies of each entity with each copy using a different <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> value.",
      "pos": [
        38653,
        38794
      ]
    },
    {
      "content": "If you store an entity with the structures shown below, you can efficiently retrieve employee entities based on email address or employee id.",
      "pos": [
        38795,
        38936
      ]
    },
    {
      "content": "The prefix values for the <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept>, \"empid_\" and \"email_\" enable you to query for a single employee or a range of employees by using a range of email addresses or employee ids.",
      "pos": [
        38937,
        39115
      ]
    },
    {
      "content": "The following two filter criteria (one looking up by employee id and one looking up by email address) both specify point queries:",
      "pos": [
        39127,
        39256
      ]
    },
    {
      "content": "$filter=(PartitionKey eq 'Sales') and (RowKey eq 'empid_000223')",
      "pos": [
        39264,
        39328
      ]
    },
    {
      "content": "$filter=(PartitionKey eq 'Sales') and (RowKey eq 'email_jonesj@contoso.com')",
      "pos": [
        39335,
        39411
      ]
    },
    {
      "pos": [
        39415,
        39627
      ],
      "content": "If you query for a range of employee entities, you can specify a range sorted in employee id order, or a range sorted in email address order by querying for entities with the appropriate prefix in the <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept>."
    },
    {
      "content": "To find all the employees in the Sales department with an employee id in the range 000100 to 000199 use:",
      "pos": [
        39635,
        39739
      ]
    },
    {
      "content": "$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000100') and (RowKey le 'empid_000199')",
      "pos": [
        39740,
        39835
      ]
    },
    {
      "content": "To find all the employees in the Sales department with an email address starting with the letter 'a' use:",
      "pos": [
        39842,
        39947
      ]
    },
    {
      "content": "$filter=(PartitionKey eq 'Sales') and (RowKey ge 'email_a') and (RowKey lt 'email_b')",
      "pos": [
        39948,
        40033
      ]
    },
    {
      "pos": [
        40038,
        40234
      ],
      "content": "Note that the filter syntax used in the examples above is from the Table service REST API, for more information see <bpt id=\"p1\">[</bpt>Query Entities<ept id=\"p1\">](http://msdn.microsoft.com/library/azure/dd179421.aspx)</ept> on MSDN."
    },
    {
      "content": "Issues and considerations",
      "pos": [
        40243,
        40268
      ]
    },
    {
      "content": "Consider the following points when deciding how to implement this pattern:",
      "pos": [
        40272,
        40346
      ]
    },
    {
      "content": "Table storage is relatively cheap to use so the cost overhead of storing duplicate data should not be a major concern.",
      "pos": [
        40354,
        40472
      ]
    },
    {
      "content": "However, you should always evaluate the cost of your design based on your anticipated storage requirements and only add duplicate entities to support the queries your client application will execute.",
      "pos": [
        40473,
        40672
      ]
    },
    {
      "content": "Because the secondary index entities are stored in the same partition as the original entities, you should ensure that you do not exceed the scalability targets for an individual partition.",
      "pos": [
        40679,
        40868
      ]
    },
    {
      "content": "You can keep your duplicate entities consistent with each other by using EGTs to update the two copies of the entity atomically.",
      "pos": [
        40875,
        41003
      ]
    },
    {
      "content": "This implies that you should store all copies of an entity in the same partition.",
      "pos": [
        41004,
        41085
      ]
    },
    {
      "content": "For more information, see the section <bpt id=\"p1\">[</bpt>Using Entity Group Transactions<ept id=\"p1\">](#entity-group-transactions)</ept>.",
      "pos": [
        41086,
        41186
      ]
    },
    {
      "content": "The value used for the <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> must be unique for each entity.",
      "pos": [
        41193,
        41258
      ]
    },
    {
      "content": "Consider using compound key values.",
      "pos": [
        41259,
        41294
      ]
    },
    {
      "pos": [
        41301,
        41451
      ],
      "content": "Padding numeric values in the <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> (for example, the employee id 000223), enables correct sorting and filtering based on upper and lower bounds."
    },
    {
      "content": "You do not necessarily need to duplicate all the properties of your entity.",
      "pos": [
        41458,
        41533
      ]
    },
    {
      "content": "For example, if the queries that lookup the entities using the email address in the <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> never need the employee’s age, these entities could have the following structure:",
      "pos": [
        41534,
        41710
      ]
    },
    {
      "content": "It is typically better to store duplicate data and ensure that you can retrieve all the data you need with a single query, than to use one query to locate an entity and another to lookup the required data.",
      "pos": [
        41724,
        41929
      ]
    },
    {
      "content": "When to use this pattern",
      "pos": [
        41938,
        41962
      ]
    },
    {
      "content": "Use this pattern when your client application needs to retrieve entities using a variety of different keys, when your client needs to retrieve entities in different sort orders, and where you can identify each entity using a variety of unique values.",
      "pos": [
        41966,
        42216
      ]
    },
    {
      "content": "However, you should be sure that you do not exceed the partition scalability limits when you are performing entity lookups using the different <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> values.",
      "pos": [
        42217,
        42378
      ]
    },
    {
      "content": "Related patterns and guidance",
      "pos": [
        42387,
        42416
      ]
    },
    {
      "content": "The following patterns and guidance may also be relevant when implementing this pattern:",
      "pos": [
        42420,
        42508
      ]
    },
    {
      "content": "Inter-partition secondary index pattern",
      "pos": [
        42517,
        42556
      ]
    },
    {
      "content": "Compound key pattern",
      "pos": [
        42605,
        42625
      ]
    },
    {
      "content": "Entity Group Transactions",
      "pos": [
        42655,
        42680
      ]
    },
    {
      "content": "Working with heterogeneous entity types",
      "pos": [
        42715,
        42754
      ]
    },
    {
      "content": "Inter-partition secondary index pattern",
      "pos": [
        42803,
        42842
      ]
    },
    {
      "pos": [
        42843,
        43059
      ],
      "content": "Store multiple copies of each entity using different <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> values."
    },
    {
      "content": "Context and problem",
      "pos": [
        43068,
        43087
      ]
    },
    {
      "content": "The Table service automatically indexes entities using the <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> values.",
      "pos": [
        43088,
        43186
      ]
    },
    {
      "content": "This enables a client application to retrieve an entity efficiently using these values.",
      "pos": [
        43187,
        43274
      ]
    },
    {
      "content": "For example, using the table structure shown below, a client application can use a point query to retrieve an individual employee entity by using the department name and the employee id (the <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> values).",
      "pos": [
        43275,
        43506
      ]
    },
    {
      "content": "A client can also retrieve entities sorted by employee id within each department.",
      "pos": [
        43507,
        43588
      ]
    },
    {
      "content": "If you also want to be able to find an employee entity based on the value of another property, such as email address, you must use a less efficient partition scan to find a match.",
      "pos": [
        43600,
        43779
      ]
    },
    {
      "content": "This is because the table service does not provide secondary indexes.",
      "pos": [
        43780,
        43849
      ]
    },
    {
      "content": "In addition, there is no option to request a list of employees sorted in a different order than <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> order.",
      "pos": [
        43850,
        43963
      ]
    },
    {
      "content": "You are anticipating a very high volume of transactions against these entities and want to minimize the risk of the Table service throttling your client.",
      "pos": [
        43967,
        44120
      ]
    },
    {
      "content": "Solution",
      "pos": [
        44129,
        44137
      ]
    },
    {
      "content": "To work around the lack of secondary indexes, you can store multiple copies of each entity with each copy using different <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> values.",
      "pos": [
        44140,
        44301
      ]
    },
    {
      "content": "If you store an entity with the structures shown below, you can efficiently retrieve employee entities based on email address or employee id.",
      "pos": [
        44302,
        44443
      ]
    },
    {
      "content": "The prefix values for the <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept>, \"empid_\" and \"email_\" enable you to identify which index you want to use for a query.",
      "pos": [
        44444,
        44573
      ]
    },
    {
      "content": "The following two filter criteria (one looking up by employee id and one looking up by email address) both specify point queries:",
      "pos": [
        44586,
        44715
      ]
    },
    {
      "content": "$filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')",
      "pos": [
        44723,
        44787
      ]
    },
    {
      "content": "$filter=(PartitionKey eq 'email_Sales') and (RowKey eq 'jonesj@contoso.com')",
      "pos": [
        44792,
        44868
      ]
    },
    {
      "pos": [
        44872,
        45084
      ],
      "content": "If you query for a range of employee entities, you can specify a range sorted in employee id order, or a range sorted in email address order by querying for entities with the appropriate prefix in the <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept>."
    },
    {
      "content": "To find all the employees in the Sales department with an employee id in the range <bpt id=\"p1\">**</bpt>000100<ept id=\"p1\">**</ept> to <bpt id=\"p2\">**</bpt>000199<ept id=\"p2\">**</ept> sorted in employee id order use:",
      "pos": [
        45092,
        45232
      ]
    },
    {
      "content": "$filter=(PartitionKey eq 'empid_Sales') and (RowKey ge '000100') and (RowKey le '000199')",
      "pos": [
        45233,
        45322
      ]
    },
    {
      "content": "To find all the employees in the Sales department with an email address that starts with 'a' sorted in email address order use:",
      "pos": [
        45329,
        45456
      ]
    },
    {
      "content": "$filter=(PartitionKey eq 'email_Sales') and (RowKey ge 'a') and (RowKey lt 'b')",
      "pos": [
        45457,
        45536
      ]
    },
    {
      "pos": [
        45540,
        45736
      ],
      "content": "Note that the filter syntax used in the examples above is from the Table service REST API, for more information see <bpt id=\"p1\">[</bpt>Query Entities<ept id=\"p1\">](http://msdn.microsoft.com/library/azure/dd179421.aspx)</ept> on MSDN."
    },
    {
      "content": "Issues and considerations",
      "pos": [
        45745,
        45770
      ]
    },
    {
      "content": "Consider the following points when deciding how to implement this pattern:",
      "pos": [
        45773,
        45847
      ]
    },
    {
      "pos": [
        45855,
        46086
      ],
      "content": "You can keep your duplicate entities eventually consistent with each other by using the <bpt id=\"p1\">[</bpt>Eventually consistent transactions pattern<ept id=\"p1\">](#eventually-consistent-transactions-pattern)</ept> to maintain the primary and secondary index entities."
    },
    {
      "content": "Table storage is relatively cheap to use so the cost overhead of storing duplicate data should not be a major concern.",
      "pos": [
        46093,
        46211
      ]
    },
    {
      "content": "However, you should always evaluate the cost of your design based on your anticipated storage requirements and only add duplicate entities to support the queries your client application will execute.",
      "pos": [
        46212,
        46411
      ]
    },
    {
      "content": "The value used for the <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> must be unique for each entity.",
      "pos": [
        46418,
        46483
      ]
    },
    {
      "content": "Consider using compound key values.",
      "pos": [
        46484,
        46519
      ]
    },
    {
      "pos": [
        46526,
        46676
      ],
      "content": "Padding numeric values in the <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> (for example, the employee id 000223), enables correct sorting and filtering based on upper and lower bounds."
    },
    {
      "content": "You do not necessarily need to duplicate all the properties of your entity.",
      "pos": [
        46683,
        46758
      ]
    },
    {
      "content": "For example, if the queries that lookup the entities using the email address in the <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> never need the employee’s age, these entities could have the following structure:",
      "pos": [
        46759,
        46935
      ]
    },
    {
      "content": "It is typically better to store duplicate data and ensure that you can retrieve all the data you need with a single query than to use one query to locate an entity using the secondary index and another to lookup the required data in the primary index.",
      "pos": [
        46954,
        47205
      ]
    },
    {
      "content": "When to use this pattern",
      "pos": [
        47214,
        47238
      ]
    },
    {
      "content": "Use this pattern when your client application needs to retrieve entities using a variety of different keys, when your client needs to retrieve entities in different sort orders, and where you can identify each entity using a variety of unique values.",
      "pos": [
        47241,
        47491
      ]
    },
    {
      "content": "Use this pattern when you want to avoid exceeding the partition scalability limits when you are performing entity lookups using the different <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> values.",
      "pos": [
        47492,
        47652
      ]
    },
    {
      "content": "Related patterns and guidance",
      "pos": [
        47661,
        47690
      ]
    },
    {
      "content": "The following patterns and guidance may also be relevant when implementing this pattern:",
      "pos": [
        47691,
        47779
      ]
    },
    {
      "content": "Eventually consistent transactions pattern",
      "pos": [
        47788,
        47830
      ]
    },
    {
      "content": "Intra-partition secondary index pattern",
      "pos": [
        47884,
        47923
      ]
    },
    {
      "content": "Compound key pattern",
      "pos": [
        47974,
        47994
      ]
    },
    {
      "content": "Entity Group Transactions",
      "pos": [
        48026,
        48051
      ]
    },
    {
      "content": "Working with heterogeneous entity types",
      "pos": [
        48088,
        48127
      ]
    },
    {
      "content": "Eventually consistent transactions pattern",
      "pos": [
        48178,
        48220
      ]
    },
    {
      "content": "Enable eventually consistent behavior across partition boundaries or storage system boundaries by using Azure queues.",
      "pos": [
        48224,
        48341
      ]
    },
    {
      "content": "Context and problem",
      "pos": [
        48350,
        48369
      ]
    },
    {
      "content": "EGTs enable atomic transactions across multiple entities that share the same partition key.",
      "pos": [
        48373,
        48464
      ]
    },
    {
      "content": "For performance and scalability reasons, you might decide to store entities that have consistency requirements in separate partitions or in a separate storage system: in such a scenario, you cannot use EGTs to maintain consistency.",
      "pos": [
        48465,
        48696
      ]
    },
    {
      "content": "For example, you might have a requirement to maintain eventual consistency between:",
      "pos": [
        48697,
        48780
      ]
    },
    {
      "content": "Entities stored in two different partitions in the same table, in different tables, in in different storage accounts.",
      "pos": [
        48788,
        48905
      ]
    },
    {
      "content": "An entity stored in the Table service and a blob stored in the Blob service.",
      "pos": [
        48912,
        48988
      ]
    },
    {
      "content": "An entity stored in the Table service and a file in a file system.",
      "pos": [
        48995,
        49061
      ]
    },
    {
      "content": "An entity store in the Table service yet indexed using the Azure Search service.",
      "pos": [
        49068,
        49148
      ]
    },
    {
      "content": "Solution",
      "pos": [
        49157,
        49165
      ]
    },
    {
      "content": "By using Azure queues, you can implement a solution that delivers eventual consistency across two or more partitions or storage systems.",
      "pos": [
        49169,
        49305
      ]
    },
    {
      "content": "To illustrate this approach, assume you have a requirement to be able to archive old employee entities.",
      "pos": [
        49306,
        49409
      ]
    },
    {
      "content": "Old employee entities are rarely queried and should be excluded from any activities that deal with current employees.",
      "pos": [
        49410,
        49527
      ]
    },
    {
      "content": "To implement this requirement you store active employees in the <bpt id=\"p1\">**</bpt>Current<ept id=\"p1\">**</ept> table and old employees in the <bpt id=\"p2\">**</bpt>Archive<ept id=\"p2\">**</ept> table.",
      "pos": [
        49528,
        49653
      ]
    },
    {
      "content": "Archiving an employee requires you to delete the entity from the <bpt id=\"p1\">**</bpt>Current<ept id=\"p1\">**</ept> table and add the entity to the <bpt id=\"p2\">**</bpt>Archive<ept id=\"p2\">**</ept> table, but you cannot use an EGT to perform these two operations.",
      "pos": [
        49654,
        49840
      ]
    },
    {
      "content": "To avoid the risk that a failure causes an entity to appear in both or neither tables, the archive operation must be eventually consistent.",
      "pos": [
        49841,
        49980
      ]
    },
    {
      "content": "The following sequence diagram outlines the steps in this operation.",
      "pos": [
        49981,
        50049
      ]
    },
    {
      "content": "More detail is provided for exception paths in the text following.",
      "pos": [
        50050,
        50116
      ]
    },
    {
      "content": "A client initiates the archive operation by placing a message on an Azure queue, in this example to archive employee #456.",
      "pos": [
        50129,
        50251
      ]
    },
    {
      "content": "A worker role polls the queue for new messages; when it finds one, it reads the message and leaves a hidden copy on the queue.",
      "pos": [
        50252,
        50378
      ]
    },
    {
      "content": "The worker role next fetches a copy of the entity from the <bpt id=\"p1\">**</bpt>Current<ept id=\"p1\">**</ept> table, inserts a copy in the <bpt id=\"p2\">**</bpt>Archive<ept id=\"p2\">**</ept> table, and then deletes the original from the <bpt id=\"p3\">**</bpt>Current<ept id=\"p3\">**</ept> table.",
      "pos": [
        50379,
        50555
      ]
    },
    {
      "content": "Finally, if there were no errors from the previous steps, the worker role deletes the hidden message from the queue.",
      "pos": [
        50556,
        50672
      ]
    },
    {
      "content": "In this example, step 4 inserts the employee into the <bpt id=\"p1\">**</bpt>Archive<ept id=\"p1\">**</ept> table.",
      "pos": [
        50676,
        50748
      ]
    },
    {
      "content": "It could add the employee to a blob in the Blob service or a file in a file system.",
      "pos": [
        50749,
        50832
      ]
    },
    {
      "content": "Recovering from failures",
      "pos": [
        50841,
        50865
      ]
    },
    {
      "content": "It is important that the operations in steps <bpt id=\"p1\">**</bpt>4<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>5<ept id=\"p2\">**</ept> must be <bpt id=\"p3\">*</bpt>idempotent<ept id=\"p3\">*</ept> in case the worker role needs to restart the archive operation.",
      "pos": [
        50869,
        51014
      ]
    },
    {
      "content": "If you are using the Table service, for step <bpt id=\"p1\">**</bpt>4<ept id=\"p1\">**</ept> you should use an \"insert or replace\" operation; for step <bpt id=\"p2\">**</bpt>5<ept id=\"p2\">**</ept> you should use a \"delete if exists\" operation in the client library you are using.",
      "pos": [
        51015,
        51212
      ]
    },
    {
      "content": "If you are using another storage system, you must use an appropriate idempotent operation.",
      "pos": [
        51213,
        51303
      ]
    },
    {
      "content": "If the worker role never completes step <bpt id=\"p1\">**</bpt>6<ept id=\"p1\">**</ept>, then after a timeout the message reappears on the queue ready for the worker role to try to reprocess it.",
      "pos": [
        51307,
        51459
      ]
    },
    {
      "content": "The worker role can check how many times a message on the queue has been read and, if necessary, flag it is a \"poison\" message for investigation by sending it to a separate queue.",
      "pos": [
        51460,
        51639
      ]
    },
    {
      "content": "For more information about reading queue messages and checking the dequeue count, see <bpt id=\"p1\">[</bpt>Get Messages<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dd179474.aspx)</ept>.",
      "pos": [
        51640,
        51797
      ]
    },
    {
      "content": "Some errors from the Table and Queue services are transient errors, and your client application should include suitable retry logic to handle them.",
      "pos": [
        51801,
        51948
      ]
    },
    {
      "content": "Issues and considerations",
      "pos": [
        51957,
        51982
      ]
    },
    {
      "content": "Consider the following points when deciding how to implement this pattern:",
      "pos": [
        51983,
        52057
      ]
    },
    {
      "content": "This solution does not provide for transaction isolation.",
      "pos": [
        52065,
        52122
      ]
    },
    {
      "content": "For example, a client could read the <bpt id=\"p1\">**</bpt>Current<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>Archive<ept id=\"p2\">**</ept> tables when the worker role was between steps <bpt id=\"p3\">**</bpt>4<ept id=\"p3\">**</ept> and <bpt id=\"p4\">**</bpt>5<ept id=\"p4\">**</ept>, and see an inconsistent view of the data.",
      "pos": [
        52123,
        52292
      ]
    },
    {
      "content": "Note that the data will be consistent eventually.",
      "pos": [
        52293,
        52342
      ]
    },
    {
      "content": "You must be sure that steps 4 and 5 are idempotent in order to ensure eventual consistency.",
      "pos": [
        52349,
        52440
      ]
    },
    {
      "content": "You can scale the solution by using multiple queues and worker role instances.",
      "pos": [
        52447,
        52525
      ]
    },
    {
      "content": "When to use this pattern",
      "pos": [
        52534,
        52558
      ]
    },
    {
      "content": "Use this pattern when you want to guarantee eventual consistency between entities that exist in different partitions or tables.",
      "pos": [
        52561,
        52688
      ]
    },
    {
      "content": "You can extend this pattern to ensure eventual consistency for operations across the Table service and the Blob service and other non-Azure Storage data sources such as database or the file system.",
      "pos": [
        52689,
        52886
      ]
    },
    {
      "content": "Related patterns and guidance",
      "pos": [
        52895,
        52924
      ]
    },
    {
      "content": "The following patterns and guidance may also be relevant when implementing this pattern:",
      "pos": [
        52927,
        53015
      ]
    },
    {
      "content": "Entity Group Transactions",
      "pos": [
        53023,
        53048
      ]
    },
    {
      "content": "Merge or replace",
      "pos": [
        53085,
        53101
      ]
    },
    {
      "pos": [
        53126,
        53265
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> If transaction isolation is important to your solution, you should consider redesigning your tables to enable you to use EGTs."
    },
    {
      "content": "Index Entities Pattern",
      "pos": [
        53273,
        53295
      ]
    },
    {
      "content": "Maintain index entities to enable efficient searches that return lists of entities.",
      "pos": [
        53296,
        53379
      ]
    },
    {
      "content": "Context and problem",
      "pos": [
        53388,
        53407
      ]
    },
    {
      "content": "The Table service automatically indexes entities using the <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> values.",
      "pos": [
        53411,
        53509
      ]
    },
    {
      "content": "This enables a client application to retrieve an entity efficiently using a point query.",
      "pos": [
        53510,
        53598
      ]
    },
    {
      "content": "For example, using the table structure shown below, a client application can efficiently retrieve an individual employee entity by using the department name and the employee id (the <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept>).",
      "pos": [
        53599,
        53814
      ]
    },
    {
      "content": "If you also want to be able to retrieve a list of employee entities based on the value of another non-unique property, such as their last name, you must use a less efficient partition scan to find matches rather than using an index to look them up directly.",
      "pos": [
        53827,
        54084
      ]
    },
    {
      "content": "This is because the table service does not provide secondary indexes.",
      "pos": [
        54085,
        54154
      ]
    },
    {
      "content": "Solution",
      "pos": [
        54163,
        54171
      ]
    },
    {
      "content": "To enable lookup by last name with the entity structure shown above, you must maintain lists of employee ids.",
      "pos": [
        54175,
        54284
      ]
    },
    {
      "content": "If you want to retrieve the employee entities with a particular last name, such as Jones, you must first locate the list of employee ids for employees with Jones as their last name, and then retrieve those employee entities.",
      "pos": [
        54285,
        54509
      ]
    },
    {
      "content": "There are three main options for storing the lists of employee ids:",
      "pos": [
        54510,
        54577
      ]
    },
    {
      "content": "Use blob storage.",
      "pos": [
        54585,
        54602
      ]
    },
    {
      "content": "Create index entities in the same partition as the employee entities.",
      "pos": [
        54609,
        54678
      ]
    },
    {
      "content": "Create index entities in a separate partition or table.",
      "pos": [
        54685,
        54740
      ]
    },
    {
      "content": "Option #1: Use blob storage",
      "pos": [
        54747,
        54774
      ]
    },
    {
      "content": "For the first option, you create a blob for every unique last name, and in each blob store a list of the <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> (department) and <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> (employee id) values for employees that have that last name.",
      "pos": [
        54782,
        54992
      ]
    },
    {
      "content": "When you add or delete an employee you should ensure that the content of the relevant blob is eventually consistent with the employee entities.",
      "pos": [
        54993,
        55136
      ]
    },
    {
      "content": "Option #2:",
      "pos": [
        55143,
        55153
      ]
    },
    {
      "content": "Create index entities in the same partition",
      "pos": [
        55158,
        55201
      ]
    },
    {
      "content": "For the second option, use index entities that store the following data:",
      "pos": [
        55205,
        55277
      ]
    },
    {
      "pos": [
        55290,
        55409
      ],
      "content": "The <bpt id=\"p1\">**</bpt>EmployeeIDs<ept id=\"p1\">**</ept> property contains a list of employee ids for employees with the last name stored in the <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept>."
    },
    {
      "content": "The following steps outline the process you should follow when you are adding a new employee if you are using the second option.",
      "pos": [
        55413,
        55541
      ]
    },
    {
      "content": "In this example, we are adding an employee with Id 000152 and a last name Jones in the Sales department:",
      "pos": [
        55542,
        55646
      ]
    },
    {
      "content": "Retrieve the index entity with a <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> value \"Sales\" and the <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> value \"Jones.\"",
      "pos": [
        55653,
        55750
      ]
    },
    {
      "content": "Save the ETag of this entity to use in step 2.",
      "pos": [
        55751,
        55797
      ]
    },
    {
      "content": "Create an entity group transaction (that is, a batch operation) that inserts the new employee entity (<bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> value \"Sales\" and <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> value \"000152\"), and updates the index entity (<bpt id=\"p3\">**</bpt>PartitionKey<ept id=\"p3\">**</ept> value \"Sales\" and <bpt id=\"p4\">**</bpt>RowKey<ept id=\"p4\">**</ept> value \"Jones\") by adding the new employee id to the list in the EmployeeIDs field.",
      "pos": [
        55804,
        56127
      ]
    },
    {
      "content": "For more information about entity group transactions, see <bpt id=\"p1\">[</bpt>Entity Group Transactions<ept id=\"p1\">](#entity-group-transactions)</ept>.",
      "pos": [
        56128,
        56242
      ]
    },
    {
      "content": "If the entity group transaction fails because of an optimistic concurrency error (someone else has just modified the index entity), then you need to start over at step 1 again.",
      "pos": [
        56248,
        56424
      ]
    },
    {
      "content": "You can use a similar approach to deleting an employee if you are using the second option.",
      "pos": [
        56428,
        56518
      ]
    },
    {
      "content": "Changing an employee's last name is slightly more complex because you will need to execute an entity group transaction that updates three entities: the employee entity, the index entity for the old last name, and the index entity for the new last name.",
      "pos": [
        56519,
        56771
      ]
    },
    {
      "content": "You must retrieve each entity before making any changes in order to retrieve the ETag values that you can then use to perform the updates using optimistic concurrency.",
      "pos": [
        56772,
        56939
      ]
    },
    {
      "content": "The following steps outline the process you should follow when you need to look up all the employees with a given last name in a department if you are using the second option.",
      "pos": [
        56943,
        57118
      ]
    },
    {
      "content": "In this example, we are looking up all the employees with last name Jones in the Sales department:",
      "pos": [
        57119,
        57217
      ]
    },
    {
      "pos": [
        57225,
        57322
      ],
      "content": "Retrieve the index entity with a <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> value \"Sales\" and the <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> value \"Jones.\""
    },
    {
      "content": "Parse the list of employee Ids in the EmployeeIDs field.",
      "pos": [
        57329,
        57385
      ]
    },
    {
      "pos": [
        57392,
        57638
      ],
      "content": "If you need additional information about each of these employees (such as their email addresses), retrieve each of the employee entities using <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> value \"Sales\" and <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> values from the list of employees you obtained in step 2."
    },
    {
      "content": "Option #3:",
      "pos": [
        57645,
        57655
      ]
    },
    {
      "content": "Create index entities in a separate partition or table",
      "pos": [
        57660,
        57714
      ]
    },
    {
      "content": "For the third option, use index entities that store the following data:",
      "pos": [
        57718,
        57789
      ]
    },
    {
      "pos": [
        57802,
        57921
      ],
      "content": "The <bpt id=\"p1\">**</bpt>EmployeeIDs<ept id=\"p1\">**</ept> property contains a list of employee ids for employees with the last name stored in the <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept>."
    },
    {
      "content": "With the third option, you cannot use EGTs to maintain consistency because the index entities are in a separate partition from the employee entities.",
      "pos": [
        57925,
        58074
      ]
    },
    {
      "content": "You should ensure that the index entities are eventually consistent with the employee entities.",
      "pos": [
        58075,
        58170
      ]
    },
    {
      "content": "Issues and considerations",
      "pos": [
        58179,
        58204
      ]
    },
    {
      "content": "Consider the following points when deciding how to implement this pattern:",
      "pos": [
        58208,
        58282
      ]
    },
    {
      "pos": [
        58289,
        58490
      ],
      "content": "This solution requires at least two queries to retrieve matching entities: one to query the index entities to obtain the list of <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> values, and then queries to retrieve each entity in the list."
    },
    {
      "content": "Given that an individual entity has a maximum size of 1 MB, option #2 and option #3 in the solution assume that the list of employee ids for any given last name is never greater than 1 MB.",
      "pos": [
        58497,
        58685
      ]
    },
    {
      "content": "If the list of employee ids is likely to be greater than 1 MB in size, use option #1 and store the index data in blob storage.",
      "pos": [
        58686,
        58812
      ]
    },
    {
      "content": "If you use option #2 (using EGTs to handle adding and deleting employees, and changing an employee’s last name) you must evaluate if the volume of transactions will approach the scalability limits in a given partition.",
      "pos": [
        58819,
        59037
      ]
    },
    {
      "content": "If this is the case, you should consider an eventually consistent solution (option #1 or option #3) that uses queues to handle the update requests and enables you to store your index entities in a separate partition from the employee entities.",
      "pos": [
        59038,
        59281
      ]
    },
    {
      "content": "Option #2 in this solution assumes that you want to look up by last name within a department: for example, you want to retrieve a list of employees with a last name Jones in the Sales department.",
      "pos": [
        59288,
        59483
      ]
    },
    {
      "content": "If you want to be able to look up all the employees with a last name Jones across the whole organization, use either option #1 or option #3.",
      "pos": [
        59484,
        59624
      ]
    },
    {
      "pos": [
        59629,
        59822
      ],
      "content": "You can implement a queue-based solution that delivers eventual consistency (see the <bpt id=\"p1\">[</bpt>Eventually consistent transactions pattern<ept id=\"p1\">](#eventually-consistent-transactions-pattern)</ept> for more details)."
    },
    {
      "content": "When to use this pattern",
      "pos": [
        59831,
        59855
      ]
    },
    {
      "content": "Use this pattern when you want to lookup a set of entities that all share a common property value, such as all employees with the last name Jones.",
      "pos": [
        59859,
        60005
      ]
    },
    {
      "content": "Related patterns and guidance",
      "pos": [
        60014,
        60043
      ]
    },
    {
      "content": "The following patterns and guidance may also be relevant when implementing this pattern:",
      "pos": [
        60047,
        60135
      ]
    },
    {
      "content": "Compound key pattern",
      "pos": [
        60143,
        60163
      ]
    },
    {
      "content": "Eventually consistent transactions pattern",
      "pos": [
        60195,
        60237
      ]
    },
    {
      "content": "Entity Group Transactions",
      "pos": [
        60291,
        60316
      ]
    },
    {
      "content": "Working with heterogeneous entity types",
      "pos": [
        60353,
        60392
      ]
    },
    {
      "content": "Denormalization pattern",
      "pos": [
        60443,
        60466
      ]
    },
    {
      "content": "Combine related data together in a single entity to enable you to retrieve all the data you need with a single point query.",
      "pos": [
        60470,
        60593
      ]
    },
    {
      "content": "Context and problem",
      "pos": [
        60602,
        60621
      ]
    },
    {
      "content": "In a relational database, you typically normalize data to remove duplication resulting in queries that retrieve data from multiple tables.",
      "pos": [
        60625,
        60763
      ]
    },
    {
      "content": "If you normalize your data in Azure tables, you must make multiple round trips from the client to the server to retrieve your related data.",
      "pos": [
        60764,
        60903
      ]
    },
    {
      "content": "For example, with the table structure shown below you need two round trips to retrieve the details for a department: one to fetch the department entity that includes the manager’s id, and then another request to fetch the manager’s details in an employee entity.",
      "pos": [
        60904,
        61166
      ]
    },
    {
      "content": "Solution",
      "pos": [
        61184,
        61192
      ]
    },
    {
      "content": "Instead of storing the data in two separate entities, denormalize the data and keep a copy of the manager’s details in the department entity.",
      "pos": [
        61196,
        61337
      ]
    },
    {
      "content": "For example:",
      "pos": [
        61338,
        61350
      ]
    },
    {
      "content": "With department entities stored with these properties, you can now retrieve all the details you need about a department using a point query.",
      "pos": [
        61363,
        61503
      ]
    },
    {
      "content": "Issues and considerations",
      "pos": [
        61512,
        61537
      ]
    },
    {
      "content": "Consider the following points when deciding how to implement this pattern:",
      "pos": [
        61541,
        61615
      ]
    },
    {
      "content": "There is some cost overhead associated with storing some data twice.",
      "pos": [
        61623,
        61691
      ]
    },
    {
      "content": "The performance benefit (resulting from fewer requests to the storage service) typically outweighs the marginal increase in storage costs (and this cost is partially offset by a reduction in the number of transactions you require to fetch the details of a department).",
      "pos": [
        61692,
        61960
      ]
    },
    {
      "content": "You must maintain the consistency of the two entities that store information about managers.",
      "pos": [
        61967,
        62059
      ]
    },
    {
      "content": "You can handle the consistency issue by using EGTs to update multiple entities in a single atomic transaction: in this case, the department entity, and the employee entity for the department manager are stored in the same partition.",
      "pos": [
        62060,
        62292
      ]
    },
    {
      "content": "When to use this pattern",
      "pos": [
        62301,
        62325
      ]
    },
    {
      "content": "Use this pattern when you frequently need to look up related information.",
      "pos": [
        62326,
        62399
      ]
    },
    {
      "content": "This pattern reduces the number of queries your client must make to retrieve the data it requires.",
      "pos": [
        62400,
        62498
      ]
    },
    {
      "content": "Related patterns and guidance",
      "pos": [
        62507,
        62536
      ]
    },
    {
      "content": "The following patterns and guidance may also be relevant when implementing this pattern:",
      "pos": [
        62537,
        62625
      ]
    },
    {
      "content": "Compound key pattern",
      "pos": [
        62633,
        62653
      ]
    },
    {
      "content": "Entity Group Transactions",
      "pos": [
        62685,
        62710
      ]
    },
    {
      "content": "Working with heterogeneous entity types",
      "pos": [
        62747,
        62786
      ]
    },
    {
      "content": "Compound key pattern",
      "pos": [
        62835,
        62855
      ]
    },
    {
      "pos": [
        62859,
        62958
      ],
      "content": "Use compound <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> values to enable a client to lookup related data with a single point query."
    },
    {
      "content": "Context and problem",
      "pos": [
        62967,
        62986
      ]
    },
    {
      "content": "In a relational database, it is quite natural to use joins in queries to return related pieces of data to the client in a single query.",
      "pos": [
        62990,
        63125
      ]
    },
    {
      "content": "For example, you might use the employee id to look up a list of related entities that contain performance and review data for that employee.",
      "pos": [
        63126,
        63266
      ]
    },
    {
      "content": "Assume you are storing employee entities in the Table service using the following structure:",
      "pos": [
        63270,
        63362
      ]
    },
    {
      "content": "You also need to store historical data relating to reviews and performance for each year the employee has worked for your organization and you need to be able to access this information by year.",
      "pos": [
        63375,
        63569
      ]
    },
    {
      "content": "One option is to create another table that stores entities with the following structure:",
      "pos": [
        63570,
        63658
      ]
    },
    {
      "content": "Notice that with this approach you may decide to duplicate some information (such as first name and last name) in the new entity to enable you to retrieve your data with a single request.",
      "pos": [
        63671,
        63858
      ]
    },
    {
      "content": "However, you cannot maintain strong consistency because you cannot use an EGT to update the two entities atomically.",
      "pos": [
        63859,
        63975
      ]
    },
    {
      "content": "Solution",
      "pos": [
        63984,
        63992
      ]
    },
    {
      "content": "Store a new entity type in your original table using entities with the following structure:",
      "pos": [
        63993,
        64084
      ]
    },
    {
      "pos": [
        64097,
        64318
      ],
      "content": "Notice how the <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> is now a compound key made up of the employee id and the year of the review data that enables you to retrieve the employee’s performance and review data with a single request for a single entity."
    },
    {
      "content": "The following example outlines how you can retrieve all the review data for a particular employee (such as employee 000123 in the Sales department):",
      "pos": [
        64322,
        64470
      ]
    },
    {
      "content": "$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000123') and (RowKey lt 'empid_000124')&amp;$select=RowKey,Manager Rating,Peer Rating,Comments",
      "pos": [
        64474,
        64620
      ]
    },
    {
      "content": "Issues and considerations",
      "pos": [
        64629,
        64654
      ]
    },
    {
      "content": "Consider the following points when deciding how to implement this pattern:",
      "pos": [
        64655,
        64729
      ]
    },
    {
      "pos": [
        64737,
        64862
      ],
      "content": "You should use a suitable separator character that makes it easy to parse the <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> value: for example, <bpt id=\"p2\">**</bpt>000123_2012<ept id=\"p2\">**</ept>."
    },
    {
      "content": "You are also storing this entity in the same partition as other entities that contain related data for the same employee, which means you can use EGTs to maintain strong consistency.",
      "pos": [
        64869,
        65051
      ]
    },
    {
      "content": "You should consider how frequently you will query the data to determine whether this pattern is appropriate.",
      "pos": [
        65056,
        65164
      ]
    },
    {
      "content": "For example, if you will access the review data infrequently and the main employee data often you should keep them as separate entities.",
      "pos": [
        65166,
        65302
      ]
    },
    {
      "content": "When to use this pattern",
      "pos": [
        65311,
        65335
      ]
    },
    {
      "content": "Use this pattern when you need to store one or more related entities that you query frequently.",
      "pos": [
        65339,
        65434
      ]
    },
    {
      "content": "Related patterns and guidance",
      "pos": [
        65443,
        65472
      ]
    },
    {
      "content": "The following patterns and guidance may also be relevant when implementing this pattern:",
      "pos": [
        65476,
        65564
      ]
    },
    {
      "content": "Entity Group Transactions",
      "pos": [
        65573,
        65598
      ]
    },
    {
      "content": "Working with heterogeneous entity types",
      "pos": [
        65635,
        65674
      ]
    },
    {
      "content": "Eventually consistent transactions pattern",
      "pos": [
        65725,
        65767
      ]
    },
    {
      "content": "Log tail pattern",
      "pos": [
        65821,
        65837
      ]
    },
    {
      "pos": [
        65841,
        65972
      ],
      "content": "Retrieve the <bpt id=\"p1\">*</bpt>n<ept id=\"p1\">*</ept> entities most recently added to a partition by using a <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> value that sorts in reverse date and time order."
    },
    {
      "content": "Context and problem",
      "pos": [
        65981,
        66000
      ]
    },
    {
      "content": "A common requirement is be able to retrieve the most recently created entities, for example the ten most recent expense claims submitted by an employee.",
      "pos": [
        66004,
        66156
      ]
    },
    {
      "content": "Table queries support a <bpt id=\"p1\">**</bpt>$top<ept id=\"p1\">**</ept> query operation to return the first <bpt id=\"p2\">*</bpt>n<ept id=\"p2\">*</ept> entities from a set: there is no equivalent query operation to return the last n entities in a set.",
      "pos": [
        66157,
        66329
      ]
    },
    {
      "content": "Solution",
      "pos": [
        66338,
        66346
      ]
    },
    {
      "pos": [
        66350,
        66507
      ],
      "content": "Store the entities using a <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> that naturally sorts in reverse date/time order by using so the most recent entry is always the first one in the table."
    },
    {
      "content": "For example, to be able to retrieve the ten most recent expense claims submitted by an employee, you can use a reverse tick value derived from the current date/time.",
      "pos": [
        66511,
        66676
      ]
    },
    {
      "content": "The following C# code sample shows one way to create a suitable \"inverted ticks\" value for a <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> that sorts from the most recent to the oldest:",
      "pos": [
        66677,
        66827
      ]
    },
    {
      "content": "You can get back to the date time value using the following code:",
      "pos": [
        66934,
        66999
      ]
    },
    {
      "content": "The table query looks like this:",
      "pos": [
        67090,
        67122
      ]
    },
    {
      "content": "Issues and considerations",
      "pos": [
        67223,
        67248
      ]
    },
    {
      "content": "Consider the following points when deciding how to implement this pattern:",
      "pos": [
        67252,
        67326
      ]
    },
    {
      "content": "You must pad the reverse tick value with leading zeroes to ensure the string value sorts as expected.",
      "pos": [
        67334,
        67435
      ]
    },
    {
      "content": "You must be aware of the scalability targets at the level of a partition.",
      "pos": [
        67442,
        67515
      ]
    },
    {
      "content": "Be careful not create hot spot partitions.",
      "pos": [
        67516,
        67558
      ]
    },
    {
      "content": "When to use this pattern",
      "pos": [
        67567,
        67591
      ]
    },
    {
      "content": "Use this pattern when you need to access entities in reverse date/time order or when you need to access the most recently added entities.",
      "pos": [
        67595,
        67732
      ]
    },
    {
      "content": "Related patterns and guidance",
      "pos": [
        67741,
        67770
      ]
    },
    {
      "content": "The following patterns and guidance may also be relevant when implementing this pattern:",
      "pos": [
        67774,
        67862
      ]
    },
    {
      "content": "Prepend / append anti-pattern",
      "pos": [
        67871,
        67900
      ]
    },
    {
      "content": "Retrieving entities",
      "pos": [
        67939,
        67958
      ]
    },
    {
      "content": "High volume delete pattern",
      "pos": [
        67989,
        68015
      ]
    },
    {
      "content": "Enable the deletion of a high volume of entities by storing all the entities for simultaneous deletion in their own separate table; you delete the entities by deleting the table.",
      "pos": [
        68019,
        68197
      ]
    },
    {
      "content": "Context and problem",
      "pos": [
        68206,
        68225
      ]
    },
    {
      "content": "Many applications delete old data which no longer needs to be available to a client application, or that the application has archived to another storage medium.",
      "pos": [
        68229,
        68389
      ]
    },
    {
      "content": "You typically identify such data by a date: for example, you have a requirement to delete records of all login requests that are more than 60 days old.",
      "pos": [
        68390,
        68541
      ]
    },
    {
      "pos": [
        68545,
        68632
      ],
      "content": "One possible design is to use the date and time of the login request in the <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept>:"
    },
    {
      "content": "This approach avoids partition hotspots because the application can insert and delete login entities for each user in a separate partition.",
      "pos": [
        68645,
        68784
      ]
    },
    {
      "content": "However, this approach may be costly and time consuming if you have a large number of entities because first you need to perform a table scan in order to identify all the entities to delete, and then you must delete each old entity.",
      "pos": [
        68785,
        69017
      ]
    },
    {
      "content": "Note that you can reduce the number of round trips to the server required to delete the old entities by batching multiple delete requests into EGTs.",
      "pos": [
        69018,
        69166
      ]
    },
    {
      "content": "Solution",
      "pos": [
        69175,
        69183
      ]
    },
    {
      "content": "Use a separate table for each day of login attempts.",
      "pos": [
        69187,
        69239
      ]
    },
    {
      "content": "You can use the entity design above to avoid hotspots when you are inserting entities, and deleting old entities is now simply a question of deleting one table every day (a single storage operation) instead of finding and deleting hundreds and thousands of individual login entities every day.",
      "pos": [
        69240,
        69533
      ]
    },
    {
      "content": "Issues and considerations",
      "pos": [
        69542,
        69567
      ]
    },
    {
      "content": "Consider the following points when deciding how to implement this pattern:",
      "pos": [
        69571,
        69645
      ]
    },
    {
      "content": "Does your design support other ways your application will use the data such as looking up specific entities, linking with other data, or generating aggregate information?",
      "pos": [
        69653,
        69823
      ]
    },
    {
      "content": "Does your design avoid hot spots when you are inserting new entities?",
      "pos": [
        69830,
        69899
      ]
    },
    {
      "content": "Expect a delay if you want to reuse the same table name after deleting it.",
      "pos": [
        69906,
        69980
      ]
    },
    {
      "content": "It's better to always use unique table names.",
      "pos": [
        69981,
        70026
      ]
    },
    {
      "content": "Expect some throttling when you first use a new table while the Table service learns the access patterns and distributes the partitions across nodes.",
      "pos": [
        70033,
        70182
      ]
    },
    {
      "content": "You should consider how frequently you need to create new tables.",
      "pos": [
        70183,
        70248
      ]
    },
    {
      "content": "When to use this pattern",
      "pos": [
        70257,
        70281
      ]
    },
    {
      "content": "Use this pattern when you have a high volume of entities that you must delete at the same time.",
      "pos": [
        70285,
        70380
      ]
    },
    {
      "content": "Related patterns and guidance",
      "pos": [
        70389,
        70418
      ]
    },
    {
      "content": "The following patterns and guidance may also be relevant when implementing this pattern:",
      "pos": [
        70422,
        70510
      ]
    },
    {
      "content": "Entity Group Transactions",
      "pos": [
        70519,
        70544
      ]
    },
    {
      "content": "Modifying entities",
      "pos": [
        70579,
        70597
      ]
    },
    {
      "content": "Data series pattern",
      "pos": [
        70648,
        70667
      ]
    },
    {
      "content": "Store complete data series in a single entity to minimize the number of requests you make.",
      "pos": [
        70671,
        70761
      ]
    },
    {
      "content": "Context and problem",
      "pos": [
        70770,
        70789
      ]
    },
    {
      "content": "A common scenario is for an application to store a series of data that it typically needs to retrieve all at once.",
      "pos": [
        70793,
        70907
      ]
    },
    {
      "content": "For example, your application might record how many IM messages each employee sends every hour, and then use this information to plot how many messages each user sent over the preceding 24 hours.",
      "pos": [
        70908,
        71103
      ]
    },
    {
      "content": "One design might be to store 24 entities for each employee:",
      "pos": [
        71104,
        71163
      ]
    },
    {
      "content": "With this design, you can easily locate and update the entity to update for each employee whenever the application needs to update the message count value.",
      "pos": [
        71176,
        71331
      ]
    },
    {
      "content": "However, to retrieve the information to plot a chart of the activity for the preceding 24 hours, you must retrieve 24 entities.",
      "pos": [
        71332,
        71459
      ]
    },
    {
      "content": "Solution",
      "pos": [
        71468,
        71476
      ]
    },
    {
      "content": "Use the following design with a separate property to store the message count for each hour:",
      "pos": [
        71480,
        71571
      ]
    },
    {
      "content": "With this design, you can use a merge operation to update the message count for an employee for a specific hour.",
      "pos": [
        71584,
        71696
      ]
    },
    {
      "content": "Now, you can retrieve all the information you need to plot the chart using a request for a single entity.",
      "pos": [
        71697,
        71802
      ]
    },
    {
      "content": "Issues and considerations",
      "pos": [
        71811,
        71836
      ]
    },
    {
      "content": "Consider the following points when deciding how to implement this pattern:",
      "pos": [
        71840,
        71914
      ]
    },
    {
      "content": "If your complete data series does not fit into a single entity (an entity can have up to 252 properties), use an alternative data store such as a blob.",
      "pos": [
        71921,
        72072
      ]
    },
    {
      "content": "If you have multiple clients updating an entity simultaneously, you will need to use the <bpt id=\"p1\">**</bpt>ETag<ept id=\"p1\">**</ept> to implement optimistic concurrency.",
      "pos": [
        72079,
        72213
      ]
    },
    {
      "content": "If you have many clients, you may experience high contention.",
      "pos": [
        72214,
        72275
      ]
    },
    {
      "content": "When to use this pattern",
      "pos": [
        72284,
        72308
      ]
    },
    {
      "content": "Use this pattern when you need to update and retrieve a data series associated with an individual entity.",
      "pos": [
        72312,
        72417
      ]
    },
    {
      "content": "Related patterns and guidance",
      "pos": [
        72426,
        72455
      ]
    },
    {
      "content": "The following patterns and guidance may also be relevant when implementing this pattern:",
      "pos": [
        72459,
        72547
      ]
    },
    {
      "content": "Large entity pattern",
      "pos": [
        72556,
        72576
      ]
    },
    {
      "content": "Merge or replace",
      "pos": [
        72608,
        72624
      ]
    },
    {
      "pos": [
        72674,
        72810
      ],
      "content": "<bpt id=\"p1\">[</bpt>Eventually consistent transactions pattern<ept id=\"p1\">](#eventually-consistent-transactions-pattern)</ept> (if you are storing the data series in a blob)"
    },
    {
      "content": "Wide entities pattern",
      "pos": [
        72818,
        72839
      ]
    },
    {
      "content": "Use multiple physical entities to store logical entities with more than 252 properties.",
      "pos": [
        72843,
        72930
      ]
    },
    {
      "content": "Context and problem",
      "pos": [
        72939,
        72958
      ]
    },
    {
      "content": "An individual entity can have no more than 252 properties (excluding the mandatory system properties) and cannot store more than 1 MB of data in total.",
      "pos": [
        72962,
        73113
      ]
    },
    {
      "content": "In a relational database, you would typically get round any limits on the size of a row by adding a new table and enforcing a 1-to-1 relationship between them.",
      "pos": [
        73114,
        73273
      ]
    },
    {
      "content": "Solution",
      "pos": [
        73282,
        73290
      ]
    },
    {
      "content": "Using the Table service, you can store multiple entities to represent a single large business object with more than 252 properties.",
      "pos": [
        73294,
        73425
      ]
    },
    {
      "content": "For example, if you want to store a count of the number of IM messages sent by each employee for the last 365 days, you could use the following design that uses two entities with different schemas:",
      "pos": [
        73426,
        73623
      ]
    },
    {
      "content": "If you need to make a change that requires updating both entities to keep them synchronized with each other you can use an EGT.",
      "pos": [
        73636,
        73763
      ]
    },
    {
      "content": "Otherwise, you can use a single merge operation to update the message count for a specific day.",
      "pos": [
        73764,
        73859
      ]
    },
    {
      "content": "To retrieve all the data for an individual employee you must retrieve both entities, which you can do with two efficient requests that use both a <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> and a <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> value.",
      "pos": [
        73860,
        74046
      ]
    },
    {
      "content": "Issues and considerations",
      "pos": [
        74055,
        74080
      ]
    },
    {
      "content": "Consider the following points when deciding how to implement this pattern:",
      "pos": [
        74084,
        74158
      ]
    },
    {
      "content": "Retrieving a complete logical entity involves at least two storage transactions: one to retrieve each physical entity.",
      "pos": [
        74166,
        74284
      ]
    },
    {
      "content": "When to use this pattern",
      "pos": [
        74293,
        74317
      ]
    },
    {
      "content": "Use this pattern when  need to store entities whose size or number of properties exceeds the limits for an individual entity in the Table service.",
      "pos": [
        74321,
        74467
      ]
    },
    {
      "content": "Related patterns and guidance",
      "pos": [
        74476,
        74505
      ]
    },
    {
      "content": "The following patterns and guidance may also be relevant when implementing this pattern:",
      "pos": [
        74509,
        74597
      ]
    },
    {
      "content": "Entity Group Transactions",
      "pos": [
        74606,
        74631
      ]
    },
    {
      "content": "Merge or replace",
      "pos": [
        74666,
        74682
      ]
    },
    {
      "content": "Large entities pattern",
      "pos": [
        74731,
        74753
      ]
    },
    {
      "content": "Use blob storage to store large property values.",
      "pos": [
        74757,
        74805
      ]
    },
    {
      "content": "Context and problem",
      "pos": [
        74814,
        74833
      ]
    },
    {
      "content": "An individual entity cannot store more than 1 MB of data in total.",
      "pos": [
        74837,
        74903
      ]
    },
    {
      "content": "If one or several of your properties store values that cause the total size of your entity to exceed this value, you cannot store the entire entity in the Table service.",
      "pos": [
        74904,
        75073
      ]
    },
    {
      "content": "Solution",
      "pos": [
        75082,
        75090
      ]
    },
    {
      "content": "If your entity exceeds 1 MB in size because one or more properties contain a large amount of data, you can store data in the Blob service and then store the address of the blob in a property in the entity.",
      "pos": [
        75094,
        75299
      ]
    },
    {
      "content": "For example, you can store the photo of an employee in blob storage and store a link to the photo in the <bpt id=\"p1\">**</bpt>Photo<ept id=\"p1\">**</ept> property of your employee entity:",
      "pos": [
        75300,
        75448
      ]
    },
    {
      "content": "Issues and considerations",
      "pos": [
        75466,
        75491
      ]
    },
    {
      "content": "Consider the following points when deciding how to implement this pattern:",
      "pos": [
        75495,
        75569
      ]
    },
    {
      "pos": [
        75577,
        75808
      ],
      "content": "To maintain eventual consistency between the entity in the Table service and the data in the Blob service, use the <bpt id=\"p1\">[</bpt>Eventually consistent transactions pattern<ept id=\"p1\">](#eventually-consistent-transactions-pattern)</ept> to maintain your entities."
    },
    {
      "content": "Retrieving a complete entity involves at least two storage transactions: one to retrieve the entity and one to retrieve the blob data.",
      "pos": [
        75813,
        75947
      ]
    },
    {
      "content": "When to use this pattern",
      "pos": [
        75956,
        75980
      ]
    },
    {
      "content": "Use this pattern when you need to store entities whose size exceeds the limits for an individual entity in the Table service.",
      "pos": [
        75984,
        76109
      ]
    },
    {
      "content": "Related patterns and guidance",
      "pos": [
        76118,
        76147
      ]
    },
    {
      "content": "The following patterns and guidance may also be relevant when implementing this pattern:",
      "pos": [
        76151,
        76239
      ]
    },
    {
      "content": "Eventually consistent transactions pattern",
      "pos": [
        76248,
        76290
      ]
    },
    {
      "content": "Wide entities pattern",
      "pos": [
        76344,
        76365
      ]
    },
    {
      "content": "Prepend/append anti-pattern",
      "pos": [
        76395,
        76422
      ]
    },
    {
      "content": "Increase scalability when you have a high volume of inserts by spreading the inserts across multiple partitions.",
      "pos": [
        76426,
        76538
      ]
    },
    {
      "content": "Context and problem",
      "pos": [
        76547,
        76566
      ]
    },
    {
      "content": "Prepending or appending entities to your stored entities typically results in the application adding new entities to the first or last partition of a sequence of partitions.",
      "pos": [
        76570,
        76743
      ]
    },
    {
      "content": "In this case, all of the inserts at any given time are taking place in the same partition, creating a hotspot that prevents the table service from load balancing inserts across multiple nodes, and possibly causing your application to hit the scalability targets for partition.",
      "pos": [
        76744,
        77020
      ]
    },
    {
      "content": "For example, if you have an application that logs network and resource access by employees, then an entity structure as shown below could result in the current hour’s partition becoming a hotspot if the volume of transactions reaches the scalability target for an individual partition:",
      "pos": [
        77021,
        77306
      ]
    },
    {
      "content": "Solution",
      "pos": [
        77324,
        77332
      ]
    },
    {
      "content": "The following alternative entity structure avoids a hotspot on any particular partition as the application logs events:",
      "pos": [
        77336,
        77455
      ]
    },
    {
      "content": "Notice with this example how both the <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> are compound keys.",
      "pos": [
        77468,
        77556
      ]
    },
    {
      "content": "The <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> uses both the department and employee id to distribute the logging across multiple partitions.",
      "pos": [
        77557,
        77672
      ]
    },
    {
      "content": "Issues and considerations",
      "pos": [
        77681,
        77706
      ]
    },
    {
      "content": "Consider the following points when deciding how to implement this pattern:",
      "pos": [
        77710,
        77784
      ]
    },
    {
      "content": "Does the alternative key structure that avoids creating hot partitions on inserts efficiently support the queries your client application makes?",
      "pos": [
        77792,
        77936
      ]
    },
    {
      "content": "Does your anticipated volume of transactions mean that you are likely to reach the scalability targets for an individual partition and be throttled by the storage service?",
      "pos": [
        77943,
        78114
      ]
    },
    {
      "content": "When to use this pattern",
      "pos": [
        78123,
        78147
      ]
    },
    {
      "content": "Avoid the prepend/append anti-pattern when your volume of transactions is likely to result in throttling by the storage service when you access a hot partition.",
      "pos": [
        78151,
        78311
      ]
    },
    {
      "content": "Related patterns and guidance",
      "pos": [
        78320,
        78349
      ]
    },
    {
      "content": "The following patterns and guidance may also be relevant when implementing this pattern:",
      "pos": [
        78353,
        78441
      ]
    },
    {
      "content": "Compound key pattern",
      "pos": [
        78450,
        78470
      ]
    },
    {
      "content": "Log tail pattern",
      "pos": [
        78502,
        78518
      ]
    },
    {
      "content": "Modifying entities",
      "pos": [
        78546,
        78564
      ]
    },
    {
      "content": "Log data anti-pattern",
      "pos": [
        78615,
        78636
      ]
    },
    {
      "content": "Typically, you should use the Blob service instead of the Table service to store log data.",
      "pos": [
        78640,
        78730
      ]
    },
    {
      "content": "Context and problem",
      "pos": [
        78739,
        78758
      ]
    },
    {
      "content": "A common use case for log data is to retrieve a selection of log entries for a specific date/time range: for example, you want to find all the error and critical messages that your application logged between 15:04 and 15:06 on a specific date.",
      "pos": [
        78762,
        79005
      ]
    },
    {
      "content": "You do not want to use the date and time of the log message to determine the partition you save log entities to: that results in a hot partition because at any given time, all the log entities will share the same <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> value (see the section <bpt id=\"p2\">[</bpt>Prepend/append anti-pattern<ept id=\"p2\">](#prepend-append-anti-pattern)</ept>).",
      "pos": [
        79006,
        79320
      ]
    },
    {
      "content": "For example, the following entity schema for a log message results in a hot partition because the application writes all log messages to the partition for the current date and hour:",
      "pos": [
        79321,
        79502
      ]
    },
    {
      "pos": [
        79515,
        79744
      ],
      "content": "In this example, the <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> includes the date and time of the log message to ensure that log messages are stored sorted in date/time order, and includes a message id in case multiple log messages share the same date and time."
    },
    {
      "content": "Another approach is to use a <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> that ensures that the application writes messages across a range of partitions.",
      "pos": [
        79748,
        79873
      ]
    },
    {
      "content": "For example, if the source of the log message provides a way to distribute messages across many partitions, you could use the following entity schema:",
      "pos": [
        79874,
        80024
      ]
    },
    {
      "content": "However, the problem with this schema is that to retrieve all the log messages for a specific time span you must search every partition in the table.",
      "pos": [
        80037,
        80186
      ]
    },
    {
      "content": "Solution",
      "pos": [
        80193,
        80201
      ]
    },
    {
      "content": "The previous section highlighted the problem of trying to use the Table service to store log entries and suggested two, unsatisfactory, designs.",
      "pos": [
        80205,
        80349
      ]
    },
    {
      "content": "One solution led to a hot partition with the risk of poor performance writing log messages; the other solution resulted in poor query performance because of the requirement to scan every partition in the table to retrieve log messages for a specific time span.",
      "pos": [
        80350,
        80610
      ]
    },
    {
      "content": "Blob storage offers a better solution for this type of scenario and this is how Azure Storage Analytics stores the log data it collects.",
      "pos": [
        80611,
        80747
      ]
    },
    {
      "content": "This section outlines how Storage Analytics stores log data in blob storage as an illustration of this approach to storing data that you typically query by range.",
      "pos": [
        80751,
        80913
      ]
    },
    {
      "content": "Storage Analytics stores log messages in a delimited format in multiple blobs.",
      "pos": [
        80917,
        80995
      ]
    },
    {
      "content": "The delimited format makes it easy for a client application to parse the data in the log message.",
      "pos": [
        80996,
        81093
      ]
    },
    {
      "content": "Storage Analytics uses a naming convention for blobs that enables you to locate the blob (or blobs) that contain the log messages for which you are searching.",
      "pos": [
        81097,
        81255
      ]
    },
    {
      "content": "For example, a blob named \"queue/2014/07/31/1800/000001.log\" contains log messages that relate to the queue service for the hour starting at 18:00 on 31 July 2014.",
      "pos": [
        81256,
        81419
      ]
    },
    {
      "content": "The \"000001\" indicates that this is the first log file for this period.",
      "pos": [
        81420,
        81491
      ]
    },
    {
      "content": "Storage Analytics also records the timestamps of the first and last log messages stored in the file as part of the blob’s metadata.",
      "pos": [
        81492,
        81623
      ]
    },
    {
      "content": "The API for blob storage enables you locate blobs in a container based on a name prefix: to locate all the blobs that contain queue log data for the hour starting at 18:00, you can use the prefix \"queue/2014/07/31/1800.\"",
      "pos": [
        81624,
        81844
      ]
    },
    {
      "content": "Storage Analytics buffers log messages internally and then periodically updates the appropriate blob or creates a new one with the latest batch of log entries.",
      "pos": [
        81848,
        82007
      ]
    },
    {
      "content": "This reduces the number of writes it must perform to the blob service.",
      "pos": [
        82008,
        82078
      ]
    },
    {
      "content": "If you are implementing a similar solution in your own application, you must consider how to manage the trade-off between reliability (writing every log entry to blob storage as it happens) and cost and scalability (buffering updates in your application and writing them to blob storage in batches).",
      "pos": [
        82082,
        82381
      ]
    },
    {
      "content": "Issues and considerations",
      "pos": [
        82390,
        82415
      ]
    },
    {
      "content": "Consider the following points when deciding how to store log data:",
      "pos": [
        82419,
        82485
      ]
    },
    {
      "content": "If you create a table design that avoids potential hot partitions, you may find that you cannot access your log data efficiently.",
      "pos": [
        82493,
        82622
      ]
    },
    {
      "content": "To process log data, a client often needs to load many records.",
      "pos": [
        82629,
        82692
      ]
    },
    {
      "content": "Although log data is often structured, blob storage may be a better solution.",
      "pos": [
        82699,
        82776
      ]
    },
    {
      "content": "Implementation considerations",
      "pos": [
        82784,
        82813
      ]
    },
    {
      "content": "This section discusses some of the considerations to bear in mind when you implement the patterns described in the previous sections.",
      "pos": [
        82817,
        82950
      ]
    },
    {
      "content": "Most of this section uses examples written in C# that use the Storage Client Library (version 4.3.0 at the time of writing).",
      "pos": [
        82951,
        83075
      ]
    },
    {
      "content": "Retrieving entities",
      "pos": [
        83083,
        83102
      ]
    },
    {
      "content": "As discussed in the section <bpt id=\"p1\">[</bpt>Design for querying<ept id=\"p1\">](#design-for-querying)</ept>,\" the most efficient query is a point query.",
      "pos": [
        83106,
        83222
      ]
    },
    {
      "content": "However, in some scenarios you may need to retrieve multiple entities.",
      "pos": [
        83223,
        83293
      ]
    },
    {
      "content": "This section describes some common approaches to retrieving entities using the Storage Client Library.",
      "pos": [
        83294,
        83396
      ]
    },
    {
      "content": "Executing a point query using the Storage Client Library",
      "pos": [
        83405,
        83461
      ]
    },
    {
      "pos": [
        83465,
        83689
      ],
      "content": "The easiest way to execute a point query is to use the <bpt id=\"p1\">**</bpt>Retrieve<ept id=\"p1\">**</ept> table operation as shown in the following C# code snippet that retrieves an entity with a <bpt id=\"p2\">**</bpt>PartitionKey<ept id=\"p2\">**</ept> of value \"Sales\" and a <bpt id=\"p3\">**</bpt>RowKey<ept id=\"p3\">**</ept> of value \"212\":"
    },
    {
      "pos": [
        83995,
        84084
      ],
      "content": "Notice how this example expects the entity it retrieves to be of type <bpt id=\"p1\">**</bpt>EmployeeEntity<ept id=\"p1\">**</ept>."
    },
    {
      "content": "Retrieving multiple entities using LINQ",
      "pos": [
        84093,
        84132
      ]
    },
    {
      "content": "You can retrieve multiple entities by using LINQ with Storage Client Library and specifying a query with a <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clause.",
      "pos": [
        84136,
        84260
      ]
    },
    {
      "content": "To avoid a table scan, you should always include the <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> value in the where clause, and if possible the <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> value to avoid table and partition scans.",
      "pos": [
        84261,
        84430
      ]
    },
    {
      "content": "The table service supports a limited set of comparison operators (greater than, greater than or equal, less than, less than or equal, equal, and not equal) to use in the where clause.",
      "pos": [
        84431,
        84614
      ]
    },
    {
      "content": "The following C# code snippet finds all the employees whose last name starts with \"B\" (assuming that the <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> stores the last name) in the sales department (assuming the <bpt id=\"p2\">**</bpt>PartitionKey<ept id=\"p2\">**</ept> stores the department name):",
      "pos": [
        84615,
        84836
      ]
    },
    {
      "pos": [
        85245,
        85346
      ],
      "content": "Notice how the query specifies both a <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> and a <bpt id=\"p2\">**</bpt>PartitionKey<ept id=\"p2\">**</ept> to ensure better performance."
    },
    {
      "pos": [
        85350,
        85629
      ],
      "content": "The following code sample shows equivalent functionality using the fluent API (for more information about fluent APIs in general, see <bpt id=\"p1\">[</bpt>Best Practices for Designing a Fluent API<ept id=\"p1\">](http://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)</ept>):"
    },
    {
      "pos": [
        86211,
        86316
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> The sample nests multiple <bpt id=\"p1\">**</bpt>CombineFilters<ept id=\"p1\">**</ept> methods to include the three filter conditions."
    },
    {
      "content": "Retrieving large numbers of entities from a query",
      "pos": [
        86325,
        86374
      ]
    },
    {
      "content": "An optimal query returns an individual entity based on a <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> value and a <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept> value.",
      "pos": [
        86378,
        86481
      ]
    },
    {
      "content": "However, in some scenarios you may have a requirement to return many entities from the same partition or even from many partitions.",
      "pos": [
        86482,
        86613
      ]
    },
    {
      "content": "You should always fully test the performance of your application in such scenarios.",
      "pos": [
        86617,
        86700
      ]
    },
    {
      "content": "A query against the table service may return a maximum of 1,000 entities at one time and may execute for a maximum of five seconds.",
      "pos": [
        86704,
        86835
      ]
    },
    {
      "content": "If the result set contains more than 1,000 entities, if the query did not complete within five seconds, or if the query crosses the partition boundary, the Table service returns a continuation token to enable the client application to request the next set of entities.",
      "pos": [
        86836,
        87104
      ]
    },
    {
      "content": "For more information about how continuation tokens work, see <bpt id=\"p1\">[</bpt>Query Timeout and Pagination<ept id=\"p1\">](http://msdn.microsoft.com/library/azure/dd135718.aspx)</ept> on MSDN.",
      "pos": [
        87105,
        87260
      ]
    },
    {
      "content": "If you are using the Storage Client Library, it can automatically handle continuation tokens for you as it returns entities from the Table service.",
      "pos": [
        87264,
        87411
      ]
    },
    {
      "content": "The following C# code sample using the Storage Client Library automatically handles continuation tokens if the table service returns them in a response:",
      "pos": [
        87412,
        87564
      ]
    },
    {
      "content": "The following C# code handles continuation tokens explicitly:",
      "pos": [
        87911,
        87972
      ]
    },
    {
      "content": "By using continuation tokens explicitly, you can control when your application retrieves the next segment of data.",
      "pos": [
        88522,
        88636
      ]
    },
    {
      "content": "For example, if your client application enables users to page through the entities stored in a table, a user may decide not to page through all the entities retrieved by the query so your application would only use a continuation token to retrieve the next segment when the user had finished paging through all the entities in the current segment.",
      "pos": [
        88637,
        88984
      ]
    },
    {
      "content": "This approach has several benefits:",
      "pos": [
        88985,
        89020
      ]
    },
    {
      "content": "It enables you to limit the amount of data to retrieve from the Table service and that you move over the network.",
      "pos": [
        89028,
        89141
      ]
    },
    {
      "content": "It enables you to perform asynchronous IO in .NET.",
      "pos": [
        89148,
        89198
      ]
    },
    {
      "content": "It enables you to serialize the continuation token to persistent storage so you can continue in the event of an application crash.",
      "pos": [
        89205,
        89335
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> A continuation token typically returns a segment containing 1,000 entities, although it may be fewer.",
      "pos": [
        89340,
        89454
      ]
    },
    {
      "content": "This is also the case if you limit the number of entries a query returns by using <bpt id=\"p1\">**</bpt>Take<ept id=\"p1\">**</ept> to return the first n entities that match your lookup criteria: the table service may return a segment containing fewer than n entities along with a continuation token to enable you to retrieve the remaining entities.",
      "pos": [
        89455,
        89763
      ]
    },
    {
      "content": "The following C# code shows how to modify the number of entities returned inside a segment:",
      "pos": [
        89767,
        89858
      ]
    },
    {
      "content": "Server-side projection",
      "pos": [
        89904,
        89926
      ]
    },
    {
      "content": "A single entity can have up to 255 properties and be up to 1 MB in size.",
      "pos": [
        89930,
        90002
      ]
    },
    {
      "content": "When you query the table and retrieve entities, you may not need all the properties and can avoid transferring data unnecessarily (to help reduce latency and cost).",
      "pos": [
        90003,
        90167
      ]
    },
    {
      "content": "You can use server-side projection to transfer just the properties you need.",
      "pos": [
        90168,
        90244
      ]
    },
    {
      "content": "The following example is retrieves just the <bpt id=\"p1\">**</bpt>Email<ept id=\"p1\">**</ept> property (along with <bpt id=\"p2\">**</bpt>PartitionKey<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>RowKey<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>Timestamp<ept id=\"p4\">**</ept>, and <bpt id=\"p5\">**</bpt>ETag<ept id=\"p5\">**</ept>) from the entities selected by the query.",
      "pos": [
        90245,
        90419
      ]
    },
    {
      "pos": [
        90906,
        91021
      ],
      "content": "Notice how the <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> value is available even though it was not included in the list of properties to retrieve."
    },
    {
      "content": "Modifying entities",
      "pos": [
        91029,
        91047
      ]
    },
    {
      "content": "The Storage Client Library enables you to modify your entities stored in the table service by inserting, deleting, and updating entities.",
      "pos": [
        91051,
        91188
      ]
    },
    {
      "content": "You can use EGTs to batch multiple insert, update, and delete operations together to reduce the number of round trips required and improve the performance of your solution.",
      "pos": [
        91189,
        91361
      ]
    },
    {
      "content": "Note that exceptions thrown when the Storage Client Library executes an EGT typically include the index of the entity that caused the batch to fail.",
      "pos": [
        91365,
        91513
      ]
    },
    {
      "content": "This is helpful when you are debugging code that uses EGTs.",
      "pos": [
        91514,
        91573
      ]
    },
    {
      "content": "You should also consider how your design affects how your client application handles concurrency and update operations.",
      "pos": [
        91577,
        91696
      ]
    },
    {
      "content": "Managing concurrency",
      "pos": [
        91705,
        91725
      ]
    },
    {
      "content": "By default, the table service implements optimistic concurrency checks at the level of individual entities for <bpt id=\"p1\">**</bpt>Insert<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>Merge<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>Delete<ept id=\"p3\">**</ept> operations, although it is possible for a client to force the table service to bypass these checks.",
      "pos": [
        91729,
        91977
      ]
    },
    {
      "content": "For more information about how the table service manages concurrency, see  <bpt id=\"p1\">[</bpt>Managing Concurrency in Microsoft Azure Storage<ept id=\"p1\">](storage-concurrency.md)</ept> on the Microsoft Azure web site.",
      "pos": [
        91978,
        92159
      ]
    },
    {
      "content": "Merge or replace",
      "pos": [
        92168,
        92184
      ]
    },
    {
      "content": "The <bpt id=\"p1\">**</bpt>Replace<ept id=\"p1\">**</ept> method of the <bpt id=\"p2\">**</bpt>TableOperation<ept id=\"p2\">**</ept> class always replaces the complete entity in the Table service.",
      "pos": [
        92188,
        92300
      ]
    },
    {
      "content": "If you do not include a property in the request when that property exists in the stored entity, the request removes that property from the stored entity.",
      "pos": [
        92301,
        92454
      ]
    },
    {
      "content": "Unless you want to remove a property explicitly from a stored entity, you must include every property in the request.",
      "pos": [
        92455,
        92572
      ]
    },
    {
      "content": "You can use the <bpt id=\"p1\">**</bpt>Merge<ept id=\"p1\">**</ept> method of the <bpt id=\"p2\">**</bpt>TableOperation<ept id=\"p2\">**</ept> class to reduce the amount of data that you send to the Table service when you want to update an entity.",
      "pos": [
        92576,
        92739
      ]
    },
    {
      "content": "The <bpt id=\"p1\">**</bpt>Merge<ept id=\"p1\">**</ept> method replaces any properties in the stored entity with property values from the entity included in the request, but leaves intact any properties in the stored entity that are not included in the request.",
      "pos": [
        92740,
        92959
      ]
    },
    {
      "content": "This is useful if you have large entities and only need to update a small number of properties in a request.",
      "pos": [
        92960,
        93068
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> The <bpt id=\"p1\">**</bpt>Replace<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>Merge<ept id=\"p2\">**</ept> methods fail if the entity does not exist.",
      "pos": [
        93073,
        93158
      ]
    },
    {
      "content": "As an alternative, you can use the <bpt id=\"p1\">**</bpt>InsertOrReplace<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>InsertOrMerge<ept id=\"p2\">**</ept> methods that create a new entity if it doesn't exist.",
      "pos": [
        93159,
        93289
      ]
    },
    {
      "content": "Working with heterogeneous entity types",
      "pos": [
        93297,
        93336
      ]
    },
    {
      "content": "The Table service is a <bpt id=\"p1\">*</bpt>schema-less<ept id=\"p1\">*</ept> table store that means that a single table can store entities of multiple types providing great flexibility in your design.",
      "pos": [
        93340,
        93500
      ]
    },
    {
      "content": "The following example illustrates a table storing both employee and department entities:",
      "pos": [
        93501,
        93589
      ]
    },
    {
      "content": "PartitionKey",
      "pos": [
        93610,
        93622
      ]
    },
    {
      "content": "RowKey",
      "pos": [
        93632,
        93638
      ]
    },
    {
      "content": "Timestamp",
      "pos": [
        93648,
        93657
      ]
    },
    {
      "content": "FirstName",
      "pos": [
        93736,
        93745
      ]
    },
    {
      "content": "LastName",
      "pos": [
        93755,
        93763
      ]
    },
    {
      "content": "Age",
      "pos": [
        93773,
        93776
      ]
    },
    {
      "content": "Email",
      "pos": [
        93786,
        93791
      ]
    },
    {
      "content": "FirstName",
      "pos": [
        93926,
        93935
      ]
    },
    {
      "content": "LastName",
      "pos": [
        93945,
        93953
      ]
    },
    {
      "content": "Age",
      "pos": [
        93963,
        93966
      ]
    },
    {
      "content": "Email",
      "pos": [
        93976,
        93981
      ]
    },
    {
      "content": "DepartmentName",
      "pos": [
        94116,
        94130
      ]
    },
    {
      "content": "EmployeeCount",
      "pos": [
        94140,
        94153
      ]
    },
    {
      "content": "FirstName",
      "pos": [
        94274,
        94283
      ]
    },
    {
      "content": "LastName",
      "pos": [
        94293,
        94301
      ]
    },
    {
      "content": "Age",
      "pos": [
        94311,
        94314
      ]
    },
    {
      "content": "Email",
      "pos": [
        94324,
        94329
      ]
    },
    {
      "content": "Note that each entity must still have <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>RowKey<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>Timestamp<ept id=\"p3\">**</ept> values, but may have any set of properties.",
      "pos": [
        94423,
        94552
      ]
    },
    {
      "content": "Furthermore, there is nothing to indicate the type of an entity unless you choose to store that information somewhere.",
      "pos": [
        94553,
        94671
      ]
    },
    {
      "content": "There are two options for identifying the entity type:",
      "pos": [
        94672,
        94726
      ]
    },
    {
      "content": "Prepend the entity type to the <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> (or possibly the <bpt id=\"p2\">**</bpt>PartitionKey<ept id=\"p2\">**</ept>).",
      "pos": [
        94734,
        94811
      ]
    },
    {
      "content": "For example, <bpt id=\"p1\">**</bpt>EMPLOYEE_000123<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>DEPARTMENT_SALES<ept id=\"p2\">**</ept> as <bpt id=\"p3\">**</bpt>RowKey<ept id=\"p3\">**</ept> values.",
      "pos": [
        94812,
        94890
      ]
    },
    {
      "content": "Use a separate property to record the entity type as shown in the table below.",
      "pos": [
        94897,
        94975
      ]
    },
    {
      "content": "PartitionKey",
      "pos": [
        94996,
        95008
      ]
    },
    {
      "content": "RowKey",
      "pos": [
        95018,
        95024
      ]
    },
    {
      "content": "Timestamp",
      "pos": [
        95034,
        95043
      ]
    },
    {
      "content": "EntityType",
      "pos": [
        95122,
        95132
      ]
    },
    {
      "content": "FirstName",
      "pos": [
        95142,
        95151
      ]
    },
    {
      "content": "LastName",
      "pos": [
        95161,
        95169
      ]
    },
    {
      "content": "Age",
      "pos": [
        95179,
        95182
      ]
    },
    {
      "content": "Email",
      "pos": [
        95192,
        95197
      ]
    },
    {
      "content": "Employee",
      "pos": [
        95218,
        95226
      ]
    },
    {
      "content": "EntityType",
      "pos": [
        95350,
        95360
      ]
    },
    {
      "content": "FirstName",
      "pos": [
        95370,
        95379
      ]
    },
    {
      "content": "LastName",
      "pos": [
        95389,
        95397
      ]
    },
    {
      "content": "Age",
      "pos": [
        95407,
        95410
      ]
    },
    {
      "content": "Email",
      "pos": [
        95420,
        95425
      ]
    },
    {
      "content": "Employee",
      "pos": [
        95446,
        95454
      ]
    },
    {
      "content": "EntityType",
      "pos": [
        95578,
        95588
      ]
    },
    {
      "content": "DepartmentName",
      "pos": [
        95598,
        95612
      ]
    },
    {
      "content": "EmployeeCount",
      "pos": [
        95622,
        95635
      ]
    },
    {
      "content": "Department",
      "pos": [
        95656,
        95666
      ]
    },
    {
      "content": "EntityType",
      "pos": [
        95776,
        95786
      ]
    },
    {
      "content": "FirstName",
      "pos": [
        95796,
        95805
      ]
    },
    {
      "content": "LastName",
      "pos": [
        95815,
        95823
      ]
    },
    {
      "content": "Age",
      "pos": [
        95833,
        95836
      ]
    },
    {
      "content": "Email",
      "pos": [
        95846,
        95851
      ]
    },
    {
      "content": "Employee",
      "pos": [
        95872,
        95880
      ]
    },
    {
      "content": "The first option, prepending the entity type to the <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept>, is useful if there is a possibility that two entities of different types might have the same key value.",
      "pos": [
        95963,
        96130
      ]
    },
    {
      "content": "It also groups entities of the same type together in the partition.",
      "pos": [
        96131,
        96198
      ]
    },
    {
      "pos": [
        96202,
        96430
      ],
      "content": "The techniques discussed in this section are especially relevant to the discussion <bpt id=\"p1\">[</bpt>Inheritance relationships<ept id=\"p1\">](#inheritance-relationships)</ept> earlier in this guide in the section <bpt id=\"p2\">[</bpt>Modelling relationships<ept id=\"p2\">](#modelling-relationships)</ept>."
    },
    {
      "pos": [
        96435,
        96606
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> You should consider including a version number in the entity type value to enable client applications to evolve POCO objects and work with different versions."
    },
    {
      "content": "The remainder of this section describes some of the features in the Storage Client Library that facilitate working with multiple entity types in the same table.",
      "pos": [
        96610,
        96770
      ]
    },
    {
      "content": "Retrieving heterogeneous entity types",
      "pos": [
        96779,
        96816
      ]
    },
    {
      "content": "If you are using the Storage Client Library, you have three options for working with multiple entity types.",
      "pos": [
        96820,
        96927
      ]
    },
    {
      "pos": [
        96931,
        97396
      ],
      "content": "If you know the type of the entity stored with a specific <bpt id=\"p1\">**</bpt>RowKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>PartitionKey<ept id=\"p2\">**</ept> values, then you can specify the entity type when you retrieve the entity as shown in the previous two examples that retrieve entities of type <bpt id=\"p3\">**</bpt>EmployeeEntity<ept id=\"p3\">**</ept>: <bpt id=\"p4\">[</bpt>Retrieving a single entity using the Storage Client Library<ept id=\"p4\">](#retrieving-a-single-entity-using-the-storage-client-library)</ept> and <bpt id=\"p5\">[</bpt>Retrieving multiple entities using LINQ<ept id=\"p5\">](#retrieving-multiple-entities-using-linq)</ept>."
    },
    {
      "content": "The second option is to use the <bpt id=\"p1\">**</bpt>DynamicTableEntity<ept id=\"p1\">**</ept> type (a property bag) instead of a concrete POCO entity type (this option may also improve performance because there is no need to serialize and deserialize the entity to .NET types).",
      "pos": [
        97400,
        97638
      ]
    },
    {
      "content": "The following C# code potentially retrieves multiple entities of different types from the table, but returns all entities as <bpt id=\"p1\">**</bpt>DynamicTableEntity<ept id=\"p1\">**</ept> instances.",
      "pos": [
        97639,
        97797
      ]
    },
    {
      "content": "It then uses the <bpt id=\"p1\">**</bpt>EntityType<ept id=\"p1\">**</ept> property to determine the type of each entity:",
      "pos": [
        97798,
        97876
      ]
    },
    {
      "pos": [
        98944,
        99090
      ],
      "content": "Note that to retrieve other properties you must use the <bpt id=\"p1\">**</bpt>TryGetValue<ept id=\"p1\">**</ept> method on the <bpt id=\"p2\">**</bpt>Properties<ept id=\"p2\">**</ept> property of the <bpt id=\"p3\">**</bpt>DynamicTableEntity<ept id=\"p3\">**</ept> class."
    },
    {
      "content": "A third option is to combine using the <bpt id=\"p1\">**</bpt>DynamicTableEntity<ept id=\"p1\">**</ept> type and an <bpt id=\"p2\">**</bpt>EntityResolver<ept id=\"p2\">**</ept> instance.",
      "pos": [
        99094,
        99196
      ]
    },
    {
      "content": "This enables you to resolve to multiple POCO types in the same query.",
      "pos": [
        99197,
        99266
      ]
    },
    {
      "content": "In this example, the <bpt id=\"p1\">**</bpt>EntityResolver<ept id=\"p1\">**</ept> delegate is using the <bpt id=\"p2\">**</bpt>EntityType<ept id=\"p2\">**</ept> property to distinguish between the two types of entity that the query returns.",
      "pos": [
        99267,
        99423
      ]
    },
    {
      "content": "The <bpt id=\"p1\">**</bpt>Resolve<ept id=\"p1\">**</ept> method uses the <bpt id=\"p2\">**</bpt>resolver<ept id=\"p2\">**</ept> delegate to resolve <bpt id=\"p3\">**</bpt>DynamicTableEntity<ept id=\"p3\">**</ept> instances to <bpt id=\"p4\">**</bpt>TableEntity<ept id=\"p4\">**</ept> instances.",
      "pos": [
        99424,
        99551
      ]
    },
    {
      "content": "Modifying heterogeneous entity types",
      "pos": [
        100739,
        100775
      ]
    },
    {
      "content": "You do not need to know the type of an entity to delete it, and you always know the type of an entity when you insert it.",
      "pos": [
        100779,
        100900
      ]
    },
    {
      "content": "However, you can use <bpt id=\"p1\">**</bpt>DynamicTableEntity<ept id=\"p1\">**</ept> type to update an entity without knowing its type and without using a POCO entity class.",
      "pos": [
        100901,
        101033
      ]
    },
    {
      "content": "The following code sample retrieves a single entity, and checks the <bpt id=\"p1\">**</bpt>EmployeeCount<ept id=\"p1\">**</ept> property exists before updating it.",
      "pos": [
        101034,
        101155
      ]
    },
    {
      "content": "Controlling access with Shared Access Signatures",
      "pos": [
        101674,
        101722
      ]
    },
    {
      "content": "You can use Shared Access Signature (SAS) tokens to enable client applications to modify (and query) table entities directly without the need to authenticate directly with the table service.",
      "pos": [
        101726,
        101916
      ]
    },
    {
      "content": "Typically, there are three main benefits to using SAS in your application:",
      "pos": [
        101917,
        101991
      ]
    },
    {
      "content": "You do not need to distribute your storage account key to an insecure platform (such as a mobile device) in order to allow that device to access and modify entities in the Table service.",
      "pos": [
        101999,
        102185
      ]
    },
    {
      "content": "You can offload some of the work that web and worker roles perform in managing your entities to client devices such as end-user computers and mobile devices.",
      "pos": [
        102192,
        102349
      ]
    },
    {
      "content": "You can assign a constrained and time limited set of permissions to a client (such as allowing read-only access to specific resources).",
      "pos": [
        102356,
        102491
      ]
    },
    {
      "pos": [
        102495,
        102682
      ],
      "content": "For more information about using SAS tokens with the Table service, see <bpt id=\"p1\">[</bpt>Shared Access Signatures, Part 1: Understanding the SAS Model<ept id=\"p1\">](../storage-dotnet-shared-access-signature-part-1/)</ept>."
    },
    {
      "content": "However, you must still generate the SAS tokens that grant a client application to the entities in the table service: you should do this in an environment that has secure access to your storage account keys.",
      "pos": [
        102686,
        102893
      ]
    },
    {
      "content": "Typically, you use a web or worker role to generate the SAS tokens and deliver them to the client applications that need access to your entities.",
      "pos": [
        102894,
        103039
      ]
    },
    {
      "content": "Because there is still an overhead involved in generating and delivering SAS tokens to clients, you should consider how best to reduce this overhead, especially in high-volume scenarios.",
      "pos": [
        103040,
        103226
      ]
    },
    {
      "content": "It is possible to generate a SAS token that grants access to a subset of the entities in a table.",
      "pos": [
        103230,
        103327
      ]
    },
    {
      "content": "By default, you create a SAS token for an entire table, but it is also possible to specify that the SAS token grant access to either a range of <bpt id=\"p1\">**</bpt>PartitionKey<ept id=\"p1\">**</ept> values, or a range of <bpt id=\"p2\">**</bpt>PartitionKey<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>RowKey<ept id=\"p3\">**</ept> values.",
      "pos": [
        103328,
        103550
      ]
    },
    {
      "content": "You might choose to generate SAS tokens for individual users of your system such that each user’s SAS token only allows them access to their own entities in the table service.",
      "pos": [
        103551,
        103726
      ]
    },
    {
      "content": "Asynchronous and parallel operations",
      "pos": [
        103734,
        103770
      ]
    },
    {
      "content": "Provided you are spreading your requests across multiple partitions, you can improve throughput and client responsiveness by using asynchronous or parallel queries.",
      "pos": [
        103774,
        103938
      ]
    },
    {
      "content": "For example, you might have two or more worker role instances accessing your tables in parallel.",
      "pos": [
        103939,
        104035
      ]
    },
    {
      "content": "You could have individual worker roles responsible for particular sets of partitions, or simply have multiple worker role instances, each able to access all the partitions in a table.",
      "pos": [
        104036,
        104219
      ]
    },
    {
      "content": "Within a client instance, you can improve throughput by executing storage operations asynchronously.",
      "pos": [
        104223,
        104323
      ]
    },
    {
      "content": "The Storage Client Library makes it easy to write asynchronous queries and modifications.",
      "pos": [
        104324,
        104413
      ]
    },
    {
      "content": "For example, you might start with the synchronous method that retrieves all the entities in a partition as shown in the following C# code:",
      "pos": [
        104414,
        104552
      ]
    },
    {
      "content": "You can easily modify this code so that the query runs asynchronously as follows:",
      "pos": [
        105271,
        105352
      ]
    },
    {
      "content": "In this asynchronous example, you can see the following changes from the synchronous version:",
      "pos": [
        106109,
        106202
      ]
    },
    {
      "pos": [
        106210,
        106299
      ],
      "content": "The method signature now includes the <bpt id=\"p1\">**</bpt>async<ept id=\"p1\">**</ept> modifier and returns a <bpt id=\"p2\">**</bpt>Task<ept id=\"p2\">**</ept> instance."
    },
    {
      "pos": [
        106306,
        106503
      ],
      "content": "Instead of calling the <bpt id=\"p1\">**</bpt>ExecuteSegmented<ept id=\"p1\">**</ept> method to retrieve results, the method now calls the <bpt id=\"p2\">**</bpt>ExecuteSegmentedAsync<ept id=\"p2\">**</ept> method and uses the <bpt id=\"p3\">**</bpt>await<ept id=\"p3\">**</ept> modifier to retrieve results asynchronously."
    },
    {
      "pos": [
        106507,
        106669
      ],
      "content": "The client application can call this method multiple times (with different values for the <bpt id=\"p1\">**</bpt>department<ept id=\"p1\">**</ept> parameter), and each query will run on a separate thread."
    },
    {
      "pos": [
        106673,
        106850
      ],
      "content": "Note that there is no asynchronous version of the <bpt id=\"p1\">**</bpt>Execute<ept id=\"p1\">**</ept> method in the <bpt id=\"p2\">**</bpt>TableQuery<ept id=\"p2\">**</ept> class because the <bpt id=\"p3\">**</bpt>IEnumerable<ept id=\"p3\">**</ept> interface does not support asynchronous enumeration."
    },
    {
      "content": "You can also insert, update, and delete entities asynchronously.",
      "pos": [
        106854,
        106918
      ]
    },
    {
      "content": "The following C# example shows a simple, synchronous method to insert or replace an employee entity:",
      "pos": [
        106919,
        107019
      ]
    },
    {
      "content": "You can easily modify this code so that the update runs asynchronously as follows:",
      "pos": [
        107319,
        107401
      ]
    },
    {
      "content": "In this asynchronous example, you can see the following changes from the synchronous version:",
      "pos": [
        107723,
        107816
      ]
    },
    {
      "pos": [
        107824,
        107913
      ],
      "content": "The method signature now includes the <bpt id=\"p1\">**</bpt>async<ept id=\"p1\">**</ept> modifier and returns a <bpt id=\"p2\">**</bpt>Task<ept id=\"p2\">**</ept> instance."
    },
    {
      "pos": [
        107920,
        108100
      ],
      "content": "Instead of calling the <bpt id=\"p1\">**</bpt>Execute<ept id=\"p1\">**</ept> method to update the entity, the method now calls the <bpt id=\"p2\">**</bpt>ExecuteAsync<ept id=\"p2\">**</ept> method and uses the <bpt id=\"p3\">**</bpt>await<ept id=\"p3\">**</ept> modifier to retrieve results asynchronously."
    },
    {
      "content": "The client application can call multiple asynchronous methods like this one, and each method invocation will run on a separate thread.",
      "pos": [
        108104,
        108238
      ]
    },
    {
      "content": "Credits",
      "pos": [
        108247,
        108254
      ]
    },
    {
      "content": "We would like to thank the following members of the Azure team for their contributions: Dominic Betts, Jason Hogg, Jean Ghanem, Jai Haridas, Jeff Irwin, Vamshidhar Kommineni, Vinay Shah and Serdar Ozler as well as  Tom Hollander from Microsoft DX.",
      "pos": [
        108255,
        108502
      ]
    },
    {
      "content": "We would also like to thank the following Microsoft MVP’s for their valuable feedback during review cycles: Igor Papirov and Edward Bakker.",
      "pos": [
        108505,
        108644
      ]
    }
  ],
  "content": "<properties\n   pageTitle=\"Azure Storage Table Design Guide | Microsoft Azure\"\n   description=\"Design Scalable and Performant Tables in Azure Table Storage\"\n   services=\"storage\"\n   documentationCenter=\"na\"\n   authors=\"tamram\" \n   manager=\"carolz\"\n   editor=\"\"/>\n\n<tags\n   ms.service=\"storage\"\n   ms.devlang=\"na\"\n   ms.topic=\"article\"\n   ms.tgt_pltfrm=\"na\"\n   ms.workload=\"storage\"\n   ms.date=\"08/03/2015\"\n   ms.author=\"tamram\"/>\n\n# Azure Storage Table Design Guide: Designing Scalable and Performant Tables\n\n## Overview\n\nTo design scalable and performant tables you must consider a number of factors such as performance, scalability, and cost. If you have previously designed schemas for relational databases, these considerations will be familiar to you, but while there are some similarities between the Azure Table service storage model and relational models, there are also many important differences. These differences typically lead to very different designs that may look counter-intuitive or wrong to someone familiar with relational databases, but which do make good sense if you are designing for a NoSQL key/value store such as the Azure Table service. Many of your design differences will reflect the fact that the Table service is designed to support cloud-scale applications that can contain billions of entities (rows in relational database terminology) of data or for datasets that must support very high transaction volumes: therefore, you need to think differently about how you store your data and understand how the Table service works. A well designed NoSQL data store can enable your solution to scale much further (and at a lower cost) than a solution that uses a relational database. This guide helps you with these topics.  \n\n## About the Azure Table service\n\nThis section highlights some of the key features of the Table service that are especially relevant to designing for performance and scalability. If you are new to Azure Storage and the Table service, first read [Introduction to Microsoft Azure Storage](storage-introduction.md) and [How to use Table Storage from .NET](storage-dotnet-how-to-use-tables.md) before reading the remainder of this article. Although the focus of this guide is on the Table service, it will include some discussion of the Azure Queue and Blob services, and how you might use them along with the Table service in a solution.  \n\nWhat is the Table service? As you might expect from the name, the Table service uses a tabular format to store data. In the standard terminology, each row of the table represents an entity, and the columns store the various properties of that entity. Every entity has a pair of keys to uniquely identify it, and a timestamp column that the Table service uses to track when the entity was last updated (this happens automatically and you cannot manually overwrite the timestamp with an arbitrary value). The Table service uses this last-modified timestamp (LMT) to manage optimistic concurrency.  \n\n>[AZURE.NOTE] The Table service REST API operations also return an **ETag** value that it derives from the last-modified timestamp (LMT). In this document we will use the terms ETag and LMT interchangeably because they refer to the same underlying data.  \n\nThe following example shows a simple table design to store employee and department entities. Many of the examples shown later in this guide are based on this simple design.  \n\n<table>\n<tr>\n<th>PartitionKey</th>\n<th>RowKey</th>\n<th>Timestamp</th>\n<th></th>\n</tr>\n<tr>\n<td>Marketing</td>\n<td>00001</td>\n<td>2014-08-22T00:50:32Z</td>\n<td>\n<table>\n<tr>\n<th>FirstName</th>\n<th>LastName</th>\n<th>Age</th>\n<th>Email</th>\n</tr>\n<tr>\n<td>Don</td>\n<td>Hall</td>\n<td>34</td>\n<td>donh@contoso.com</td>\n</tr>\n</table>\n</tr>\n<tr>\n<td>Marketing</td>\n<td>00002</td>\n<td>2014-08-22T00:50:34Z</td>\n<td>\n<table>\n<tr>\n<th>FirstName</th>\n<th>LastName</th>\n<th>Age</th>\n<th>Email</th>\n</tr>\n<tr>\n<td>Jun</td>\n<td>Cao</td>\n<td>47</td>\n<td>junc@contoso.com</td>\n</tr>\n</table>\n</tr>\n<tr>\n<td>Marketing</td>\n<td>Department</td>\n<td>2014-08-22T00:50:30Z</td>\n<td>\n<table>\n<tr>\n<th>DepartmentName</th>\n<th>EmployeeCount</th>\n</tr>\n<tr>\n<td>Marketing</td>\n<td>153</td>\n</tr>\n</table>\n</td>\n</tr>\n<tr>\n<td>Sales</td>\n<td>00010</td>\n<td>2014-08-22T00:50:44Z</td>\n<td>\n<table>\n<tr>\n<th>FirstName</th>\n<th>LastName</th>\n<th>Age</th>\n<th>Email</th>\n</tr>\n<tr>\n<td>Ken</td>\n<td>Kwok</td>\n<td>23</td>\n<td>kenk@contoso.com</td>\n</tr>\n</table>\n</td>\n</tr>\n</table>\n\n\nSo far, this looks very similar to a table in a relational database with the key differences being the mandatory columns, and the ability to store multiple entity types in the same table. In addition, each of the user-defined properties such as **FirstName** or **Age** has a data type, such as integer or string, just like a column in a relational database. Although unlike in a relational database, the schema-less nature of the Table service means that a property need not have the same data type on each entity. To store complex data types in a single property, you must use a serialized format such as JSON or XML. For more information about the table service such as supported data types, supported date ranges, naming rules, and size constraints, see [Understanding the Table Service Data Model](http://msdn.microsoft.com/library/azure/dd179338.aspx) on MSDN.\n\nAs you will see, your choice of **PartitionKey** and **RowKey** is fundamental to good table design. Every entity stored in a table must have a unique combination of **PartitionKey** and **RowKey**. As with keys in a relational database table, the **PartitionKey** and **RowKey** values are indexed to create a clustered index that enables fast look-ups; however, the Table service does not create any secondary indexes so these are the only two indexed properties (some of the patterns described later show how you can work around this apparent limitation).  \n\nA table is made up of one or more partitions, and as you will see, many of the design decisions you make will be around choosing a suitable **PartitionKey** and **RowKey** to optimize your solution. A solution could consist of just a single table that contains all your entities organized into partitions, but typically a solution will have multiple tables. Tables help you to logically organize your entities, help you manage access to the data using access control lists, and you can drop an entire table using a single storage operation.  \n\n### Table partitions  \nThe account name, table name and **PartitionKey** together identify the partition within the storage service where the table service stores the entity. As well as being part of the addressing scheme for entities, partitions define a scope for transactions (see [Entity Group Transactions](#entity-group-transactions) below), and form the basis of how the table service scales. For more information on partitions see [Azure Storage Scalability and Performance Targets](http://msdn.microsoft.com/library/azure/dn249410.aspx).  \n\nIn the Table service, an individual node services one or more complete partitions and the service scales by dynamically load-balancing partitions across nodes. If a node is under load, the table service can *split* the range of partitions serviced by that node onto different nodes; when traffic subsides, the service can *merge* the partition ranges from quiet nodes back onto a single node.  \n\nFor more information about the internal details of the Table service, and in particular how the service manages partitions, see the paper [Microsoft Azure Storage: A Highly Available\nCloud Storage Service with Strong Consistency](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx).  \n\n### Entity Group Transactions\nIn the Table service, Entity Group Transactions (EGTs) are the only built-in mechanism for performing atomic updates across multiple entities. EGTs are also referred to as *batch transactions* in some documentation. EGTs can only operate on entities stored in the same partition (share the same partition key in a given table), so anytime you need atomic transactional behavior across multiple entities you need to ensure that those entities are in the same partition. This is often a reason for keeping multiple entity types in the same table (and partition) and not using multiple tables for different entity types. A single EGT can operate on at most 100 entities.  If you submit multiple concurrent EGTs for processing it is important to ensure  those EGTs do not operate on entities that are common across EGTs as otherwise processing can be delayed.\n\nEGTs also introduce a potential trade-off for you to evaluate in your design: using more partitions will increase the scalability of your application because Azure has more opportunities for load balancing requests across nodes, but this might limit the ability of your application to perform atomic transactions and maintain strong consistency for your data. Furthermore, there are specific scalability targets at the level of a partition that might limit the throughput of transactions you can expect for a single node: for more information about the scalability targets for Azure storage accounts and the table service, see [Azure Storage Scalability and Performance Targets](http://msdn.microsoft.com/library/azure/dd179338.aspx) on MSDN. Later sections of this guide discuss various design strategies that help you manage trade-offs such as this one, and discuss how best to choose your partition key based on the specific requirements of your client application.  \n\n### Capacity considerations\nThe following table includes some of the key values to be aware of when you are designing a Table service solution:  \n\n|Total capacity of an Azure storage account|500 TB|\n|------------------------------------------|------|\n|Number of tables in an Azure storage account | Limited only by the capacity of the storage account |\n|Number of partitions in a table | Limited only by the capacity of the storage account |\n|Number of entities in a partition | Limited only by the capacity of the storage account|\n|Size of an individual entity | Up to 1 MB with a maximum of 255 properties (including the **PartitionKey**, **RowKey**, and **Timestamp**) |\n|Size of the **PartitionKey** | A string up to 1 KB in size |\n| Size of the **RowKey** | A string up to 1 KB in size |\n|Size of an Entity Group Transaction | A transaction can include at most 100 entities and the payload must be less than 4 MB in size. An EGT can only update an entity once. |\n\nFor more information, see [Understanding the Table Service Data Model](http://msdn.microsoft.com/library/azure/dd179338.aspx) on MSDN.  \n\n### Cost considerations  \nTable storage is relatively inexpensive, but you should include cost estimates for both capacity usage and the quantity of transactions as part of your evaluation of any solution that uses the Table service. However, in many scenarios storing denormalized or duplicate data in order to improve the performance or scalability of your solution is a valid approach to take. For more information about pricing, see [Storage Pricing Details](http://azure.microsoft.com/pricing/details/storage/).  \n\n### Comparing Azure Tables and SQL Azure  \nFor a comparison between Azure SQL Database (a relational database service) and the Table service, see [Microsoft Azure Table Storage and Microsoft Azure SQL Database - Compared and Contrasted](http://msdn.microsoft.com/library/azure/jj553018.aspx) on MSDN.  \n\n## Guidelines for table design  \nThese lists summarize some of the key guidelines you should keep in mind when you are designing your tables, and this guide will address them all in more detail later in. These guidelines are very different from the guidelines you would typically follow for relational database design.  \n\nDesigning your Table service solution to be *read* efficient:\n\n-   ***Design for querying in read-heavy applications.*** When you are designing your tables, think about the queries (especially the latency sensitive ones) that you will execute before you think about how you will update your entities. This typically results in an efficient and performant solution.  \n-   ***Specify both PartitionKey and RowKey in your queries.*** *Point queries* such as these are the most efficient table service queries.  \n-   ***Consider storing duplicate copies of entities.*** Table storage is cheap so consider storing the same entity multiple times (with different keys) to enable more efficient queries.  \n-   ***Consider denormalizing your data.*** Table storage is cheap so consider denormalizing your data. For example, store summary entities so that queries for aggregate data only need to access a single entity.  \n-   ***Use compound key values.*** The only keys you have are **PartitionKey** and **RowKey**. For example, use compound key values to enable alternate keyed access paths to entities.  \n-   ***Use query projection.*** You can reduce the amount of data that you transfer over the network by using queries that select just the fields you need.  \n\nDesigning your Table service solution to be *write* efficient:  \n\n-   ***Do not create hot partitions.*** Choose keys that enable you to spread your requests across multiple partitions at any point of time.  \n-   ***Avoid spikes in traffic.*** Smooth the traffic over a reasonable period of time and avoid spikes in traffic.\n-   ***Don’t necessarily create a separate table for each type of entity.*** When you require atomic transactions across entity types, you can store these multiple entity types in the same partition in the same table.\n-   ***Consider the maximum throughput you must achieve.*** You must be aware of the scalability targets for the Table service and ensure that your design will not cause you to exceed them.  \n\nAs you read this guide, you will see examples that put all of these principles into practice.  \n\n## Design for querying  \nTable service solutions may be read intensive, write intensive, or a mix of the two. This section focuses on the things to bear in mind when you are designing your Table service to support read operations efficiently. Typically, a design that supports read operations efficiently is also efficient for write operations. However, there are additional considerations to bear in mind when designing to support write operations, which the next section, [Design for data modification](#design-for-data-modification), discusses.\n\nA good starting point for designing your Table service solution to enable you to read data efficiently is to ask \"What queries will my application need to execute to retrieve the data it needs from the Table service?\"  \n\n>[AZURE.NOTE] With the Table service, it’s important to get the design correct up front because it’s difficult and expensive to change it later. For example, in a relational database it’s often possible to address performance issues simply by adding indexes to an existing database: this is not an option with the Table service.  \n\nThis section focuses on the key issues you must address when you design your tables for querying. The topics covered in this section include:\n\n- [How your choice of PartitionKey and RowKey impacts query performance](#how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance)\n- [Choosing an appropriate PartitionKey](#choosing-an-appropriate-partitionkey)\n- [Optimizing queries with a key value store for the Table service](#optimizing-queries-with-a-key-value-store-for-the-table-service)\n- [Sorting data in a key value store in the Table service](#sorting-data-in-a-key-value-store-in-the-table-service)\n\n### How your choice of PartitionKey and RowKey impacts query performance  \n\nThe following examples assume the table service is storing employee entities with the following structure (most of the examples omit the **Timestamp** property for clarity):  \n\n|*Column name* |*Data type*|\n|--------------|-----------|\n|**PartitionKey** (Department Name)|String|\n|**RowKey** (Employee Id)|String|\n|**FirstName**|String|\n|**LastName**|String|\n|**Age**|Integer|\n|**EmailAddress**|String|\n\nThe earlier section [Azure Table service overview](#azure-table-service-overview) describes some of the key features of the Azure Table service that have a direct influence on designing for query. These result in the following general guidelines for designing Table service queries. Note that the filter syntax used in the examples below is from the Table service REST API, for more information see [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx) on MSDN.  \n\n-   A ***Point Query*** is the most efficient lookup to use and is recommended to be used for high-volume lookups or lookups requiring lowest latency. Such a query can use the indexes to locate an individual entity very efficiently by specifying both the **PartitionKey** and **RowKey** values. For example:\n$filter=(PartitionKey eq 'Sales') and (RowKey eq '2')  \n-   Second best is a ***Range Query*** that uses the **PartitionKey** and filters on a range of **RowKey** values to return more than one entity. The **PartitionKey** value identifies a specific partition, and the **RowKey** values identify a subset of the entities in that partition. For example:\n$filter=PartitionKey eq 'Sales' and RowKey ge 'S' and RowKey lt 'T'  \n-   Third best is a ***Partition Scan*** that uses the **PartitionKey** and filters on another non-key property and that may return more than one entity. The **PartitionKey** value identifies a specific partition, and the property values select for a subset of the entities in that partition. For example:\n$filter=PartitionKey eq 'Sales' and LastName eq 'Smith'  \n-   A ***Table Scan*** does not include the **PartitionKey** and is very inefficient because it searches all of the partitions that make up your table in turn for any matching entities. It will perform a table scan regardless of whether or not your filter uses the **RowKey**. For example:\n$filter=LastName eq 'Jones'  \n-   Queries that return multiple entities return them sorted in **PartitionKey** and **RowKey** order. To avoid resorting the entities in the client chose a **RowKey** that defines the most common sort order.  \n\nNote that using an \"**or**\" to specify a filter based on **RowKey** values results in a partition scan and is not treated as a range query. Therefore, you should avoid queries that use filters such as:\n$filter=PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322')  \n\nFor examples of client-side code that use the Storage Client Library to execute efficient queries, see:  \n\n-   [Retrieving a single entity using the Storage Client Library](#retrieving-a-single-entity-using-the-storage-client-library)\n-   [Retrieving multiple entities using LINQ](#retrieving-multiple-entities-using-linq)\n-   [Server-side projection](#server-side-projection)  \n\nFor examples of client-side code that can handle multiple entity types stored in the same table, see:  \n\n-   [Working with heterogeneous entity types](#working-with-heterogeneous-entity-types)  \n\n### Choosing an appropriate PartitionKey  \n\nYour choice of **PartitionKey** should balance the need to enables the use of EGTs (to ensure consistency) against the requirement to distribute your entities across multiple partitions (to ensure a scalable solution).  \n\nAt one extreme, you could store all your entities in a single partition, but this may limit the scalability of your solution and would prevent the table service from being able to load-balance requests. At the other extreme, you could store one entity per partition, which would be highly scalable and which enables the table service to load-balance requests, but which would prevent you from using entity group transactions.  \n\nAn ideal **PartitionKey** is one that enables you to use efficient queries and that has sufficient partitions to ensure your solution is scalable. Typically, you will find that your entities will have a suitable property that distributes your entities across sufficient partitions.\n\n>[AZURE.NOTE] For example, in a system that stores information about users or employees, UserID may be a good PartitionKey. You may have several entities that use a given UserID as the partition key. Each entity that stores data about a user is grouped into a single partition, and so these entities are accessible via entity group transactions, while still being highly scalable.\n\nThere are additional considerations in your choice of **PartitionKey** that relate to how you will insert, update, and delete entities: see the section [Design for data modification](#design-for-data-modification) below.  \n\n### Optimizing queries for the Table service  \n\nThe Table service automatically indexes your entities using the **PartitionKey** and **RowKey** values in a single clustered index, hence the reason that point queries are the most efficient to use. However, there are no indexes other than that on the clustered index on the **PartitionKey** and **RowKey**.\n\nMany designs must meet requirements to enable lookup of entities based on multiple criteria. For example, locating employee entities based on email, employee id, or last name. The following patterns in the section [Table Design Patterns](#table-design-patterns) address these types of requirement and describe ways of working around the fact that the Table service does not provide secondary indexes:  \n\n-   [Intra-partition secondary index pattern](#intra-partition-secondary-index-pattern) - Store multiple copies of each entity using different **RowKey** values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.  \n-   [Inter-partition secondary index pattern](#inter-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.  \n-   [Index Entities Pattern](#index-entities-pattern) - Maintain index entities to enable efficient searches that return lists of entities.  \n\n### Sorting data in in the Table service  \n\nThe Table service returns entities sorted in ascending order based on **PartitionKey** and then by **RowKey**. These keys are string values and to ensure that numeric values sort correctly, you should convert them to a fixed length and pad them with zeroes. For example, if the employee id value you use as the **RowKey** is an integer value, you should convert employee id **123** to **00000123**.  \n\nMany applications have requirements to use data sorted in different orders: for example, sorting employees by name, or by joining date. The following patterns in the section [Table Design Patterns](#table-design-patterns) address how to alternate sort orders for your entities:  \n\n-   [Intra-partition secondary index pattern](#intra-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different RowKey values.  \n-   [Inter-partition secondary index pattern](#inter-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values in separate partitions in separate tables to enable fast and efficient lookups and alternate sort orders by using different RowKey values.\n-   [Log tail pattern](#log-tail-pattern) - Retrieve the *n* entities most recently added to a partition by using a **RowKey** value that sorts in reverse date and time order.  \n\n## Design for data modification\nThis section focuses on the design considerations for optimizing inserts, updates, and deletes. In some cases, you will need to evaluate the trade-off between designs that optimize for querying against designs that optimize for data modification just as you do in designs for relational databases (although the techniques for managing the design trade-offs are different in a relational database). The section [Table Design Patterns](#table-design-patterns) describes some detailed design patterns for the Table service and highlights some these trade-offs. In practice, you will find that many designs optimized for querying entities also work well for modifying entities.  \n\n### Optimizing the performance of insert, update, and delete operations  \n\nTo update or delete an entity, you must be able to identify it by using the **PartitionKey** and **RowKey** values. In this respect, your choice of **PartitionKey** and **RowKey** for modifying entities should follow similar criteria to your choice to support point queries because you want to identify entities as efficiently as possible. You do not want to use an inefficient partition or table scan to locate an entity in order to discover the **PartitionKey** and **RowKey** values you need to update or delete it.  \n\nThe following patterns in the section [Table Design Patterns](#table-design-patterns) address optimizing the performance or your insert, update, and delete operations:  \n\n-   [High volume delete pattern](#high-volume-delete-pattern) - Enable the deletion of a high volume of entities by storing all the entities for simultaneous deletion in their own separate table; you delete the entities by deleting the table.  \n-   [Data series pattern](#data-series-pattern) - Store complete data series in a single entity to minimize the number of requests you make.  \n-   [Wide entities pattern](#wide-entities-pattern) - Use multiple physical entities to store logical entities with more than 252 properties.  \n-   [Large entities pattern](#large-entities-pattern) - Use blob storage to store large property values.  \n\n### Ensuring consistency in your stored entities  \n\nThe other key factor that influences your choice of keys for optimizing data modifications is how to ensure consistency by using atomic transactions. You can only use an EGT to operate on entities stored in the same partition.  \n\nThe following patterns in the section [Table Design Patterns](#table-design-patterns) address managing consistency:  \n\n-   [Intra-partition secondary index pattern](#intra-partition-secondary-index-pattern) - Store multiple copies of each entity using different **RowKey** values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.  \n-   [Inter-partition secondary index pattern](#inter-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.  \n-   [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) - Enable eventually consistent behavior across partition boundaries or storage system boundaries by using Azure queues.\n-   [Index Entities Pattern](#index-entities-pattern) - Maintain index entities to enable efficient searches that return lists of entities.  \n-   [Denormalization pattern](#denormalization-pattern) - Combine related data together in a single entity to enable you to retrieve all the data you need with a single point query.  \n-   [Data series pattern](#data-series-pattern) - Store complete data series in a single entity to minimize the number of requests you make.  \n\nFor information about entity group transactions, see the section [Entity Group Transactions](#entity-group-transactions).  \n\n### Ensuring your design for efficient modifications facilitates efficient queries  \n\nIn many cases, a design for efficient querying results in efficient modifications, but you should always evaluate whether this is the case for your specific scenario. Some of the patterns in the section [Table Design Patterns](#table-design-patterns) explicitly evaluate trade-offs between querying and modifying entities, and you should always take into account the number of each type of operation.  \n\nThe following patterns in the section [Table Design Patterns](#table-design-patterns) address trade-offs between designing for efficient queries and designing for efficient data modification:  \n\n-   [Compound key pattern](#compound-key-pattern) - Use compound **RowKey** values to enable a client to lookup related data with a single point query.  \n-   [Log tail pattern](#log-tail-pattern) - Retrieve the *n* entities most recently added to a partition by using a **RowKey** value that sorts in reverse date and time order.  \n\n## Modelling relationships  \n\nBuilding domain models is a key step in the design of complex systems. Typically, you use the modelling process to identify entities and the relationships between them as a way to understand the business domain and inform the design of your system. This section focuses on how you can translate some of the common relationship types found in domain models to designs for the Table service. The process of mapping from a logical data-model to a physical NoSQL based data-model is very different from that used when designing a relational database. Relational databases design typically assumes a data normalization process optimized for minimizing redundancy – and a declarative querying capability that abstracts how the implementation of how the database works.  \n\n### One-to-many relationships  \n\nOne-to-many relationships between business domain objects occur very frequently: for example, one department has many employees. There are several ways to implement one-to-many relationships in the Table service each with pros and cons that may be relevant to the particular scenario.  \n\nConsider the example of a large multi-national corporation with tens of thousands of departments and employee entities where every department has many employees and each employee as associated with one specific department. One approach is to store separate department and employee entities such as these:  \n\n![][1]\n\nThis example shows an implicit one-to-many relationship between the types based on the **PartitionKey** value. Each department can have many employees.  \n\nThis example also shows a department entity and its related employee entities in the same partition. You could choose to use different partitions, tables, or even storage accounts for the different entity types.  \n\nAn alternative approach is to denormalize your data and store only employee entities with denormalized department data as shown in the following example. In this particular scenario, this denormalized approach may not be the best if you have a requirement to be able to change the details of a department manager because to do this you need to update every employee in the department.  \n\n![][2]\n\nFor more information, see the [Denormalization pattern](#denormalization-pattern) later in this guide.  \n\nThe following table summarizes the pros and cons of each of the approaches outlined above for storing employee and department entities that have a one-to-many relationship. You should also consider how often you expect to perform various operations: it may be acceptable to have a design that includes an expensive operation if that operation only happens infrequently.  \n\n<table>\n<tr>\n<th>Approach</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n<tr>\n<td>Separate entity types, same partition, same table</td>\n<td>\n<ul>\n<li>You can update a department entity with a single operation.</li>\n<li>You can use an EGT to maintain consistency if you have a requirement to modify a department entity whenever you update/insert/delete an employee entity. For example if you maintain a departmental employee count for each department.</li>\n</ul>\n</td>\n<td>\n<ul>\n<li>You may need to retrieve both an employee and a department entity for some client activities.</li>\n<li>Storage operations happen in the same partition. At high transaction volumes, this may result in a hotspot.</li>\n<li>You cannot move an employee to a new department using an EGT.</li>\n</ul>\n</td>\n</tr>\n<tr>\n<td>Separate entity types, different partitions or tables or storage accounts</td>\n<td>\n<ul>\n<li>You can update a department entity or employee entity with a single operation.</li>\n<li>At high transaction volumes, this may help spread the load across more partitions.</li>\n</ul>\n</td>\n<td>\n<ul>\n<li>You may need to retrieve both an employee and a department entity for some client activities.</li>\n<li>You cannot use EGTs to maintain consistency when you update/insert/delete an employee and update a department. For example, updating an employee count in a department entity.</li>\n<li>You cannot move an employee to a new department using an EGT.</li>\n</ul>\n</td>\n</tr>\n<tr>\n<td>Denormalize into single entity type</td>\n<td>\n<ul>\n<li>You can retrieve all the information you need with a single request.</li>\n</ul>\n</td>\n<td>\n<ul>\n<li>It may be expensive to maintain consistency if you need to update department information (this would require you to update all the employees in a department).</li>\n</ul>\n</td>\n</tr>\n</table>\n\nHow you choose between these options, and which of the pros and cons are most significant, depends on your specific application scenarios. For example, how often do you modify department entities; do all your employee queries need the additional departmental information; how close are you to the scalability limits on your partitions or your storage account?  \n\n### One-to-one relationships  \n\nDomain models may include one-to-one relationships between entities. If you need to implement a one-to-one relationship in the Table service, you must also choose how to link the two related entities when you need to retrieve them both. This link can be either implicit, based on a convention in the key values, or explicit by storing a link in the form of **PartitionKey** and **RowKey** values in each entity to its related entity. For a discussion of whether you should store the related entities in the same partition, see the section [One-to-many relationships](#one-to-many-relationships).  \n\nNote that there are also implementation considerations that might lead you to implement one-to-one relationships in the Table service:  \n\n-   Handling large entities (for more information, see [Working with large entities](#working-with-large-entities)).  \n-   Implementing access controls (for more information, see [Controlling access with Shared Access Signatures](#controlling-access-with-shared-access-signatures)).  \n\n### Join in the client  \n\nAlthough there are ways to model relationships in the Table service, you should not forget that the two prime reasons for using the Table service are scalability and performance. If you find you are modelling many relationships that compromise the performance and scalability of your solution, you should ask yourself if it is necessary to build all the data relationships into your table design. You may be able to simplify the design and improve the scalability and performance of your solution if you let your client application perform any necessary joins.  \n\nFor example, if you have small tables that contain data that does not change very often, then you can retrieve this data once and cache it on the client. This can avoid repeated roundtrips to retrieve the same data. In the examples we have looked at in this guide, the set of departments in a small organization is likely to be small and change infrequently making it a good candidate for data that client application can download once and cache as look up data.  \n\n### Inheritance relationships  \n\nIf your client application uses a set of classes that form part of an inheritance relationship to represent business entities, you can easily persist those entities in the Table service. For example, you might have the following set of classes defined in your client application where **Person** is an abstract class.\n\n![][3]\n\nYou can persist instances of the two concrete classes in the Table service using a single Person table using entities in that look like this:  \n\n![][4]\n\nFor more information about working with multiple entity types in the same table in client code, see the section [Working with heterogeneous entity types](#working-with-heterogeneous-entity-types) later in this guide. This provides examples of how to recognize the entity type in client code.  \n\n## Table Design Patterns\nIn previous sections, you have seen some detailed discussions about how to optimize your table design for both retrieving entity data using queries and for inserting, updating, and deleting entity data. This section describes some patterns appropriate for use with Table service solutions. In addition, you will see how you can practically address some of the issues and trade-offs raised previously in this guide. The following diagram summarizes the relationships between the different patterns:  \n\n![][5]\n\nThe pattern map above highlights some relationships between patterns (blue) and anti-patterns (orange) that are documented in this guide. There are of course many other patterns that are worth considering. For example, one of the key scenarios for Table Service is to store [Materialized Views](https://msdn.microsoft.com/library/azure/dn589782.aspx) from the [Command Query Responsibility Segregation](https://msdn.microsoft.com/library/azure/jj554200.aspx) (CQRS) pattern.  \n\n### Intra-partition secondary index pattern\nStore multiple copies of each entity using different **RowKey** values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values. Updates between copies can be kept consistent using EGT’s.  \n\n#### Context and problem\nThe Table service automatically indexes entities using the **PartitionKey** and **RowKey** values. This enables a client application to retrieve an entity efficiently using these values. For example, using the table structure shown below, a client application can use a point query to retrieve an individual employee entity by using the department name and the employee id (the **PartitionKey** and **RowKey** values). A client can also retrieve entities sorted by employee id within each department.\n\n![][6]\n\nIf you also want to be able to find an employee entity based on the value of another property, such as email address, you must use a less efficient partition scan to find a match. This is because the table service does not provide secondary indexes. In addition, there is no option to request a list of employees sorted in a different order than **RowKey** order.  \n\n#### Solution\nTo work around the lack of secondary indexes, you can store multiple copies of each entity with each copy using a different **RowKey** value. If you store an entity with the structures shown below, you can efficiently retrieve employee entities based on email address or employee id. The prefix values for the **RowKey**, \"empid_\" and \"email_\" enable you to query for a single employee or a range of employees by using a range of email addresses or employee ids.  \n\n![][7]\n\nThe following two filter criteria (one looking up by employee id and one looking up by email address) both specify point queries:  \n\n-   $filter=(PartitionKey eq 'Sales') and (RowKey eq 'empid_000223')  \n-   $filter=(PartitionKey eq 'Sales') and (RowKey eq 'email_jonesj@contoso.com')  \n\nIf you query for a range of employee entities, you can specify a range sorted in employee id order, or a range sorted in email address order by querying for entities with the appropriate prefix in the **RowKey**.  \n\n-   To find all the employees in the Sales department with an employee id in the range 000100 to 000199 use:\n$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000100') and (RowKey le 'empid_000199')  \n-   To find all the employees in the Sales department with an email address starting with the letter 'a' use:\n$filter=(PartitionKey eq 'Sales') and (RowKey ge 'email_a') and (RowKey lt 'email_b')  \n\n Note that the filter syntax used in the examples above is from the Table service REST API, for more information see [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx) on MSDN.  \n\n#### Issues and considerations  \n\nConsider the following points when deciding how to implement this pattern:  \n\n-   Table storage is relatively cheap to use so the cost overhead of storing duplicate data should not be a major concern. However, you should always evaluate the cost of your design based on your anticipated storage requirements and only add duplicate entities to support the queries your client application will execute.  \n-   Because the secondary index entities are stored in the same partition as the original entities, you should ensure that you do not exceed the scalability targets for an individual partition.  \n-   You can keep your duplicate entities consistent with each other by using EGTs to update the two copies of the entity atomically. This implies that you should store all copies of an entity in the same partition. For more information, see the section [Using Entity Group Transactions](#entity-group-transactions).  \n-   The value used for the **RowKey** must be unique for each entity. Consider using compound key values.  \n-   Padding numeric values in the **RowKey** (for example, the employee id 000223), enables correct sorting and filtering based on upper and lower bounds.  \n-   You do not necessarily need to duplicate all the properties of your entity. For example, if the queries that lookup the entities using the email address in the **RowKey** never need the employee’s age, these entities could have the following structure:\n\n![][8]\n\n-   It is typically better to store duplicate data and ensure that you can retrieve all the data you need with a single query, than to use one query to locate an entity and another to lookup the required data.  \n\n#### When to use this pattern  \n\nUse this pattern when your client application needs to retrieve entities using a variety of different keys, when your client needs to retrieve entities in different sort orders, and where you can identify each entity using a variety of unique values. However, you should be sure that you do not exceed the partition scalability limits when you are performing entity lookups using the different **RowKey** values.  \n\n#### Related patterns and guidance  \n\nThe following patterns and guidance may also be relevant when implementing this pattern:  \n\n-   [Inter-partition secondary index pattern](#inter-partition-secondary-index-pattern)\n-   [Compound key pattern](#compound-key-pattern)\n-   [Entity Group Transactions](#entity-group-transactions)\n-   [Working with heterogeneous entity types](#working-with-heterogeneous-entity-types)\n\n### Inter-partition secondary index pattern\nStore multiple copies of each entity using different **RowKey** values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.  \n\n#### Context and problem\nThe Table service automatically indexes entities using the **PartitionKey** and **RowKey** values. This enables a client application to retrieve an entity efficiently using these values. For example, using the table structure shown below, a client application can use a point query to retrieve an individual employee entity by using the department name and the employee id (the **PartitionKey** and **RowKey** values). A client can also retrieve entities sorted by employee id within each department.  \n\n![][9]\n\nIf you also want to be able to find an employee entity based on the value of another property, such as email address, you must use a less efficient partition scan to find a match. This is because the table service does not provide secondary indexes. In addition, there is no option to request a list of employees sorted in a different order than **RowKey** order.  \n\nYou are anticipating a very high volume of transactions against these entities and want to minimize the risk of the Table service throttling your client.  \n\n#### Solution  \nTo work around the lack of secondary indexes, you can store multiple copies of each entity with each copy using different **PartitionKey** and **RowKey** values. If you store an entity with the structures shown below, you can efficiently retrieve employee entities based on email address or employee id. The prefix values for the **PartitionKey**, \"empid_\" and \"email_\" enable you to identify which index you want to use for a query.  \n\n![][10]\n\nThe following two filter criteria (one looking up by employee id and one looking up by email address) both specify point queries:  \n\n-   $filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')\n-   $filter=(PartitionKey eq 'email_Sales') and (RowKey eq 'jonesj@contoso.com')  \n\nIf you query for a range of employee entities, you can specify a range sorted in employee id order, or a range sorted in email address order by querying for entities with the appropriate prefix in the **RowKey**.  \n\n-   To find all the employees in the Sales department with an employee id in the range **000100** to **000199** sorted in employee id order use:\n$filter=(PartitionKey eq 'empid_Sales') and (RowKey ge '000100') and (RowKey le '000199')  \n-   To find all the employees in the Sales department with an email address that starts with 'a' sorted in email address order use:\n$filter=(PartitionKey eq 'email_Sales') and (RowKey ge 'a') and (RowKey lt 'b')  \n\nNote that the filter syntax used in the examples above is from the Table service REST API, for more information see [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx) on MSDN.  \n\n#### Issues and considerations  \nConsider the following points when deciding how to implement this pattern:  \n\n-   You can keep your duplicate entities eventually consistent with each other by using the [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) to maintain the primary and secondary index entities.  \n-   Table storage is relatively cheap to use so the cost overhead of storing duplicate data should not be a major concern. However, you should always evaluate the cost of your design based on your anticipated storage requirements and only add duplicate entities to support the queries your client application will execute.  \n-   The value used for the **RowKey** must be unique for each entity. Consider using compound key values.  \n-   Padding numeric values in the **RowKey** (for example, the employee id 000223), enables correct sorting and filtering based on upper and lower bounds.  \n-   You do not necessarily need to duplicate all the properties of your entity. For example, if the queries that lookup the entities using the email address in the **RowKey** never need the employee’s age, these entities could have the following structure:\n\n    ![][11]\n\n-   It is typically better to store duplicate data and ensure that you can retrieve all the data you need with a single query than to use one query to locate an entity using the secondary index and another to lookup the required data in the primary index.  \n\n#### When to use this pattern  \nUse this pattern when your client application needs to retrieve entities using a variety of different keys, when your client needs to retrieve entities in different sort orders, and where you can identify each entity using a variety of unique values. Use this pattern when you want to avoid exceeding the partition scalability limits when you are performing entity lookups using the different **RowKey** values.  \n\n#### Related patterns and guidance\nThe following patterns and guidance may also be relevant when implementing this pattern:  \n\n-   [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern)  \n-   [Intra-partition secondary index pattern](#intra-partition-secondary-index-pattern)  \n-   [Compound key pattern](#compound-key-pattern)  \n-   [Entity Group Transactions](#entity-group-transactions)  \n-   [Working with heterogeneous entity types](#working-with-heterogeneous-entity-types)  \n\n### Eventually consistent transactions pattern  \n\nEnable eventually consistent behavior across partition boundaries or storage system boundaries by using Azure queues.  \n\n#### Context and problem  \n\nEGTs enable atomic transactions across multiple entities that share the same partition key. For performance and scalability reasons, you might decide to store entities that have consistency requirements in separate partitions or in a separate storage system: in such a scenario, you cannot use EGTs to maintain consistency. For example, you might have a requirement to maintain eventual consistency between:  \n\n-   Entities stored in two different partitions in the same table, in different tables, in in different storage accounts.  \n-   An entity stored in the Table service and a blob stored in the Blob service.  \n-   An entity stored in the Table service and a file in a file system.  \n-   An entity store in the Table service yet indexed using the Azure Search service.  \n\n#### Solution  \n\nBy using Azure queues, you can implement a solution that delivers eventual consistency across two or more partitions or storage systems.\nTo illustrate this approach, assume you have a requirement to be able to archive old employee entities. Old employee entities are rarely queried and should be excluded from any activities that deal with current employees. To implement this requirement you store active employees in the **Current** table and old employees in the **Archive** table. Archiving an employee requires you to delete the entity from the **Current** table and add the entity to the **Archive** table, but you cannot use an EGT to perform these two operations. To avoid the risk that a failure causes an entity to appear in both or neither tables, the archive operation must be eventually consistent. The following sequence diagram outlines the steps in this operation. More detail is provided for exception paths in the text following.  \n\n![][12]\n\nA client initiates the archive operation by placing a message on an Azure queue, in this example to archive employee #456. A worker role polls the queue for new messages; when it finds one, it reads the message and leaves a hidden copy on the queue. The worker role next fetches a copy of the entity from the **Current** table, inserts a copy in the **Archive** table, and then deletes the original from the **Current** table. Finally, if there were no errors from the previous steps, the worker role deletes the hidden message from the queue.  \n\nIn this example, step 4 inserts the employee into the **Archive** table. It could add the employee to a blob in the Blob service or a file in a file system.  \n\n#### Recovering from failures  \n\nIt is important that the operations in steps **4** and **5** must be *idempotent* in case the worker role needs to restart the archive operation. If you are using the Table service, for step **4** you should use an \"insert or replace\" operation; for step **5** you should use a \"delete if exists\" operation in the client library you are using. If you are using another storage system, you must use an appropriate idempotent operation.  \n\nIf the worker role never completes step **6**, then after a timeout the message reappears on the queue ready for the worker role to try to reprocess it. The worker role can check how many times a message on the queue has been read and, if necessary, flag it is a \"poison\" message for investigation by sending it to a separate queue. For more information about reading queue messages and checking the dequeue count, see [Get Messages](https://msdn.microsoft.com/library/azure/dd179474.aspx).  \n\nSome errors from the Table and Queue services are transient errors, and your client application should include suitable retry logic to handle them.  \n\n#### Issues and considerations\nConsider the following points when deciding how to implement this pattern:  \n\n-   This solution does not provide for transaction isolation. For example, a client could read the **Current** and **Archive** tables when the worker role was between steps **4** and **5**, and see an inconsistent view of the data. Note that the data will be consistent eventually.  \n-   You must be sure that steps 4 and 5 are idempotent in order to ensure eventual consistency.  \n-   You can scale the solution by using multiple queues and worker role instances.  \n\n#### When to use this pattern  \nUse this pattern when you want to guarantee eventual consistency between entities that exist in different partitions or tables. You can extend this pattern to ensure eventual consistency for operations across the Table service and the Blob service and other non-Azure Storage data sources such as database or the file system.  \n\n#### Related patterns and guidance  \nThe following patterns and guidance may also be relevant when implementing this pattern:  \n-   [Entity Group Transactions](#entity-group-transactions)  \n-   [Merge or replace](#merge-or-replace)  \n\n>[AZURE.NOTE] If transaction isolation is important to your solution, you should consider redesigning your tables to enable you to use EGTs.  \n\n### Index Entities Pattern\nMaintain index entities to enable efficient searches that return lists of entities.  \n\n#### Context and problem  \n\nThe Table service automatically indexes entities using the **PartitionKey** and **RowKey** values. This enables a client application to retrieve an entity efficiently using a point query. For example, using the table structure shown below, a client application can efficiently retrieve an individual employee entity by using the department name and the employee id (the **PartitionKey** and **RowKey**).  \n\n![][13]\n\nIf you also want to be able to retrieve a list of employee entities based on the value of another non-unique property, such as their last name, you must use a less efficient partition scan to find matches rather than using an index to look them up directly. This is because the table service does not provide secondary indexes.  \n\n#### Solution  \n\nTo enable lookup by last name with the entity structure shown above, you must maintain lists of employee ids. If you want to retrieve the employee entities with a particular last name, such as Jones, you must first locate the list of employee ids for employees with Jones as their last name, and then retrieve those employee entities. There are three main options for storing the lists of employee ids:  \n\n-   Use blob storage.  \n-   Create index entities in the same partition as the employee entities.  \n-   Create index entities in a separate partition or table.  \n\n<u>Option #1: Use blob storage</u>  \n\nFor the first option, you create a blob for every unique last name, and in each blob store a list of the **PartitionKey** (department) and **RowKey** (employee id) values for employees that have that last name. When you add or delete an employee you should ensure that the content of the relevant blob is eventually consistent with the employee entities.  \n\n<u>Option #2:</u> Create index entities in the same partition  \n\nFor the second option, use index entities that store the following data:  \n\n![][14]\n\nThe **EmployeeIDs** property contains a list of employee ids for employees with the last name stored in the **RowKey**.  \n\nThe following steps outline the process you should follow when you are adding a new employee if you are using the second option. In this example, we are adding an employee with Id 000152 and a last name Jones in the Sales department:  \n1.  Retrieve the index entity with a **PartitionKey** value \"Sales\" and the **RowKey** value \"Jones.\" Save the ETag of this entity to use in step 2.  \n2.  Create an entity group transaction (that is, a batch operation) that inserts the new employee entity (**PartitionKey** value \"Sales\" and **RowKey** value \"000152\"), and updates the index entity (**PartitionKey** value \"Sales\" and **RowKey** value \"Jones\") by adding the new employee id to the list in the EmployeeIDs field. For more information about entity group transactions, see [Entity Group Transactions](#entity-group-transactions). \n3.  If the entity group transaction fails because of an optimistic concurrency error (someone else has just modified the index entity), then you need to start over at step 1 again.  \n\nYou can use a similar approach to deleting an employee if you are using the second option. Changing an employee's last name is slightly more complex because you will need to execute an entity group transaction that updates three entities: the employee entity, the index entity for the old last name, and the index entity for the new last name. You must retrieve each entity before making any changes in order to retrieve the ETag values that you can then use to perform the updates using optimistic concurrency.  \n\nThe following steps outline the process you should follow when you need to look up all the employees with a given last name in a department if you are using the second option. In this example, we are looking up all the employees with last name Jones in the Sales department:  \n\n1.  Retrieve the index entity with a **PartitionKey** value \"Sales\" and the **RowKey** value \"Jones.\"  \n2.  Parse the list of employee Ids in the EmployeeIDs field.  \n3.  If you need additional information about each of these employees (such as their email addresses), retrieve each of the employee entities using **PartitionKey** value \"Sales\" and **RowKey** values from the list of employees you obtained in step 2.  \n\n<u>Option #3:</u> Create index entities in a separate partition or table  \n\nFor the third option, use index entities that store the following data:  \n\n![][15]\n\nThe **EmployeeIDs** property contains a list of employee ids for employees with the last name stored in the **RowKey**.  \n\nWith the third option, you cannot use EGTs to maintain consistency because the index entities are in a separate partition from the employee entities. You should ensure that the index entities are eventually consistent with the employee entities.  \n\n#### Issues and considerations  \n\nConsider the following points when deciding how to implement this pattern:  \n-   This solution requires at least two queries to retrieve matching entities: one to query the index entities to obtain the list of **RowKey** values, and then queries to retrieve each entity in the list.  \n-   Given that an individual entity has a maximum size of 1 MB, option #2 and option #3 in the solution assume that the list of employee ids for any given last name is never greater than 1 MB. If the list of employee ids is likely to be greater than 1 MB in size, use option #1 and store the index data in blob storage.  \n-   If you use option #2 (using EGTs to handle adding and deleting employees, and changing an employee’s last name) you must evaluate if the volume of transactions will approach the scalability limits in a given partition. If this is the case, you should consider an eventually consistent solution (option #1 or option #3) that uses queues to handle the update requests and enables you to store your index entities in a separate partition from the employee entities.  \n-   Option #2 in this solution assumes that you want to look up by last name within a department: for example, you want to retrieve a list of employees with a last name Jones in the Sales department. If you want to be able to look up all the employees with a last name Jones across the whole organization, use either option #1 or option #3.\n-   You can implement a queue-based solution that delivers eventual consistency (see the [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) for more details).  \n\n#### When to use this pattern  \n\nUse this pattern when you want to lookup a set of entities that all share a common property value, such as all employees with the last name Jones.  \n\n#### Related patterns and guidance  \n\nThe following patterns and guidance may also be relevant when implementing this pattern:  \n-   [Compound key pattern](#compound-key-pattern)  \n-   [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern)  \n-   [Entity Group Transactions](#entity-group-transactions)  \n-   [Working with heterogeneous entity types](#working-with-heterogeneous-entity-types)  \n\n### Denormalization pattern  \n\nCombine related data together in a single entity to enable you to retrieve all the data you need with a single point query.  \n\n#### Context and problem  \n\nIn a relational database, you typically normalize data to remove duplication resulting in queries that retrieve data from multiple tables. If you normalize your data in Azure tables, you must make multiple round trips from the client to the server to retrieve your related data. For example, with the table structure shown below you need two round trips to retrieve the details for a department: one to fetch the department entity that includes the manager’s id, and then another request to fetch the manager’s details in an employee entity.  \n\n![][16]\n\n#### Solution  \n\nInstead of storing the data in two separate entities, denormalize the data and keep a copy of the manager’s details in the department entity. For example:  \n\n![][17]\n\nWith department entities stored with these properties, you can now retrieve all the details you need about a department using a point query.  \n\n#### Issues and considerations  \n\nConsider the following points when deciding how to implement this pattern:  \n\n-   There is some cost overhead associated with storing some data twice. The performance benefit (resulting from fewer requests to the storage service) typically outweighs the marginal increase in storage costs (and this cost is partially offset by a reduction in the number of transactions you require to fetch the details of a department).  \n-   You must maintain the consistency of the two entities that store information about managers. You can handle the consistency issue by using EGTs to update multiple entities in a single atomic transaction: in this case, the department entity, and the employee entity for the department manager are stored in the same partition.  \n\n#### When to use this pattern\nUse this pattern when you frequently need to look up related information. This pattern reduces the number of queries your client must make to retrieve the data it requires.  \n\n#### Related patterns and guidance\nThe following patterns and guidance may also be relevant when implementing this pattern:  \n-   [Compound key pattern](#compound-key-pattern)  \n-   [Entity Group Transactions](#entity-group-transactions)  \n-   [Working with heterogeneous entity types](#working-with-heterogeneous-entity-types)\n\n### Compound key pattern  \n\nUse compound **RowKey** values to enable a client to lookup related data with a single point query.  \n\n#### Context and problem  \n\nIn a relational database, it is quite natural to use joins in queries to return related pieces of data to the client in a single query. For example, you might use the employee id to look up a list of related entities that contain performance and review data for that employee.  \n\nAssume you are storing employee entities in the Table service using the following structure:  \n\n![][18]\n\nYou also need to store historical data relating to reviews and performance for each year the employee has worked for your organization and you need to be able to access this information by year. One option is to create another table that stores entities with the following structure:  \n\n![][19]\n\nNotice that with this approach you may decide to duplicate some information (such as first name and last name) in the new entity to enable you to retrieve your data with a single request. However, you cannot maintain strong consistency because you cannot use an EGT to update the two entities atomically.  \n\n#### Solution\nStore a new entity type in your original table using entities with the following structure:  \n\n![][20]\n\nNotice how the **RowKey** is now a compound key made up of the employee id and the year of the review data that enables you to retrieve the employee’s performance and review data with a single request for a single entity.  \n\nThe following example outlines how you can retrieve all the review data for a particular employee (such as employee 000123 in the Sales department):  \n\n$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000123') and (RowKey lt 'empid_000124')&$select=RowKey,Manager Rating,Peer Rating,Comments  \n\n#### Issues and considerations\nConsider the following points when deciding how to implement this pattern:  \n\n-   You should use a suitable separator character that makes it easy to parse the **RowKey** value: for example, **000123_2012**.  \n-   You are also storing this entity in the same partition as other entities that contain related data for the same employee, which means you can use EGTs to maintain strong consistency.\n-   You should consider how frequently you will query the data to determine whether this pattern is appropriate.  For example, if you will access the review data infrequently and the main employee data often you should keep them as separate entities.  \n\n#### When to use this pattern  \n\nUse this pattern when you need to store one or more related entities that you query frequently.  \n\n#### Related patterns and guidance  \n\nThe following patterns and guidance may also be relevant when implementing this pattern:  \n\n-   [Entity Group Transactions](#entity-group-transactions)  \n-   [Working with heterogeneous entity types](#working-with-heterogeneous-entity-types)  \n-   [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern)  \n\n### Log tail pattern  \n\nRetrieve the *n* entities most recently added to a partition by using a **RowKey** value that sorts in reverse date and time order.  \n\n#### Context and problem  \n\nA common requirement is be able to retrieve the most recently created entities, for example the ten most recent expense claims submitted by an employee. Table queries support a **$top** query operation to return the first *n* entities from a set: there is no equivalent query operation to return the last n entities in a set.  \n\n#### Solution  \n\nStore the entities using a **RowKey** that naturally sorts in reverse date/time order by using so the most recent entry is always the first one in the table.  \n\nFor example, to be able to retrieve the ten most recent expense claims submitted by an employee, you can use a reverse tick value derived from the current date/time. The following C# code sample shows one way to create a suitable \"inverted ticks\" value for a **RowKey** that sorts from the most recent to the oldest:  \n\n`string invertedTicks = string.Format(\"{0:D19}\", DateTime.MaxValue.Ticks - DateTime.UtcNow.Ticks);`  \n\nYou can get back to the date time value using the following code:  \n\n`DateTime dt = new DateTime(DateTime.MaxValue.Ticks - Int64.Parse(invertedTicks));`  \n\nThe table query looks like this:  \n\n`https://myaccount.table.core.windows.net/EmployeeExpense(PartitionKey='empid')?$top=10`  \n\n#### Issues and considerations  \n\nConsider the following points when deciding how to implement this pattern:  \n\n-   You must pad the reverse tick value with leading zeroes to ensure the string value sorts as expected.  \n-   You must be aware of the scalability targets at the level of a partition. Be careful not create hot spot partitions.  \n\n#### When to use this pattern  \n\nUse this pattern when you need to access entities in reverse date/time order or when you need to access the most recently added entities.  \n\n#### Related patterns and guidance  \n\nThe following patterns and guidance may also be relevant when implementing this pattern:  \n\n-   [Prepend / append anti-pattern](#prepend-append-anti-pattern)  \n-   [Retrieving entities](#retrieving-entities)  \n\n### High volume delete pattern  \n\nEnable the deletion of a high volume of entities by storing all the entities for simultaneous deletion in their own separate table; you delete the entities by deleting the table.  \n\n#### Context and problem  \n\nMany applications delete old data which no longer needs to be available to a client application, or that the application has archived to another storage medium. You typically identify such data by a date: for example, you have a requirement to delete records of all login requests that are more than 60 days old.  \n\nOne possible design is to use the date and time of the login request in the **RowKey**:  \n\n![][21]\n\nThis approach avoids partition hotspots because the application can insert and delete login entities for each user in a separate partition. However, this approach may be costly and time consuming if you have a large number of entities because first you need to perform a table scan in order to identify all the entities to delete, and then you must delete each old entity. Note that you can reduce the number of round trips to the server required to delete the old entities by batching multiple delete requests into EGTs.  \n\n#### Solution  \n\nUse a separate table for each day of login attempts. You can use the entity design above to avoid hotspots when you are inserting entities, and deleting old entities is now simply a question of deleting one table every day (a single storage operation) instead of finding and deleting hundreds and thousands of individual login entities every day.  \n\n#### Issues and considerations  \n\nConsider the following points when deciding how to implement this pattern:  \n\n-   Does your design support other ways your application will use the data such as looking up specific entities, linking with other data, or generating aggregate information?  \n-   Does your design avoid hot spots when you are inserting new entities?  \n-   Expect a delay if you want to reuse the same table name after deleting it. It's better to always use unique table names.  \n-   Expect some throttling when you first use a new table while the Table service learns the access patterns and distributes the partitions across nodes. You should consider how frequently you need to create new tables.  \n\n#### When to use this pattern  \n\nUse this pattern when you have a high volume of entities that you must delete at the same time.  \n\n#### Related patterns and guidance  \n\nThe following patterns and guidance may also be relevant when implementing this pattern:  \n\n-   [Entity Group Transactions](#entity-group-transactions)\n-   [Modifying entities](#working-with-heterogeneous-entity-types)  \n\n### Data series pattern  \n\nStore complete data series in a single entity to minimize the number of requests you make.  \n\n#### Context and problem  \n\nA common scenario is for an application to store a series of data that it typically needs to retrieve all at once. For example, your application might record how many IM messages each employee sends every hour, and then use this information to plot how many messages each user sent over the preceding 24 hours. One design might be to store 24 entities for each employee:  \n\n![][22]\n\nWith this design, you can easily locate and update the entity to update for each employee whenever the application needs to update the message count value. However, to retrieve the information to plot a chart of the activity for the preceding 24 hours, you must retrieve 24 entities.  \n\n#### Solution  \n\nUse the following design with a separate property to store the message count for each hour:  \n\n![][23]\n\nWith this design, you can use a merge operation to update the message count for an employee for a specific hour. Now, you can retrieve all the information you need to plot the chart using a request for a single entity.  \n\n#### Issues and considerations  \n\nConsider the following points when deciding how to implement this pattern:  \n-   If your complete data series does not fit into a single entity (an entity can have up to 252 properties), use an alternative data store such as a blob.  \n-   If you have multiple clients updating an entity simultaneously, you will need to use the **ETag** to implement optimistic concurrency. If you have many clients, you may experience high contention.  \n\n#### When to use this pattern  \n\nUse this pattern when you need to update and retrieve a data series associated with an individual entity.  \n\n#### Related patterns and guidance  \n\nThe following patterns and guidance may also be relevant when implementing this pattern:  \n\n-   [Large entity pattern](#large-entity-pattern)  \n-   [Merge or replace](#working-with-heterogeneous-entity-types)  \n-   [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) (if you are storing the data series in a blob)  \n\n### Wide entities pattern  \n\nUse multiple physical entities to store logical entities with more than 252 properties.  \n\n#### Context and problem  \n\nAn individual entity can have no more than 252 properties (excluding the mandatory system properties) and cannot store more than 1 MB of data in total. In a relational database, you would typically get round any limits on the size of a row by adding a new table and enforcing a 1-to-1 relationship between them.  \n\n#### Solution  \n\nUsing the Table service, you can store multiple entities to represent a single large business object with more than 252 properties. For example, if you want to store a count of the number of IM messages sent by each employee for the last 365 days, you could use the following design that uses two entities with different schemas:  \n\n![][24]\n\nIf you need to make a change that requires updating both entities to keep them synchronized with each other you can use an EGT. Otherwise, you can use a single merge operation to update the message count for a specific day. To retrieve all the data for an individual employee you must retrieve both entities, which you can do with two efficient requests that use both a **PartitionKey** and a **RowKey** value.  \n\n#### Issues and considerations  \n\nConsider the following points when deciding how to implement this pattern:  \n\n-   Retrieving a complete logical entity involves at least two storage transactions: one to retrieve each physical entity.  \n\n#### When to use this pattern  \n\nUse this pattern when  need to store entities whose size or number of properties exceeds the limits for an individual entity in the Table service.  \n\n#### Related patterns and guidance  \n\nThe following patterns and guidance may also be relevant when implementing this pattern:  \n\n-   [Entity Group Transactions](#entity-group-transactions)\n-   [Merge or replace](#working-with-heterogeneous-entity-types)\n\n### Large entities pattern  \n\nUse blob storage to store large property values.  \n\n#### Context and problem  \n\nAn individual entity cannot store more than 1 MB of data in total. If one or several of your properties store values that cause the total size of your entity to exceed this value, you cannot store the entire entity in the Table service.  \n\n#### Solution  \n\nIf your entity exceeds 1 MB in size because one or more properties contain a large amount of data, you can store data in the Blob service and then store the address of the blob in a property in the entity. For example, you can store the photo of an employee in blob storage and store a link to the photo in the **Photo** property of your employee entity:  \n\n![][25]\n\n#### Issues and considerations  \n\nConsider the following points when deciding how to implement this pattern:  \n\n-   To maintain eventual consistency between the entity in the Table service and the data in the Blob service, use the [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) to maintain your entities.\n-   Retrieving a complete entity involves at least two storage transactions: one to retrieve the entity and one to retrieve the blob data.  \n\n#### When to use this pattern  \n\nUse this pattern when you need to store entities whose size exceeds the limits for an individual entity in the Table service.  \n\n#### Related patterns and guidance  \n\nThe following patterns and guidance may also be relevant when implementing this pattern:  \n\n-   [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern)  \n-   [Wide entities pattern](#large-entity-pattern)\n\n### Prepend/append anti-pattern  \n\nIncrease scalability when you have a high volume of inserts by spreading the inserts across multiple partitions.  \n\n#### Context and problem  \n\nPrepending or appending entities to your stored entities typically results in the application adding new entities to the first or last partition of a sequence of partitions. In this case, all of the inserts at any given time are taking place in the same partition, creating a hotspot that prevents the table service from load balancing inserts across multiple nodes, and possibly causing your application to hit the scalability targets for partition. For example, if you have an application that logs network and resource access by employees, then an entity structure as shown below could result in the current hour’s partition becoming a hotspot if the volume of transactions reaches the scalability target for an individual partition:  \n\n![][26]\n\n#### Solution  \n\nThe following alternative entity structure avoids a hotspot on any particular partition as the application logs events:  \n\n![][27]\n\nNotice with this example how both the **PartitionKey** and **RowKey** are compound keys. The **PartitionKey** uses both the department and employee id to distribute the logging across multiple partitions.  \n\n#### Issues and considerations  \n\nConsider the following points when deciding how to implement this pattern:  \n\n-   Does the alternative key structure that avoids creating hot partitions on inserts efficiently support the queries your client application makes?  \n-   Does your anticipated volume of transactions mean that you are likely to reach the scalability targets for an individual partition and be throttled by the storage service?  \n\n#### When to use this pattern  \n\nAvoid the prepend/append anti-pattern when your volume of transactions is likely to result in throttling by the storage service when you access a hot partition.  \n\n#### Related patterns and guidance  \n\nThe following patterns and guidance may also be relevant when implementing this pattern:  \n\n-   [Compound key pattern](#compound-key-pattern)  \n-   [Log tail pattern](#log-tail-pattern)  \n-   [Modifying entities](#working-with-heterogeneous-entity-types)  \n\n### Log data anti-pattern  \n\nTypically, you should use the Blob service instead of the Table service to store log data.  \n\n#### Context and problem  \n\nA common use case for log data is to retrieve a selection of log entries for a specific date/time range: for example, you want to find all the error and critical messages that your application logged between 15:04 and 15:06 on a specific date. You do not want to use the date and time of the log message to determine the partition you save log entities to: that results in a hot partition because at any given time, all the log entities will share the same **PartitionKey** value (see the section [Prepend/append anti-pattern](#prepend-append-anti-pattern)). For example, the following entity schema for a log message results in a hot partition because the application writes all log messages to the partition for the current date and hour:  \n\n![][28]\n\nIn this example, the **RowKey** includes the date and time of the log message to ensure that log messages are stored sorted in date/time order, and includes a message id in case multiple log messages share the same date and time.  \n\nAnother approach is to use a **PartitionKey** that ensures that the application writes messages across a range of partitions. For example, if the source of the log message provides a way to distribute messages across many partitions, you could use the following entity schema:  \n\n![][29]\n\nHowever, the problem with this schema is that to retrieve all the log messages for a specific time span you must search every partition in the table.\n\n#### Solution  \n\nThe previous section highlighted the problem of trying to use the Table service to store log entries and suggested two, unsatisfactory, designs. One solution led to a hot partition with the risk of poor performance writing log messages; the other solution resulted in poor query performance because of the requirement to scan every partition in the table to retrieve log messages for a specific time span. Blob storage offers a better solution for this type of scenario and this is how Azure Storage Analytics stores the log data it collects.  \n\nThis section outlines how Storage Analytics stores log data in blob storage as an illustration of this approach to storing data that you typically query by range.  \n\nStorage Analytics stores log messages in a delimited format in multiple blobs. The delimited format makes it easy for a client application to parse the data in the log message.  \n\nStorage Analytics uses a naming convention for blobs that enables you to locate the blob (or blobs) that contain the log messages for which you are searching. For example, a blob named \"queue/2014/07/31/1800/000001.log\" contains log messages that relate to the queue service for the hour starting at 18:00 on 31 July 2014. The \"000001\" indicates that this is the first log file for this period. Storage Analytics also records the timestamps of the first and last log messages stored in the file as part of the blob’s metadata. The API for blob storage enables you locate blobs in a container based on a name prefix: to locate all the blobs that contain queue log data for the hour starting at 18:00, you can use the prefix \"queue/2014/07/31/1800.\"  \n\nStorage Analytics buffers log messages internally and then periodically updates the appropriate blob or creates a new one with the latest batch of log entries. This reduces the number of writes it must perform to the blob service.  \n\nIf you are implementing a similar solution in your own application, you must consider how to manage the trade-off between reliability (writing every log entry to blob storage as it happens) and cost and scalability (buffering updates in your application and writing them to blob storage in batches).  \n\n#### Issues and considerations  \n\nConsider the following points when deciding how to store log data:  \n\n-   If you create a table design that avoids potential hot partitions, you may find that you cannot access your log data efficiently.  \n-   To process log data, a client often needs to load many records.  \n-   Although log data is often structured, blob storage may be a better solution.  \n\n### Implementation considerations  \n\nThis section discusses some of the considerations to bear in mind when you implement the patterns described in the previous sections. Most of this section uses examples written in C# that use the Storage Client Library (version 4.3.0 at the time of writing).  \n\n### Retrieving entities  \n\nAs discussed in the section [Design for querying](#design-for-querying),\" the most efficient query is a point query. However, in some scenarios you may need to retrieve multiple entities. This section describes some common approaches to retrieving entities using the Storage Client Library.  \n\n#### Executing a point query using the Storage Client Library  \n\nThe easiest way to execute a point query is to use the **Retrieve** table operation as shown in the following C# code snippet that retrieves an entity with a **PartitionKey** of value \"Sales\" and a **RowKey** of value \"212\":  \n\n    TableOperation retrieveOperation =\n        TableOperation.Retrieve<EmployeeEntity>(\"Sales\", \"212\");\n    var retrieveResult = employeeTable.Execute(retrieveOperation);\n    if (retrieveResult.Result != null)\n    {\n    EmployeeEntity employee = (EmployeeEntity)retrieveResult.Result;\n    ...\n    }  \n\nNotice how this example expects the entity it retrieves to be of type **EmployeeEntity**.  \n\n#### Retrieving multiple entities using LINQ  \n\nYou can retrieve multiple entities by using LINQ with Storage Client Library and specifying a query with a **where** clause. To avoid a table scan, you should always include the **PartitionKey** value in the where clause, and if possible the **RowKey** value to avoid table and partition scans. The table service supports a limited set of comparison operators (greater than, greater than or equal, less than, less than or equal, equal, and not equal) to use in the where clause. The following C# code snippet finds all the employees whose last name starts with \"B\" (assuming that the **RowKey** stores the last name) in the sales department (assuming the **PartitionKey** stores the department name):  \n\n    TableQuery<EmployeeEntity> employeeQuery =\n            employeeTable.CreateQuery<EmployeeEntity>();\n    var query = (from employee in employeeQuery\n                where employee.PartitionKey == \"Sales\" &&\n                employee.RowKey.CompareTo(\"B\") >= 0 &&\n                employee.RowKey.CompareTo(\"C\") < 0\n                select employee).AsTableQuery();\n    var employees = query.Execute();  \n\nNotice how the query specifies both a **RowKey** and a **PartitionKey** to ensure better performance.  \n\nThe following code sample shows equivalent functionality using the fluent API (for more information about fluent APIs in general, see [Best Practices for Designing a Fluent API](http://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)):  \n\n    TableQuery<EmployeeEntity> employeeQuery = new TableQuery<EmployeeEntity>().Where(\n     TableQuery.CombineFilters(\n        TableQuery.CombineFilters(\n        TableQuery.GenerateFilterCondition(\n        \"PartitionKey\", QueryComparisons.Equal, \"Sales\"),\n      TableOperators.And,\n      TableQuery.GenerateFilterCondition(\n        \"RowKey\", QueryComparisons.GreaterThanOrEqual, \"B\")\n    ),\n    TableOperators.And,\n    TableQuery.GenerateFilterCondition(\"RowKey\", QueryComparisons.LessThan, \"C\")\n     )\n    );\n    var employees = employeeTable.ExecuteQuery(employeeQuery);  \n\n\n>[AZURE.NOTE] The sample nests multiple **CombineFilters** methods to include the three filter conditions.  \n\n#### Retrieving large numbers of entities from a query  \n\nAn optimal query returns an individual entity based on a **PartitionKey** value and a **RowKey** value. However, in some scenarios you may have a requirement to return many entities from the same partition or even from many partitions.  \n\nYou should always fully test the performance of your application in such scenarios.  \n\nA query against the table service may return a maximum of 1,000 entities at one time and may execute for a maximum of five seconds. If the result set contains more than 1,000 entities, if the query did not complete within five seconds, or if the query crosses the partition boundary, the Table service returns a continuation token to enable the client application to request the next set of entities. For more information about how continuation tokens work, see [Query Timeout and Pagination](http://msdn.microsoft.com/library/azure/dd135718.aspx) on MSDN.  \n\nIf you are using the Storage Client Library, it can automatically handle continuation tokens for you as it returns entities from the Table service. The following C# code sample using the Storage Client Library automatically handles continuation tokens if the table service returns them in a response:  \n\n    string filter = TableQuery.GenerateFilterCondition(\n        \"PartitionKey\", QueryComparisons.Equal, \"Sales\");\n    TableQuery<EmployeeEntity> employeeQuery =\n        new TableQuery<EmployeeEntity>().Where(filter);\n\n    var employees = employeeTable.ExecuteQuery(employeeQuery);\n    foreach (var emp in employees)\n    {\n        ...\n    }  \n\nThe following C# code handles continuation tokens explicitly:  \n\n    string filter = TableQuery.GenerateFilterCondition(\n        \"PartitionKey\", QueryComparisons.Equal, \"Sales\");\n    TableQuery<EmployeeEntity> employeeQuery =\n        new TableQuery<EmployeeEntity>().Where(filter);\n\n    TableContinuationToken continuationToken = null;\n\n    do\n    {\n        var employees = employeeTable.ExecuteQuerySegmented(\n            employeeQuery, continuationToken);\n    foreach (var emp in employees)\n    {\n     ...\n    }\n    continuationToken = employees.ContinuationToken;\n    } while (continuationToken != null);  \n\nBy using continuation tokens explicitly, you can control when your application retrieves the next segment of data. For example, if your client application enables users to page through the entities stored in a table, a user may decide not to page through all the entities retrieved by the query so your application would only use a continuation token to retrieve the next segment when the user had finished paging through all the entities in the current segment. This approach has several benefits:  \n\n-   It enables you to limit the amount of data to retrieve from the Table service and that you move over the network.  \n-   It enables you to perform asynchronous IO in .NET.  \n-   It enables you to serialize the continuation token to persistent storage so you can continue in the event of an application crash.  \n\n>[AZURE.NOTE] A continuation token typically returns a segment containing 1,000 entities, although it may be fewer. This is also the case if you limit the number of entries a query returns by using **Take** to return the first n entities that match your lookup criteria: the table service may return a segment containing fewer than n entities along with a continuation token to enable you to retrieve the remaining entities.  \n\nThe following C# code shows how to modify the number of entities returned inside a segment:  \n\n    employeeQuery.TakeCount = 50;  \n\n#### Server-side projection  \n\nA single entity can have up to 255 properties and be up to 1 MB in size. When you query the table and retrieve entities, you may not need all the properties and can avoid transferring data unnecessarily (to help reduce latency and cost). You can use server-side projection to transfer just the properties you need. The following example is retrieves just the **Email** property (along with **PartitionKey**, **RowKey**, **Timestamp**, and **ETag**) from the entities selected by the query.  \n\n    string filter = TableQuery.GenerateFilterCondition(\n        \"PartitionKey\", QueryComparisons.Equal, \"Sales\");\n    List<string> columns = new List<string>() { \"Email\" };\n    TableQuery<EmployeeEntity> employeeQuery =\n        new TableQuery<EmployeeEntity>().Where(filter).Select(columns);\n\n    var entities = employeeTable.ExecuteQuery(employeeQuery);\n    foreach (var e in entities)\n    {\n        Console.WriteLine(\"RowKey: {0}, EmployeeEmail: {1}\", e.RowKey, e.Email);\n    }  \n\nNotice how the **RowKey** value is available even though it was not included in the list of properties to retrieve.  \n\n### Modifying entities  \n\nThe Storage Client Library enables you to modify your entities stored in the table service by inserting, deleting, and updating entities. You can use EGTs to batch multiple insert, update, and delete operations together to reduce the number of round trips required and improve the performance of your solution.  \n\nNote that exceptions thrown when the Storage Client Library executes an EGT typically include the index of the entity that caused the batch to fail. This is helpful when you are debugging code that uses EGTs.  \n\nYou should also consider how your design affects how your client application handles concurrency and update operations.  \n\n#### Managing concurrency  \n\nBy default, the table service implements optimistic concurrency checks at the level of individual entities for **Insert**, **Merge**, and **Delete** operations, although it is possible for a client to force the table service to bypass these checks. For more information about how the table service manages concurrency, see  [Managing Concurrency in Microsoft Azure Storage](storage-concurrency.md) on the Microsoft Azure web site.  \n\n#### Merge or replace  \n\nThe **Replace** method of the **TableOperation** class always replaces the complete entity in the Table service. If you do not include a property in the request when that property exists in the stored entity, the request removes that property from the stored entity. Unless you want to remove a property explicitly from a stored entity, you must include every property in the request.  \n\nYou can use the **Merge** method of the **TableOperation** class to reduce the amount of data that you send to the Table service when you want to update an entity. The **Merge** method replaces any properties in the stored entity with property values from the entity included in the request, but leaves intact any properties in the stored entity that are not included in the request. This is useful if you have large entities and only need to update a small number of properties in a request.  \n\n>[AZURE.NOTE] The **Replace** and **Merge** methods fail if the entity does not exist. As an alternative, you can use the **InsertOrReplace** and **InsertOrMerge** methods that create a new entity if it doesn't exist.  \n\n### Working with heterogeneous entity types  \n\nThe Table service is a *schema-less* table store that means that a single table can store entities of multiple types providing great flexibility in your design. The following example illustrates a table storing both employee and department entities:  \n\n<table>\n<tr>\n<th>PartitionKey</th>\n<th>RowKey</th>\n<th>Timestamp</th>\n<th></th>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>\n<table>\n<tr>\n<th>FirstName</th>\n<th>LastName</th>\n<th>Age</th>\n<th>Email</th>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</table>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>\n<table>\n<tr>\n<th>FirstName</th>\n<th>LastName</th>\n<th>Age</th>\n<th>Email</th>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</table>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>\n<table>\n<tr>\n<th>DepartmentName</th>\n<th>EmployeeCount</th>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</table>\n</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>\n<table>\n<tr>\n<th>FirstName</th>\n<th>LastName</th>\n<th>Age</th>\n<th>Email</th>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</table>\n</td>\n</tr>\n</table>\n\nNote that each entity must still have **PartitionKey**, **RowKey**, and **Timestamp** values, but may have any set of properties. Furthermore, there is nothing to indicate the type of an entity unless you choose to store that information somewhere. There are two options for identifying the entity type:  \n\n-   Prepend the entity type to the **RowKey** (or possibly the **PartitionKey**). For example, **EMPLOYEE_000123** or **DEPARTMENT_SALES** as **RowKey** values.  \n-   Use a separate property to record the entity type as shown in the table below.  \n\n<table>\n<tr>\n<th>PartitionKey</th>\n<th>RowKey</th>\n<th>Timestamp</th>\n<th></th>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>\n<table>\n<tr>\n<th>EntityType</th>\n<th>FirstName</th>\n<th>LastName</th>\n<th>Age</th>\n<th>Email</th>\n</tr>\n<tr>\n<td>Employee</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</table>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>\n<table>\n<tr>\n<th>EntityType</th>\n<th>FirstName</th>\n<th>LastName</th>\n<th>Age</th>\n<th>Email</th>\n</tr>\n<tr>\n<td>Employee</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</table>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>\n<table>\n<tr>\n<th>EntityType</th>\n<th>DepartmentName</th>\n<th>EmployeeCount</th>\n</tr>\n<tr>\n<td>Department</td>\n<td></td>\n<td></td>\n</tr>\n</table>\n</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>\n<table>\n<tr>\n<th>EntityType</th>\n<th>FirstName</th>\n<th>LastName</th>\n<th>Age</th>\n<th>Email</th>\n</tr>\n<tr>\n<td>Employee</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</table>\n</td>\n</tr>\n</table>\n\nThe first option, prepending the entity type to the **RowKey**, is useful if there is a possibility that two entities of different types might have the same key value. It also groups entities of the same type together in the partition.  \n\nThe techniques discussed in this section are especially relevant to the discussion [Inheritance relationships](#inheritance-relationships) earlier in this guide in the section [Modelling relationships](#modelling-relationships).  \n\n>[AZURE.NOTE] You should consider including a version number in the entity type value to enable client applications to evolve POCO objects and work with different versions.  \n\nThe remainder of this section describes some of the features in the Storage Client Library that facilitate working with multiple entity types in the same table.  \n\n#### Retrieving heterogeneous entity types  \n\nIf you are using the Storage Client Library, you have three options for working with multiple entity types.  \n\nIf you know the type of the entity stored with a specific **RowKey** and **PartitionKey** values, then you can specify the entity type when you retrieve the entity as shown in the previous two examples that retrieve entities of type **EmployeeEntity**: [Retrieving a single entity using the Storage Client Library](#retrieving-a-single-entity-using-the-storage-client-library) and [Retrieving multiple entities using LINQ](#retrieving-multiple-entities-using-linq).  \n\nThe second option is to use the **DynamicTableEntity** type (a property bag) instead of a concrete POCO entity type (this option may also improve performance because there is no need to serialize and deserialize the entity to .NET types). The following C# code potentially retrieves multiple entities of different types from the table, but returns all entities as **DynamicTableEntity** instances. It then uses the **EntityType** property to determine the type of each entity:  \n\n    string filter =     TableQuery.CombineFilters(\n        TableQuery.GenerateFilterCondition(\"PartitionKey\",\n      QueryComparisons.Equal, \"Sales\"),\n        TableOperators.And,\n        TableQuery.CombineFilters(\n        TableQuery.GenerateFilterCondition(\"RowKey\",\n                    QueryComparisons.GreaterThanOrEqual, \"B\"),\n            TableOperators.And,\n            TableQuery.GenerateFilterCondition(\"RowKey\",\n          QueryComparisons.LessThan, \"F\")\n        )\n    );\n    TableQuery<DynamicTableEntity> entityQuery =\n    new TableQuery<DynamicTableEntity>().Where(filter);\n    var employees = employeeTable.ExecuteQuery(entityQuery);\n\n    IEnumerable<DynamicTableEntity> entities = employeeTable.ExecuteQuery(entityQuery);\n    foreach (var e in entities)\n    {\n    EntityProperty entityTypeProperty;\n    if (e.Properties.TryGetValue(\"EntityType\", out entityTypeProperty))\n    {\n        if (entityTypeProperty.StringValue == \"Employee\")\n        {\n            // Use entityTypeProperty, RowKey, PartitionKey, Etag, and Timestamp\n          }\n     }\n    }  \n\nNote that to retrieve other properties you must use the **TryGetValue** method on the **Properties** property of the **DynamicTableEntity** class.  \n\nA third option is to combine using the **DynamicTableEntity** type and an **EntityResolver** instance. This enables you to resolve to multiple POCO types in the same query. In this example, the **EntityResolver** delegate is using the **EntityType** property to distinguish between the two types of entity that the query returns. The **Resolve** method uses the **resolver** delegate to resolve **DynamicTableEntity** instances to **TableEntity** instances.  \n\n    EntityResolver<TableEntity> resolver = (pk, rk, ts, props, etag) =>\n    {\n\n        TableEntity resolvedEntity = null;\n        if (props[\"EntityType\"].StringValue == \"Department\")\n        {\n            resolvedEntity = new DepartmentEntity();\n        }\n        else if (props[\"EntityType\"].StringValue == \"Employee\")\n        {\n            resolvedEntity = new EmployeeEntity();\n        }\n        else throw new ArgumentException(\"Unrecognized entity\", \"props\");\n\n        resolvedEntity.PartitionKey = pk;\n        resolvedEntity.RowKey = rk;\n        resolvedEntity.Timestamp = ts;\n        resolvedEntity.ETag = etag;\n        resolvedEntity.ReadEntity(props, null);\n        return resolvedEntity;\n    };\n\n    string filter = TableQuery.GenerateFilterCondition(\n        \"PartitionKey\", QueryComparisons.Equal, \"Sales\");\n    TableQuery<DynamicTableEntity> entityQuery =\n        new TableQuery<DynamicTableEntity>().Where(filter);\n\n    var entities = employeeTable.ExecuteQuery(entityQuery, resolver);\n    foreach (var e in entities)\n    {\n        if (e is DepartmentEntity)\n        {\n        ...\n        }\n        if (e is EmployeeEntity)\n        {\n        ...\n        }\n    }  \n\n#### Modifying heterogeneous entity types  \n\nYou do not need to know the type of an entity to delete it, and you always know the type of an entity when you insert it. However, you can use **DynamicTableEntity** type to update an entity without knowing its type and without using a POCO entity class. The following code sample retrieves a single entity, and checks the **EmployeeCount** property exists before updating it.  \n\n    TableResult result =\n        employeeTable.Execute(TableOperation.Retrieve(partitionKey, rowKey));\n    DynamicTableEntity department = (DynamicTableEntity)result.Result;\n\n    EntityProperty countProperty;\n\n    if (!department.Properties.TryGetValue(\"EmployeeCount\", out countProperty))\n    {\n        throw new\n            InvalidOperationException(\"Invalid entity, EmployeeCount property not found.\");\n    }\n    countProperty.Int32Value += 1;\n    employeeTable.Execute(TableOperation.Merge(department));  \n\n### Controlling access with Shared Access Signatures  \n\nYou can use Shared Access Signature (SAS) tokens to enable client applications to modify (and query) table entities directly without the need to authenticate directly with the table service. Typically, there are three main benefits to using SAS in your application:  \n\n-   You do not need to distribute your storage account key to an insecure platform (such as a mobile device) in order to allow that device to access and modify entities in the Table service.  \n-   You can offload some of the work that web and worker roles perform in managing your entities to client devices such as end-user computers and mobile devices.  \n-   You can assign a constrained and time limited set of permissions to a client (such as allowing read-only access to specific resources).  \n\nFor more information about using SAS tokens with the Table service, see [Shared Access Signatures, Part 1: Understanding the SAS Model](../storage-dotnet-shared-access-signature-part-1/).  \n\nHowever, you must still generate the SAS tokens that grant a client application to the entities in the table service: you should do this in an environment that has secure access to your storage account keys. Typically, you use a web or worker role to generate the SAS tokens and deliver them to the client applications that need access to your entities. Because there is still an overhead involved in generating and delivering SAS tokens to clients, you should consider how best to reduce this overhead, especially in high-volume scenarios.  \n\nIt is possible to generate a SAS token that grants access to a subset of the entities in a table. By default, you create a SAS token for an entire table, but it is also possible to specify that the SAS token grant access to either a range of **PartitionKey** values, or a range of **PartitionKey** and **RowKey** values. You might choose to generate SAS tokens for individual users of your system such that each user’s SAS token only allows them access to their own entities in the table service.  \n\n### Asynchronous and parallel operations  \n\nProvided you are spreading your requests across multiple partitions, you can improve throughput and client responsiveness by using asynchronous or parallel queries.\nFor example, you might have two or more worker role instances accessing your tables in parallel. You could have individual worker roles responsible for particular sets of partitions, or simply have multiple worker role instances, each able to access all the partitions in a table.  \n\nWithin a client instance, you can improve throughput by executing storage operations asynchronously. The Storage Client Library makes it easy to write asynchronous queries and modifications. For example, you might start with the synchronous method that retrieves all the entities in a partition as shown in the following C# code:  \n\n    private static void ManyEntitiesQuery(CloudTable employeeTable, string department)\n    {\n        string filter = TableQuery.GenerateFilterCondition(\n            \"PartitionKey\", QueryComparisons.Equal, department);\n        TableQuery<EmployeeEntity> employeeQuery =\n            new TableQuery<EmployeeEntity>().Where(filter);\n\n        TableContinuationToken continuationToken = null;\n\n        do\n        {\n            var employees = employeeTable.ExecuteQuerySegmented(\n                employeeQuery, continuationToken);\n            foreach (var emp in employees)\n        {\n        ...\n        }\n            continuationToken = employees.ContinuationToken;\n        } while (continuationToken != null);\n    }  \n\nYou can easily modify this code so that the query runs asynchronously as follows:  \n\n    private static async Task ManyEntitiesQueryAsync(CloudTable employeeTable, string department)\n    {\n        string filter = TableQuery.GenerateFilterCondition(\n            \"PartitionKey\", QueryComparisons.Equal, department);\n        TableQuery<EmployeeEntity> employeeQuery =\n            new TableQuery<EmployeeEntity>().Where(filter);\n        TableContinuationToken continuationToken = null;\n\n        do\n        {\n            var employees = await employeeTable.ExecuteQuerySegmentedAsync(\n                employeeQuery, continuationToken);\n            foreach (var emp in employees)\n            {\n             ...\n            }\n            continuationToken = employees.ContinuationToken;\n            } while (continuationToken != null);\n    }  \n\nIn this asynchronous example, you can see the following changes from the synchronous version:  \n\n-   The method signature now includes the **async** modifier and returns a **Task** instance.  \n-   Instead of calling the **ExecuteSegmented** method to retrieve results, the method now calls the **ExecuteSegmentedAsync** method and uses the **await** modifier to retrieve results asynchronously.  \n\nThe client application can call this method multiple times (with different values for the **department** parameter), and each query will run on a separate thread.  \n\nNote that there is no asynchronous version of the **Execute** method in the **TableQuery** class because the **IEnumerable** interface does not support asynchronous enumeration.  \n\nYou can also insert, update, and delete entities asynchronously. The following C# example shows a simple, synchronous method to insert or replace an employee entity:  \n\n    private static void SimpleEmployeeUpsert(CloudTable employeeTable,\n        EmployeeEntity employee)\n    {\n        TableResult result = employeeTable\n            .Execute(TableOperation.InsertOrReplace(employee));\n        Console.WriteLine(\"HTTP Status: {0}\", result.HttpStatusCode);\n    }  \n\nYou can easily modify this code so that the update runs asynchronously as follows:  \n\n    private static async Task SimpleEmployeeUpsertAsync(CloudTable employeeTable,\n        EmployeeEntity employee)\n    {\n        TableResult result = await employeeTable\n            .ExecuteAsync(TableOperation.InsertOrReplace(employee));\n        Console.WriteLine(\"HTTP Status: {0}\", result.HttpStatusCode);\n    }  \n\nIn this asynchronous example, you can see the following changes from the synchronous version:  \n\n-   The method signature now includes the **async** modifier and returns a **Task** instance.  \n-   Instead of calling the **Execute** method to update the entity, the method now calls the **ExecuteAsync** method and uses the **await** modifier to retrieve results asynchronously.  \n\nThe client application can call multiple asynchronous methods like this one, and each method invocation will run on a separate thread.  \n\n\n### Credits\nWe would like to thank the following members of the Azure team for their contributions: Dominic Betts, Jason Hogg, Jean Ghanem, Jai Haridas, Jeff Irwin, Vamshidhar Kommineni, Vinay Shah and Serdar Ozler as well as  Tom Hollander from Microsoft DX. \n\nWe would also like to thank the following Microsoft MVP’s for their valuable feedback during review cycles: Igor Papirov and Edward Bakker.\n\n\n\n[1]: ./media/storage-table-design-guide/storage-table-design-IMAGE01.png\n[2]: ./media/storage-table-design-guide/storage-table-design-IMAGE02.png\n[3]: ./media/storage-table-design-guide/storage-table-design-IMAGE03.png\n[4]: ./media/storage-table-design-guide/storage-table-design-IMAGE04.png\n[5]: ./media/storage-table-design-guide/storage-table-design-IMAGE05.png\n[6]: ./media/storage-table-design-guide/storage-table-design-IMAGE06.png\n[7]: ./media/storage-table-design-guide/storage-table-design-IMAGE07.png\n[8]: ./media/storage-table-design-guide/storage-table-design-IMAGE08.png\n[9]: ./media/storage-table-design-guide/storage-table-design-IMAGE09.png\n[10]: ./media/storage-table-design-guide/storage-table-design-IMAGE10.png\n[11]: ./media/storage-table-design-guide/storage-table-design-IMAGE11.png\n[12]: ./media/storage-table-design-guide/storage-table-design-IMAGE12.png\n[13]: ./media/storage-table-design-guide/storage-table-design-IMAGE13.png\n[14]: ./media/storage-table-design-guide/storage-table-design-IMAGE14.png\n[15]: ./media/storage-table-design-guide/storage-table-design-IMAGE15.png\n[16]: ./media/storage-table-design-guide/storage-table-design-IMAGE16.png\n[17]: ./media/storage-table-design-guide/storage-table-design-IMAGE17.png\n[18]: ./media/storage-table-design-guide/storage-table-design-IMAGE18.png\n[19]: ./media/storage-table-design-guide/storage-table-design-IMAGE19.png\n[20]: ./media/storage-table-design-guide/storage-table-design-IMAGE20.png\n[21]: ./media/storage-table-design-guide/storage-table-design-IMAGE21.png\n[22]: ./media/storage-table-design-guide/storage-table-design-IMAGE22.png\n[23]: ./media/storage-table-design-guide/storage-table-design-IMAGE23.png\n[24]: ./media/storage-table-design-guide/storage-table-design-IMAGE24.png\n[25]: ./media/storage-table-design-guide/storage-table-design-IMAGE25.png\n[26]: ./media/storage-table-design-guide/storage-table-design-IMAGE26.png\n[27]: ./media/storage-table-design-guide/storage-table-design-IMAGE27.png\n[28]: ./media/storage-table-design-guide/storage-table-design-IMAGE28.png\n[29]: ./media/storage-table-design-guide/storage-table-design-IMAGE29.png\n "
}