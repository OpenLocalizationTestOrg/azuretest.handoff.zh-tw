{
  "nodes": [
    {
      "content": "Retry service specific guidance | Microsoft Azure",
      "pos": [
        26,
        75
      ]
    },
    {
      "content": "Service specific guidance for setting the retry mechanism.",
      "pos": [
        93,
        151
      ]
    },
    {
      "content": "Retry service specific guidance",
      "pos": [
        439,
        470
      ]
    },
    {
      "content": "Overview",
      "pos": [
        538,
        546
      ]
    },
    {
      "content": "Most Azure services and client SDKs include a retry mechanism.",
      "pos": [
        548,
        610
      ]
    },
    {
      "content": "However, these differ because each service has different characteristics and requirements, and so each retry mechanism is tuned to a specific service.",
      "pos": [
        611,
        761
      ]
    },
    {
      "content": "This guide summarizes the retry mechanism features for the majority of Azure services, and includes information to help you use, adapt, or extend the retry mechanism for that service.",
      "pos": [
        762,
        945
      ]
    },
    {
      "pos": [
        947,
        1124
      ],
      "content": "For general guidance on handling transient faults, and retrying connections and operations against services and resources, see <bpt id=\"p1\">[</bpt>Retry guidance<ept id=\"p1\">](best-practices-retry-general.md)</ept>."
    },
    {
      "content": "The following table summarizes the retry features for the Azure services described in this guidance.",
      "pos": [
        1126,
        1226
      ]
    },
    {
      "content": "Service",
      "pos": [
        1232,
        1239
      ]
    },
    {
      "content": "Retry capabilities",
      "pos": [
        1272,
        1290
      ]
    },
    {
      "content": "Policy configuration",
      "pos": [
        1314,
        1334
      ]
    },
    {
      "content": "Scope",
      "pos": [
        1345,
        1350
      ]
    },
    {
      "content": "Telemetry features",
      "pos": [
        1396,
        1414
      ]
    },
    {
      "content": "AzureStorage",
      "pos": [
        1614,
        1626
      ]
    },
    {
      "content": "Native in client",
      "pos": [
        1686,
        1702
      ]
    },
    {
      "content": "Programmatic",
      "pos": [
        1728,
        1740
      ]
    },
    {
      "content": "Client and individual operations",
      "pos": [
        1759,
        1791
      ]
    },
    {
      "content": "TraceSource",
      "pos": [
        1810,
        1821
      ]
    },
    {
      "content": "SQL Database with Entity Framework",
      "pos": [
        1840,
        1874
      ]
    },
    {
      "content": "Native in client",
      "pos": [
        1937,
        1953
      ]
    },
    {
      "content": "Programmatic",
      "pos": [
        1979,
        1991
      ]
    },
    {
      "content": "Global per AppDomain",
      "pos": [
        2010,
        2030
      ]
    },
    {
      "content": "None",
      "pos": [
        2061,
        2065
      ]
    },
    {
      "content": "SQL Database with ADO.NET",
      "pos": [
        2091,
        2116
      ]
    },
    {
      "content": "Topaz*",
      "pos": [
        2176,
        2182
      ]
    },
    {
      "content": "Declarative and programmatic",
      "pos": [
        2218,
        2246
      ]
    },
    {
      "content": "Single statements or blocks of code",
      "pos": [
        2249,
        2284
      ]
    },
    {
      "content": "Custom",
      "pos": [
        2300,
        2306
      ]
    },
    {
      "content": "Service Bus",
      "pos": [
        2330,
        2341
      ]
    },
    {
      "content": "Native in client",
      "pos": [
        2400,
        2416
      ]
    },
    {
      "content": "Programmatic",
      "pos": [
        2442,
        2454
      ]
    },
    {
      "content": "Namespace Manager, Messaging Factory, and Client",
      "pos": [
        2473,
        2521
      ]
    },
    {
      "content": "ETW",
      "pos": [
        2524,
        2527
      ]
    },
    {
      "content": "Cache",
      "pos": [
        2554,
        2559
      ]
    },
    {
      "content": "Native in client",
      "pos": [
        2624,
        2640
      ]
    },
    {
      "content": "Programmatic",
      "pos": [
        2666,
        2678
      ]
    },
    {
      "content": "Client",
      "pos": [
        2697,
        2703
      ]
    },
    {
      "content": "TextWriter",
      "pos": [
        2748,
        2758
      ]
    },
    {
      "content": "DocumentDB",
      "pos": [
        2778,
        2788
      ]
    },
    {
      "content": "Native in service",
      "pos": [
        2859,
        2876
      ]
    },
    {
      "content": "Non-configurable",
      "pos": [
        2901,
        2917
      ]
    },
    {
      "content": "Global",
      "pos": [
        2932,
        2938
      ]
    },
    {
      "content": "TraceSource",
      "pos": [
        2983,
        2994
      ]
    },
    {
      "content": "Search",
      "pos": [
        3013,
        3019
      ]
    },
    {
      "content": "Topaz* (with custom detection strategy)",
      "pos": [
        3078,
        3117
      ]
    },
    {
      "content": "Declarative and programmatic",
      "pos": [
        3120,
        3148
      ]
    },
    {
      "content": "Blocks of code",
      "pos": [
        3151,
        3165
      ]
    },
    {
      "content": "Custom",
      "pos": [
        3202,
        3208
      ]
    },
    {
      "content": "Active Directory",
      "pos": [
        3232,
        3248
      ]
    },
    {
      "content": "Topaz* (with custom detection strategy)",
      "pos": [
        3313,
        3352
      ]
    },
    {
      "content": "Declarative and programmatic",
      "pos": [
        3355,
        3383
      ]
    },
    {
      "content": "Blocks of code",
      "pos": [
        3386,
        3400
      ]
    },
    {
      "content": "Custom",
      "pos": [
        3437,
        3443
      ]
    },
    {
      "content": "*Topaz in the friendly name for the Transient Fault Handling Application Block that is included in <ph id=\"ph1\">&lt;a href=\"http://msdn.microsoft.com/library/dn440719.aspx\"&gt;</ph>Enterprise Library 6.0<ph id=\"ph2\">&lt;/a&gt;</ph>.",
      "pos": [
        3462,
        3646
      ]
    },
    {
      "content": "You can use a custom detection strategy with Topaz for most types of services, as described in this guidance.",
      "pos": [
        3647,
        3756
      ]
    },
    {
      "content": "Default strategies for Topaz are shown in the section <bpt id=\"p1\">[</bpt>Transient Fault Handling Application Block (Topaz) strategies<ept id=\"p1\">](#transient-fault-handling-application-block-topaz-strategies)</ept> at the end of this guidance.",
      "pos": [
        3757,
        3965
      ]
    },
    {
      "content": "Note that the block is now an open-sourced framework and is not directly supported by Microsoft.",
      "pos": [
        3966,
        4062
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> For most of the Azure built-in retry mechanisms, there is currently no way apply a different retry policy for different types of error or exception beyond the functionality include in the retry policy.",
      "pos": [
        4066,
        4280
      ]
    },
    {
      "content": "Therefore, the best guidance available at the time of writing is to configure a policy that provides the optimum average performance and availability.",
      "pos": [
        4281,
        4431
      ]
    },
    {
      "content": "One way to fine-tune the policy is to analyze log files to determine the type of transient faults that are occurring.",
      "pos": [
        4432,
        4549
      ]
    },
    {
      "content": "For example, if the majority of errors are related to network connectivity issues, you might attempt an immediate retry rather than wait a long time for the first retry.",
      "pos": [
        4550,
        4719
      ]
    },
    {
      "content": "Azure Storage retry guidelines",
      "pos": [
        4724,
        4754
      ]
    },
    {
      "content": "Azure storage services include table and blob storage, files, and storage queues.",
      "pos": [
        4756,
        4837
      ]
    },
    {
      "content": "Retry mechanism",
      "pos": [
        4843,
        4858
      ]
    },
    {
      "content": "Retries occur at the individual REST operation level and are an integral part of the client API implementation.",
      "pos": [
        4860,
        4971
      ]
    },
    {
      "content": "The client storage SDK uses classes that implement the <bpt id=\"p1\">[</bpt>IExtendedRetryPolicy Interface<ept id=\"p1\">](http://msdn.microsoft.com/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.aspx)</ept>.",
      "pos": [
        4972,
        5166
      ]
    },
    {
      "content": "There are different implementations of the interface.",
      "pos": [
        5168,
        5221
      ]
    },
    {
      "content": "Storage clients can choose from policies specifically designed for accessing tables, blobs, and queues.",
      "pos": [
        5222,
        5325
      ]
    },
    {
      "content": "Each implementation uses a different retry strategy that essentially defines the retry interval and other details.",
      "pos": [
        5326,
        5440
      ]
    },
    {
      "content": "The built-in classes provide support for linear (constant delay) and exponential with randomization retry intervals.",
      "pos": [
        5442,
        5558
      ]
    },
    {
      "content": "There is also a no retry policy for use when another process is handling retries at a higher level.",
      "pos": [
        5559,
        5658
      ]
    },
    {
      "content": "However, you can implement your own retry classes if you have specific requirements not provided by the built-in classes.",
      "pos": [
        5659,
        5780
      ]
    },
    {
      "content": "Alternate retries switch between primary and secondary storage service location if you are using read access geo-redundant storage (RA-GRS) and the result of the request is a retryable error.",
      "pos": [
        5782,
        5973
      ]
    },
    {
      "content": "See <bpt id=\"p1\">[</bpt>Azure Storage Redundancy Options<ept id=\"p1\">](http://msdn.microsoft.com/library/azure/dn727290.aspx)</ept> for more information.",
      "pos": [
        5974,
        6089
      ]
    },
    {
      "content": "Policy configuration (Azure storage)",
      "pos": [
        6095,
        6131
      ]
    },
    {
      "content": "Retry policies are configured programmatically.",
      "pos": [
        6133,
        6180
      ]
    },
    {
      "content": "A typical procedure is to create and populate a <bpt id=\"p1\">**</bpt>TableRequestOptions<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>BlobRequestOptions<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>FileRequestOptions<ept id=\"p3\">**</ept>, or <bpt id=\"p4\">**</bpt>QueueRequestOptions<ept id=\"p4\">**</ept> instance.",
      "pos": [
        6181,
        6338
      ]
    },
    {
      "content": "The request options instance can then be set on the client, and all operations with the client will use the specified request options.",
      "pos": [
        6804,
        6938
      ]
    },
    {
      "content": "You can override the client request options by passing a populated instance of the request options class as a parameter to operation methods.",
      "pos": [
        7061,
        7202
      ]
    },
    {
      "content": "You use an <bpt id=\"p1\">**</bpt>OperationContext<ept id=\"p1\">**</ept> instance to specify the code to execute when a retry occurs and when an operation has completed.",
      "pos": [
        7316,
        7444
      ]
    },
    {
      "content": "This code can collect information about the operation for use in logs and telemetry.",
      "pos": [
        7445,
        7529
      ]
    },
    {
      "content": "In addition to indicating whether a failure is suitable for retry, the extended retry policies return a <bpt id=\"p1\">**</bpt>RetryContext<ept id=\"p1\">**</ept> object that indicates the number of retries, the results of the last request, whether the next retry will happen in the primary or secondary location (see table below for details).",
      "pos": [
        7943,
        8244
      ]
    },
    {
      "content": "The properties of the <bpt id=\"p1\">**</bpt>RetryContext<ept id=\"p1\">**</ept> object can be used to decide if and when to attempt a retry.",
      "pos": [
        8245,
        8344
      ]
    },
    {
      "content": "For more details, see <bpt id=\"p1\">[</bpt>IExtendedRetryPolicy.Evaluate Method<ept id=\"p1\">](http://msdn.microsoft.com/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx)</ept>.",
      "pos": [
        8345,
        8521
      ]
    },
    {
      "content": "The following table shows the default settings for the built-in retry policies.",
      "pos": [
        8523,
        8602
      ]
    },
    {
      "content": "Context",
      "pos": [
        8608,
        8615
      ]
    },
    {
      "content": "Setting",
      "pos": [
        8635,
        8642
      ]
    },
    {
      "content": "Default value",
      "pos": [
        8697,
        8710
      ]
    },
    {
      "content": "Meaning",
      "pos": [
        8734,
        8741
      ]
    },
    {
      "content": "Table / Blob / File",
      "pos": [
        10294,
        10313
      ]
    },
    {
      "content": "QueueRequestOptions",
      "pos": [
        10319,
        10338
      ]
    },
    {
      "content": "MaximumExecutionTime",
      "pos": [
        10341,
        10361
      ]
    },
    {
      "content": "ServerTimeout",
      "pos": [
        10373,
        10386
      ]
    },
    {
      "content": "LocationMode",
      "pos": [
        10416,
        10428
      ]
    },
    {
      "content": "RetryPolicy",
      "pos": [
        10470,
        10481
      ]
    },
    {
      "content": "120 seconds",
      "pos": [
        10484,
        10495
      ]
    },
    {
      "content": "None",
      "pos": [
        10507,
        10511
      ]
    },
    {
      "content": "ExponentialPolicy",
      "pos": [
        10583,
        10600
      ]
    },
    {
      "content": "Maximum execution time for the request, including all potential retry attempts.",
      "pos": [
        10603,
        10682
      ]
    },
    {
      "content": "Server timeout interval for the request (value is rounded to seconds).",
      "pos": [
        10688,
        10758
      ]
    },
    {
      "content": "If not specified, it will use the default value for all requests to the server.",
      "pos": [
        10759,
        10838
      ]
    },
    {
      "content": "Usually, the best option is to omit this setting so that the server default is used.",
      "pos": [
        10839,
        10923
      ]
    },
    {
      "content": "If the storage account is created with the Read access geo-redundant storage (RA-GRS) replication option, you can use the location mode to indicate which location should receive the request.",
      "pos": [
        10929,
        11119
      ]
    },
    {
      "content": "For example, if <bpt id=\"p1\">**</bpt>PrimaryThenSecondary<ept id=\"p1\">**</ept> is specified, requests are always sent to the primary location first.",
      "pos": [
        11120,
        11230
      ]
    },
    {
      "content": "If a request fails, it is sent to the secondary location.",
      "pos": [
        11231,
        11288
      ]
    },
    {
      "content": "See below for details of each option.",
      "pos": [
        11294,
        11331
      ]
    },
    {
      "content": "Exponential policy",
      "pos": [
        11336,
        11354
      ]
    },
    {
      "content": "maxAttempt",
      "pos": [
        11378,
        11388
      ]
    },
    {
      "content": "deltaBackoff",
      "pos": [
        11394,
        11406
      ]
    },
    {
      "content": "MinBackoff",
      "pos": [
        11424,
        11434
      ]
    },
    {
      "content": "MaxBackoff",
      "pos": [
        11446,
        11456
      ]
    },
    {
      "content": "3",
      "pos": [
        11473,
        11474
      ]
    },
    {
      "content": "4 seconds",
      "pos": [
        11480,
        11489
      ]
    },
    {
      "content": "3 seconds",
      "pos": [
        11507,
        11516
      ]
    },
    {
      "content": "30 seconds",
      "pos": [
        11528,
        11538
      ]
    },
    {
      "content": "Number of retry attempts.",
      "pos": [
        11543,
        11568
      ]
    },
    {
      "content": "Back-off interval between retries.",
      "pos": [
        11574,
        11608
      ]
    },
    {
      "content": "Multiples of this timespan, including a random element, will be used for subsequent retry attempts.",
      "pos": [
        11609,
        11708
      ]
    },
    {
      "content": "Added to all retry intervals computed from deltaBackoff.",
      "pos": [
        11714,
        11770
      ]
    },
    {
      "content": "This value cannot be changed.",
      "pos": [
        11771,
        11800
      ]
    },
    {
      "content": "MaxBackoff is used if the computed retry interval is greater than MaxBackoff.",
      "pos": [
        11806,
        11883
      ]
    },
    {
      "content": "This value cannot be changed.",
      "pos": [
        11884,
        11913
      ]
    },
    {
      "content": "Linear policy",
      "pos": [
        12276,
        12289
      ]
    },
    {
      "content": "maxAttempt",
      "pos": [
        12318,
        12328
      ]
    },
    {
      "content": "deltaBackoff",
      "pos": [
        12334,
        12346
      ]
    },
    {
      "content": "3",
      "pos": [
        12385,
        12386
      ]
    },
    {
      "content": "30 seconds",
      "pos": [
        12392,
        12402
      ]
    },
    {
      "content": "Number of retry attempts.",
      "pos": [
        12437,
        12462
      ]
    },
    {
      "content": "Back-off interval between retries.",
      "pos": [
        12468,
        12502
      ]
    },
    {
      "content": "Retry usage guidance",
      "pos": [
        13163,
        13183
      ]
    },
    {
      "content": "Consider the following guidelines when accessing Azure storage services using the storage client API:",
      "pos": [
        13184,
        13285
      ]
    },
    {
      "content": "Use the built-in retry policies from the Microsoft.WindowsAzure.Storage.RetryPolicies namespace where they are appropriate for your requirements.",
      "pos": [
        13289,
        13434
      ]
    },
    {
      "content": "In most cases, these policies will be sufficient.",
      "pos": [
        13435,
        13484
      ]
    },
    {
      "content": "Use the <bpt id=\"p1\">**</bpt>ExponentialRetry<ept id=\"p1\">**</ept> policy in batch operations, background tasks, or non-interactive scenarios.",
      "pos": [
        13487,
        13591
      ]
    },
    {
      "content": "In these scenarios, you can typically allow more time for the service to recover—with a consequently increased chance of the operation eventually succeeding.",
      "pos": [
        13592,
        13749
      ]
    },
    {
      "pos": [
        13752,
        13968
      ],
      "content": "Consider specifying the <bpt id=\"p1\">**</bpt>MaximumExecutionTime<ept id=\"p1\">**</ept> property of the <bpt id=\"p2\">**</bpt>RequestOptions<ept id=\"p2\">**</ept> parameter to limit the total execution time, but take into account the type and size of the operation when choosing a timeout value."
    },
    {
      "content": "If you need to implement a custom retry, avoid creating wrappers around the storage client classes.",
      "pos": [
        13971,
        14070
      ]
    },
    {
      "content": "Instead, use the capabilities to extend the existing policies through the <bpt id=\"p1\">**</bpt>IExtendedRetryPolicy<ept id=\"p1\">**</ept> interface.",
      "pos": [
        14071,
        14180
      ]
    },
    {
      "content": "If you are using read access geo-redundant storage (RA-GRS) you can use the <bpt id=\"p1\">**</bpt>LocationMode<ept id=\"p1\">**</ept> to specify that retry attempts will access the secondary read-only copy of the store should the primary access fail.",
      "pos": [
        14183,
        14392
      ]
    },
    {
      "content": "However, when using this option you must ensure that your application can work successfully with data that may be stale if the replication from the primary store has not yet completed.",
      "pos": [
        14393,
        14577
      ]
    },
    {
      "content": "Consider starting with following settings for retrying operations.",
      "pos": [
        14579,
        14645
      ]
    },
    {
      "content": "These are general purpose settings, and you should monitor the operations and fine tune the values to suit your own scenario.",
      "pos": [
        14646,
        14771
      ]
    },
    {
      "content": "Context",
      "pos": [
        14779,
        14786
      ]
    },
    {
      "content": "Sample target E2E",
      "pos": [
        14802,
        14819
      ]
    },
    {
      "content": "max latency",
      "pos": [
        14825,
        14836
      ]
    },
    {
      "content": "Retry policy",
      "pos": [
        14843,
        14855
      ]
    },
    {
      "content": "Settings",
      "pos": [
        14862,
        14870
      ]
    },
    {
      "content": "Values",
      "pos": [
        14888,
        14894
      ]
    },
    {
      "content": "How it works",
      "pos": [
        14902,
        14914
      ]
    },
    {
      "content": "Interactive, UI,",
      "pos": [
        15178,
        15194
      ]
    },
    {
      "content": "or foreground",
      "pos": [
        15200,
        15213
      ]
    },
    {
      "content": "2 seconds",
      "pos": [
        15216,
        15225
      ]
    },
    {
      "content": "Linear",
      "pos": [
        15252,
        15258
      ]
    },
    {
      "content": "maxAttempt",
      "pos": [
        15271,
        15281
      ]
    },
    {
      "content": "deltaBackoff",
      "pos": [
        15287,
        15299
      ]
    },
    {
      "content": "3",
      "pos": [
        15302,
        15303
      ]
    },
    {
      "content": "500 ms",
      "pos": [
        15309,
        15315
      ]
    },
    {
      "content": "Attempt 1 - delay 500 ms",
      "pos": [
        15321,
        15345
      ]
    },
    {
      "content": "Attempt 2 - delay 500 ms",
      "pos": [
        15351,
        15375
      ]
    },
    {
      "content": "Attempt 3 - delay 500 ms",
      "pos": [
        15381,
        15405
      ]
    },
    {
      "content": "Background",
      "pos": [
        15411,
        15421
      ]
    },
    {
      "content": "or batch",
      "pos": [
        15427,
        15435
      ]
    },
    {
      "content": "30 seconds",
      "pos": [
        15449,
        15459
      ]
    },
    {
      "content": "Exponential",
      "pos": [
        15485,
        15496
      ]
    },
    {
      "content": "maxAttempt",
      "pos": [
        15504,
        15514
      ]
    },
    {
      "content": "deltaBackoff",
      "pos": [
        15520,
        15532
      ]
    },
    {
      "content": "5",
      "pos": [
        15535,
        15536
      ]
    },
    {
      "content": "4 seconds",
      "pos": [
        15542,
        15551
      ]
    },
    {
      "content": "Attempt 1 - delay ~3 sec",
      "pos": [
        15554,
        15578
      ]
    },
    {
      "content": "Attempt 2 - delay ~7 sec",
      "pos": [
        15584,
        15608
      ]
    },
    {
      "content": "Attempt 3 - delay ~15 sec",
      "pos": [
        15614,
        15639
      ]
    },
    {
      "content": "Telemetry",
      "pos": [
        15646,
        15655
      ]
    },
    {
      "content": "Retry attempts are logged to a <bpt id=\"p1\">**</bpt>TraceSource<ept id=\"p1\">**</ept>.",
      "pos": [
        15657,
        15704
      ]
    },
    {
      "content": "You must configure a <bpt id=\"p1\">**</bpt>TraceListener<ept id=\"p1\">**</ept> to capture the events and write them to a suitable destination log.",
      "pos": [
        15705,
        15811
      ]
    },
    {
      "content": "You can use the <bpt id=\"p1\">**</bpt>TextWriterTraceListener<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>XmlWriterTraceListener<ept id=\"p2\">**</ept> to write the data to a log file, the <bpt id=\"p3\">**</bpt>EventLogTraceListener<ept id=\"p3\">**</ept> to write to the Windows Event Log, or the <bpt id=\"p4\">**</bpt>EventProviderTraceListener<ept id=\"p4\">**</ept> to write trace data to the ETW subsystem.",
      "pos": [
        15812,
        16063
      ]
    },
    {
      "content": "You can also configure auto-flushing of the buffer, and the verbosity of events that will be logged (for example, Error, Warning, Informational, and Verbose).",
      "pos": [
        16064,
        16222
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Client-side Logging with the .NET Storage Client Library<ept id=\"p1\">](http://msdn.microsoft.com/library/azure/dn782839.aspx)</ept>.",
      "pos": [
        16223,
        16363
      ]
    },
    {
      "content": "Operations can receive an <bpt id=\"p1\">**</bpt>OperationContext<ept id=\"p1\">**</ept> instance, which exposes a <bpt id=\"p2\">**</bpt>Retrying<ept id=\"p2\">**</ept> event that can be used to attach custom telemetry logic.",
      "pos": [
        16365,
        16507
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>OperationContext.Retrying Event<ept id=\"p1\">](http://msdn.microsoft.com/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx)</ept>.",
      "pos": [
        16508,
        16665
      ]
    },
    {
      "content": "Examples (Azure storage)",
      "pos": [
        16670,
        16694
      ]
    },
    {
      "content": "The following code example shows how to create two <bpt id=\"p1\">**</bpt>TableRequestOptions<ept id=\"p1\">**</ept> instances with different retry settings; one for interactive requests and one for background requests.",
      "pos": [
        16696,
        16873
      ]
    },
    {
      "content": "The example then sets these two retry policies on the client so that they apply for all requests, and also sets the interactive strategy on a specific request so that it overrides the default settings applied to the client.",
      "pos": [
        16874,
        17097
      ]
    },
    {
      "content": "More information",
      "pos": [
        20205,
        20221
      ]
    },
    {
      "content": "Azure Storage Client Library Retry Policy Recommendations",
      "pos": [
        20226,
        20283
      ]
    },
    {
      "content": "Storage Client Library 2.0 – Implementing Retry Policies",
      "pos": [
        20391,
        20447
      ]
    },
    {
      "content": "SQL Database using Entity Framework 6 retry guidelines",
      "pos": [
        20545,
        20599
      ]
    },
    {
      "content": "SQL Database is a hosted SQL database available in a range of sizes and as both a standard (shared) and premium (non-shared) service.",
      "pos": [
        20601,
        20734
      ]
    },
    {
      "content": "Entity Framework is an object-relational mapper that enables .NET developers to work with relational data using domain-specific objects.",
      "pos": [
        20735,
        20871
      ]
    },
    {
      "content": "It eliminates the need for most of the data-access code that developers usually need to write.",
      "pos": [
        20872,
        20966
      ]
    },
    {
      "content": "Retry mechanism",
      "pos": [
        20971,
        20986
      ]
    },
    {
      "content": "Retry support is provided when accessing SQL Database using Entity Framework 6.0 and higher through a mechanism called <bpt id=\"p1\">[</bpt>Connection Resiliency / Retry Logic<ept id=\"p1\">](http://msdn.microsoft.com/data/dn456835.aspx)</ept>.",
      "pos": [
        20988,
        21191
      ]
    },
    {
      "content": "A full specification is available in the <bpt id=\"p1\">[</bpt>.NET Entity Framework wiki<ept id=\"p1\">](https://entityframework.codeplex.com/wikipage?title=Connection%20Resiliency%20Spec)</ept> on Codeplex.",
      "pos": [
        21192,
        21358
      ]
    },
    {
      "content": "The main features of the retry mechanism are:",
      "pos": [
        21359,
        21404
      ]
    },
    {
      "content": "The primary abstraction is the <bpt id=\"p1\">**</bpt>IDbExecutionStrategy<ept id=\"p1\">**</ept> interface.",
      "pos": [
        21408,
        21474
      ]
    },
    {
      "content": "This interface:",
      "pos": [
        21475,
        21490
      ]
    },
    {
      "pos": [
        21495,
        21553
      ],
      "content": "Defines synchronous and asynchronous <bpt id=\"p1\">**</bpt>Execute<ept id=\"p1\">**</ept>* methods."
    },
    {
      "content": "Defines classes that can be used directly or can be configured on a database context as a default strategy, mapped to provider name, or mapped to a provider name and server name.",
      "pos": [
        21558,
        21736
      ]
    },
    {
      "content": "When configured on a context, retries occur at the level of individual database operations, of which there might be several for a given context operation.",
      "pos": [
        21737,
        21891
      ]
    },
    {
      "content": "Defines when to retry a failed connection, and how.",
      "pos": [
        21896,
        21947
      ]
    },
    {
      "pos": [
        21950,
        22037
      ],
      "content": "It includes several built-in implementations of the <bpt id=\"p1\">**</bpt>IDbExecutionStrategy<ept id=\"p1\">**</ept> interface:"
    },
    {
      "content": "Default - no retrying.",
      "pos": [
        22042,
        22064
      ]
    },
    {
      "content": "Default for SQL Database (automatic) - no retrying, but inspects exceptions and wraps them with suggestion to use the SQL Database strategy.",
      "pos": [
        22069,
        22209
      ]
    },
    {
      "content": "Default for SQL Database - exponential (inherited from base class) plus SQL Database detection logic.",
      "pos": [
        22214,
        22315
      ]
    },
    {
      "content": "It implements an exponential back-off strategy that includes randomization.",
      "pos": [
        22318,
        22393
      ]
    },
    {
      "content": "The built-in retry classes are stateful and are not thread safe.",
      "pos": [
        22396,
        22460
      ]
    },
    {
      "content": "However, they can be reused after the current operation is completed.",
      "pos": [
        22461,
        22530
      ]
    },
    {
      "content": "If the specified retry count is exceeded, the results are wrapped in a new exception.",
      "pos": [
        22533,
        22618
      ]
    },
    {
      "content": "It does not bubble up the current exception.",
      "pos": [
        22619,
        22663
      ]
    },
    {
      "content": "Policy configuration (SQL Database using Entity Framework 6)",
      "pos": [
        22668,
        22728
      ]
    },
    {
      "content": "Retry support is provided when accessing SQL Database using Entity Framework 6.0 and higher.",
      "pos": [
        22730,
        22822
      ]
    },
    {
      "content": "Retry policies are configured programmatically.",
      "pos": [
        22823,
        22870
      ]
    },
    {
      "content": "The configuration cannot be changed on a per-operation basis.",
      "pos": [
        22871,
        22932
      ]
    },
    {
      "content": "When configuring a strategy on the context as the default, you specify a function that creates a new strategy on demand.",
      "pos": [
        22934,
        23054
      ]
    },
    {
      "content": "The following code shows how you can create a retry configuration class that extends the <bpt id=\"p1\">**</bpt>DbConfiguration<ept id=\"p1\">**</ept> base class.",
      "pos": [
        23055,
        23175
      ]
    },
    {
      "content": "You can then specify this as the default retry strategy for all operations using the <bpt id=\"p1\">**</bpt>SetConfiguration<ept id=\"p1\">**</ept> method of the <bpt id=\"p2\">**</bpt>DbConfiguration<ept id=\"p2\">**</ept> instance when the application starts.",
      "pos": [
        23523,
        23700
      ]
    },
    {
      "content": "By default, EF will automatically discover and use the configuration class.",
      "pos": [
        23701,
        23776
      ]
    },
    {
      "content": "You can specify the retry configuration class for a context by annotating the context class with a <bpt id=\"p1\">**</bpt>DbConfigurationType<ept id=\"p1\">**</ept> attribute.",
      "pos": [
        23853,
        23986
      ]
    },
    {
      "content": "However, if you have only one configuration class, EF will use it without the need to annotate the context.",
      "pos": [
        23987,
        24094
      ]
    },
    {
      "content": "If you need to use different retry strategies for specific operations, or disable retries for specific operations, you can create a configuration class that allows you to suspend or swap strategies by setting a flag in the <bpt id=\"p1\">**</bpt>CallContext<ept id=\"p1\">**</ept>.",
      "pos": [
        24216,
        24455
      ]
    },
    {
      "content": "The configuration class can use this flag to switch strategies, or disable the strategy you provide and use a default strategy.",
      "pos": [
        24456,
        24583
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Suspend Execution Strategy<ept id=\"p1\">](http://msdn.microsoft.com/dn307226#transactions_workarounds)</ept> in the page Limitations with Retrying Execution Strategies (EF6 onwards).",
      "pos": [
        24584,
        24773
      ]
    },
    {
      "content": "Another technique for using specific retry strategies for individual operations is to create an instance of the required strategy class and supply the desired settings through parameters.",
      "pos": [
        24775,
        24962
      ]
    },
    {
      "content": "You then invoke its <bpt id=\"p1\">**</bpt>ExecuteAsync<ept id=\"p1\">**</ept> method.",
      "pos": [
        24963,
        25007
      ]
    },
    {
      "content": "The simplest way to use a <bpt id=\"p1\">**</bpt>DbConfiguration<ept id=\"p1\">**</ept> class is to locate it in the same assembly as the <bpt id=\"p2\">**</bpt>DbContext<ept id=\"p2\">**</ept> class.",
      "pos": [
        25387,
        25503
      ]
    },
    {
      "content": "However, this is not appropriate when the same context is required in different scenarios, such as different interactive and background retry strategies.",
      "pos": [
        25504,
        25657
      ]
    },
    {
      "content": "If the different contexts execute in separate AppDomains, you can use the built-in support for specifying configuration classes in the configuration file or set it explicitly using code.",
      "pos": [
        25658,
        25844
      ]
    },
    {
      "content": "If the different contexts must execute in the same AppDomain, a custom solution will be required.",
      "pos": [
        25845,
        25942
      ]
    },
    {
      "pos": [
        25944,
        26057
      ],
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Code-Based Configuration (EF6 onwards)<ept id=\"p1\">](http://msdn.microsoft.com/data/jj680699.aspx)</ept>."
    },
    {
      "content": "The following table shows the default settings for the built-in retry policy when using EF6.",
      "pos": [
        26059,
        26151
      ]
    },
    {
      "content": "Retry usage guidance",
      "pos": [
        26244,
        26264
      ]
    },
    {
      "content": "Consider the following guidelines when accessing SQL Database using EF6:",
      "pos": [
        26266,
        26338
      ]
    },
    {
      "content": "Choose the appropriate service option (shared or premium).",
      "pos": [
        26342,
        26400
      ]
    },
    {
      "content": "A shared instance may suffer longer than usual connection delays and throttling due to the usage by other tenants of the shared server.",
      "pos": [
        26401,
        26536
      ]
    },
    {
      "content": "If predictable performance and reliable low latency operations are required, consider choosing the premium option.",
      "pos": [
        26537,
        26651
      ]
    },
    {
      "content": "A fixed interval strategy is not recommended for use with Azure SQL Database.",
      "pos": [
        26654,
        26731
      ]
    },
    {
      "content": "Instead, use an exponential back-off strategy because the service may be overloaded, and longer delays allow more time for it to recover.",
      "pos": [
        26732,
        26869
      ]
    },
    {
      "content": "Choose a suitable value for the connection and command timeouts when defining connections.",
      "pos": [
        26872,
        26962
      ]
    },
    {
      "content": "Base the timeout on both your business logic design and through testing.",
      "pos": [
        26963,
        27035
      ]
    },
    {
      "content": "You may need to modify this value over time as the volumes of data or the business processes change.",
      "pos": [
        27036,
        27136
      ]
    },
    {
      "content": "Too short a timeout may result in premature failures of connections when the database is busy.",
      "pos": [
        27137,
        27231
      ]
    },
    {
      "content": "Too long a timeout may prevent the retry logic working correctly by waiting too long before detecting a failed connection.",
      "pos": [
        27232,
        27354
      ]
    },
    {
      "content": "The value of the timeout is a component of the end-to-end latency, although you cannot easily determine how many commands will execute when saving the context.",
      "pos": [
        27355,
        27514
      ]
    },
    {
      "content": "You can change the default timeout by setting the <bpt id=\"p1\">**</bpt>CommandTimeout<ept id=\"p1\">**</ept> property of the <bpt id=\"p2\">**</bpt>DbContext<ept id=\"p2\">**</ept> instance.",
      "pos": [
        27515,
        27623
      ]
    },
    {
      "content": "Entity Framework supports retry configurations defined in configuration files.",
      "pos": [
        27626,
        27704
      ]
    },
    {
      "content": "However, for maximum flexibility on Azure you should consider creating the configuration programmatically within the application.",
      "pos": [
        27705,
        27834
      ]
    },
    {
      "content": "The specific parameters for the retry policies, such as the number of retries and the retry intervals, can be stored in the service configuration file and used at runtime to create the appropriate policies.",
      "pos": [
        27835,
        28041
      ]
    },
    {
      "content": "This allows the settings to be changed within requiring the application to be restarted.",
      "pos": [
        28042,
        28130
      ]
    },
    {
      "content": "Consider starting with following settings for retrying operations.",
      "pos": [
        28132,
        28198
      ]
    },
    {
      "content": "You cannot specify the delay between retry attempts (it is fixed and generated as an exponential sequence).",
      "pos": [
        28199,
        28306
      ]
    },
    {
      "content": "You can specify only the maximum values, as shown here; unless you create a custom retry strategy.",
      "pos": [
        28307,
        28405
      ]
    },
    {
      "content": "These are general purpose settings, and you should monitor the operations and fine tune the values to suit your own scenario.",
      "pos": [
        28406,
        28531
      ]
    },
    {
      "content": "Context",
      "pos": [
        28537,
        28544
      ]
    },
    {
      "content": "Sample target E2E",
      "pos": [
        28560,
        28577
      ]
    },
    {
      "content": "max latency",
      "pos": [
        28583,
        28594
      ]
    },
    {
      "content": "Retry policy",
      "pos": [
        28601,
        28613
      ]
    },
    {
      "content": "Settings",
      "pos": [
        28620,
        28628
      ]
    },
    {
      "content": "Values",
      "pos": [
        28645,
        28651
      ]
    },
    {
      "content": "How it works",
      "pos": [
        28660,
        28672
      ]
    },
    {
      "content": "Interactive, UI,",
      "pos": [
        29034,
        29050
      ]
    },
    {
      "content": "or foreground",
      "pos": [
        29056,
        29069
      ]
    },
    {
      "content": "2 seconds",
      "pos": [
        29072,
        29081
      ]
    },
    {
      "content": "Exponential",
      "pos": [
        29108,
        29119
      ]
    },
    {
      "content": "MaxRetryCount",
      "pos": [
        29129,
        29142
      ]
    },
    {
      "content": "MaxDelay",
      "pos": [
        29148,
        29156
      ]
    },
    {
      "content": "3",
      "pos": [
        29159,
        29160
      ]
    },
    {
      "content": "750 ms",
      "pos": [
        29166,
        29172
      ]
    },
    {
      "content": "Attempt 1 - delay 0 sec",
      "pos": [
        29179,
        29202
      ]
    },
    {
      "content": "Attempt 2 - delay 750 ms",
      "pos": [
        29208,
        29232
      ]
    },
    {
      "content": "Attempt 3 – delay 750 ms",
      "pos": [
        29238,
        29262
      ]
    },
    {
      "content": "Background",
      "pos": [
        29317,
        29327
      ]
    },
    {
      "content": "or batch",
      "pos": [
        29334,
        29342
      ]
    },
    {
      "content": "30 seconds",
      "pos": [
        29356,
        29366
      ]
    },
    {
      "content": "Exponential",
      "pos": [
        29392,
        29403
      ]
    },
    {
      "content": "MaxRetryCount",
      "pos": [
        29413,
        29426
      ]
    },
    {
      "content": "MaxDelay",
      "pos": [
        29432,
        29440
      ]
    },
    {
      "content": "5",
      "pos": [
        29443,
        29444
      ]
    },
    {
      "content": "12 seconds",
      "pos": [
        29450,
        29460
      ]
    },
    {
      "content": "Attempt 1 - delay 0 sec",
      "pos": [
        29463,
        29486
      ]
    },
    {
      "content": "Attempt 2 - delay ~1 sec",
      "pos": [
        29492,
        29516
      ]
    },
    {
      "content": "Attempt 3 - delay ~3 sec",
      "pos": [
        29522,
        29546
      ]
    },
    {
      "content": "Attempt 4 - delay ~7 sec",
      "pos": [
        29552,
        29576
      ]
    },
    {
      "content": "Attempt 5 - delay 12 sec",
      "pos": [
        29582,
        29606
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> The end-to-end latency targets assume the default timeout for connections to the service.",
      "pos": [
        29612,
        29714
      ]
    },
    {
      "content": "If you specify longer connection timeouts, the end-to-end latency will be extended by this additional time for every retry attempt.",
      "pos": [
        29715,
        29846
      ]
    },
    {
      "content": "Examples (SQL Database using Entity Framework 6)",
      "pos": [
        29851,
        29899
      ]
    },
    {
      "content": "The following code example defines a simple data access solution that uses Entity Framework.",
      "pos": [
        29901,
        29993
      ]
    },
    {
      "content": "It sets a specific retry strategy by defining an instance of a class named <bpt id=\"p1\">**</bpt>BlogConfiguration<ept id=\"p1\">**</ept> that extends <bpt id=\"p2\">**</bpt>DbConfiguration<ept id=\"p2\">**</ept>.",
      "pos": [
        29994,
        30124
      ]
    },
    {
      "pos": [
        31517,
        31677
      ],
      "content": "More examples of using the Entity Framework retry mechanism can be found in <bpt id=\"p1\">[</bpt>Connection Resiliency / Retry Logic<ept id=\"p1\">](http://msdn.microsoft.com/data/dn456835.aspx)</ept>."
    },
    {
      "content": "More information",
      "pos": [
        31682,
        31698
      ]
    },
    {
      "content": "Azure SQL Database Performance and Elasticity Guide",
      "pos": [
        31703,
        31754
      ]
    },
    {
      "content": "SQL Database using ADO.NET retry guidelines",
      "pos": [
        31890,
        31933
      ]
    },
    {
      "content": "SQL Database is a hosted SQL database available in a range of sizes and as both a standard (shared) and premium (non-shared) service.",
      "pos": [
        31935,
        32068
      ]
    },
    {
      "content": "Retry mechanism",
      "pos": [
        32074,
        32089
      ]
    },
    {
      "content": "SQL Database has no built-in support for retries when accessed using ADO.NET.",
      "pos": [
        32091,
        32168
      ]
    },
    {
      "content": "However, the return codes from requests can be used to determine why a request failed.",
      "pos": [
        32169,
        32255
      ]
    },
    {
      "content": "The page <bpt id=\"p1\">[</bpt>Azure SQL Database Throttling<ept id=\"p1\">](http://msdn.microsoft.com/library/dn338079.aspx)</ept> explains how throttling can prevent connections, the return codes for specific situations, and how you can handle these and retry operations.",
      "pos": [
        32256,
        32487
      ]
    },
    {
      "pos": [
        32489,
        32725
      ],
      "content": "You can use the Transient Fault Handling Application Block (Topaz) with the Nuget package EnterpriseLibrary.TransientFaultHandling.Data (class <bpt id=\"p1\">**</bpt>SqlAzureTransientErrorDetectionStrategy<ept id=\"p1\">**</ept>) to implement a retry mechanism for SQL Database."
    },
    {
      "content": "The block also provides the <bpt id=\"p1\">**</bpt>ReliableSqlConnection<ept id=\"p1\">**</ept> class, which implements the old ADO.NET 1.0 API (<bpt id=\"p2\">**</bpt>IDbConnection<ept id=\"p2\">**</ept> instead of <bpt id=\"p3\">**</bpt>DbConnection<ept id=\"p3\">**</ept>) and performs retries and connection management internally.",
      "pos": [
        32727,
        32935
      ]
    },
    {
      "content": "While convenient, this requires you to use a different set of methods for invoking operations with retries, and so is not a simple direct replacement.",
      "pos": [
        32936,
        33086
      ]
    },
    {
      "content": "It does not support asynchronous execution, which is recommended when implementing and using Azure services.",
      "pos": [
        33087,
        33195
      ]
    },
    {
      "content": "In addition, because this class uses ADO.NET 1.0, it does not benefit from the recent improvements and updates to ADO.NET.",
      "pos": [
        33196,
        33318
      ]
    },
    {
      "content": "Policy configuration (SQL Database using ADO.NET)",
      "pos": [
        33324,
        33373
      ]
    },
    {
      "content": "The Transient Fault Handling Application Block supports both file-based and programmatic configuration.",
      "pos": [
        33375,
        33478
      ]
    },
    {
      "content": "In general, you should use programmatic configuration for maximum flexibility (see the notes in the following section for more information).",
      "pos": [
        33479,
        33619
      ]
    },
    {
      "content": "The following code, which would be executed once at application startup, creates and populates a <bpt id=\"p1\">**</bpt>RetryManager<ept id=\"p1\">**</ept> with a list of four retry strategies suitable for use with Azure SQL Database.",
      "pos": [
        33620,
        33812
      ]
    },
    {
      "content": "It also sets the default strategies for the <bpt id=\"p1\">**</bpt>RetryManager<ept id=\"p1\">**</ept>.",
      "pos": [
        33813,
        33874
      ]
    },
    {
      "content": "These are the strategies that will be used for connections and commands if an alternative is not specified when creating a connection or command.",
      "pos": [
        33875,
        34020
      ]
    },
    {
      "pos": [
        36182,
        36367
      ],
      "content": "For information about how you can use the retry policies you have configured when you access Azure SQL Database, see the <bpt id=\"p1\">[</bpt>Examples<ept id=\"p1\">](#examples-sql-database-using-ado-net-)</ept> section below."
    },
    {
      "pos": [
        36369,
        36618
      ],
      "content": "Default strategies for the Transient Fault Handling Application Block are shown in the section <bpt id=\"p1\">[</bpt>Transient Fault Handling Application Block (Topaz) strategies<ept id=\"p1\">](#transient-fault-handling-application-block-topaz-strategies)</ept> at the end of this guidance."
    },
    {
      "content": "Retry usage guidance",
      "pos": [
        36624,
        36644
      ]
    },
    {
      "content": "Consider the following guidelines when accessing SQL Database using ADO.NET:",
      "pos": [
        36646,
        36722
      ]
    },
    {
      "content": "Choose the appropriate service option (shared or premium).",
      "pos": [
        36726,
        36784
      ]
    },
    {
      "content": "A shared instance may suffer longer than usual connection delays and throttling due to the usage by other tenants of the shared server.",
      "pos": [
        36785,
        36920
      ]
    },
    {
      "content": "If more predictable performance and reliable low latency operations are required, consider choosing the premium option.",
      "pos": [
        36921,
        37040
      ]
    },
    {
      "content": "Ensure that you perform retries at the appropriate level or scope to avoid non-idempotent operations causing inconsistency in the data.",
      "pos": [
        37043,
        37178
      ]
    },
    {
      "content": "Ideally, all operations should be idempotent so that they can be repeated without causing inconsistency.",
      "pos": [
        37179,
        37283
      ]
    },
    {
      "content": "Where this is not the case, the retry should be performed at a level or scope that allows all related changes to be undone if one operation fails; for example, from within a transactional scope.",
      "pos": [
        37284,
        37478
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Cloud Service Fundamentals Data Access Layer – Transient Fault Handling<ept id=\"p1\">](http://social.technet.microsoft.com/wiki/contents/articles/18665.cloud-service-fundamentals-data-access-layer-transient-fault-handling.aspx#Idempotent_Guarantee)</ept>.",
      "pos": [
        37479,
        37741
      ]
    },
    {
      "content": "A fixed interval strategy is not recommended for use with Azure SQL Database except for interactive scenarios where there are only a few retries at very short intervals.",
      "pos": [
        37744,
        37913
      ]
    },
    {
      "content": "Instead, consider using an exponential back-off strategy for the majority of scenarios.",
      "pos": [
        37914,
        38001
      ]
    },
    {
      "content": "Choose a suitable value for the connection and command timeouts when defining connections.",
      "pos": [
        38004,
        38094
      ]
    },
    {
      "content": "Too short a timeout may result in premature failures of connections when the database is busy.",
      "pos": [
        38095,
        38189
      ]
    },
    {
      "content": "Too long a timeout may prevent the retry logic working correctly by waiting too long before detecting a failed connection.",
      "pos": [
        38190,
        38312
      ]
    },
    {
      "content": "The value of the timeout is a component of the end-to-end latency; it is effectively added to the retry delay specified in the retry policy for every retry attempt.",
      "pos": [
        38313,
        38477
      ]
    },
    {
      "content": "Close the connection after a certain number of retries, even when using an exponential back off retry logic, and retry the operation on a new connection.",
      "pos": [
        38480,
        38633
      ]
    },
    {
      "content": "Retrying the same operation multiple times on the same connection can be a factor that contributes to connection problems.",
      "pos": [
        38634,
        38756
      ]
    },
    {
      "content": "For an example of this technique, see <bpt id=\"p1\">[</bpt>Cloud Service Fundamentals Data Access Layer – Transient Fault Handling<ept id=\"p1\">](http://social.technet.microsoft.com/wiki/contents/articles/18665.cloud-service-fundamentals-data-access-layer-transient-fault-handling.aspx)</ept>.",
      "pos": [
        38757,
        39010
      ]
    },
    {
      "content": "When connection pooling is in use (the default) there is a chance that the same connection will be chosen from the pool, even after closing and reopening a connection.",
      "pos": [
        39013,
        39180
      ]
    },
    {
      "content": "If this is the case, a technique to resolve it is to call the <bpt id=\"p1\">**</bpt>ClearPool<ept id=\"p1\">**</ept> method of the <bpt id=\"p2\">**</bpt>SqlConnection<ept id=\"p2\">**</ept> class to mark the connection as not reusable.",
      "pos": [
        39181,
        39334
      ]
    },
    {
      "content": "However, you should do this only after several connection attempts have failed, and only when encountering the specific class of transient failures such as SQL timeouts (error code -2) related to faulty connections.",
      "pos": [
        39335,
        39550
      ]
    },
    {
      "content": "If the data access code uses transactions initiated as <bpt id=\"p1\">**</bpt>TransactionScope<ept id=\"p1\">**</ept> instances, the retry logic should reopen the connection and initiate a new transaction scope.",
      "pos": [
        39553,
        39722
      ]
    },
    {
      "content": "For this reason, the retryable code block should encompass the entire scope of the transaction.",
      "pos": [
        39723,
        39818
      ]
    },
    {
      "content": "The Transient Fault Handling Application Block supports retry configurations entirely defined in configuration files.",
      "pos": [
        39821,
        39938
      ]
    },
    {
      "content": "However, for maximum flexibility on Azure you should consider creating the configuration programmatically within the application.",
      "pos": [
        39939,
        40068
      ]
    },
    {
      "content": "The specific parameters for the retry policies, such as the number of retries and the retry intervals, can be stored in the service configuration file and used at runtime to create the appropriate policies.",
      "pos": [
        40069,
        40275
      ]
    },
    {
      "content": "This allows the settings to be changed within requiring the application to be restarted.",
      "pos": [
        40276,
        40364
      ]
    },
    {
      "content": "Consider starting with following settings for retrying operations.",
      "pos": [
        40366,
        40432
      ]
    },
    {
      "content": "These are general purpose settings, and you should monitor the operations and fine tune the values to suit your own scenario.",
      "pos": [
        40433,
        40558
      ]
    },
    {
      "content": "Context",
      "pos": [
        40564,
        40571
      ]
    },
    {
      "content": "Sample target E2E",
      "pos": [
        40587,
        40604
      ]
    },
    {
      "content": "max latency",
      "pos": [
        40610,
        40621
      ]
    },
    {
      "content": "Retry strategy",
      "pos": [
        40628,
        40642
      ]
    },
    {
      "content": "Settings",
      "pos": [
        40649,
        40657
      ]
    },
    {
      "content": "Values",
      "pos": [
        40721,
        40727
      ]
    },
    {
      "content": "How it works",
      "pos": [
        40750,
        40762
      ]
    },
    {
      "content": "Interactive, UI,",
      "pos": [
        41189,
        41205
      ]
    },
    {
      "content": "or foreground",
      "pos": [
        41211,
        41224
      ]
    },
    {
      "content": "2 sec",
      "pos": [
        41227,
        41232
      ]
    },
    {
      "content": "FixedInterval",
      "pos": [
        41263,
        41276
      ]
    },
    {
      "content": "Retry count",
      "pos": [
        41284,
        41295
      ]
    },
    {
      "content": "Retry interval",
      "pos": [
        41301,
        41315
      ]
    },
    {
      "content": "First fast retry",
      "pos": [
        41321,
        41337
      ]
    },
    {
      "content": "3",
      "pos": [
        41366,
        41367
      ]
    },
    {
      "content": "500 ms",
      "pos": [
        41373,
        41379
      ]
    },
    {
      "content": "true",
      "pos": [
        41385,
        41389
      ]
    },
    {
      "content": "Attempt 1 - delay 0 sec",
      "pos": [
        41405,
        41428
      ]
    },
    {
      "content": "Attempt 2 - delay 500 ms",
      "pos": [
        41434,
        41458
      ]
    },
    {
      "content": "Attempt 3 - delay 500 ms",
      "pos": [
        41464,
        41488
      ]
    },
    {
      "content": "Background",
      "pos": [
        41545,
        41555
      ]
    },
    {
      "content": "or batch",
      "pos": [
        41561,
        41569
      ]
    },
    {
      "content": "30 sec",
      "pos": [
        41583,
        41589
      ]
    },
    {
      "content": "ExponentialBackoff",
      "pos": [
        41619,
        41637
      ]
    },
    {
      "content": "Retry count",
      "pos": [
        41640,
        41651
      ]
    },
    {
      "content": "Min back-off",
      "pos": [
        41657,
        41669
      ]
    },
    {
      "content": "Max back-off",
      "pos": [
        41675,
        41687
      ]
    },
    {
      "content": "Delta back-off",
      "pos": [
        41693,
        41707
      ]
    },
    {
      "content": "First fast retry",
      "pos": [
        41713,
        41729
      ]
    },
    {
      "content": "5",
      "pos": [
        41732,
        41733
      ]
    },
    {
      "content": "0 sec",
      "pos": [
        41739,
        41744
      ]
    },
    {
      "content": "60 sec",
      "pos": [
        41750,
        41756
      ]
    },
    {
      "content": "2 sec",
      "pos": [
        41762,
        41767
      ]
    },
    {
      "content": "false",
      "pos": [
        41773,
        41778
      ]
    },
    {
      "content": "Attempt 1 - delay 0 sec",
      "pos": [
        41781,
        41804
      ]
    },
    {
      "content": "Attempt 2 - delay ~2 sec",
      "pos": [
        41810,
        41834
      ]
    },
    {
      "content": "Attempt 3 - delay ~6 sec",
      "pos": [
        41840,
        41864
      ]
    },
    {
      "content": "Attempt 4 - delay ~14 sec",
      "pos": [
        41870,
        41895
      ]
    },
    {
      "content": "Attempt 5 - delay ~30 sec",
      "pos": [
        41901,
        41926
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> The end-to-end latency targets assume the default timeout for connections to the service.",
      "pos": [
        41932,
        42034
      ]
    },
    {
      "content": "If you specify longer connection timeouts, the end-to-end latency will be extended by this additional time for every retry attempt.",
      "pos": [
        42035,
        42166
      ]
    },
    {
      "content": "Examples (SQL Database using ADO.NET)",
      "pos": [
        42172,
        42209
      ]
    },
    {
      "content": "This section describes how you can use the Transient Fault Handling Application Block to access Azure SQL Database using a set of retry policies you have configured in the <bpt id=\"p1\">**</bpt>RetryManager<ept id=\"p1\">**</ept> (as shown in the previous section <bpt id=\"p2\">[</bpt>Policy configuration<ept id=\"p2\">](#policy-configuration-sql-database-using-ado-net-)</ept>.",
      "pos": [
        42211,
        42508
      ]
    },
    {
      "content": "The simplest approach to using the block is through the <bpt id=\"p1\">**</bpt>ReliableSqlConnection<ept id=\"p1\">**</ept> class, or by calling the extension methods such as <bpt id=\"p2\">**</bpt>OpenWithRetry<ept id=\"p2\">**</ept> on a connection (see <bpt id=\"p3\">[</bpt>The Transient Fault Handling Application Block<ept id=\"p3\">](http://msdn.microsoft.com/library/hh680934.aspx)</ept> for more information).",
      "pos": [
        42509,
        42801
      ]
    },
    {
      "content": "However, in the current version of the Transient Fault Handling Application Block these approaches do not indigenously support asynchronous operations against SQL Database.",
      "pos": [
        42803,
        42975
      ]
    },
    {
      "content": "Good practice demands that you use only asynchronous techniques to access Azure services such as SQL Database, and so you should consider the following techniques to use the Transient Fault Handling Application Block with SQL Database.",
      "pos": [
        42976,
        43211
      ]
    },
    {
      "content": "You can use the simplified asynchronous support in version 5 of the C# language to create asynchronous versions of the methods provided by the block.",
      "pos": [
        43213,
        43362
      ]
    },
    {
      "content": "For example, the following code shows how you might create an asynchronous version of the <bpt id=\"p1\">**</bpt>ExecuteReaderWithRetry<ept id=\"p1\">**</ept> extension method.",
      "pos": [
        43363,
        43497
      ]
    },
    {
      "content": "The changes and additions to the original code are highlighted.",
      "pos": [
        43498,
        43561
      ]
    },
    {
      "content": "The source code for Topaz is available on GitHub at <bpt id=\"p1\">[</bpt>Transient Fault Handling Application Block (\"Topaz\")<ept id=\"p1\">](http://topaz.codeplex.com/SourceControl/latest)</ept>.",
      "pos": [
        43562,
        43717
      ]
    },
    {
      "content": "This new asynchronous extension method can be used in the same way as the synchronous versions included in the block.",
      "pos": [
        44605,
        44722
      ]
    },
    {
      "content": "However, this approach deals only with individual operations or commands, and not with blocks of statements where there can be properly defined transactional boundaries.",
      "pos": [
        45063,
        45232
      ]
    },
    {
      "content": "In addition, it does not address the situation of removing faulty connections from the connection pool so that they are not selected for subsequent attempts.",
      "pos": [
        45233,
        45390
      ]
    },
    {
      "content": "A synchronous example of resolving these issues can be found in <bpt id=\"p1\">[</bpt>Cloud Service Fundamentals Data Access Layer – Transient Fault Handling<ept id=\"p1\">](http://social.technet.microsoft.com/wiki/contents/articles/18665.cloud-service-fundamentals-data-access-layer-transient-fault-handling.aspx#Timeouts_amp_Connection_Management)</ept>.",
      "pos": [
        45391,
        45705
      ]
    },
    {
      "content": "In addition to retrying arbitrary sequences of database instructions, it clears the connection pool to remove invalid connections, and instruments the entire process.",
      "pos": [
        45706,
        45872
      ]
    },
    {
      "content": "While the code shown in this example is synchronous, it is relatively easy to convert it to asynchronous code.",
      "pos": [
        45873,
        45983
      ]
    },
    {
      "content": "More information",
      "pos": [
        45989,
        46005
      ]
    },
    {
      "content": "For detailed information about using the Transient Fault Handling Application Block, see:",
      "pos": [
        46007,
        46096
      ]
    },
    {
      "content": "Using the Transient Fault Handling Application Block with SQL Azure",
      "pos": [
        46101,
        46168
      ]
    },
    {
      "content": "Perseverance, Secret of All Triumphs: Using the Transient Fault Handling Application Block",
      "pos": [
        46222,
        46312
      ]
    },
    {
      "content": "Cloud Service Fundamentals Data Access Layer – Transient Fault Handling",
      "pos": [
        46366,
        46437
      ]
    },
    {
      "content": "For general guidance on getting the most from SQL Database, see:",
      "pos": [
        46581,
        46645
      ]
    },
    {
      "content": "Azure SQL Database Performance and Elasticity Guide",
      "pos": [
        46650,
        46701
      ]
    },
    {
      "content": "Minimizing Connection Pool errors in SQL Azure",
      "pos": [
        46836,
        46882
      ]
    },
    {
      "content": "Service Bus retry guidelines",
      "pos": [
        46991,
        47019
      ]
    },
    {
      "content": "Service Bus is a cloud messaging platform that provides loosely coupled message exchange with improved scale and resiliency for components of an application, whether hosted in the cloud or on-premises.",
      "pos": [
        47021,
        47222
      ]
    },
    {
      "content": "Retry mechanism",
      "pos": [
        47228,
        47243
      ]
    },
    {
      "content": "Service Bus implements retries using implementations of the <bpt id=\"p1\">[</bpt>RetryPolicy<ept id=\"p1\">](http://msdn.microsoft.com/library/microsoft.servicebus.retrypolicy.aspx)</ept> base class.",
      "pos": [
        47245,
        47403
      ]
    },
    {
      "content": "All of the Service Bus clients expose a <bpt id=\"p1\">**</bpt>RetryPolicy<ept id=\"p1\">**</ept> property that can be set to one of the implementations of the <bpt id=\"p2\">**</bpt>RetryPolicy<ept id=\"p2\">**</ept> base class.",
      "pos": [
        47404,
        47549
      ]
    },
    {
      "content": "The built-in implementations are:",
      "pos": [
        47550,
        47583
      ]
    },
    {
      "content": "The <bpt id=\"p1\">[</bpt>RetryExponential Class<ept id=\"p1\">](http://msdn.microsoft.com/library/microsoft.servicebus.retryexponential.aspx)</ept>.",
      "pos": [
        47587,
        47694
      ]
    },
    {
      "content": "This exposes properties that control the back-off interval, the retry count, and the <bpt id=\"p1\">**</bpt>TerminationTimeBuffer<ept id=\"p1\">**</ept> property that is used to limit the total time for the operation to complete.",
      "pos": [
        47695,
        47882
      ]
    },
    {
      "content": "The <bpt id=\"p1\">[</bpt>NoRetry Class<ept id=\"p1\">](http://msdn.microsoft.com/library/microsoft.servicebus.noretry.aspx)</ept>.",
      "pos": [
        47885,
        47974
      ]
    },
    {
      "content": "This is used when retries at the Service Bus API level are not required, such as when retries are managed by another process as part of a batch or multiple step operation.",
      "pos": [
        47975,
        48146
      ]
    },
    {
      "content": "Service Bus actions can return a range of exceptions, as listed in <bpt id=\"p1\">[</bpt>Appendix: Messaging Exceptions<ept id=\"p1\">](http://msdn.microsoft.com/library/hh418082.aspx)</ept>.",
      "pos": [
        48148,
        48297
      ]
    },
    {
      "content": "The list provides information about which if these indicate that retrying the operation is appropriate.",
      "pos": [
        48298,
        48401
      ]
    },
    {
      "content": "For example, a <bpt id=\"p1\">[</bpt>ServerBusyException<ept id=\"p1\">](http://msdn.microsoft.com/library/microsoft.servicebus.messaging.serverbusyexception.aspx)</ept> indicates that the client should wait for a period of time, then retry the operation.",
      "pos": [
        48402,
        48615
      ]
    },
    {
      "content": "The occurrence of a <bpt id=\"p1\">**</bpt>ServerBusyException<ept id=\"p1\">**</ept> also causes Service Bus to switch to a different mode, in which an extra 10-second delay is added to the computed retry delays.",
      "pos": [
        48616,
        48787
      ]
    },
    {
      "content": "This mode is reset after a short period.",
      "pos": [
        48788,
        48828
      ]
    },
    {
      "content": "The exceptions returned from Service Bus expose the <bpt id=\"p1\">**</bpt>IsTransient<ept id=\"p1\">**</ept> property that indicates if the client should retry the operation.",
      "pos": [
        48830,
        48963
      ]
    },
    {
      "content": "The built-in <bpt id=\"p1\">**</bpt>RetryExponential<ept id=\"p1\">**</ept> policy relies on the <bpt id=\"p2\">**</bpt>IsTransient<ept id=\"p2\">**</ept> property in the <bpt id=\"p3\">**</bpt>MessagingException<ept id=\"p3\">**</ept> class, which is the base class for all Service Bus exceptions.",
      "pos": [
        48964,
        49136
      ]
    },
    {
      "content": "If you create custom implementations of the <bpt id=\"p1\">**</bpt>RetryPolicy<ept id=\"p1\">**</ept> base class you could use a combination of the exception type and the <bpt id=\"p2\">**</bpt>IsTransient<ept id=\"p2\">**</ept> property to provide more fine-grained control over retry actions.",
      "pos": [
        49137,
        49347
      ]
    },
    {
      "content": "For example, you could detect a <bpt id=\"p1\">**</bpt>QuotaExceededException<ept id=\"p1\">**</ept> and take action to drain the queue before retrying sending a message to it.",
      "pos": [
        49348,
        49482
      ]
    },
    {
      "content": "Policy configuration (Service bus)",
      "pos": [
        49488,
        49522
      ]
    },
    {
      "content": "Retry policies are set programmatically, and can be set as a default policy for a <bpt id=\"p1\">**</bpt>NamespaceManager<ept id=\"p1\">**</ept> and for a <bpt id=\"p2\">**</bpt>MessagingFactory<ept id=\"p2\">**</ept>, or individually for each messaging client.",
      "pos": [
        49524,
        49701
      ]
    },
    {
      "content": "To set the default retry policy for a messaging session you set the <bpt id=\"p1\">**</bpt>RetryPolicy<ept id=\"p1\">**</ept> of the <bpt id=\"p2\">**</bpt>NamespaceManager<ept id=\"p2\">**</ept>.",
      "pos": [
        49702,
        49814
      ]
    },
    {
      "content": "Note that this code uses named parameters for clarity.",
      "pos": [
        50325,
        50379
      ]
    },
    {
      "content": "Alternatively you can omit the names because none of the parameters is optional.",
      "pos": [
        50380,
        50460
      ]
    },
    {
      "pos": [
        50656,
        50794
      ],
      "content": "To set the default retry policy for all clients created from a messaging factory, you set the <bpt id=\"p1\">**</bpt>RetryPolicy<ept id=\"p1\">**</ept> of the <bpt id=\"p2\">**</bpt>MessagingFactory<ept id=\"p2\">**</ept>."
    },
    {
      "pos": [
        51260,
        51427
      ],
      "content": "To set the retry policy for a messaging client, or to override its default policy, you set its <bpt id=\"p1\">**</bpt>RetryPolicy<ept id=\"p1\">**</ept> property using an instance of the required policy class:"
    },
    {
      "content": "The retry policy cannot be set at the individual operation level.",
      "pos": [
        51845,
        51910
      ]
    },
    {
      "content": "It applies to all operations for the messaging client.",
      "pos": [
        51911,
        51965
      ]
    },
    {
      "content": "The following table shows the default settings for the built-in retry policy.",
      "pos": [
        51966,
        52043
      ]
    },
    {
      "content": "Retry usage guidance",
      "pos": [
        52138,
        52158
      ]
    },
    {
      "content": "Consider the following guidelines when using Service Bus:",
      "pos": [
        52160,
        52217
      ]
    },
    {
      "pos": [
        52221,
        52423
      ],
      "content": "When using the built-in <bpt id=\"p1\">**</bpt>RetryExponential<ept id=\"p1\">**</ept> implementation, do not implement a fallback operation as the policy reacts to Server Busy exceptions and automatically switches to an appropriate retry mode."
    },
    {
      "content": "Service Bus supports a feature called Paired Namespaces, which implements automatic failover to a backup queue in a separate namespace if the queue in the primary namespace fails.",
      "pos": [
        52426,
        52605
      ]
    },
    {
      "content": "Messages from the secondary queue can be sent back to the primary queue when it recovers.",
      "pos": [
        52606,
        52695
      ]
    },
    {
      "content": "This feature helps to address transient failures.",
      "pos": [
        52696,
        52745
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Asynchronous Messaging Patterns and High Availability<ept id=\"p1\">](http://msdn.microsoft.com/library/azure/dn292562.aspx)</ept>.",
      "pos": [
        52746,
        52883
      ]
    },
    {
      "content": "Consider starting with following settings for retrying operations.",
      "pos": [
        52885,
        52951
      ]
    },
    {
      "content": "These are general purpose settings, and you should monitor the operations and fine tune the values to suit your own scenario.",
      "pos": [
        52952,
        53077
      ]
    },
    {
      "content": "Telemetry",
      "pos": [
        53173,
        53182
      ]
    },
    {
      "content": "Service Bus logs retries as ETW events using an <bpt id=\"p1\">**</bpt>EventSource<ept id=\"p1\">**</ept>.",
      "pos": [
        53184,
        53248
      ]
    },
    {
      "content": "You must attach an <bpt id=\"p1\">**</bpt>EventListener<ept id=\"p1\">**</ept> to the event source to capture the events and view them in Performance Viewer, or write them to a suitable destination log.",
      "pos": [
        53249,
        53409
      ]
    },
    {
      "content": "You could use the <bpt id=\"p1\">[</bpt>Semantic Logging Application Block<ept id=\"p1\">](http://msdn.microsoft.com/library/dn775006.aspx)</ept> to do this.",
      "pos": [
        53410,
        53525
      ]
    },
    {
      "content": "The retry events are of the following form:",
      "pos": [
        53526,
        53569
      ]
    },
    {
      "content": "Examples (Service bus)",
      "pos": [
        54557,
        54579
      ]
    },
    {
      "content": "The following code example shows how to set the retry policy for:",
      "pos": [
        54581,
        54646
      ]
    },
    {
      "content": "A namespace manager.",
      "pos": [
        54650,
        54670
      ]
    },
    {
      "content": "The policy applies to all operations on that manager, and cannot be overridden for individual operations.",
      "pos": [
        54671,
        54776
      ]
    },
    {
      "content": "A messaging factory.",
      "pos": [
        54779,
        54799
      ]
    },
    {
      "content": "The policy applies to all clients created from that factory, and cannot be overridden when creating individual clients.",
      "pos": [
        54800,
        54919
      ]
    },
    {
      "content": "An individual messaging client.",
      "pos": [
        54922,
        54953
      ]
    },
    {
      "content": "After a client has been created, you can set the retry policy for that client.",
      "pos": [
        54954,
        55032
      ]
    },
    {
      "content": "The policy applies to all operations on that client.",
      "pos": [
        55033,
        55085
      ]
    },
    {
      "content": "More information",
      "pos": [
        58881,
        58897
      ]
    },
    {
      "content": "Asynchronous Messaging Patterns and High Availability",
      "pos": [
        58902,
        58955
      ]
    },
    {
      "content": "Cache (Redis) retry guidelines",
      "pos": [
        59016,
        59046
      ]
    },
    {
      "content": "Azure Redis Cache is a fast data access and low latency cache service based on the popular open source Redis Cache.",
      "pos": [
        59048,
        59163
      ]
    },
    {
      "content": "It is secure, managed by Microsoft, and is accessible from any application in Azure.",
      "pos": [
        59164,
        59248
      ]
    },
    {
      "content": "The guidance in this section is based on using the StackExchange.Redis client to access the cache.",
      "pos": [
        59250,
        59348
      ]
    },
    {
      "content": "A list of other suitable clients can be found on the <bpt id=\"p1\">[</bpt>Redis website<ept id=\"p1\">](http://redis.io/clients)</ept>, and these may have different retry mechanisms.",
      "pos": [
        59349,
        59490
      ]
    },
    {
      "content": "Note that the StackExchange.Redis client uses multiplexing through a single connection.",
      "pos": [
        59492,
        59579
      ]
    },
    {
      "content": "The recommended usage is to create an instance of the client at application startup and use this instance for all operations against the cache.",
      "pos": [
        59580,
        59723
      ]
    },
    {
      "content": "For this reason, the connection to the cache is made only once, and so all of the guidance in this section is related to the retry policy for this initial connection—and not for each operation that accesses the cache.",
      "pos": [
        59724,
        59941
      ]
    },
    {
      "content": "Retry mechanism",
      "pos": [
        59947,
        59962
      ]
    },
    {
      "content": "The StackExchange.Redis client uses a connection manager class that is configured through a set of options.",
      "pos": [
        59964,
        60071
      ]
    },
    {
      "content": "These options include a <bpt id=\"p1\">**</bpt>ConnectRetry<ept id=\"p1\">**</ept> property that specifies the number of times a failed connection to the cache will be retried.",
      "pos": [
        60072,
        60206
      ]
    },
    {
      "content": "However, the retry policy in used only for the initial connect action, and it does not wait between retries.",
      "pos": [
        60207,
        60315
      ]
    },
    {
      "content": "Policy configuration (Azure Redis Cache)",
      "pos": [
        60321,
        60361
      ]
    },
    {
      "content": "Retry policies are configured programmatically by setting the options for the client before connecting to the cache.",
      "pos": [
        60363,
        60479
      ]
    },
    {
      "content": "This can be done by creating an instance of the <bpt id=\"p1\">**</bpt>ConfigurationOptions<ept id=\"p1\">**</ept> class, populating its properties, and passing it to the <bpt id=\"p2\">**</bpt>Connect<ept id=\"p2\">**</ept> method.",
      "pos": [
        60480,
        60628
      ]
    },
    {
      "pos": [
        60924,
        61049
      ],
      "content": "Note that the <bpt id=\"p1\">**</bpt>ConnectTimeout<ept id=\"p1\">**</ept> property specifies the maximum waiting time in milliseconds), not the delay between retries."
    },
    {
      "pos": [
        61051,
        61147
      ],
      "content": "Alternatively, you can specify the options as a string, and pass this to the <bpt id=\"p1\">**</bpt>Connect<ept id=\"p1\">**</ept> method."
    },
    {
      "content": "It is also possible to specify options directly when you connect to the cache.",
      "pos": [
        61312,
        61390
      ]
    },
    {
      "content": "The following table shows the default settings for the built-in retry policy.",
      "pos": [
        61491,
        61568
      ]
    },
    {
      "content": "Context",
      "pos": [
        61574,
        61581
      ]
    },
    {
      "content": "Setting",
      "pos": [
        61597,
        61604
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Default value<ept id=\"p1\">**</ept>",
      "pos": [
        61637,
        61654
      ]
    },
    {
      "content": "(v 1.0.331)",
      "pos": [
        61660,
        61671
      ]
    },
    {
      "content": "Meaning",
      "pos": [
        61686,
        61693
      ]
    },
    {
      "content": "ConfigurationOptions",
      "pos": [
        62211,
        62231
      ]
    },
    {
      "content": "ConnectRetry",
      "pos": [
        62234,
        62246
      ]
    },
    {
      "content": "ConnectTimeout",
      "pos": [
        62258,
        62272
      ]
    },
    {
      "content": "SyncTimeout",
      "pos": [
        62284,
        62295
      ]
    },
    {
      "content": "3",
      "pos": [
        62298,
        62299
      ]
    },
    {
      "content": "Maximum 5000 ms plus SyncTimeout",
      "pos": [
        62311,
        62343
      ]
    },
    {
      "content": "1000",
      "pos": [
        62349,
        62353
      ]
    },
    {
      "content": "The number of times to repeat connect attempts during the initial connection operation.",
      "pos": [
        62356,
        62443
      ]
    },
    {
      "content": "Timeout (ms) for connect operations.",
      "pos": [
        62449,
        62485
      ]
    },
    {
      "content": "Not a delay between retry attempts.",
      "pos": [
        62486,
        62521
      ]
    },
    {
      "content": "Time (ms) to allow for synchronous operations.",
      "pos": [
        62527,
        62573
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> SyncTimeout contributes to the end-to-end latency of an operation.",
      "pos": [
        62579,
        62658
      ]
    },
    {
      "content": "However, in general, using synchronous operations is not recommended.",
      "pos": [
        62659,
        62728
      ]
    },
    {
      "content": "For more information see <bpt id=\"p1\">[</bpt>Pipelines and Multiplexers<ept id=\"p1\">](http://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/PipelinesMultiplexers.md)</ept>.",
      "pos": [
        62729,
        62878
      ]
    },
    {
      "content": "Retry usage guidance",
      "pos": [
        62883,
        62903
      ]
    },
    {
      "content": "Consider the following guidelines when using Azure Redis Cache:",
      "pos": [
        62905,
        62968
      ]
    },
    {
      "content": "The StackExchange Redis client manages its own retries, but only when establishing a connection to the cache when the application first starts.",
      "pos": [
        62972,
        63115
      ]
    },
    {
      "content": "You can configure the connection timeout and the number of retry attempts to establish this connection, but the retry policy does not apply to operations against the cache.",
      "pos": [
        63116,
        63288
      ]
    },
    {
      "content": "The retry mechanism has no delay between retry attempts.",
      "pos": [
        63291,
        63347
      ]
    },
    {
      "content": "It simply retries a failed connection after the specified connection timeout expires, and for the specified number of times.",
      "pos": [
        63348,
        63472
      ]
    },
    {
      "content": "Instead of using a large number of retry attempts, consider falling back by accessing the original data source instead.",
      "pos": [
        63475,
        63594
      ]
    },
    {
      "content": "Telemetry",
      "pos": [
        63599,
        63608
      ]
    },
    {
      "pos": [
        63610,
        63706
      ],
      "content": "You can collect information about connections (but not other operations) using a <bpt id=\"p1\">**</bpt>TextWriter<ept id=\"p1\">**</ept>."
    },
    {
      "content": "An example of the output this generates is shown below.",
      "pos": [
        63838,
        63893
      ]
    },
    {
      "content": "Examples (Azure Redis Cache)",
      "pos": [
        64714,
        64742
      ]
    },
    {
      "content": "The following code example shows how you can configure the connection timeout setting and the number of retries when initializing the StackExchange.Redis client to access Azure Redis Cache at application startup.",
      "pos": [
        64744,
        64956
      ]
    },
    {
      "content": "Note that the connection timeout is the period of time that you are willing to wait for connection to the cache; it is not the delay between retry attempts.",
      "pos": [
        64957,
        65113
      ]
    },
    {
      "pos": [
        65115,
        65213
      ],
      "content": "This example shows how to set the configuration using an instance of the <bpt id=\"p1\">**</bpt>ConfigurationOptions<ept id=\"p1\">**</ept>."
    },
    {
      "content": "This example shows how to set the configuration by specifying the options as a string.",
      "pos": [
        66453,
        66539
      ]
    },
    {
      "pos": [
        67440,
        67603
      ],
      "content": "For more examples, see <bpt id=\"p1\">[</bpt>Configuration<ept id=\"p1\">](http://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Configuration.md#configuration)</ept> on the project website."
    },
    {
      "content": "More information",
      "pos": [
        67608,
        67624
      ]
    },
    {
      "content": "Redis website",
      "pos": [
        67629,
        67642
      ]
    },
    {
      "content": "DocumentDB (pre-release) retry guidelines",
      "pos": [
        67666,
        67707
      ]
    },
    {
      "content": "DocumentDB is a fully-managed document database-as-a-service with rich query and indexing capabilities over a schema-free JSON data model.",
      "pos": [
        67709,
        67847
      ]
    },
    {
      "content": "It offers configurable and reliable performance, native JavaScript transactional processing, and is built for the cloud with elastic scale.",
      "pos": [
        67848,
        67987
      ]
    },
    {
      "content": "Retry mechanism",
      "pos": [
        67992,
        68007
      ]
    },
    {
      "content": "The pre-release version of the DocumentDB client includes an internal and non-configurable retry mechanism (this may change in subsequent releases).",
      "pos": [
        68009,
        68157
      ]
    },
    {
      "content": "The default settings for this vary depending on the context of its use.",
      "pos": [
        68158,
        68229
      ]
    },
    {
      "content": "Some operations use an exponential back-off strategy with hard-coded parameters.",
      "pos": [
        68230,
        68310
      ]
    },
    {
      "content": "Others specify only how many retries should be attempted, and use the retry delay in the <bpt id=\"p1\">[</bpt>DocumentClientException<ept id=\"p1\">](http://msdn.microsoft.com/library/microsoft.azure.documents.documentclientexception.retryafter.aspx)</ept> instance that is returned from the service.",
      "pos": [
        68311,
        68570
      ]
    },
    {
      "content": "A delay of five seconds is used if no delay is specified.",
      "pos": [
        68571,
        68628
      ]
    },
    {
      "content": "Policy configuration (DocumentDB)",
      "pos": [
        68633,
        68666
      ]
    },
    {
      "content": "None.",
      "pos": [
        68668,
        68673
      ]
    },
    {
      "content": "All of the classes used to implement retries are internal.",
      "pos": [
        68674,
        68732
      ]
    },
    {
      "content": "The retry parameters are either constants or are set using parameters to the class constructors.",
      "pos": [
        68733,
        68829
      ]
    },
    {
      "content": "The following table shows the default settings for the built-in retry policy.",
      "pos": [
        68831,
        68908
      ]
    },
    {
      "content": "Context",
      "pos": [
        68914,
        68921
      ]
    },
    {
      "content": "Settings",
      "pos": [
        68939,
        68947
      ]
    },
    {
      "content": "Values",
      "pos": [
        68991,
        68997
      ]
    },
    {
      "content": "How it works",
      "pos": [
        69004,
        69016
      ]
    },
    {
      "content": "RetryPolicy (internal)",
      "pos": [
        69418,
        69440
      ]
    },
    {
      "content": "MaxRetryAttemptsOnQuery",
      "pos": [
        69443,
        69466
      ]
    },
    {
      "content": "MaxRetryAttemptsOnRequest",
      "pos": [
        69478,
        69503
      ]
    },
    {
      "content": "3",
      "pos": [
        69506,
        69507
      ]
    },
    {
      "content": "0",
      "pos": [
        69519,
        69520
      ]
    },
    {
      "content": "The number of retry attempts for document queries.",
      "pos": [
        69530,
        69580
      ]
    },
    {
      "content": "This value cannot be changed.",
      "pos": [
        69581,
        69610
      ]
    },
    {
      "content": "The number of retry attempts for other requests.",
      "pos": [
        69616,
        69664
      ]
    },
    {
      "content": "This value cannot be changed.",
      "pos": [
        69665,
        69694
      ]
    },
    {
      "content": "Retry usage guidance",
      "pos": [
        69701,
        69721
      ]
    },
    {
      "content": "Consider the following guidelines when using DocumentDB:",
      "pos": [
        69723,
        69779
      ]
    },
    {
      "content": "You cannot change the default retry policy.",
      "pos": [
        69783,
        69826
      ]
    },
    {
      "content": "See [TBD] for more information about the default settings.",
      "pos": [
        69829,
        69887
      ]
    },
    {
      "content": "Telemetry",
      "pos": [
        69892,
        69901
      ]
    },
    {
      "content": "Retry attempts are logged as unstructured trace messages through a .NET <bpt id=\"p1\">**</bpt>TraceSource<ept id=\"p1\">**</ept>.",
      "pos": [
        69903,
        69991
      ]
    },
    {
      "content": "You must configure a <bpt id=\"p1\">**</bpt>TraceListener<ept id=\"p1\">**</ept> to capture the events and write them to a suitable destination log.",
      "pos": [
        69992,
        70098
      ]
    },
    {
      "content": "Search retry guidelines",
      "pos": [
        70103,
        70126
      ]
    },
    {
      "content": "Azure Search can be used to add powerful and sophisticated search capabilities to a website or application, quickly and easily tune search results, and construct rich and fine-tuned ranking models.",
      "pos": [
        70128,
        70325
      ]
    },
    {
      "content": "Retry mechanism",
      "pos": [
        70331,
        70346
      ]
    },
    {
      "content": "There is no built-in retry mechanism for Search as the typical usage is though HTTP requests.",
      "pos": [
        70348,
        70441
      ]
    },
    {
      "content": "To implement retries you can use a generic implementation of a REST client, and make decisions on when and if to retry the operation based on the response from the service.",
      "pos": [
        70442,
        70614
      ]
    },
    {
      "content": "For more information, see the section <bpt id=\"p1\">[</bpt>General REST and retry guidelines<ept id=\"p1\">](#general-rest-and-retry-guidelines)</ept> later in this guidance.",
      "pos": [
        70615,
        70748
      ]
    },
    {
      "content": "Retry usage guidance",
      "pos": [
        70754,
        70774
      ]
    },
    {
      "content": "Consider the following guidelines when using Azure Search:",
      "pos": [
        70776,
        70834
      ]
    },
    {
      "content": "Use the status code returned by the service to determine the type of failure.",
      "pos": [
        70838,
        70915
      ]
    },
    {
      "content": "The status codes are defined in <bpt id=\"p1\">[</bpt>HTTP status codes (Azure Search)<ept id=\"p1\">](http://msdn.microsoft.com/library/dn798925.aspx)</ept>.",
      "pos": [
        70916,
        71032
      ]
    },
    {
      "content": "The status code 503 (Service Unavailable) indicates that the service is under heavy load and the request cannot be processed immediately.",
      "pos": [
        71033,
        71170
      ]
    },
    {
      "content": "The appropriate action is to retry the operation only after allowing time for the service to recover.",
      "pos": [
        71171,
        71272
      ]
    },
    {
      "content": "Retrying after too short a delay interval is likely to prolong the unavailability.",
      "pos": [
        71273,
        71355
      ]
    },
    {
      "pos": [
        71358,
        71524
      ],
      "content": "See the section <bpt id=\"p1\">[</bpt>General REST and retry guidelines<ept id=\"p1\">](#general-rest-and-retry-guidelines)</ept> later in this guidance for general information about retrying REST operations."
    },
    {
      "content": "More information",
      "pos": [
        71529,
        71545
      ]
    },
    {
      "content": "Azure Search REST API",
      "pos": [
        71550,
        71571
      ]
    },
    {
      "content": "Azure Active Directory retry guidelines",
      "pos": [
        71626,
        71665
      ]
    },
    {
      "content": "Azure Active Directory (AD) is a comprehensive identity and access management cloud solution that combines core directory services, advanced identity governance, security, and application access management.",
      "pos": [
        71667,
        71873
      ]
    },
    {
      "content": "Azure AD also offers developers an identity management platform to deliver access control to their applications, based on centralized policy and rules.",
      "pos": [
        71874,
        72025
      ]
    },
    {
      "content": "Retry mechanism",
      "pos": [
        72031,
        72046
      ]
    },
    {
      "content": "There is no built-in retry mechanism for Azure Active Directory in the Active Directory Authentication Library (ADAL).",
      "pos": [
        72048,
        72166
      ]
    },
    {
      "content": "You can use the Transient Fault Handling Application Block to implement a retry strategy that contains a custom detection mechanism for the exceptions returned by Active Directory.",
      "pos": [
        72167,
        72347
      ]
    },
    {
      "content": "Policy configuration (Azure Active Directory)",
      "pos": [
        72353,
        72398
      ]
    },
    {
      "pos": [
        72400,
        72593
      ],
      "content": "When using the Transient Fault Handling Application Block with Azure Active Directory you create a <bpt id=\"p1\">**</bpt>RetryPolicy<ept id=\"p1\">**</ept> instance based on a class that defines the detection strategy you want to use."
    },
    {
      "pos": [
        73023,
        73152
      ],
      "content": "You then call the <bpt id=\"p1\">**</bpt>ExecuteAction<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>ExecuteAsync<ept id=\"p2\">**</ept> method of the retry policy, passing in the operation you want to execute."
    },
    {
      "content": "The detection strategy class receives exceptions when a failure occurs, and must detect whether this is likely to be a transient fault or a more permanent failure.",
      "pos": [
        73272,
        73435
      ]
    },
    {
      "content": "Typically it will do this by examining the exception type and status code.",
      "pos": [
        73436,
        73510
      ]
    },
    {
      "content": "For example, a Service Unavailable response indicates that a retry attempt should be made.",
      "pos": [
        73511,
        73601
      ]
    },
    {
      "content": "The Transient Fault Handling Application Block does not include a detection strategy class that is suitable for use with the ADAL client, but an example of a custom detection strategy is provided in the <bpt id=\"p1\">[</bpt>Examples<ept id=\"p1\">](#examples-azure-active-directory-)</ept> section below.",
      "pos": [
        73602,
        73865
      ]
    },
    {
      "content": "Using a custom detection strategy is no different from using one supplied with the block.",
      "pos": [
        73866,
        73955
      ]
    },
    {
      "pos": [
        73957,
        74206
      ],
      "content": "Default strategies for the Transient Fault Handling Application Block are shown in the section <bpt id=\"p1\">[</bpt>Transient Fault Handling Application Block (Topaz) strategies<ept id=\"p1\">](#transient-fault-handling-application-block-topaz-strategies)</ept> at the end of this guidance."
    },
    {
      "content": "Retry usage guidance",
      "pos": [
        74211,
        74231
      ]
    },
    {
      "content": "Consider the following guidelines when using Azure Active Directory:",
      "pos": [
        74233,
        74301
      ]
    },
    {
      "content": "If you are using the REST API for Azure Active Directory, you should retry the operation only if the result is an error in the 5xx range (such as 500 Internal Server Error, 502 Bad Gateway, 503 Service Unavailable, and 504 Gateway Timeout).",
      "pos": [
        74305,
        74545
      ]
    },
    {
      "content": "Do not retry for any other errors.",
      "pos": [
        74546,
        74580
      ]
    },
    {
      "content": "If you are using the Active Directory Authentication Library (ADAL), HTTP codes are not readily accessible.",
      "pos": [
        74583,
        74690
      ]
    },
    {
      "content": "You will need to create a custom detection strategy that includes logic to check the properties of the ADAL-specific exceptions.",
      "pos": [
        74691,
        74819
      ]
    },
    {
      "content": "See the <bpt id=\"p1\">[</bpt>Examples<ept id=\"p1\">](#examples-azure-active-directory-)</ept> section below.",
      "pos": [
        74820,
        74888
      ]
    },
    {
      "content": "An exponential back-off policy is recommended for use in batch scenarios with Azure Active Directory.",
      "pos": [
        74891,
        74992
      ]
    },
    {
      "content": "Consider starting with following settings for retrying operations.",
      "pos": [
        74994,
        75060
      ]
    },
    {
      "content": "These are general purpose settings, and you should monitor the operations and fine tune the values to suit your own scenario.",
      "pos": [
        75061,
        75186
      ]
    },
    {
      "content": "Context",
      "pos": [
        75193,
        75200
      ]
    },
    {
      "content": "Sample target E2E",
      "pos": [
        75216,
        75233
      ]
    },
    {
      "content": "max latency",
      "pos": [
        75239,
        75250
      ]
    },
    {
      "content": "Retry strategy",
      "pos": [
        75257,
        75271
      ]
    },
    {
      "content": "Settings",
      "pos": [
        75278,
        75286
      ]
    },
    {
      "content": "Values",
      "pos": [
        75350,
        75356
      ]
    },
    {
      "content": "How it works",
      "pos": [
        75379,
        75391
      ]
    },
    {
      "content": "Interactive, UI,",
      "pos": [
        75829,
        75845
      ]
    },
    {
      "content": "or foreground",
      "pos": [
        75851,
        75864
      ]
    },
    {
      "content": "2 sec",
      "pos": [
        75867,
        75872
      ]
    },
    {
      "content": "FixedInterval",
      "pos": [
        75914,
        75927
      ]
    },
    {
      "content": "Retry count",
      "pos": [
        75935,
        75946
      ]
    },
    {
      "content": "Retry interval",
      "pos": [
        75952,
        75966
      ]
    },
    {
      "content": "First fast retry",
      "pos": [
        75972,
        75988
      ]
    },
    {
      "content": "3",
      "pos": [
        76017,
        76018
      ]
    },
    {
      "content": "500 ms",
      "pos": [
        76024,
        76030
      ]
    },
    {
      "content": "true",
      "pos": [
        76036,
        76040
      ]
    },
    {
      "content": "Attempt 1 - delay 0 sec",
      "pos": [
        76056,
        76079
      ]
    },
    {
      "content": "Attempt 2 - delay 500 ms",
      "pos": [
        76085,
        76109
      ]
    },
    {
      "content": "Attempt 3 - delay 500 ms",
      "pos": [
        76115,
        76139
      ]
    },
    {
      "content": "Background or",
      "pos": [
        76196,
        76209
      ]
    },
    {
      "content": "batch",
      "pos": [
        76215,
        76220
      ]
    },
    {
      "content": "60 sec",
      "pos": [
        76234,
        76240
      ]
    },
    {
      "content": "ExponentialBackoff",
      "pos": [
        76281,
        76299
      ]
    },
    {
      "content": "Retry count",
      "pos": [
        76302,
        76313
      ]
    },
    {
      "content": "Min back-off",
      "pos": [
        76319,
        76331
      ]
    },
    {
      "content": "Max back-off",
      "pos": [
        76337,
        76349
      ]
    },
    {
      "content": "Delta back-off",
      "pos": [
        76355,
        76369
      ]
    },
    {
      "content": "First fast retry",
      "pos": [
        76375,
        76391
      ]
    },
    {
      "content": "5",
      "pos": [
        76394,
        76395
      ]
    },
    {
      "content": "0 sec",
      "pos": [
        76401,
        76406
      ]
    },
    {
      "content": "60 sec",
      "pos": [
        76412,
        76418
      ]
    },
    {
      "content": "2 sec",
      "pos": [
        76424,
        76429
      ]
    },
    {
      "content": "false",
      "pos": [
        76435,
        76440
      ]
    },
    {
      "content": "Attempt 1 - delay 0 sec",
      "pos": [
        76443,
        76466
      ]
    },
    {
      "content": "Attempt 2 - delay ~2 sec",
      "pos": [
        76472,
        76496
      ]
    },
    {
      "content": "Attempt 3 - delay ~6 sec",
      "pos": [
        76502,
        76526
      ]
    },
    {
      "content": "Attempt 4 - delay ~14 sec",
      "pos": [
        76532,
        76557
      ]
    },
    {
      "content": "Attempt 5 - delay ~30 sec",
      "pos": [
        76563,
        76588
      ]
    },
    {
      "content": "Examples (Azure Active Directory)",
      "pos": [
        76595,
        76628
      ]
    },
    {
      "content": "The following code example shows how you can use the Transient Fault Handling Application Block (Topaz) to define a custom transient error detection strategy suitable for use with the ADAL client.",
      "pos": [
        76630,
        76826
      ]
    },
    {
      "content": "The code creates a new <bpt id=\"p1\">**</bpt>RetryPolicy<ept id=\"p1\">**</ept> instance based on a custom detection strategy of type <bpt id=\"p2\">**</bpt>AdalDetectionStrategy<ept id=\"p2\">**</ept>, as defined in the code listing below.",
      "pos": [
        76827,
        76984
      ]
    },
    {
      "content": "Custom detection strategies for Topaz implement the <bpt id=\"p1\">**</bpt>ITransientErrorDetectionStrategy<ept id=\"p1\">**</ept> interface and return true if a retry should be attempted, or <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if the failure appears to be non-transient and a retry should not be attempted.",
      "pos": [
        76985,
        77224
      ]
    },
    {
      "content": "For information about retrying Active Directory Graph API operations and the error codes returned see:",
      "pos": [
        80685,
        80787
      ]
    },
    {
      "content": "Code Sample: Retry Logic",
      "pos": [
        80792,
        80816
      ]
    },
    {
      "content": "Azure AD Graph Error Codes",
      "pos": [
        80876,
        80902
      ]
    },
    {
      "content": "More information",
      "pos": [
        80963,
        80979
      ]
    },
    {
      "pos": [
        80983,
        81082
      ],
      "content": "<bpt id=\"p1\">[</bpt>Implementing a Custom Detection Strategy<ept id=\"p1\">](http://msdn.microsoft.com/library/hh680940.aspx)</ept> (Topaz)"
    },
    {
      "pos": [
        81085,
        81180
      ],
      "content": "<bpt id=\"p1\">[</bpt>Implementing a Custom Retry Strategy<ept id=\"p1\">](http://msdn.microsoft.com/library/hh680943.aspx)</ept> (Topaz)"
    },
    {
      "content": "Token Issuance and Retry Guidelines",
      "pos": [
        81184,
        81219
      ]
    },
    {
      "content": "General REST and retry guidelines",
      "pos": [
        81280,
        81313
      ]
    },
    {
      "content": "Consider the following when accessing Azure or third party services:",
      "pos": [
        81315,
        81383
      ]
    },
    {
      "content": "Use a systematic approach to managing retries, perhaps as reusable code, so that you can apply a consistent methodology across all clients and all solutions.",
      "pos": [
        81387,
        81544
      ]
    },
    {
      "content": "Consider using a retry framework such as the Transient Fault Handling Application Block to manage retries if the target service or client has no built-in retry mechanism.",
      "pos": [
        81547,
        81717
      ]
    },
    {
      "content": "This will help you implement a consistent retry behavior, and it may provide a suitable default retry strategy for the target service.",
      "pos": [
        81718,
        81852
      ]
    },
    {
      "content": "However, you may need to create custom retry code for services that have non-standard behavior, that do not rely on exceptions to indicate transient failures, or if you want to use a <bpt id=\"p1\">**</bpt>Retry-Response<ept id=\"p1\">**</ept> reply to manage retry behavior.",
      "pos": [
        81853,
        82086
      ]
    },
    {
      "content": "The transient detection logic will depend on the actual client API you use to invoke the REST calls.",
      "pos": [
        82089,
        82189
      ]
    },
    {
      "content": "Some clients, such as the newer <bpt id=\"p1\">**</bpt>HttpClient<ept id=\"p1\">**</ept> class, will not throw exceptions for completed requests with a non-success HTTP status code.",
      "pos": [
        82190,
        82329
      ]
    },
    {
      "content": "This improves performance but prevents the use of the Transient Fault Handling Application Block.",
      "pos": [
        82330,
        82427
      ]
    },
    {
      "content": "In this case you could wrap the call to the REST API with code that produces exceptions for non-success HTTP status codes, which can then be processed by the block.",
      "pos": [
        82428,
        82592
      ]
    },
    {
      "content": "Alternatively, you can use a different mechanism to drive the retries.",
      "pos": [
        82593,
        82663
      ]
    },
    {
      "content": "The HTTP status code returned from the service can help to indicate whether the failure is transient.",
      "pos": [
        82666,
        82767
      ]
    },
    {
      "content": "You may need to examine the exceptions generated by a client or the retry framework to access the status code or to determine the equivalent exception type.",
      "pos": [
        82768,
        82924
      ]
    },
    {
      "content": "The following HTTP codes typically indicate that a retry is appropriate:",
      "pos": [
        82925,
        82997
      ]
    },
    {
      "content": "408 Request Timeout",
      "pos": [
        83002,
        83021
      ]
    },
    {
      "content": "500 Internal Server Error",
      "pos": [
        83026,
        83051
      ]
    },
    {
      "content": "502 Bad Gateway",
      "pos": [
        83056,
        83071
      ]
    },
    {
      "content": "503 Service Unavailable",
      "pos": [
        83076,
        83099
      ]
    },
    {
      "content": "504 Gateway Timeout",
      "pos": [
        83104,
        83123
      ]
    },
    {
      "content": "If you base your retry logic on exceptions, the following typically indicate a transient failure where no connection could be established:",
      "pos": [
        83126,
        83264
      ]
    },
    {
      "content": "WebExceptionStatus.ConnectionClosed",
      "pos": [
        83269,
        83304
      ]
    },
    {
      "content": "WebExceptionStatus.ConnectFailure",
      "pos": [
        83309,
        83342
      ]
    },
    {
      "content": "WebExceptionStatus.Timeout",
      "pos": [
        83347,
        83373
      ]
    },
    {
      "content": "WebExceptionStatus.RequestCanceled",
      "pos": [
        83378,
        83412
      ]
    },
    {
      "content": "In the case of a service unavailable status, the service might indicate the appropriate delay before retrying in the <bpt id=\"p1\">**</bpt>Retry-After<ept id=\"p1\">**</ept> response header or a different custom header (as in the DocumentDB service).",
      "pos": [
        83415,
        83624
      ]
    },
    {
      "content": "Services might also send additional information as custom headers, or embedded in the content of the response.",
      "pos": [
        83625,
        83735
      ]
    },
    {
      "content": "The Transient Fault Handling Application Block cannot use the standard or any custom “retry-after” headers.",
      "pos": [
        83736,
        83843
      ]
    },
    {
      "content": "Do not retry for status codes representing client errors (errors in the 4xx range) except for a 408 Request Timeout.",
      "pos": [
        83846,
        83962
      ]
    },
    {
      "content": "Thoroughly test your retry strategies and mechanisms under a range of conditions, such as different network states and varying system loadings.",
      "pos": [
        83965,
        84108
      ]
    },
    {
      "content": "Retry strategies",
      "pos": [
        84113,
        84129
      ]
    },
    {
      "content": "The following are the typical types of retry strategy intervals:",
      "pos": [
        84131,
        84195
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Exponential<ept id=\"p1\">**</ept>: A retry policy that performs a specified number of retries, using a randomized exponential back off approach to determine the interval between retries.",
      "pos": [
        84199,
        84367
      ]
    },
    {
      "content": "For example:",
      "pos": [
        84368,
        84380
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Incremental<ept id=\"p1\">**</ept>: A retry strategy with a specified number of retry attempts and an incremental time interval between retries.",
      "pos": [
        84853,
        84978
      ]
    },
    {
      "content": "For example:",
      "pos": [
        84979,
        84991
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>LinearRetry<ept id=\"p1\">**</ept>: A retry policy that performs a specified number of retries, using a specified fixed time interval between retries.",
      "pos": [
        85167,
        85298
      ]
    },
    {
      "content": "For example:",
      "pos": [
        85299,
        85311
      ]
    },
    {
      "content": "More information",
      "pos": [
        85360,
        85376
      ]
    },
    {
      "content": "Circuit breaker strategies",
      "pos": [
        85381,
        85407
      ]
    },
    {
      "content": "Transient Fault Handling Application Block (Topaz) strategies",
      "pos": [
        85462,
        85523
      ]
    },
    {
      "content": "The Transient Fault Handling Application Block has the following default strategies.",
      "pos": [
        85525,
        85609
      ]
    },
    {
      "content": "Strategy",
      "pos": [
        85615,
        85623
      ]
    },
    {
      "content": "Setting",
      "pos": [
        85641,
        85648
      ]
    },
    {
      "content": "Default value",
      "pos": [
        85695,
        85708
      ]
    },
    {
      "content": "Meaning",
      "pos": [
        85725,
        85732
      ]
    },
    {
      "content": "Exponential",
      "pos": [
        86411,
        86422
      ]
    },
    {
      "content": "retryCount",
      "pos": [
        86435,
        86445
      ]
    },
    {
      "content": "minBackoff",
      "pos": [
        86451,
        86461
      ]
    },
    {
      "content": "maxBackoff",
      "pos": [
        86473,
        86483
      ]
    },
    {
      "content": "deltaBackoff",
      "pos": [
        86495,
        86507
      ]
    },
    {
      "content": "fastFirstRetry",
      "pos": [
        86519,
        86533
      ]
    },
    {
      "content": "10",
      "pos": [
        86538,
        86540
      ]
    },
    {
      "content": "1 second",
      "pos": [
        86546,
        86554
      ]
    },
    {
      "content": "30 seconds",
      "pos": [
        86566,
        86576
      ]
    },
    {
      "content": "10 seconds",
      "pos": [
        86588,
        86598
      ]
    },
    {
      "content": "true",
      "pos": [
        86610,
        86614
      ]
    },
    {
      "content": "The number of retry attempts.",
      "pos": [
        86617,
        86646
      ]
    },
    {
      "content": "The minimum back-off time.",
      "pos": [
        86652,
        86678
      ]
    },
    {
      "content": "The higher of this value or the computed back-off will be used as the retry delay.",
      "pos": [
        86679,
        86761
      ]
    },
    {
      "content": "The minimum back-off time.",
      "pos": [
        86767,
        86793
      ]
    },
    {
      "content": "The lower of this value or the computed back-off will be used as the retry delay.",
      "pos": [
        86794,
        86875
      ]
    },
    {
      "content": "The value used to calculate a random delta for the exponential delay between retries.",
      "pos": [
        86881,
        86966
      ]
    },
    {
      "content": "Whether the first retry attempt will be made immediately.",
      "pos": [
        86972,
        87029
      ]
    },
    {
      "content": "Incremental",
      "pos": [
        87036,
        87047
      ]
    },
    {
      "content": "retryCount",
      "pos": [
        87060,
        87070
      ]
    },
    {
      "content": "initialInterval",
      "pos": [
        87076,
        87091
      ]
    },
    {
      "content": "increment",
      "pos": [
        87097,
        87106
      ]
    },
    {
      "content": "fastFirstRetry",
      "pos": [
        87118,
        87132
      ]
    },
    {
      "content": "10",
      "pos": [
        87140,
        87142
      ]
    },
    {
      "content": "1 second",
      "pos": [
        87148,
        87156
      ]
    },
    {
      "content": "1 second",
      "pos": [
        87162,
        87170
      ]
    },
    {
      "content": "true",
      "pos": [
        87182,
        87186
      ]
    },
    {
      "content": "The number of retry attempts.",
      "pos": [
        87191,
        87220
      ]
    },
    {
      "content": "The initial interval that will apply for the first retry.",
      "pos": [
        87226,
        87283
      ]
    },
    {
      "content": "The incremental time value that will be used to calculate the progressive delay between retries.",
      "pos": [
        87289,
        87385
      ]
    },
    {
      "content": "Whether the first retry attempt will be made immediately.",
      "pos": [
        87391,
        87448
      ]
    },
    {
      "content": "Linear (fixed interval)",
      "pos": [
        87496,
        87519
      ]
    },
    {
      "content": "retryCount",
      "pos": [
        87524,
        87534
      ]
    },
    {
      "content": "retryInterval",
      "pos": [
        87540,
        87553
      ]
    },
    {
      "content": "fastFirstRetry",
      "pos": [
        87559,
        87573
      ]
    },
    {
      "content": "10",
      "pos": [
        87594,
        87596
      ]
    },
    {
      "content": "1 second",
      "pos": [
        87602,
        87610
      ]
    },
    {
      "content": "true",
      "pos": [
        87616,
        87620
      ]
    },
    {
      "content": "The number of retry attempts.",
      "pos": [
        87634,
        87663
      ]
    },
    {
      "content": "The delay between retries.",
      "pos": [
        87669,
        87695
      ]
    },
    {
      "content": "Whether first retry attempt will be made immediately.",
      "pos": [
        87701,
        87754
      ]
    },
    {
      "content": "For examples of using the Transient Fault Handling Application Block, see the Examples sections earlier in this guidance for Azure SQL Database using ADO.NET and Azure Active Directory.",
      "pos": [
        87930,
        88115
      ]
    },
    {
      "content": "test",
      "pos": [
        88117,
        88121
      ]
    }
  ],
  "content": "<properties\n   pageTitle=\"Retry service specific guidance | Microsoft Azure\"\n   description=\"Service specific guidance for setting the retry mechanism.\"\n   services=\"\"\n   documentationCenter=\"na\"\n   authors=\"dragon119\"\n   manager=\"masimms\"\n   editor=\"\"\n   tags=\"\"/>\n\n<tags\n   ms.service=\"best-practice\"\n   ms.devlang=\"na\"\n   ms.topic=\"article\"\n   ms.tgt_pltfrm=\"na\"\n   ms.workload=\"na\"\n   ms.date=\"04/28/2015\"\n   ms.author=\"masashin\"/>\n\n# Retry service specific guidance\n\n![](media/best-practices-retry-service-specific/pnp-logo.png)\n\n## Overview\n\nMost Azure services and client SDKs include a retry mechanism. However, these differ because each service has different characteristics and requirements, and so each retry mechanism is tuned to a specific service. This guide summarizes the retry mechanism features for the majority of Azure services, and includes information to help you use, adapt, or extend the retry mechanism for that service.\n\nFor general guidance on handling transient faults, and retrying connections and operations against services and resources, see [Retry guidance](best-practices-retry-general.md).\n\nThe following table summarizes the retry features for the Azure services described in this guidance.\n\n| **Service**                           | **Retry capabilities**                  | **Policy configuration**     | **Scope**                                        | **Telemetry features** |\n|---------------------------------------|-----------------------------------------|------------------------------|--------------------------------------------------|------------------------\n| **[AzureStorage](#azure-storage-retry-guidelines)**                      | Native in client                        | Programmatic                 | Client and individual operations                 | TraceSource            |\n| **[SQL Database with Entity Framework](#sql-database-using-entity-framework-6-retry-guidelines)** | Native in client                        | Programmatic                 | Global per AppDomain                             | None                   |\n| **[SQL Database with ADO.NET](#sql-database-using-ado-net-retry-guidelines)**         | Topaz*                                  | Declarative and programmatic | Single statements or blocks of code              | Custom                 |\n| **[Service Bus](#service-bus-retry-guidelines)**                       | Native in client                        | Programmatic                 | Namespace Manager, Messaging Factory, and Client | ETW                    |\n| **[Cache](#cache-redis-retry-guidelines)**                             | Native in client                        | Programmatic                 | Client                                           | TextWriter             |\n| **[DocumentDB](#documentdb-pre-release-retry-guidelines)**                        | Native in service                       | Non-configurable             | Global                                           | TraceSource            |\n| **[Search](#search-retry-guidelines)**                            | Topaz* (with custom detection strategy) | Declarative and programmatic | Blocks of code                                   | Custom                 |\n| **[Active Directory](#azure-active-directory-retry-guidelines)**                  | Topaz* (with custom detection strategy) | Declarative and programmatic | Blocks of code                                   | Custom                 |\n*Topaz in the friendly name for the Transient Fault Handling Application Block that is included in <a href=\"http://msdn.microsoft.com/library/dn440719.aspx\">Enterprise Library 6.0</a>. You can use a custom detection strategy with Topaz for most types of services, as described in this guidance. Default strategies for Topaz are shown in the section [Transient Fault Handling Application Block (Topaz) strategies](#transient-fault-handling-application-block-topaz-strategies) at the end of this guidance. Note that the block is now an open-sourced framework and is not directly supported by Microsoft.\n\n> [AZURE.NOTE] For most of the Azure built-in retry mechanisms, there is currently no way apply a different retry policy for different types of error or exception beyond the functionality include in the retry policy. Therefore, the best guidance available at the time of writing is to configure a policy that provides the optimum average performance and availability. One way to fine-tune the policy is to analyze log files to determine the type of transient faults that are occurring. For example, if the majority of errors are related to network connectivity issues, you might attempt an immediate retry rather than wait a long time for the first retry.\n\n## Azure Storage retry guidelines\n\nAzure storage services include table and blob storage, files, and storage queues.\n\n### Retry mechanism\n\nRetries occur at the individual REST operation level and are an integral part of the client API implementation. The client storage SDK uses classes that implement the [IExtendedRetryPolicy Interface](http://msdn.microsoft.com/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.aspx).\n\nThere are different implementations of the interface. Storage clients can choose from policies specifically designed for accessing tables, blobs, and queues. Each implementation uses a different retry strategy that essentially defines the retry interval and other details.\n\nThe built-in classes provide support for linear (constant delay) and exponential with randomization retry intervals. There is also a no retry policy for use when another process is handling retries at a higher level. However, you can implement your own retry classes if you have specific requirements not provided by the built-in classes.\n\nAlternate retries switch between primary and secondary storage service location if you are using read access geo-redundant storage (RA-GRS) and the result of the request is a retryable error. See [Azure Storage Redundancy Options](http://msdn.microsoft.com/library/azure/dn727290.aspx) for more information.\n\n### Policy configuration (Azure storage)\n\nRetry policies are configured programmatically. A typical procedure is to create and populate a **TableRequestOptions**, **BlobRequestOptions**, **FileRequestOptions**, or **QueueRequestOptions** instance.\n\n```csharp\nTableRequestOptions interactiveRequestOption = new TableRequestOptions()\n{\n  RetryPolicy = new LinearRetry(TimeSpan.FromMilliseconds(500), 3),\n  // For Read-access geo-redundant storage, use PrimaryThenSecondary.\n  // Otherwise set this to PrimaryOnly.\n  LocationMode = LocationMode.PrimaryThenSecondary,\n  // Maximum execution time based on the business use case. Maximum value up to 10 seconds.\n  MaximumExecutionTime = TimeSpan.FromSeconds(2)\n};\n```\n\nThe request options instance can then be set on the client, and all operations with the client will use the specified request options.\n\n```csharp\nclient.DefaultRequestOptions = interactiveRequestOption;\nvar stats = await client.GetServiceStatsAsync();\n```\n\nYou can override the client request options by passing a populated instance of the request options class as a parameter to operation methods.\n\n```csharp\nvar stats = await client.GetServiceStatsAsync(interactiveRequestOption, operationContext: null);\n```\n\nYou use an **OperationContext** instance to specify the code to execute when a retry occurs and when an operation has completed. This code can collect information about the operation for use in logs and telemetry.\n\n    // Set up notifications for an operation\n    var context = new OperationContext();\n    context.ClientRequestID = \"some request id\";\n    context.Retrying += (sender, args) =>\n    {\n      /* Collect retry information */\n    };\n    context.RequestCompleted += (sender, args) =>\n    {\n      /* Collect operation completion information */\n    };\n    var stats = await client.GetServiceStatsAsync(null, context);\n\nIn addition to indicating whether a failure is suitable for retry, the extended retry policies return a **RetryContext** object that indicates the number of retries, the results of the last request, whether the next retry will happen in the primary or secondary location (see table below for details). The properties of the **RetryContext** object can be used to decide if and when to attempt a retry. For more details, see [IExtendedRetryPolicy.Evaluate Method](http://msdn.microsoft.com/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx).\n\nThe following table shows the default settings for the built-in retry policies.\n\n| **Context**              | **Setting**                                                 | **Default value**                  | **Meaning**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |\n|--------------------------|-------------------------------------------------------------|------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| Table / Blob / File<br />QueueRequestOptions | MaximumExecutionTime<br /><br />ServerTimeout<br /><br /><br /><br /><br />LocationMode<br /><br /><br /><br /><br /><br /><br />RetryPolicy | 120 seconds<br /><br />None<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />ExponentialPolicy | Maximum execution time for the request, including all potential retry attempts.<br />Server timeout interval for the request (value is rounded to seconds). If not specified, it will use the default value for all requests to the server. Usually, the best option is to omit this setting so that the server default is used.<br />If the storage account is created with the Read access geo-redundant storage (RA-GRS) replication option, you can use the location mode to indicate which location should receive the request. For example, if **PrimaryThenSecondary** is specified, requests are always sent to the primary location first. If a request fails, it is sent to the secondary location.<br />See below for details of each option. |\n| Exponential policy                      | maxAttempt<br />deltaBackoff<br /><br /><br />MinBackoff<br /><br />MaxBackoff               | 3<br />4 seconds<br /><br /><br />3 seconds<br /><br />30 seconds   | Number of retry attempts.<br />Back-off interval between retries. Multiples of this timespan, including a random element, will be used for subsequent retry attempts.<br />Added to all retry intervals computed from deltaBackoff. This value cannot be changed.<br />MaxBackoff is used if the computed retry interval is greater than MaxBackoff. This value cannot be changed.                                                                                                                                                                                                                                                                                                                                                                       |\n| Linear policy                           | maxAttempt<br />deltaBackoff                                     | 3<br />30 seconds                                 | Number of retry attempts.<br />Back-off interval between retries.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\n\n### Retry usage guidance\nConsider the following guidelines when accessing Azure storage services using the storage client API:\n\n* Use the built-in retry policies from the Microsoft.WindowsAzure.Storage.RetryPolicies namespace where they are appropriate for your requirements. In most cases, these policies will be sufficient.\n* Use the **ExponentialRetry** policy in batch operations, background tasks, or non-interactive scenarios. In these scenarios, you can typically allow more time for the service to recover—with a consequently increased chance of the operation eventually succeeding.\n* Consider specifying the **MaximumExecutionTime** property of the **RequestOptions** parameter to limit the total execution time, but take into account the type and size of the operation when choosing a timeout value.\n* If you need to implement a custom retry, avoid creating wrappers around the storage client classes. Instead, use the capabilities to extend the existing policies through the **IExtendedRetryPolicy** interface.\n* If you are using read access geo-redundant storage (RA-GRS) you can use the **LocationMode** to specify that retry attempts will access the secondary read-only copy of the store should the primary access fail. However, when using this option you must ensure that your application can work successfully with data that may be stale if the replication from the primary store has not yet completed.\n\nConsider starting with following settings for retrying operations. These are general purpose settings, and you should monitor the operations and fine tune the values to suit your own scenario.  \n\n| **Context**          | **Sample target E2E<br />max latency** | **Retry policy** | **Settings**            | **Values**  | **How it works**                                                            |\n|----------------------|-----------------------------------|------------------|-------------------------|-------------|-----------------------------------------------------------------------------|\n| Interactive, UI,<br />or foreground | 2 seconds                         | Linear           | maxAttempt<br />deltaBackoff | 3<br />500 ms    | Attempt 1 - delay 500 ms<br />Attempt 2 - delay 500 ms<br />Attempt 3 - delay 500 ms  |\n| Background<br />or batch            | 30 seconds                        | Exponential      | maxAttempt<br />deltaBackoff | 5<br />4 seconds | Attempt 1 - delay ~3 sec<br />Attempt 2 - delay ~7 sec<br />Attempt 3 - delay ~15 sec |\n\n## Telemetry\n\nRetry attempts are logged to a **TraceSource**. You must configure a **TraceListener** to capture the events and write them to a suitable destination log. You can use the **TextWriterTraceListener** or **XmlWriterTraceListener** to write the data to a log file, the **EventLogTraceListener** to write to the Windows Event Log, or the **EventProviderTraceListener** to write trace data to the ETW subsystem. You can also configure auto-flushing of the buffer, and the verbosity of events that will be logged (for example, Error, Warning, Informational, and Verbose). For more information, see [Client-side Logging with the .NET Storage Client Library](http://msdn.microsoft.com/library/azure/dn782839.aspx).\n\nOperations can receive an **OperationContext** instance, which exposes a **Retrying** event that can be used to attach custom telemetry logic. For more information, see [OperationContext.Retrying Event](http://msdn.microsoft.com/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx).\n\n## Examples (Azure storage)\n\nThe following code example shows how to create two **TableRequestOptions** instances with different retry settings; one for interactive requests and one for background requests. The example then sets these two retry policies on the client so that they apply for all requests, and also sets the interactive strategy on a specific request so that it overrides the default settings applied to the client.\n\n```csharp\nusing System;\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.Storage;\nusing Microsoft.WindowsAzure.Storage.RetryPolicies;\nusing Microsoft.WindowsAzure.Storage.Table;\n\nnamespace RetryCodeSamples\n{\n    class AzureStorageCodeSamples\n    {\n        private const string connectionString = \"UseDevelopmentStorage=true\";\n\n        public async static Task Samples()\n        {\n            var storageAccount = CloudStorageAccount.Parse(connectionString);\n\n            TableRequestOptions interactiveRequestOption = new TableRequestOptions()\n            {\n                RetryPolicy = new LinearRetry(TimeSpan.FromMilliseconds(500), 3),\n                // For Read-access geo-redundant storage, use PrimaryThenSecondary.\n                // Otherwise set this to PrimaryOnly.\n                LocationMode = LocationMode.PrimaryThenSecondary,\n                // Maximum execution time based on the business use case. Maximum value up to 10 seconds.\n                MaximumExecutionTime = TimeSpan.FromSeconds(2)\n            };\n\n            TableRequestOptions backgroundRequestOption = new TableRequestOptions()\n            {\n                // Client has a default exponential retry policy with 4 sec delay and 3 retry attempts\n                // Retry delays will be approximately 3 sec, 7 sec, and 15 sec\n                MaximumExecutionTime = TimeSpan.FromSeconds(30),\n                // PrimaryThenSecondary in case of Read-access geo-redundant storage, else set this to PrimaryOnly\n                LocationMode = LocationMode.PrimaryThenSecondary\n            };\n\n            var client = storageAccount.CreateCloudTableClient();\n            // Client has a default exponential retry policy with 4 sec delay and 3 retry attempts\n            // Retry delays will be approximately 3 sec, 7 sec, and 15 sec\n            // ServerTimeout and MaximumExecutionTime are not set\n\n            {\n                // Set properties for the client (used on all requests unless overridden)\n                // Different exponential policy parameters for background scenarios\n                client.DefaultRequestOptions = backgroundRequestOption;\n                // Linear policy for interactive scenarios\n                client.DefaultRequestOptions = interactiveRequestOption;\n            }\n\n            {\n                // set properties for a specific request\n                var stats = await client.GetServiceStatsAsync(interactiveRequestOption, operationContext: null);\n            }\n\n            {\n                // Set up notifications for an operation\n                var context = new OperationContext();\n                context.ClientRequestID = \"some request id\";\n                context.Retrying += (sender, args) =>\n                {\n                    /* Collect retry information */\n                };\n                context.RequestCompleted += (sender, args) =>\n                {\n                    /* Collect operation completion information */\n                };\n                var stats = await client.GetServiceStatsAsync(null, context);\n            }\n        }\n    }\n}\n```\n\n## More information\n\n- [Azure Storage Client Library Retry Policy Recommendations](http://azure.microsoft.com/blog/2014/05/22/azure-storage-client-library-retry-policy-recommendations/)\n- [Storage Client Library 2.0 – Implementing Retry Policies](http://gauravmantri.com/2012/12/30/storage-client-library-2-0-implementing-retry-policies/)\n\n## SQL Database using Entity Framework 6 retry guidelines\n\nSQL Database is a hosted SQL database available in a range of sizes and as both a standard (shared) and premium (non-shared) service. Entity Framework is an object-relational mapper that enables .NET developers to work with relational data using domain-specific objects. It eliminates the need for most of the data-access code that developers usually need to write.\n\n## Retry mechanism\n\nRetry support is provided when accessing SQL Database using Entity Framework 6.0 and higher through a mechanism called [Connection Resiliency / Retry Logic](http://msdn.microsoft.com/data/dn456835.aspx). A full specification is available in the [.NET Entity Framework wiki](https://entityframework.codeplex.com/wikipage?title=Connection%20Resiliency%20Spec) on Codeplex. The main features of the retry mechanism are:\n\n* The primary abstraction is the **IDbExecutionStrategy** interface. This interface:\n  * Defines synchronous and asynchronous **Execute*** methods.\n  * Defines classes that can be used directly or can be configured on a database context as a default strategy, mapped to provider name, or mapped to a provider name and server name. When configured on a context, retries occur at the level of individual database operations, of which there might be several for a given context operation.\n  * Defines when to retry a failed connection, and how.\n* It includes several built-in implementations of the **IDbExecutionStrategy** interface:\n  * Default - no retrying.\n  * Default for SQL Database (automatic) - no retrying, but inspects exceptions and wraps them with suggestion to use the SQL Database strategy.\n  * Default for SQL Database - exponential (inherited from base class) plus SQL Database detection logic.\n* It implements an exponential back-off strategy that includes randomization.\n* The built-in retry classes are stateful and are not thread safe. However, they can be reused after the current operation is completed.\n* If the specified retry count is exceeded, the results are wrapped in a new exception. It does not bubble up the current exception.\n\n## Policy configuration (SQL Database using Entity Framework 6)\n\nRetry support is provided when accessing SQL Database using Entity Framework 6.0 and higher. Retry policies are configured programmatically. The configuration cannot be changed on a per-operation basis.\n\nWhen configuring a strategy on the context as the default, you specify a function that creates a new strategy on demand. The following code shows how you can create a retry configuration class that extends the **DbConfiguration** base class.\n\n```csharp\npublic class BloggingContextConfiguration : DbConfiguration\n{\n  public BlogConfiguration()\n  {\n    // Set up the execution strategy for SQL Database (exponential) with 5 retries and 4 sec delay\n    this.SetExecutionStrategy(\n         \"System.Data.SqlClient\", () => new SqlAzureExecutionStrategy(5, TimeSpan.FromSeconds(4)));\n  }\n}\n```\n\nYou can then specify this as the default retry strategy for all operations using the **SetConfiguration** method of the **DbConfiguration** instance when the application starts. By default, EF will automatically discover and use the configuration class.\n\n    DbConfiguration.SetConfiguration(new BloggingContextConfiguration());\n\nYou can specify the retry configuration class for a context by annotating the context class with a **DbConfigurationType** attribute. However, if you have only one configuration class, EF will use it without the need to annotate the context.\n\n    [DbConfigurationType(typeof(BloggingContextConfiguration))]\n    public class BloggingContext : DbContext\n    { ...\n\nIf you need to use different retry strategies for specific operations, or disable retries for specific operations, you can create a configuration class that allows you to suspend or swap strategies by setting a flag in the **CallContext**. The configuration class can use this flag to switch strategies, or disable the strategy you provide and use a default strategy. For more information, see [Suspend Execution Strategy](http://msdn.microsoft.com/dn307226#transactions_workarounds) in the page Limitations with Retrying Execution Strategies (EF6 onwards).\n\nAnother technique for using specific retry strategies for individual operations is to create an instance of the required strategy class and supply the desired settings through parameters. You then invoke its **ExecuteAsync** method.\n\n    var executionStrategy = new SqlAzureExecutionStrategy(5, TimeSpan.FromSeconds(4));\n    var blogs = await executionStrategy.ExecuteAsync(\n        async () =>\n        {\n            using (var db = new BloggingContext(\"Blogs\"))\n            {\n                // Acquire some values asynchronously and return them\n            }\n        },\n        new CancellationToken()\n    );\n\nThe simplest way to use a **DbConfiguration** class is to locate it in the same assembly as the **DbContext** class. However, this is not appropriate when the same context is required in different scenarios, such as different interactive and background retry strategies. If the different contexts execute in separate AppDomains, you can use the built-in support for specifying configuration classes in the configuration file or set it explicitly using code. If the different contexts must execute in the same AppDomain, a custom solution will be required.\n\nFor more information, see [Code-Based Configuration (EF6 onwards)](http://msdn.microsoft.com/data/jj680699.aspx).\n\nThe following table shows the default settings for the built-in retry policy when using EF6.\n\n![](media/best-practices-retry-service-specific/RetryServiceSpecificGuidanceTable4.png)\n## Retry usage guidance\n\nConsider the following guidelines when accessing SQL Database using EF6:\n\n* Choose the appropriate service option (shared or premium). A shared instance may suffer longer than usual connection delays and throttling due to the usage by other tenants of the shared server. If predictable performance and reliable low latency operations are required, consider choosing the premium option.\n* A fixed interval strategy is not recommended for use with Azure SQL Database. Instead, use an exponential back-off strategy because the service may be overloaded, and longer delays allow more time for it to recover.\n* Choose a suitable value for the connection and command timeouts when defining connections. Base the timeout on both your business logic design and through testing. You may need to modify this value over time as the volumes of data or the business processes change. Too short a timeout may result in premature failures of connections when the database is busy. Too long a timeout may prevent the retry logic working correctly by waiting too long before detecting a failed connection. The value of the timeout is a component of the end-to-end latency, although you cannot easily determine how many commands will execute when saving the context. You can change the default timeout by setting the **CommandTimeout** property of the **DbContext** instance.\n* Entity Framework supports retry configurations defined in configuration files. However, for maximum flexibility on Azure you should consider creating the configuration programmatically within the application. The specific parameters for the retry policies, such as the number of retries and the retry intervals, can be stored in the service configuration file and used at runtime to create the appropriate policies. This allows the settings to be changed within requiring the application to be restarted.\n\nConsider starting with following settings for retrying operations. You cannot specify the delay between retry attempts (it is fixed and generated as an exponential sequence). You can specify only the maximum values, as shown here; unless you create a custom retry strategy. These are general purpose settings, and you should monitor the operations and fine tune the values to suit your own scenario.\n\n| **Context**          | **Sample target E2E<br />max latency** | **Retry policy** | **Settings**           | **Values**   | **How it works**                                                                                                            |\n|----------------------|-----------------------------------|--------------------|------------------------|--------------|-----------------------------------------------------------------------------------------------------------------------------|\n| Interactive, UI,<br />or foreground | 2 seconds                         | Exponential        | MaxRetryCount<br />MaxDelay | 3<br />750 ms     | Attempt 1 - delay 0 sec<br />Attempt 2 - delay 750 ms<br />Attempt 3 – delay 750 ms                                                   |\n| Background<br /> or batch            | 30 seconds                        | Exponential        | MaxRetryCount<br />MaxDelay | 5<br />12 seconds | Attempt 1 - delay 0 sec<br />Attempt 2 - delay ~1 sec<br />Attempt 3 - delay ~3 sec<br />Attempt 4 - delay ~7 sec<br />Attempt 5 - delay 12 sec |\n\n> [AZURE.NOTE] The end-to-end latency targets assume the default timeout for connections to the service. If you specify longer connection timeouts, the end-to-end latency will be extended by this additional time for every retry attempt.\n\n## Examples (SQL Database using Entity Framework 6)\n\nThe following code example defines a simple data access solution that uses Entity Framework. It sets a specific retry strategy by defining an instance of a class named **BlogConfiguration** that extends **DbConfiguration**.\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Data.Entity;\nusing System.Data.Entity.SqlServer;\nusing System.Threading.Tasks;\n\nnamespace RetryCodeSamples\n{\n    public class BlogConfiguration : DbConfiguration\n    {\n        public BlogConfiguration()\n        {\n            // Set up the execution strategy for SQL Database (exponential) with 5 retries and 12 sec delay.\n            // These values could be loaded from configuration rather than being hard-coded.\n            this.SetExecutionStrategy(\n                    \"System.Data.SqlClient\", () => new SqlAzureExecutionStrategy(5, TimeSpan.FromSeconds(12)));\n        }\n    }\n\n    // Specify the configuration type if more than one has been defined.\n    // [DbConfigurationType(typeof(BlogConfiguration))]\n    public class BloggingContext : DbContext\n    {\n        // Definition of content goes here.\n    }\n\n    class EF6CodeSamples\n    {\n        public async static Task Samples()\n        {\n            // Execution strategy configured by DbConfiguration subclass, discovered automatically or\n            // or explicitly indicated through configuration or with an attribute. Default is no retries.\n            using (var db = new BloggingContext(\"Blogs\"))\n            {\n                // Add, edit, delete blog items here, then:\n                await db.SaveChangesAsync();\n            }\n        }\n    }\n}\n```\n\nMore examples of using the Entity Framework retry mechanism can be found in [Connection Resiliency / Retry Logic](http://msdn.microsoft.com/data/dn456835.aspx).\n\n## More information\n\n* [Azure SQL Database Performance and Elasticity Guide](http://social.technet.microsoft.com/wiki/contents/articles/3507.windows-azure-sql-database-performance-and-elasticity-guide.aspx)\n\n## SQL Database using ADO.NET retry guidelines\n\nSQL Database is a hosted SQL database available in a range of sizes and as both a standard (shared) and premium (non-shared) service.\n\n### Retry mechanism\n\nSQL Database has no built-in support for retries when accessed using ADO.NET. However, the return codes from requests can be used to determine why a request failed. The page [Azure SQL Database Throttling](http://msdn.microsoft.com/library/dn338079.aspx) explains how throttling can prevent connections, the return codes for specific situations, and how you can handle these and retry operations.\n\nYou can use the Transient Fault Handling Application Block (Topaz) with the Nuget package EnterpriseLibrary.TransientFaultHandling.Data (class **SqlAzureTransientErrorDetectionStrategy**) to implement a retry mechanism for SQL Database.\n\nThe block also provides the **ReliableSqlConnection** class, which implements the old ADO.NET 1.0 API (**IDbConnection** instead of **DbConnection**) and performs retries and connection management internally. While convenient, this requires you to use a different set of methods for invoking operations with retries, and so is not a simple direct replacement. It does not support asynchronous execution, which is recommended when implementing and using Azure services. In addition, because this class uses ADO.NET 1.0, it does not benefit from the recent improvements and updates to ADO.NET.\n\n### Policy configuration (SQL Database using ADO.NET)\n\nThe Transient Fault Handling Application Block supports both file-based and programmatic configuration. In general, you should use programmatic configuration for maximum flexibility (see the notes in the following section for more information). The following code, which would be executed once at application startup, creates and populates a **RetryManager** with a list of four retry strategies suitable for use with Azure SQL Database. It also sets the default strategies for the **RetryManager**. These are the strategies that will be used for connections and commands if an alternative is not specified when creating a connection or command.\n\n```csharp\nRetryManager.SetDefault(new RetryManager(\n    new List<RetryStrategy> { new ExponentialBackoff(name: \"default\", retryCount: 3,\n                                                    minBackoff:     TimeSpan.FromMilliseconds(100),\n                                                    maxBackoff:     TimeSpan.FromSeconds(30),\n                                                    deltaBackoff:   TimeSpan.FromSeconds(1),\n                                                    firstFastRetry: true),\n                            new ExponentialBackoff(name: \"default sql connection\", retryCount: 3,\n                                                    minBackoff:     TimeSpan.FromMilliseconds(100),\n                                                    maxBackoff:     TimeSpan.FromSeconds(30),\n                                                    deltaBackoff:   TimeSpan.FromSeconds(1),\n                                                    firstFastRetry: true),\n                            new ExponentialBackoff(name: \"default sql command\", retryCount: 3,\n                                                    minBackoff:     TimeSpan.FromMilliseconds(100),\n                                                    maxBackoff:     TimeSpan.FromSeconds(30),\n                                                    deltaBackoff:   TimeSpan.FromSeconds(1),\n                                                    firstFastRetry: true),\n                            new ExponentialBackoff(name: \"alt sql\", retryCount: 5,\n                                                    minBackoff:     TimeSpan.FromMilliseconds(100),\n                                                    maxBackoff:     TimeSpan.FromSeconds(30),\n                                                    deltaBackoff:   TimeSpan.FromSeconds(1),\n                                                    firstFastRetry: true), },\n    \"default\",\n    new Dictionary<string, string> {\n        {\n        RetryManagerSqlExtensions.DefaultStrategyConnectionTechnologyName, \"default sql connection\"\n        },\n        {\n        RetryManagerSqlExtensions.DefaultStrategyCommandTechnologyName, \"default sql command\"}\n        }));\n```\n\nFor information about how you can use the retry policies you have configured when you access Azure SQL Database, see the [Examples](#examples-sql-database-using-ado-net-) section below.\n\nDefault strategies for the Transient Fault Handling Application Block are shown in the section [Transient Fault Handling Application Block (Topaz) strategies](#transient-fault-handling-application-block-topaz-strategies) at the end of this guidance.\n\n### Retry usage guidance\n\nConsider the following guidelines when accessing SQL Database using ADO.NET:\n\n* Choose the appropriate service option (shared or premium). A shared instance may suffer longer than usual connection delays and throttling due to the usage by other tenants of the shared server. If more predictable performance and reliable low latency operations are required, consider choosing the premium option.\n* Ensure that you perform retries at the appropriate level or scope to avoid non-idempotent operations causing inconsistency in the data. Ideally, all operations should be idempotent so that they can be repeated without causing inconsistency. Where this is not the case, the retry should be performed at a level or scope that allows all related changes to be undone if one operation fails; for example, from within a transactional scope. For more information, see [Cloud Service Fundamentals Data Access Layer – Transient Fault Handling](http://social.technet.microsoft.com/wiki/contents/articles/18665.cloud-service-fundamentals-data-access-layer-transient-fault-handling.aspx#Idempotent_Guarantee).\n* A fixed interval strategy is not recommended for use with Azure SQL Database except for interactive scenarios where there are only a few retries at very short intervals. Instead, consider using an exponential back-off strategy for the majority of scenarios.\n* Choose a suitable value for the connection and command timeouts when defining connections. Too short a timeout may result in premature failures of connections when the database is busy. Too long a timeout may prevent the retry logic working correctly by waiting too long before detecting a failed connection. The value of the timeout is a component of the end-to-end latency; it is effectively added to the retry delay specified in the retry policy for every retry attempt.\n* Close the connection after a certain number of retries, even when using an exponential back off retry logic, and retry the operation on a new connection. Retrying the same operation multiple times on the same connection can be a factor that contributes to connection problems. For an example of this technique, see [Cloud Service Fundamentals Data Access Layer – Transient Fault Handling](http://social.technet.microsoft.com/wiki/contents/articles/18665.cloud-service-fundamentals-data-access-layer-transient-fault-handling.aspx).\n* When connection pooling is in use (the default) there is a chance that the same connection will be chosen from the pool, even after closing and reopening a connection. If this is the case, a technique to resolve it is to call the **ClearPool** method of the **SqlConnection** class to mark the connection as not reusable. However, you should do this only after several connection attempts have failed, and only when encountering the specific class of transient failures such as SQL timeouts (error code -2) related to faulty connections.\n* If the data access code uses transactions initiated as **TransactionScope** instances, the retry logic should reopen the connection and initiate a new transaction scope. For this reason, the retryable code block should encompass the entire scope of the transaction.\n* The Transient Fault Handling Application Block supports retry configurations entirely defined in configuration files. However, for maximum flexibility on Azure you should consider creating the configuration programmatically within the application. The specific parameters for the retry policies, such as the number of retries and the retry intervals, can be stored in the service configuration file and used at runtime to create the appropriate policies. This allows the settings to be changed within requiring the application to be restarted.\n\nConsider starting with following settings for retrying operations. These are general purpose settings, and you should monitor the operations and fine tune the values to suit your own scenario.\n\n| **Context**          | **Sample target E2E<br />max latency** | **Retry strategy** | **Settings**                                                          | **Values**                 | **How it works**                                                                                                              |\n|----------------------|-----------------------------------|--------------------|-----------------------------------------------------------------------|----------------------------|-------------------------------------------------------------------------------------------------------------------------------|\n| Interactive, UI,<br />or foreground | 2 sec                             | FixedInterval      | Retry count<br />Retry interval<br />First fast retry                           | 3<br />500 ms<br />true              | Attempt 1 - delay 0 sec<br />Attempt 2 - delay 500 ms<br />Attempt 3 - delay 500 ms                                                     |\n| Background<br />or batch            | 30 sec                            | ExponentialBackoff | Retry count<br />Min back-off<br />Max back-off<br />Delta back-off<br />First fast retry | 5<br />0 sec<br />60 sec<br />2 sec<br />false | Attempt 1 - delay 0 sec<br />Attempt 2 - delay ~2 sec<br />Attempt 3 - delay ~6 sec<br />Attempt 4 - delay ~14 sec<br />Attempt 5 - delay ~30 sec |\n\n> [AZURE.NOTE] The end-to-end latency targets assume the default timeout for connections to the service. If you specify longer connection timeouts, the end-to-end latency will be extended by this additional time for every retry attempt.\n\n### Examples (SQL Database using ADO.NET)\n\nThis section describes how you can use the Transient Fault Handling Application Block to access Azure SQL Database using a set of retry policies you have configured in the **RetryManager** (as shown in the previous section [Policy configuration](#policy-configuration-sql-database-using-ado-net-). The simplest approach to using the block is through the **ReliableSqlConnection** class, or by calling the extension methods such as **OpenWithRetry** on a connection (see [The Transient Fault Handling Application Block](http://msdn.microsoft.com/library/hh680934.aspx) for more information).\n\nHowever, in the current version of the Transient Fault Handling Application Block these approaches do not indigenously support asynchronous operations against SQL Database. Good practice demands that you use only asynchronous techniques to access Azure services such as SQL Database, and so you should consider the following techniques to use the Transient Fault Handling Application Block with SQL Database.\n\nYou can use the simplified asynchronous support in version 5 of the C# language to create asynchronous versions of the methods provided by the block. For example, the following code shows how you might create an asynchronous version of the **ExecuteReaderWithRetry** extension method. The changes and additions to the original code are highlighted. The source code for Topaz is available on GitHub at [Transient Fault Handling Application Block (\"Topaz\")](http://topaz.codeplex.com/SourceControl/latest).\n\n```csharp\npublic async static Task<SqlDataReader> ExecuteReaderWithRetryAsync(this SqlCommand command, RetryPolicy cmdRetryPolicy,\nRetryPolicy conRetryPolicy)\n{\n    GuardConnectionIsNotNull(command);\n\n    // Check if retry policy was specified, if not, use the default retry policy.\n    return await (cmdRetryPolicy ?? RetryPolicy.NoRetry).ExecuteAsync(async () =>\n    {\n        var hasOpenConnection = await EnsureValidConnectionAsync(command, conRetryPolicy).ConfigureAwait(false);\n\n        try\n        {\n            return await command.ExecuteReaderAsync().ConfigureAwait(false);\n        }\n        catch (Exception)\n        {\n            if (hasOpenConnection && command.Connection != null && command.Connection.State == ConnectionState.Open)\n            {\n                command.Connection.Close();\n            }\n\n            throw;\n        }\n    }).ConfigureAwait(false);\n}\n```\n\nThis new asynchronous extension method can be used in the same way as the synchronous versions included in the block.\n\n```csharp\nvar sqlCommand = sqlConnection.CreateCommand();\nsqlCommand.CommandText = \"[some query]\";\n\nvar retryPolicy =\n    RetryManager.Instance.GetRetryPolicy<SqlDatabaseTransientErrorDetectionStrategy>(\"alt sql\");\nusing (var reader = await sqlCommand.ExecuteReaderWithRetryAsync(retryPolicy))\n{\n    // Do something with the values\n}\n```\n\nHowever, this approach deals only with individual operations or commands, and not with blocks of statements where there can be properly defined transactional boundaries. In addition, it does not address the situation of removing faulty connections from the connection pool so that they are not selected for subsequent attempts. A synchronous example of resolving these issues can be found in [Cloud Service Fundamentals Data Access Layer – Transient Fault Handling](http://social.technet.microsoft.com/wiki/contents/articles/18665.cloud-service-fundamentals-data-access-layer-transient-fault-handling.aspx#Timeouts_amp_Connection_Management). In addition to retrying arbitrary sequences of database instructions, it clears the connection pool to remove invalid connections, and instruments the entire process. While the code shown in this example is synchronous, it is relatively easy to convert it to asynchronous code.\n\n### More information\n\nFor detailed information about using the Transient Fault Handling Application Block, see:\n\n* [Using the Transient Fault Handling Application Block with SQL Azure](http://msdn.microsoft.com/library/hh680899.aspx)\n* [Perseverance, Secret of All Triumphs: Using the Transient Fault Handling Application Block](http://msdn.microsoft.com/library/dn440719.aspx)\n* [Cloud Service Fundamentals Data Access Layer – Transient Fault Handling](http://social.technet.microsoft.com/wiki/contents/articles/18665.cloud-service-fundamentals-data-access-layer-transient-fault-handling.aspx)\n\nFor general guidance on getting the most from SQL Database, see:\n\n* [Azure SQL Database Performance and Elasticity Guide](http://social.technet.microsoft.com/wiki/contents/articles/3507.windows-azure-sql-database-performance-and-elasticity-guide.aspx)\n* [Minimizing Connection Pool errors in SQL Azure](http://blogs.msdn.com/b/adonet/archive/2011/11/05/minimizing-connection-pool-errors-in-sql-azure.aspx)\n\n## Service Bus retry guidelines\n\nService Bus is a cloud messaging platform that provides loosely coupled message exchange with improved scale and resiliency for components of an application, whether hosted in the cloud or on-premises.\n\n### Retry mechanism\n\nService Bus implements retries using implementations of the [RetryPolicy](http://msdn.microsoft.com/library/microsoft.servicebus.retrypolicy.aspx) base class. All of the Service Bus clients expose a **RetryPolicy** property that can be set to one of the implementations of the **RetryPolicy** base class. The built-in implementations are:\n\n* The [RetryExponential Class](http://msdn.microsoft.com/library/microsoft.servicebus.retryexponential.aspx). This exposes properties that control the back-off interval, the retry count, and the **TerminationTimeBuffer** property that is used to limit the total time for the operation to complete.\n* The [NoRetry Class](http://msdn.microsoft.com/library/microsoft.servicebus.noretry.aspx). This is used when retries at the Service Bus API level are not required, such as when retries are managed by another process as part of a batch or multiple step operation.\n\nService Bus actions can return a range of exceptions, as listed in [Appendix: Messaging Exceptions](http://msdn.microsoft.com/library/hh418082.aspx). The list provides information about which if these indicate that retrying the operation is appropriate. For example, a [ServerBusyException](http://msdn.microsoft.com/library/microsoft.servicebus.messaging.serverbusyexception.aspx) indicates that the client should wait for a period of time, then retry the operation. The occurrence of a **ServerBusyException** also causes Service Bus to switch to a different mode, in which an extra 10-second delay is added to the computed retry delays. This mode is reset after a short period.\n\nThe exceptions returned from Service Bus expose the **IsTransient** property that indicates if the client should retry the operation. The built-in **RetryExponential** policy relies on the **IsTransient** property in the **MessagingException** class, which is the base class for all Service Bus exceptions. If you create custom implementations of the **RetryPolicy** base class you could use a combination of the exception type and the **IsTransient** property to provide more fine-grained control over retry actions. For example, you could detect a **QuotaExceededException** and take action to drain the queue before retrying sending a message to it.\n\n### Policy configuration (Service bus)\n\nRetry policies are set programmatically, and can be set as a default policy for a **NamespaceManager** and for a **MessagingFactory**, or individually for each messaging client. To set the default retry policy for a messaging session you set the **RetryPolicy** of the **NamespaceManager**.\n\n    namespaceManager.Settings.RetryPolicy = new RetryExponential(minBackoff: TimeSpan.FromSeconds(0.1),\n                                                                 maxBackoff: TimeSpan.FromSeconds(30),\n                                                                 deltaBackoff: TimeSpan.FromSeconds(2),\n                                                                 terminationTimeBuffer: TimeSpan.FromSeconds(5),\n                                                                 maxRetryCount: 3);\n\nNote that this code uses named parameters for clarity. Alternatively you can omit the names because none of the parameters is optional.\n\n    namespaceManager.Settings.RetryPolicy = new RetryExponential(TimeSpan.FromSeconds(0.1),\n                     TimeSpan.FromSeconds(30), TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(5), 3);\n\nTo set the default retry policy for all clients created from a messaging factory, you set the **RetryPolicy** of the **MessagingFactory**.\n\n    messagingFactory.RetryPolicy = new RetryExponential(minBackoff: TimeSpan.FromSeconds(0.1),\n                                                        maxBackoff: TimeSpan.FromSeconds(30),\n                                                        deltaBackoff: TimeSpan.FromSeconds(2),\n                                                        terminationTimeBuffer: TimeSpan.FromSeconds(5),\n                                                        maxRetryCount: 3);\n\nTo set the retry policy for a messaging client, or to override its default policy, you set its **RetryPolicy** property using an instance of the required policy class:\n\n```csharp\nclient.RetryPolicy = new RetryExponential(minBackoff: TimeSpan.FromSeconds(0.1),\n                                            maxBackoff: TimeSpan.FromSeconds(30),\n                                            deltaBackoff: TimeSpan.FromSeconds(2),\n                                            terminationTimeBuffer: TimeSpan.FromSeconds(5),\n                                            maxRetryCount: 3);\n```\n\nThe retry policy cannot be set at the individual operation level. It applies to all operations for the messaging client.\nThe following table shows the default settings for the built-in retry policy.\n\n![](media/best-practices-retry-service-specific/RetryServiceSpecificGuidanceTable7.png)\n\n### Retry usage guidance\n\nConsider the following guidelines when using Service Bus:\n\n* When using the built-in **RetryExponential** implementation, do not implement a fallback operation as the policy reacts to Server Busy exceptions and automatically switches to an appropriate retry mode.\n* Service Bus supports a feature called Paired Namespaces, which implements automatic failover to a backup queue in a separate namespace if the queue in the primary namespace fails. Messages from the secondary queue can be sent back to the primary queue when it recovers. This feature helps to address transient failures. For more information, see [Asynchronous Messaging Patterns and High Availability](http://msdn.microsoft.com/library/azure/dn292562.aspx).\n\nConsider starting with following settings for retrying operations. These are general purpose settings, and you should monitor the operations and fine tune the values to suit your own scenario.\n\n\n![](media/best-practices-retry-service-specific/RetryServiceSpecificGuidanceTable8.png)\n\n### Telemetry\n\nService Bus logs retries as ETW events using an **EventSource**. You must attach an **EventListener** to the event source to capture the events and view them in Performance Viewer, or write them to a suitable destination log. You could use the [Semantic Logging Application Block](http://msdn.microsoft.com/library/dn775006.aspx) to do this. The retry events are of the following form:\n\n```text\nMicrosoft-ServiceBus-Client/RetryPolicyIteration\nThreadID=\"14,500\"\nFormattedMessage=\"[TrackingId:] RetryExponential: Operation Get:https://retry-guidance-tests.servicebus.windows.net/TestQueue/?api-version=2014-05 at iteration 0 is retrying after 00:00:00.1000000 sleep because of Microsoft.ServiceBus.Messaging.MessagingCommunicationException: The remote name could not be resolved: 'retry-guidance-tests.servicebus.windows.net'.TrackingId:6a26f99c-dc6d-422e-8565-f89fdd0d4fe3, TimeStamp:9/5/2014 10:00:13 PM.\"\ntrackingId=\"\"\npolicyType=\"RetryExponential\"\noperation=\"Get:https://retry-guidance-tests.servicebus.windows.net/TestQueue/?api-version=2014-05\"\niteration=\"0\"\niterationSleep=\"00:00:00.1000000\"\nlastExceptionType=\"Microsoft.ServiceBus.Messaging.MessagingCommunicationException\"\nexceptionMessage=\"The remote name could not be resolved: 'retry-guidance-tests.servicebus.windows.net'.TrackingId:6a26f99c-dc6d-422e-8565-f89fdd0d4fe3,TimeStamp:9/5/2014 10:00:13 PM\"\n```\n\n### Examples (Service bus)\n\nThe following code example shows how to set the retry policy for:\n\n* A namespace manager. The policy applies to all operations on that manager, and cannot be overridden for individual operations.\n* A messaging factory. The policy applies to all clients created from that factory, and cannot be overridden when creating individual clients.\n* An individual messaging client. After a client has been created, you can set the retry policy for that client. The policy applies to all operations on that client.\n\n```csharp\nusing System;\nusing System.Threading.Tasks;\nusing Microsoft.ServiceBus;\nusing Microsoft.ServiceBus.Messaging;\n\nnamespace RetryCodeSamples\n{\n    class ServiceBusCodeSamples\n    {\n        private const string connectionString =\n            @\"Endpoint=sb://[my-namespace].servicebus.windows.net/;\n                SharedAccessKeyName=RootManageSharedAccessKey;\n                SharedAccessKey=C99..........Mk=\";\n\n        public async static Task Samples()\n        {\n            const string QueueName = \"TestQueue\";\n\n            ServiceBusEnvironment.SystemConnectivity.Mode = ConnectivityMode.Http;\n\n            var namespaceManager = NamespaceManager.CreateFromConnectionString(connectionString);\n\n            // The namespace manager will have a default exponential policy with 10 retry attempts\n            // and a 3 second delay delta.\n            // Retry delays will be approximately 0 sec, 3 sec, 9 sec, 25 sec and the fixed 30 sec,\n            // with an extra 10 sec added when receiving a ServiceBusyException.\n\n            {\n                // Set different values for the retry policy, used for all operations on the namespace manager.\n                namespaceManager.Settings.RetryPolicy =\n                    new RetryExponential(\n                        minBackoff: TimeSpan.FromSeconds(0),\n                        maxBackoff: TimeSpan.FromSeconds(30),\n                        deltaBackoff: TimeSpan.FromSeconds(1.75),\n                        terminationTimeBuffer: TimeSpan.FromSeconds(4),\n                        maxRetryCount: 3);\n\n                // Policies cannot be specified on a per-operation basis.\n                if (!await namespaceManager.QueueExistsAsync(QueueName))\n                {\n                    await namespaceManager.CreateQueueAsync(QueueName);\n                }\n            }\n\n\n            var messagingFactory = MessagingFactory.Create(\n                namespaceManager.Address, namespaceManager.Settings.TokenProvider);\n            // The messaging factory will have a default exponential policy with 10 retry attempts\n            // and a 3 second delay delta.\n            // Retry delays will be approximately 0 sec, 3 sec, 9 sec, 25 sec and the fixed 30 sec,\n            // with an extra 10 sec added when receiving a ServiceBusyException.\n\n            {\n                // Set different values for the retry policy, used for clients created from it.\n                messagingFactory.RetryPolicy =\n                    new RetryExponential(\n                        minBackoff: TimeSpan.FromSeconds(1),\n                        maxBackoff: TimeSpan.FromSeconds(30),\n                        deltaBackoff: TimeSpan.FromSeconds(2),\n                        terminationTimeBuffer: TimeSpan.FromSeconds(5),\n                        maxRetryCount: 3);\n\n\n                // Policies cannot be specified on a per-operation basis.\n                var session = await messagingFactory.AcceptMessageSessionAsync();\n            }\n\n\n            {\n                var client = messagingFactory.CreateQueueClient(QueueName);\n                // The client inherits the policy from the factory that created it.\n\n\n                // Set different values for the retry policy on the client.\n                client.RetryPolicy =\n                    new RetryExponential(\n                        minBackoff: TimeSpan.FromSeconds(0.1),\n                        maxBackoff: TimeSpan.FromSeconds(30),\n                        deltaBackoff: TimeSpan.FromSeconds(2),\n                        terminationTimeBuffer: TimeSpan.FromSeconds(5),\n                        maxRetryCount: 3);\n\n\n                // Policies cannot be specified on a per-operation basis.\n                var session = await client.AcceptMessageSessionAsync();\n            }\n        }\n    }\n}\n```\n\n## More information\n\n* [Asynchronous Messaging Patterns and High Availability](http://msdn.microsoft.com/library/azure/dn292562.aspx)\n\n## Cache (Redis) retry guidelines\n\nAzure Redis Cache is a fast data access and low latency cache service based on the popular open source Redis Cache. It is secure, managed by Microsoft, and is accessible from any application in Azure.\n\nThe guidance in this section is based on using the StackExchange.Redis client to access the cache. A list of other suitable clients can be found on the [Redis website](http://redis.io/clients), and these may have different retry mechanisms.\n\nNote that the StackExchange.Redis client uses multiplexing through a single connection. The recommended usage is to create an instance of the client at application startup and use this instance for all operations against the cache. For this reason, the connection to the cache is made only once, and so all of the guidance in this section is related to the retry policy for this initial connection—and not for each operation that accesses the cache.\n\n### Retry mechanism\n\nThe StackExchange.Redis client uses a connection manager class that is configured through a set of options. These options include a **ConnectRetry** property that specifies the number of times a failed connection to the cache will be retried. However, the retry policy in used only for the initial connect action, and it does not wait between retries.\n\n### Policy configuration (Azure Redis Cache)\n\nRetry policies are configured programmatically by setting the options for the client before connecting to the cache. This can be done by creating an instance of the **ConfigurationOptions** class, populating its properties, and passing it to the **Connect** method.\n\n```csharp\nvar options = new ConfigurationOptions { EndPoints = { \"localhost\" },\n                                            ConnectRetry = 3,\n                                            ConnectTimeout = 2000 };\nConnectionMultiplexer redis = ConnectionMultiplexer.Connect(options, writer);\n```\n\nNote that the **ConnectTimeout** property specifies the maximum waiting time in milliseconds), not the delay between retries.\n\nAlternatively, you can specify the options as a string, and pass this to the **Connect** method.\n\n```csharp\n    var options = \"localhost,connectRetry=3,connectTimeout=2000\";\n    ConnectionMultiplexer redis = ConnectionMultiplexer.Connect(options, writer);\n```\n\nIt is also possible to specify options directly when you connect to the cache.\n\n```csharp\nvar conn = ConnectionMultiplexer.Connect(\"redis0:6380,redis1:6380,connectRetry=3\");\n```\n\nThe following table shows the default settings for the built-in retry policy.\n\n| **Context**          | **Setting**                             | **Default value**<br />(v 1.0.331)           | **Meaning**                                                                                                                                                                                                   |\n|----------------------|-----------------------------------------|-----------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| ConfigurationOptions | ConnectRetry<br /><br />ConnectTimeout<br /><br />SyncTimeout | 3<br /><br />Maximum 5000 ms plus SyncTimeout<br />1000 | The number of times to repeat connect attempts during the initial connection operation.<br />Timeout (ms) for connect operations. Not a delay between retry attempts.<br />Time (ms) to allow for synchronous operations. |\n\n> [AZURE.NOTE] SyncTimeout contributes to the end-to-end latency of an operation. However, in general, using synchronous operations is not recommended. For more information see [Pipelines and Multiplexers](http://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/PipelinesMultiplexers.md).\n\n## Retry usage guidance\n\nConsider the following guidelines when using Azure Redis Cache:\n\n* The StackExchange Redis client manages its own retries, but only when establishing a connection to the cache when the application first starts. You can configure the connection timeout and the number of retry attempts to establish this connection, but the retry policy does not apply to operations against the cache.\n* The retry mechanism has no delay between retry attempts. It simply retries a failed connection after the specified connection timeout expires, and for the specified number of times.\n* Instead of using a large number of retry attempts, consider falling back by accessing the original data source instead.\n\n## Telemetry\n\nYou can collect information about connections (but not other operations) using a **TextWriter**.\n\n```csharp\nvar writer = new StringWriter();\n...\nConnectionMultiplexer redis = ConnectionMultiplexer.Connect(options, writer);\n```\n\nAn example of the output this generates is shown below.\n\n```text\nlocalhost:6379,connectTimeout=2000,connectRetry=3\n1 unique nodes specified\nRequesting tie-break from localhost:6379 > __Booksleeve_TieBreak...\nAllowing endpoints 00:00:02 to respond...\nlocalhost:6379 faulted: SocketFailure on PING\nlocalhost:6379 failed to nominate (Faulted)\n> UnableToResolvePhysicalConnection on GET\nNo masters detected\nlocalhost:6379: Standalone v2.0.0, master; keep-alive: 00:01:00; int: Connecting; sub: Connecting; not in use: DidNotRespond\nlocalhost:6379: int ops=0, qu=0, qs=0, qc=1, wr=0, sync=1, socks=2; sub ops=0, qu=0, qs=0, qc=0, wr=0, socks=2\nCircular op-count snapshot; int: 0 (0.00 ops/s; spans 10s); sub: 0 (0.00 ops/s; spans 10s)\nSync timeouts: 0; fire and forget: 0; last heartbeat: -1s ago\nresetting failing connections to retry...\nretrying; attempts left: 2...\n...\n```\n\n## Examples (Azure Redis Cache)\n\nThe following code example shows how you can configure the connection timeout setting and the number of retries when initializing the StackExchange.Redis client to access Azure Redis Cache at application startup. Note that the connection timeout is the period of time that you are willing to wait for connection to the cache; it is not the delay between retry attempts.\n\nThis example shows how to set the configuration using an instance of the **ConfigurationOptions**.\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing StackExchange.Redis;\n\nnamespace RetryCodeSamples\n{\n    class CacheRedisCodeSamples\n    {\n        public async static Task Samples()\n        {\n            var writer = new StringWriter();\n\n            {\n                try\n                {\n                    // Using object-based configuration.\n                    var options = new ConfigurationOptions\n                                        {\n                                            EndPoints = { \"localhost\" },\n                                            ConnectRetry = 3,\n                                            ConnectTimeout = 2000  // The maximum waiting time (ms), not the delay for retries.\n                                        };\n                    ConnectionMultiplexer redis = ConnectionMultiplexer.Connect(options, writer);\n\n                    // Store a reference to the multiplexer for use in the application.\n                }\n                catch\n                {\n                    Console.WriteLine(writer.ToString());\n                    throw;\n                }\n            }\n        }\n    }\n}\n```\n\nThis example shows how to set the configuration by specifying the options as a string.\n\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing StackExchange.Redis;\n\nnamespace RetryCodeSamples\n{\n    class CacheRedisCodeSamples\n    {\n        public async static Task Samples()\n        {\n            var writer = new StringWriter();\n\n            {\n                try\n                {\n                    // Using string-based configuration.\n                    var options = \"localhost,connectRetry=3,connectTimeout=2000\";\n                    ConnectionMultiplexer redis = ConnectionMultiplexer.Connect(options, writer);\n\n                    // Store a reference to the multiplexer for use in the application.\n                }\n                catch\n                {\n                    Console.WriteLine(writer.ToString());\n                    throw;\n                }\n            }\n        }\n    }\n}\n```\n\nFor more examples, see [Configuration](http://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Configuration.md#configuration) on the project website.\n\n## More information\n\n* [Redis website](http://redis.io/)\n\n## DocumentDB (pre-release) retry guidelines\n\nDocumentDB is a fully-managed document database-as-a-service with rich query and indexing capabilities over a schema-free JSON data model. It offers configurable and reliable performance, native JavaScript transactional processing, and is built for the cloud with elastic scale.\n\n## Retry mechanism\n\nThe pre-release version of the DocumentDB client includes an internal and non-configurable retry mechanism (this may change in subsequent releases). The default settings for this vary depending on the context of its use. Some operations use an exponential back-off strategy with hard-coded parameters. Others specify only how many retries should be attempted, and use the retry delay in the [DocumentClientException](http://msdn.microsoft.com/library/microsoft.azure.documents.documentclientexception.retryafter.aspx) instance that is returned from the service. A delay of five seconds is used if no delay is specified.\n\n## Policy configuration (DocumentDB)\n\nNone. All of the classes used to implement retries are internal. The retry parameters are either constants or are set using parameters to the class constructors.\n\nThe following table shows the default settings for the built-in retry policy.\n\n| **Context**            | **Settings**                                      | **Values** | **How it works**                                                                                                                                               |\n|------------------------|---------------------------------------------------|------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| RetryPolicy (internal) | MaxRetryAttemptsOnQuery<br /><br />MaxRetryAttemptsOnRequest | 3<br /><br />0        | The number of retry attempts for document queries. This value cannot be changed.<br />The number of retry attempts for other requests. This value cannot be changed. |\n\n## Retry usage guidance\n\nConsider the following guidelines when using DocumentDB:\n\n* You cannot change the default retry policy.\n* See [TBD] for more information about the default settings.\n\n## Telemetry\n\nRetry attempts are logged as unstructured trace messages through a .NET **TraceSource**. You must configure a **TraceListener** to capture the events and write them to a suitable destination log.\n\n## Search retry guidelines\n\nAzure Search can be used to add powerful and sophisticated search capabilities to a website or application, quickly and easily tune search results, and construct rich and fine-tuned ranking models.\n\n### Retry mechanism\n\nThere is no built-in retry mechanism for Search as the typical usage is though HTTP requests. To implement retries you can use a generic implementation of a REST client, and make decisions on when and if to retry the operation based on the response from the service. For more information, see the section [General REST and retry guidelines](#general-rest-and-retry-guidelines) later in this guidance.\n\n### Retry usage guidance\n\nConsider the following guidelines when using Azure Search:\n\n* Use the status code returned by the service to determine the type of failure. The status codes are defined in [HTTP status codes (Azure Search)](http://msdn.microsoft.com/library/dn798925.aspx). The status code 503 (Service Unavailable) indicates that the service is under heavy load and the request cannot be processed immediately. The appropriate action is to retry the operation only after allowing time for the service to recover. Retrying after too short a delay interval is likely to prolong the unavailability.\n* See the section [General REST and retry guidelines](#general-rest-and-retry-guidelines) later in this guidance for general information about retrying REST operations.\n\n## More information\n\n* [Azure Search REST API](http://msdn.microsoft.com/library/dn798935.aspx)\n\n## Azure Active Directory retry guidelines\n\nAzure Active Directory (AD) is a comprehensive identity and access management cloud solution that combines core directory services, advanced identity governance, security, and application access management. Azure AD also offers developers an identity management platform to deliver access control to their applications, based on centralized policy and rules.\n\n### Retry mechanism\n\nThere is no built-in retry mechanism for Azure Active Directory in the Active Directory Authentication Library (ADAL). You can use the Transient Fault Handling Application Block to implement a retry strategy that contains a custom detection mechanism for the exceptions returned by Active Directory.\n\n### Policy configuration (Azure Active Directory)\n\nWhen using the Transient Fault Handling Application Block with Azure Active Directory you create a **RetryPolicy** instance based on a class that defines the detection strategy you want to use.\n\n```csharp\nvar policy = new RetryPolicy<AdalDetectionStrategy>(new ExponentialBackoff(retryCount: 5,\n                                                                     minBackoff: TimeSpan.FromSeconds(0),\n                                                                     maxBackoff: TimeSpan.FromSeconds(60),\n                                                                     deltaBackoff: TimeSpan.FromSeconds(2)));\n```\n\nYou then call the **ExecuteAction** or **ExecuteAsync** method of the retry policy, passing in the operation you want to execute.\n\n```csharp\nvar result = await policy.ExecuteAsync(() => authContext.AcquireTokenAsync(resourceId, clientId, uc));\n```\n\nThe detection strategy class receives exceptions when a failure occurs, and must detect whether this is likely to be a transient fault or a more permanent failure. Typically it will do this by examining the exception type and status code. For example, a Service Unavailable response indicates that a retry attempt should be made. The Transient Fault Handling Application Block does not include a detection strategy class that is suitable for use with the ADAL client, but an example of a custom detection strategy is provided in the [Examples](#examples-azure-active-directory-) section below. Using a custom detection strategy is no different from using one supplied with the block.\n\nDefault strategies for the Transient Fault Handling Application Block are shown in the section [Transient Fault Handling Application Block (Topaz) strategies](#transient-fault-handling-application-block-topaz-strategies) at the end of this guidance.\n\n## Retry usage guidance\n\nConsider the following guidelines when using Azure Active Directory:\n\n* If you are using the REST API for Azure Active Directory, you should retry the operation only if the result is an error in the 5xx range (such as 500 Internal Server Error, 502 Bad Gateway, 503 Service Unavailable, and 504 Gateway Timeout). Do not retry for any other errors.\n* If you are using the Active Directory Authentication Library (ADAL), HTTP codes are not readily accessible. You will need to create a custom detection strategy that includes logic to check the properties of the ADAL-specific exceptions. See the [Examples](#examples-azure-active-directory-) section below.\n* An exponential back-off policy is recommended for use in batch scenarios with Azure Active Directory.\n\nConsider starting with following settings for retrying operations. These are general purpose settings, and you should monitor the operations and fine tune the values to suit your own scenario.\n\n\n| **Context**          | **Sample target E2E<br />max latency** | **Retry strategy** | **Settings**                                                          | **Values**                 | **How it works**                                                                                                              |\n|----------------------|----------------------------------------------|--------------------|-----------------------------------------------------------------------|----------------------------|-------------------------------------------------------------------------------------------------------------------------------|\n| Interactive, UI,<br />or foreground | 2 sec                                        | FixedInterval      | Retry count<br />Retry interval<br />First fast retry                           | 3<br />500 ms<br />true              | Attempt 1 - delay 0 sec<br />Attempt 2 - delay 500 ms<br />Attempt 3 - delay 500 ms                                                     |\n| Background or<br />batch            | 60 sec                                       | ExponentialBackoff | Retry count<br />Min back-off<br />Max back-off<br />Delta back-off<br />First fast retry | 5<br />0 sec<br />60 sec<br />2 sec<br />false | Attempt 1 - delay 0 sec<br />Attempt 2 - delay ~2 sec<br />Attempt 3 - delay ~6 sec<br />Attempt 4 - delay ~14 sec<br />Attempt 5 - delay ~30 sec |\n\n## Examples (Azure Active Directory)\n\nThe following code example shows how you can use the Transient Fault Handling Application Block (Topaz) to define a custom transient error detection strategy suitable for use with the ADAL client. The code creates a new **RetryPolicy** instance based on a custom detection strategy of type **AdalDetectionStrategy**, as defined in the code listing below. Custom detection strategies for Topaz implement the **ITransientErrorDetectionStrategy** interface and return true if a retry should be attempted, or **false** if the failure appears to be non-transient and a retry should not be attempted.\n\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n    using System.Net;\n    using System.Text;\n    using System.Threading.Tasks;\n    using Microsoft.IdentityModel.Clients.ActiveDirectory;\n    using Microsoft.Practices.EnterpriseLibrary.TransientFaultHandling;\n\n    namespace RetryCodeSamples\n    {\n        class ActiveDirectoryCodeSamples\n        {\n            public async static Task Samples()\n            {\n                var authority = \"[some authority]\";\n                var resourceId = “[some resource id]”;\n                var clientId = “[some client id]”;\n\n                var authContext = new AuthenticationContext(authority);\n\n                var uc = new UserCredential(“[user]\", \"[password]\");\n\n                // Use Topaz with a custom detection strategy to manage retries.\n                var policy =\n                    new RetryPolicy<AdalDetectionStrategy>(\n                        new ExponentialBackoff(\n                            retryCount: 5,\n                            minBackoff: TimeSpan.FromSeconds(0),\n                            maxBackoff: TimeSpan.FromSeconds(60),\n                            deltaBackoff: TimeSpan.FromSeconds(2)));\n\n                var result = await policy.ExecuteAsync(() => authContext.AcquireTokenAsync(resourceId, clientId, uc));\n\n                // Get the access token\n                var accessToken = result.AccessToken;\n\n                // Use the result, probably to authorize an API call.\n            }\n        }\n\n        // TODO: This is sample code that needs validation from the WAAD team!\n        // based on existing detection strategies\n        public class AdalDetectionStrategy : ITransientErrorDetectionStrategy\n        {\n            private static readonly WebExceptionStatus[] webExceptionStatus =\n                new[]\n                {\n                    WebExceptionStatus.ConnectionClosed,\n                    WebExceptionStatus.Timeout,\n                    WebExceptionStatus.RequestCanceled\n                };\n\n            private static readonly HttpStatusCode[] httpStatusCodes =\n                new[]\n                {\n                    HttpStatusCode.InternalServerError,\n                    HttpStatusCode.GatewayTimeout,\n                    HttpStatusCode.ServiceUnavailable,\n                    HttpStatusCode.RequestTimeout\n                };\n\n            public bool IsTransient(Exception ex)\n            {\n                var adalException = ex as AdalException;\n                if (adalException == null)\n                {\n                    return false;\n                }\n\n                if (adalException.ErrorCode == AdalError.ServiceUnavailable)\n                {\n                    return true;\n                }\n\n                var innerWebException = adalException.InnerException as WebException;\n                if (innerWebException != null)\n                {\n                    if (webExceptionStatus.Contains(innerWebException.Status))\n                    {\n                        return true;\n                    }\n\n                    if (innerWebException.Status == WebExceptionStatus.ProtocolError)\n                    {\n                        var response = innerWebException.Response as HttpWebResponse;\n                        return response != null && httpStatusCodes.Contains(response.StatusCode);\n                    }\n                }\n\n                return false;\n            }\n        }\n    }\n\nFor information about retrying Active Directory Graph API operations and the error codes returned see:\n\n* [Code Sample: Retry Logic](http://msdn.microsoft.com/library/azure/dn448547.aspx)\n* [Azure AD Graph Error Codes](http://msdn.microsoft.com/library/azure/hh974480.aspx)\n\n## More information\n\n* [Implementing a Custom Detection Strategy](http://msdn.microsoft.com/library/hh680940.aspx) (Topaz)\n* [Implementing a Custom Retry Strategy](http://msdn.microsoft.com/library/hh680943.aspx) (Topaz)\n* [Token Issuance and Retry Guidelines](http://msdn.microsoft.com/library/azure/dn168916.aspx)\n\n## General REST and retry guidelines\n\nConsider the following when accessing Azure or third party services:\n\n* Use a systematic approach to managing retries, perhaps as reusable code, so that you can apply a consistent methodology across all clients and all solutions.\n* Consider using a retry framework such as the Transient Fault Handling Application Block to manage retries if the target service or client has no built-in retry mechanism. This will help you implement a consistent retry behavior, and it may provide a suitable default retry strategy for the target service. However, you may need to create custom retry code for services that have non-standard behavior, that do not rely on exceptions to indicate transient failures, or if you want to use a **Retry-Response** reply to manage retry behavior.\n* The transient detection logic will depend on the actual client API you use to invoke the REST calls. Some clients, such as the newer **HttpClient** class, will not throw exceptions for completed requests with a non-success HTTP status code. This improves performance but prevents the use of the Transient Fault Handling Application Block. In this case you could wrap the call to the REST API with code that produces exceptions for non-success HTTP status codes, which can then be processed by the block. Alternatively, you can use a different mechanism to drive the retries.\n* The HTTP status code returned from the service can help to indicate whether the failure is transient. You may need to examine the exceptions generated by a client or the retry framework to access the status code or to determine the equivalent exception type. The following HTTP codes typically indicate that a retry is appropriate:\n  * 408 Request Timeout\n  * 500 Internal Server Error\n  * 502 Bad Gateway\n  * 503 Service Unavailable\n  * 504 Gateway Timeout\n* If you base your retry logic on exceptions, the following typically indicate a transient failure where no connection could be established:\n  * WebExceptionStatus.ConnectionClosed\n  * WebExceptionStatus.ConnectFailure\n  * WebExceptionStatus.Timeout\n  * WebExceptionStatus.RequestCanceled\n* In the case of a service unavailable status, the service might indicate the appropriate delay before retrying in the **Retry-After** response header or a different custom header (as in the DocumentDB service). Services might also send additional information as custom headers, or embedded in the content of the response. The Transient Fault Handling Application Block cannot use the standard or any custom “retry-after” headers.\n* Do not retry for status codes representing client errors (errors in the 4xx range) except for a 408 Request Timeout.\n* Thoroughly test your retry strategies and mechanisms under a range of conditions, such as different network states and varying system loadings.\n\n## Retry strategies\n\nThe following are the typical types of retry strategy intervals:\n\n* **Exponential**: A retry policy that performs a specified number of retries, using a randomized exponential back off approach to determine the interval between retries. For example:\n\n        var random = new Random();\n\n        var delta = (int)((Math.Pow(2.0, currentRetryCount) - 1.0) *\n                    random.Next((int)(this.deltaBackoff.TotalMilliseconds * 0.8),\n                    (int)(this.deltaBackoff.TotalMilliseconds * 1.2)));\n        var interval = (int)Math.Min(checked(this.minBackoff.TotalMilliseconds + delta),\n                       this.maxBackoff.TotalMilliseconds);\n        retryInterval = TimeSpan.FromMilliseconds(interval);\n\n* **Incremental**: A retry strategy with a specified number of retry attempts and an incremental time interval between retries. For example:\n\n        retryInterval = TimeSpan.FromMilliseconds(this.initialInterval.TotalMilliseconds +\n                       (this.increment.TotalMilliseconds * currentRetryCount));\n\n* **LinearRetry**: A retry policy that performs a specified number of retries, using a specified fixed time interval between retries. For example:\n\n        retryInterval = this.deltaBackoff;\n\n## More information\n\n* [Circuit breaker strategies](http://msdn.microsoft.com/library/dn589784.aspx)\n\n## Transient Fault Handling Application Block (Topaz) strategies\n\nThe Transient Fault Handling Application Block has the following default strategies.\n\n| **Strategy**            | **Setting**                                         | **Default value**           | **Meaning**                                                                                                                                                                                                                                                                                 |\n|-------------------------|-----------------------------------------------------|-----------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Exponential**         | retryCount<br />minBackoff<br /><br />maxBackoff<br /><br />deltaBackoff<br /><br />fastFirstRetry   | 10<br />1 second<br /><br />30 seconds<br /><br />10 seconds<br /><br />true | The number of retry attempts.<br />The minimum back-off time. The higher of this value or the computed back-off will be used as the retry delay.<br />The minimum back-off time. The lower of this value or the computed back-off will be used as the retry delay.<br />The value used to calculate a random delta for the exponential delay between retries.<br />Whether the first retry attempt will be made immediately. |\n| **Incremental**         | retryCount<br />initialInterval<br />increment<br /><br />fastFirstRetry<br />| 10<br />1 second<br />1 second<br /><br />true   | The number of retry attempts.<br />The initial interval that will apply for the first retry.<br />The incremental time value that will be used to calculate the progressive delay between retries.<br />Whether the first retry attempt will be made immediately.                                          |\n| **Linear (fixed interval)** | retryCount<br />retryInterval<br />fastFirstRetry<br />             | 10<br />1 second<br />true            | The number of retry attempts.<br />The delay between retries.<br />Whether first retry attempt will be made immediately.                                                                                                                                                                              |\nFor examples of using the Transient Fault Handling Application Block, see the Examples sections earlier in this guidance for Azure SQL Database using ADO.NET and Azure Active Directory.\n\ntest\n"
}