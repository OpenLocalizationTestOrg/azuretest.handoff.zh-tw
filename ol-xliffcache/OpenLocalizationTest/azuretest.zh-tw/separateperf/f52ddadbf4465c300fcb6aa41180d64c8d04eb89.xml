{
  "nodes": [
    {
      "content": "App Model v2 | Microsoft Azure",
      "pos": [
        27,
        57
      ]
    },
    {
      "content": "The types of tokens and claims emitted by the v2.0 Endpoint",
      "pos": [
        76,
        135
      ]
    },
    {
      "content": "App model v2.0 preview: Token reference",
      "pos": [
        448,
        487
      ]
    },
    {
      "content": "The v2.0 endpoint emits several types of security tokens in the processing of each <bpt id=\"p1\">[</bpt>authentication flow<ept id=\"p1\">](active-directory-v2-flows.md)</ept>.",
      "pos": [
        489,
        624
      ]
    },
    {
      "content": "This document describes the format, security characteristics, and contents of each type of token.",
      "pos": [
        625,
        722
      ]
    },
    {
      "content": "This information applies to the v2.0 app model public preview.",
      "pos": [
        743,
        805
      ]
    },
    {
      "content": "For instructions on how to integrate with the generally available Azure AD service, please refer to the <bpt id=\"p1\">[</bpt>Azure Active Directory Developer Guide<ept id=\"p1\">](active-directory-developers-guide.md)</ept>.",
      "pos": [
        807,
        990
      ]
    },
    {
      "content": "Types of Tokens",
      "pos": [
        995,
        1010
      ]
    },
    {
      "content": "The v2.0 endpoint supports the <bpt id=\"p1\">[</bpt>OAuth 2.0 authorization protocol<ept id=\"p1\">](active-directory-v2-protocols.md)</ept>, which makes use of both access_tokens and refresh_tokens.",
      "pos": [
        1012,
        1170
      ]
    },
    {
      "content": "It also supports authentication and sign-in via <bpt id=\"p1\">[</bpt>OpenID Connect<ept id=\"p1\">](active-directory-v2-protocols.md#openid-connect-sign-in-flow)</ept>, which introduces a third type of token, the id_token.",
      "pos": [
        1172,
        1353
      ]
    },
    {
      "content": "Each of these tokens is represented as a \"bearer token\".",
      "pos": [
        1355,
        1411
      ]
    },
    {
      "content": "A bearer token is a lightweight security token that grants the “bearer” access to a protected resource.",
      "pos": [
        1413,
        1516
      ]
    },
    {
      "content": "In this sense, the “bearer” is any party that can present the token.",
      "pos": [
        1517,
        1585
      ]
    },
    {
      "content": "Though a party must first authenticate with Azure AD to receive the bearer token, if the required steps are not taken to secure the token in transmission and storage, it can be intercepted and used by an unintended party.",
      "pos": [
        1586,
        1807
      ]
    },
    {
      "content": "While some security tokens have a built-in mechanism for preventing unauthorized parties from using them, bearer tokens do not have this mechanism and must be transported in a secure channel such as transport layer security (HTTPS).",
      "pos": [
        1808,
        2040
      ]
    },
    {
      "content": "If a bearer token is transmitted in the clear, a man-in the middle attack can be used by a malicious party to acquire the token and use it for an unauthorized access to a protected resource.",
      "pos": [
        2041,
        2231
      ]
    },
    {
      "content": "The same security principles apply when storing or caching bearer tokens for later use.",
      "pos": [
        2232,
        2319
      ]
    },
    {
      "content": "Always ensure that your app transmits and stores bearer tokens in a secure manner.",
      "pos": [
        2320,
        2402
      ]
    },
    {
      "content": "For more security considerations on bearer tokens, see <bpt id=\"p1\">[</bpt>RFC 6750 Section 5<ept id=\"p1\">](http://tools.ietf.org/html/rfc6750)</ept>.",
      "pos": [
        2403,
        2515
      ]
    },
    {
      "content": "Many of the tokens issued by the v2.0 endpoint are implemented as Json Web Tokens, or JWTs.",
      "pos": [
        2517,
        2608
      ]
    },
    {
      "content": "A JWT is a compact, URL-safe means of transferring information between two parties.",
      "pos": [
        2610,
        2693
      ]
    },
    {
      "content": "The information contained in JWTs are known as \"claims\", or assertions of information about the bearer and subject of the token.",
      "pos": [
        2695,
        2823
      ]
    },
    {
      "content": "The claims in JWTs are JSON objects encoded and serialized for transmission.",
      "pos": [
        2825,
        2901
      ]
    },
    {
      "content": "Since the JWTs issued by the v2.0 endpoint are signed, but not encrypted, you can easily inspect the contents of a JWT for debugging purposes.",
      "pos": [
        2903,
        3045
      ]
    },
    {
      "content": "There are several tools available for doing so, such as <bpt id=\"p1\">[</bpt>calebb.net<ept id=\"p1\">](https://calebb.net)</ept>.",
      "pos": [
        3047,
        3136
      ]
    },
    {
      "content": "For more information on JWTs, you can refer to the <bpt id=\"p1\">[</bpt>JWT specification<ept id=\"p1\">](http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html)</ept>.",
      "pos": [
        3137,
        3275
      ]
    },
    {
      "content": "Id_Tokens",
      "pos": [
        3280,
        3289
      ]
    },
    {
      "content": "Id_tokens are a form of sign-in security token that your app receives when performing authentication using <bpt id=\"p1\">[</bpt>OpenID Connect<ept id=\"p1\">](active-directory-v2-protocols.md#openid-connect-sign-in-flow)</ept>.",
      "pos": [
        3291,
        3477
      ]
    },
    {
      "content": "They are represented as <bpt id=\"p1\">[</bpt>JWTs<ept id=\"p1\">](#types-of-tokens)</ept>, and contain claims that you can use for signing the user into your app.",
      "pos": [
        3479,
        3600
      ]
    },
    {
      "content": "You can use the claims in an id_token as you see fit - commonly they are used for displaying account information or making access control decisions in an app.",
      "pos": [
        3602,
        3760
      ]
    },
    {
      "content": "The v2.0 endpoint only issues one type of id_token, which has a consistent set of claims regardless of the type of user that has signed in.",
      "pos": [
        3762,
        3901
      ]
    },
    {
      "content": "That is to say that the format and content of the id_tokens will be the same for both personal Microsoft Account users and work or school accounts.",
      "pos": [
        3903,
        4050
      ]
    },
    {
      "content": "Id_tokens are signed, but not encrypted at this time.",
      "pos": [
        4052,
        4105
      ]
    },
    {
      "content": "When your app receives an id_token, it must <bpt id=\"p1\">[</bpt>validate the signature<ept id=\"p1\">](#validating-tokens)</ept> to prove the token's authenticity and validate a few claims in the token to prove its validity.",
      "pos": [
        4107,
        4291
      ]
    },
    {
      "content": "The claims validated by an app vary depending on scenario requirements, but there are some <bpt id=\"p1\">[</bpt>common claim validations<ept id=\"p1\">](#validating-tokens)</ept> that your app must perform in every scenario.",
      "pos": [
        4293,
        4476
      ]
    },
    {
      "content": "Full details on the claims in id_tokens are provided below, as well as a sample id_token.",
      "pos": [
        4478,
        4567
      ]
    },
    {
      "content": "Note that the claims in id_tokens are not returned in any particular order.",
      "pos": [
        4569,
        4644
      ]
    },
    {
      "content": "In addition, new claims can be introduced into id_tokens at any point in time - your app should not break as new claims are introduced.",
      "pos": [
        4646,
        4781
      ]
    },
    {
      "content": "The list below includes the claims that your app can reliably interpret at the time of this writing.",
      "pos": [
        4783,
        4883
      ]
    },
    {
      "content": "For practice, try inspecting the claims in the sample id_token by pasting it into <bpt id=\"p1\">[</bpt>calebb.net<ept id=\"p1\">](https://calebb.net)</ept>.",
      "pos": [
        4884,
        4999
      ]
    },
    {
      "content": "If necessary, even more detail can be found in the <bpt id=\"p1\">[</bpt>OpenID Connect specification<ept id=\"p1\">](http://openid.net/specs/openid-connect-core-1_0.html)</ept>.",
      "pos": [
        5001,
        5137
      ]
    },
    {
      "content": "Sample Id_Token",
      "pos": [
        5144,
        5159
      ]
    },
    {
      "content": "Claims in Id_Tokens",
      "pos": [
        6334,
        6353
      ]
    },
    {
      "content": "Name",
      "pos": [
        6356,
        6360
      ]
    },
    {
      "content": "Claim",
      "pos": [
        6363,
        6368
      ]
    },
    {
      "content": "Example Value",
      "pos": [
        6371,
        6384
      ]
    },
    {
      "content": "Description",
      "pos": [
        6387,
        6398
      ]
    },
    {
      "content": "Audience",
      "pos": [
        6516,
        6524
      ]
    },
    {
      "content": "Identifies the intended recipient of the token.",
      "pos": [
        6576,
        6623
      ]
    },
    {
      "content": "In id_tokens, the audience is your app's Application Id, as assigned to your app in the app registration portal.",
      "pos": [
        6625,
        6737
      ]
    },
    {
      "content": "Your app should validate this value and reject the token if it does not match.",
      "pos": [
        6739,
        6817
      ]
    },
    {
      "content": "Issuer",
      "pos": [
        6822,
        6828
      ]
    },
    {
      "content": "Identifies the security token service (STS) that constructs and returns the token, as well as the Azure AD tenant in which the user was authenticated.",
      "pos": [
        6920,
        7070
      ]
    },
    {
      "content": "Your app should validate the issuer claim to ensure that the token came from the v2.0 endpoint.",
      "pos": [
        7072,
        7167
      ]
    },
    {
      "content": "It can also use the guid portion of the claim to restrict the set of tenants that are allowed to sign into the app.",
      "pos": [
        7169,
        7284
      ]
    },
    {
      "content": "Issued At",
      "pos": [
        7289,
        7298
      ]
    },
    {
      "content": "The time at which the token was issued, represented in epoch time.",
      "pos": [
        7324,
        7390
      ]
    },
    {
      "content": "Expiration Time",
      "pos": [
        7395,
        7410
      ]
    },
    {
      "content": "The time at which the token becomes invalid, represented in epoch time.",
      "pos": [
        7436,
        7507
      ]
    },
    {
      "content": "Your app should use this claim to verify the validity of the token lifetime.",
      "pos": [
        7509,
        7585
      ]
    },
    {
      "content": "Version",
      "pos": [
        7591,
        7598
      ]
    },
    {
      "content": "The version of the id_token, as defined by Azure AD.",
      "pos": [
        7617,
        7669
      ]
    },
    {
      "content": "For app model v2.0, The value will be <ph id=\"ph1\">`2.0`</ph>.",
      "pos": [
        7671,
        7715
      ]
    },
    {
      "content": "Tenant Id",
      "pos": [
        7720,
        7729
      ]
    },
    {
      "content": "A guid representing the Azure AD tenant which the user is from.",
      "pos": [
        7781,
        7844
      ]
    },
    {
      "content": "For work and school accounts, the guid will be the immutable tenant ID of the organization that the user belongs to.",
      "pos": [
        7846,
        7962
      ]
    },
    {
      "content": "For personal accounts, the value will be <ph id=\"ph1\">`9188040d-6c67-4c5b-b112-36a304b66dad`</ph>.",
      "pos": [
        7964,
        8044
      ]
    },
    {
      "content": "Code Hash",
      "pos": [
        8049,
        8058
      ]
    },
    {
      "content": "The code hash is included in id_tokens only when the id_token is issued alongside an OAuth 2.0 authorization code.",
      "pos": [
        8099,
        8213
      ]
    },
    {
      "content": "It can be used to validate the authenticity of an authorization code.",
      "pos": [
        8215,
        8284
      ]
    },
    {
      "content": "See the <bpt id=\"p1\">[</bpt>OpenID Connect specification<ept id=\"p1\">](http://openid.net/specs/openid-connect-core-1_0.html)</ept> for more details on performing this validation.",
      "pos": [
        8286,
        8426
      ]
    },
    {
      "content": "Access Token Hash",
      "pos": [
        8431,
        8448
      ]
    },
    {
      "content": "The access token hash is included in id_tokens only when the id_token is issued alongside an OAuth 2.0 access token.",
      "pos": [
        8490,
        8606
      ]
    },
    {
      "content": "It can be used to validate the authenticity of an access token.",
      "pos": [
        8608,
        8671
      ]
    },
    {
      "content": "See the <bpt id=\"p1\">[</bpt>OpenID Connect specification<ept id=\"p1\">](http://openid.net/specs/openid-connect-core-1_0.html)</ept> for more details on performing this validation.",
      "pos": [
        8673,
        8813
      ]
    },
    {
      "content": "Nonce",
      "pos": [
        8818,
        8823
      ]
    },
    {
      "content": "The nonce is a strategy for mitigating token replay attacks.",
      "pos": [
        8846,
        8906
      ]
    },
    {
      "content": "Your app can specify a nonce in an authorization request by using the <ph id=\"ph1\">`nonce`</ph> query parameter.",
      "pos": [
        8908,
        9002
      ]
    },
    {
      "content": "The value you provide in the request will be emitted in the id_token's <ph id=\"ph1\">`nonce`</ph> claim, unmodified.",
      "pos": [
        9004,
        9101
      ]
    },
    {
      "content": "This allows your app to verify the value against the value it specified on the request, which associates the app's session with a given id_token.",
      "pos": [
        9103,
        9248
      ]
    },
    {
      "content": "Your app should perform this validation during the id_token validation process.",
      "pos": [
        9250,
        9329
      ]
    },
    {
      "content": "Name",
      "pos": [
        9334,
        9338
      ]
    },
    {
      "content": "The name claim provides a human readable value that identifies the subject of the token.",
      "pos": [
        9371,
        9459
      ]
    },
    {
      "content": "This value is not guaranteed to be unique, is mutable, and is designed to be used only for display purposes.",
      "pos": [
        9460,
        9568
      ]
    },
    {
      "content": "Preferred Username",
      "pos": [
        9573,
        9591
      ]
    },
    {
      "content": "The primary username that is used to represent the user in the v2.0 endpoint.",
      "pos": [
        9637,
        9714
      ]
    },
    {
      "content": "It could be an email address, phone number, or a generic username without a specified format.",
      "pos": [
        9716,
        9809
      ]
    },
    {
      "content": "Its value is mutable and may change for a given user over time.",
      "pos": [
        9811,
        9874
      ]
    },
    {
      "content": "Subject",
      "pos": [
        9879,
        9886
      ]
    },
    {
      "content": "The principal about which the token asserts information, such as the user of an app.",
      "pos": [
        9945,
        10029
      ]
    },
    {
      "content": "This value is immutable and cannot be reassigned or reused, so it can be used to perform authorization checks safely, such as when the token is used to access a resource.",
      "pos": [
        10030,
        10200
      ]
    },
    {
      "content": "Because the subject is always present in the tokens the Azure AD issues, we recommended using this value in a general purpose authorization system.",
      "pos": [
        10201,
        10348
      ]
    },
    {
      "content": "ObjectId",
      "pos": [
        10353,
        10361
      ]
    },
    {
      "content": "The object Id of the work or school account in the Azure AD system.",
      "pos": [
        10413,
        10480
      ]
    },
    {
      "content": "This claim will not be issued for personal Microsoft accounts.",
      "pos": [
        10482,
        10544
      ]
    },
    {
      "content": "Access Tokens",
      "pos": [
        10799,
        10812
      ]
    },
    {
      "content": "Access tokens issued by the v2.0 endpoint take two different formats.",
      "pos": [
        10814,
        10883
      ]
    },
    {
      "content": "Access tokens that are issued on behalf of work or school accounts are JWTs, similar to an id_token.",
      "pos": [
        10885,
        10985
      ]
    },
    {
      "content": "Access tokens that are issued on behalf of a personal Microsoft account are in a format known as \"compact tickets\".",
      "pos": [
        10987,
        11102
      ]
    },
    {
      "content": "For this reason, in development you may notice a different string format for access tokens issued by the v2.0 endpoint.",
      "pos": [
        11104,
        11223
      ]
    },
    {
      "content": "Over time, this difference in access tokens will be eliminated from the v2.0 endpoint.",
      "pos": [
        11225,
        11311
      ]
    },
    {
      "content": "With that said, access tokens issued by the v2.0 endpoint are only consumable by Microsoft Services at this point in time.",
      "pos": [
        11313,
        11435
      ]
    },
    {
      "content": "Your apps should not need to perform any validation or inspection of access tokens for any of the currently supported scenarios.",
      "pos": [
        11437,
        11565
      ]
    },
    {
      "content": "You can treat access tokens as completely opaque - they are just strings which your app can pass to Microsoft in HTTP requests.",
      "pos": [
        11567,
        11694
      ]
    },
    {
      "content": "In the near future, the v2.0 endpoint will introduce the ability for your app to receive access tokens from other clients.",
      "pos": [
        11696,
        11818
      ]
    },
    {
      "content": "At that time, this information will be updated with the information your app needs to perform access token validation and other similar tasks.",
      "pos": [
        11820,
        11962
      ]
    },
    {
      "content": "When you request an access token from the v2.0 endpoint, the v2.0 endpoint also returns some metadata about the access token for your app's consumption.",
      "pos": [
        11964,
        12116
      ]
    },
    {
      "content": "This information includes the expiry time of the access token and the scopes for which it is valid.",
      "pos": [
        12118,
        12217
      ]
    },
    {
      "content": "This allows your app to perform intelligent caching of access tokens without having to parse open the access token itself.",
      "pos": [
        12219,
        12341
      ]
    },
    {
      "content": "Refresh Tokens",
      "pos": [
        12346,
        12360
      ]
    },
    {
      "content": "Refresh tokens are security tokens which your app can use to acquire new access tokens in an OAuth 2.0 flow.",
      "pos": [
        12362,
        12470
      ]
    },
    {
      "content": "It allows your app to achieve long-term access to resources on behalf of a user without requiring interaction by the user.",
      "pos": [
        12472,
        12594
      ]
    },
    {
      "content": "Refresh tokens are multi-resource.",
      "pos": [
        12596,
        12630
      ]
    },
    {
      "content": "That is to say that a refresh token received during a token request for one resource can be redeemed for access tokens to a completely different resource.",
      "pos": [
        12632,
        12786
      ]
    },
    {
      "content": "In order to receive a refresh  in a token response, your app must request &amp; be granted the <ph id=\"ph1\">`offline_acesss`</ph> scope.",
      "pos": [
        12788,
        12902
      ]
    },
    {
      "content": "To learn more about the <ph id=\"ph1\">`offline_access`</ph> scope, refer to the <bpt id=\"p1\">[</bpt>consent &amp; scopes article here<ept id=\"p1\">](active-directory-v2-scopes.md)</ept>.",
      "pos": [
        12905,
        13029
      ]
    },
    {
      "content": "Refresh tokens are, and will always be, completely opaque to your app.",
      "pos": [
        13031,
        13101
      ]
    },
    {
      "content": "They are issued by the Azure AD v2.0 endpoint and can only be inspected &amp; interpreted by the v2.0 endpoint.",
      "pos": [
        13103,
        13210
      ]
    },
    {
      "content": "They are long-lived, but your app should not be written to expect that a refresh token will last for any period of time.",
      "pos": [
        13212,
        13332
      ]
    },
    {
      "content": "Refresh tokens can be invalidated at any moment in time for a variety of reasons.",
      "pos": [
        13334,
        13415
      ]
    },
    {
      "content": "The only way for your app to know if a refresh token is valid is to attempt to redeem it by making a token request to the v2.0 endpoint.",
      "pos": [
        13417,
        13553
      ]
    },
    {
      "content": "When you redeem a refresh token for a new access token (and if your app had been granted the <ph id=\"ph1\">`offline_access`</ph> scope), you will receive a new refresh token in the token response.",
      "pos": [
        13555,
        13732
      ]
    },
    {
      "content": "You should  save the newly issued refresh token, replacing the one you used in the request.",
      "pos": [
        13734,
        13825
      ]
    },
    {
      "content": "This will guarantee that your refresh tokens remain valid for as long as possible.",
      "pos": [
        13827,
        13909
      ]
    },
    {
      "content": "Validating Tokens",
      "pos": [
        13914,
        13931
      ]
    },
    {
      "content": "At this point in time, the only token validation your apps should need to perform is validating id_tokens.",
      "pos": [
        13933,
        14039
      ]
    },
    {
      "content": "In order to validate an id_token, your app should validate both the id_token's signature and the claims in the id_token.",
      "pos": [
        14041,
        14161
      ]
    },
    {
      "content": "We provide libraries &amp; code samples that show how to easily handle token validation - the below information is simply provided for those who wish to understand the underlying process.",
      "pos": [
        14183,
        14366
      ]
    },
    {
      "content": "There are also several 3rd party open source libraries available for JWT validation - there is at least one option for almost every platform &amp; language out there.",
      "pos": [
        14368,
        14530
      ]
    },
    {
      "content": "Validating the Signature\nA JWT contains three segments, which are separated by the <ph id=\"ph1\">`.`</ph> character.",
      "pos": [
        14537,
        14634
      ]
    },
    {
      "content": "The first segment is known as the <bpt id=\"p1\">**</bpt>header<ept id=\"p1\">**</ept>, the second as the <bpt id=\"p2\">**</bpt>body<ept id=\"p2\">**</ept>, and the third as the <bpt id=\"p3\">**</bpt>signature<ept id=\"p3\">**</ept>.",
      "pos": [
        14636,
        14745
      ]
    },
    {
      "content": "The signature segment can be used to validate the authenticity of the id_token so that it can be trusted by your app.",
      "pos": [
        14747,
        14864
      ]
    },
    {
      "content": "Id_Tokens are signed using industry standard asymmetric encryption algorithms, such as RSA 256.",
      "pos": [
        14866,
        14961
      ]
    },
    {
      "content": "The header of the id_token contains information about the key and encryption method used to sign the token:\n\n```\n{\n        typ: \"JWT\",\n        alg: \"RS256\",\n        x5t: \"GvnPApfWMdLRi8PDmisFn7bprKg\"\n}\n```\n\nThe <ph id=\"ph1\">`alg`</ph> claim indicates the algorithm that was used to sign the token, while the <ph id=\"ph2\">`kid`</ph> or <ph id=\"ph3\">`x5t`</ph> claims indicate the particular public key that was used to sign the token.",
      "pos": [
        14962,
        15341
      ]
    },
    {
      "content": "At any given point in time, the v2.0 endpoint may sign an id_token using any one of a certain set of public-private key pairs.",
      "pos": [
        15343,
        15469
      ]
    },
    {
      "content": "The v2.0 endpoint rotates the possible set of keys on a periodic basis, so your app should be written to handle those key changes automatically.",
      "pos": [
        15471,
        15615
      ]
    },
    {
      "content": "A reasonable frequency to check for updates to the public keys used by the v2.0 endpoint is about 24 hours.",
      "pos": [
        15617,
        15724
      ]
    },
    {
      "content": "You can acquire the signing key data necessary to validate the signature by using the OpenID Connect metadata document located at:\n\n<ph id=\"ph1\">`https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration`</ph>\n\nThis metadata document is a JSON object containing several useful pieces of information, such as the location of the various endpoints required for performing OpenID Connect authentication.",
      "pos": [
        15726,
        16129
      ]
    },
    {
      "content": "It also includes a <ph id=\"ph1\">`jwks_uri`</ph>, which gives the location of the set of public keys used to sign tokens.",
      "pos": [
        16131,
        16233
      ]
    },
    {
      "content": "That location is provided below, but it is best to fetch that location dynamically by using the metadata document and parsing out the <ph id=\"ph1\">`jwks_uri`</ph>:\n\n<ph id=\"ph2\">`https://login.microsoftonline.com/common/discovery/v2.0/keys`</ph>\n\nThe JSON document located at this url contains all of the public key information in use at that particular moment in time.",
      "pos": [
        16235,
        16568
      ]
    },
    {
      "content": "Your app can use the <ph id=\"ph1\">`kid`</ph> or <ph id=\"ph2\">`x5t`</ph> claims in the JWT header to select which public key in this document has been used to sign a particular token.",
      "pos": [
        16570,
        16716
      ]
    },
    {
      "content": "It can then perform signature validation using the correct public key and the indicated algorithm.",
      "pos": [
        16718,
        16816
      ]
    },
    {
      "content": "Performing signature validation is outside the scope of this document - there are many open source libraries available for helping you do so if necessary.",
      "pos": [
        16818,
        16972
      ]
    },
    {
      "content": "Validating the Claims\nWhen your app receives an id_token upon user sign-in, it should also perform a few checks against the claims in the id_token.",
      "pos": [
        16979,
        17126
      ]
    },
    {
      "content": "These include:\n\n- The <bpt id=\"p1\">**</bpt>Audience<ept id=\"p1\">**</ept> claim - to verify that the id_token was intended to be given to your app.",
      "pos": [
        17128,
        17236
      ]
    },
    {
      "content": "- The <bpt id=\"p1\">**</bpt>Issued At<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>Expiration Time<ept id=\"p2\">**</ept> claims - to verify that the id_token has not expired.",
      "pos": [
        17237,
        17334
      ]
    },
    {
      "content": "- The <bpt id=\"p1\">**</bpt>Issuer<ept id=\"p1\">**</ept> claim - to verify that the token was indeed issued to your app by the v2.0 endpoint.",
      "pos": [
        17335,
        17436
      ]
    },
    {
      "content": "- The <bpt id=\"p1\">**</bpt>Nonce<ept id=\"p1\">**</ept> -  as a token replay attack mitigation.",
      "pos": [
        17437,
        17492
      ]
    },
    {
      "content": "Details of the expected values for these claims are included above in the <bpt id=\"p1\">[</bpt><ept id=\"p1\">id_token section](#id_tokens)</ept>.",
      "pos": [
        17494,
        17599
      ]
    },
    {
      "content": "Token Lifetimes\n\nThe following token lifetimes are provided purely for your understanding, as they can help in developing and debugging apps.",
      "pos": [
        17605,
        17746
      ]
    },
    {
      "content": "Your apps should not be written to expect any of these lifetimes to remain constant - they can and will change at any given point in time.",
      "pos": [
        17748,
        17886
      ]
    },
    {
      "content": "| Token | Lifetime | Description |\n| ----------------------- | ------------------------------- | ------------ |\n| Id_Tokens (work or school accounts) | 1 hour | Id_Tokens are typically valid for an hour.",
      "pos": [
        17888,
        18091
      ]
    },
    {
      "content": "Your web app can use this same lifetime in maintaining its own session with the user (recommended), or choose a completely different session lifetime.",
      "pos": [
        18093,
        18243
      ]
    },
    {
      "content": "If your app needs to get a new id_token, it simply needs to make a new sign-in request to the v2.0 authorize endpoint.",
      "pos": [
        18245,
        18363
      ]
    },
    {
      "content": "If the user has a valid browser session with the v2.0 endpoint, they may not be required to enter their credentials again.",
      "pos": [
        18365,
        18487
      ]
    },
    {
      "content": "|\n| Id_Tokens (personal accounts) | 24 hours | Id_Tokens for personal accounts are typically valid for 24 hours.",
      "pos": [
        18488,
        18600
      ]
    },
    {
      "content": "Your web app can use this same lifetime in maintaining its own session with the user (recommended), or choose a completely different session lifetime.",
      "pos": [
        18602,
        18752
      ]
    },
    {
      "content": "If your app needs to get a new id_token, it simply needs to make a new sign-in request to the v2.0 authorize endpoint.",
      "pos": [
        18754,
        18872
      ]
    },
    {
      "content": "If the user has a valid browser session with the v2.0 endpoint, they may not be required to enter their credentials again.",
      "pos": [
        18874,
        18996
      ]
    },
    {
      "content": "|\n| Access Tokens (work or school accounts) | 1 hour | Indicated in token responses as part of the token metadata.",
      "pos": [
        18997,
        19111
      ]
    },
    {
      "content": "|\n| Access Tokens (personal accounts) | 1 hour | Indicated in token responses as part of the token metadata.",
      "pos": [
        19112,
        19220
      ]
    },
    {
      "content": "Access_tokens issued on behalf of personal accounts may be configured for a different lifetime, but one hour is typically the case.",
      "pos": [
        19222,
        19353
      ]
    },
    {
      "content": "|\n| Refresh Tokens (work or school account) | Up to 14 days | A single refresh token is valid for a maximum of 14 days.",
      "pos": [
        19354,
        19473
      ]
    },
    {
      "content": "However, the refresh token may become invalid at any time for any number of reasons, so your app should continue to try and use a refresh token until it fails, or until your app replaces it with a new refresh token.",
      "pos": [
        19475,
        19690
      ]
    },
    {
      "content": "A refresh token will also become invalid if it has been 90 days since the user has entered their credentials.",
      "pos": [
        19692,
        19801
      ]
    },
    {
      "content": "|\n| Refresh Tokens (personal accounts) | Up to 1 year | A single refresh token is valid for a maximum of 1 year.",
      "pos": [
        19802,
        19914
      ]
    },
    {
      "content": "However, the refresh token may become invalid at any time for any number of reasons, so your app should continue to try and use a refresh token until it fails.",
      "pos": [
        19916,
        20075
      ]
    },
    {
      "content": "|\n| Authorization Codes (work or school accounts) | 10 minutes | Authorization codes are purposefully short-lived, and should be immediately redeemed for access_tokens and refresh_tokens when they are received.",
      "pos": [
        20076,
        20286
      ]
    },
    {
      "content": "|\n| Authorization Codes (personal accounts) | 5 minutes | Authorization codes are purposefully short-lived, and should be immediately redeemed for access_tokens and refresh_tokens when they are received.",
      "pos": [
        20287,
        20490
      ]
    },
    {
      "content": "Authorization codes issued on behalf of personal accounts are also one-time use.",
      "pos": [
        20492,
        20572
      ]
    },
    {
      "content": "|\n\ntest",
      "pos": [
        20573,
        20580
      ]
    }
  ],
  "content": "<properties\n    pageTitle=\"App Model v2 | Microsoft Azure\"\n    description=\"The types of tokens and claims emitted by the v2.0 Endpoint\"\n    services=\"active-directory\"\n    documentationCenter=\"\"\n    authors=\"dstrockis\"\n    manager=\"mbaldwin\"\n    editor=\"\"/>\n\n<tags\n    ms.service=\"active-directory\"\n    ms.workload=\"identity\"\n    ms.tgt_pltfrm=\"na\"\n    ms.devlang=\"na\"\n    ms.topic=\"article\"\n    ms.date=\"08/12/2015\"\n    ms.author=\"dastrock\"/>\n\n# App model v2.0 preview: Token reference\n\nThe v2.0 endpoint emits several types of security tokens in the processing of each [authentication flow](active-directory-v2-flows.md). This document describes the format, security characteristics, and contents of each type of token.\n\n> [AZURE.NOTE]\n    This information applies to the v2.0 app model public preview.  For instructions on how to integrate with the generally available Azure AD service, please refer to the [Azure Active Directory Developer Guide](active-directory-developers-guide.md).\n\n## Types of Tokens\n\nThe v2.0 endpoint supports the [OAuth 2.0 authorization protocol](active-directory-v2-protocols.md), which makes use of both access_tokens and refresh_tokens.  It also supports authentication and sign-in via [OpenID Connect](active-directory-v2-protocols.md#openid-connect-sign-in-flow), which introduces a third type of token, the id_token.  Each of these tokens is represented as a \"bearer token\".\n\nA bearer token is a lightweight security token that grants the “bearer” access to a protected resource. In this sense, the “bearer” is any party that can present the token. Though a party must first authenticate with Azure AD to receive the bearer token, if the required steps are not taken to secure the token in transmission and storage, it can be intercepted and used by an unintended party. While some security tokens have a built-in mechanism for preventing unauthorized parties from using them, bearer tokens do not have this mechanism and must be transported in a secure channel such as transport layer security (HTTPS). If a bearer token is transmitted in the clear, a man-in the middle attack can be used by a malicious party to acquire the token and use it for an unauthorized access to a protected resource. The same security principles apply when storing or caching bearer tokens for later use. Always ensure that your app transmits and stores bearer tokens in a secure manner. For more security considerations on bearer tokens, see [RFC 6750 Section 5](http://tools.ietf.org/html/rfc6750).\n\nMany of the tokens issued by the v2.0 endpoint are implemented as Json Web Tokens, or JWTs.  A JWT is a compact, URL-safe means of transferring information between two parties.  The information contained in JWTs are known as \"claims\", or assertions of information about the bearer and subject of the token.  The claims in JWTs are JSON objects encoded and serialized for transmission.  Since the JWTs issued by the v2.0 endpoint are signed, but not encrypted, you can easily inspect the contents of a JWT for debugging purposes.  There are several tools available for doing so, such as [calebb.net](https://calebb.net). For more information on JWTs, you can refer to the [JWT specification](http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html).\n\n## Id_Tokens\n\nId_tokens are a form of sign-in security token that your app receives when performing authentication using [OpenID Connect](active-directory-v2-protocols.md#openid-connect-sign-in-flow).  They are represented as [JWTs](#types-of-tokens), and contain claims that you can use for signing the user into your app.  You can use the claims in an id_token as you see fit - commonly they are used for displaying account information or making access control decisions in an app.  The v2.0 endpoint only issues one type of id_token, which has a consistent set of claims regardless of the type of user that has signed in.  That is to say that the format and content of the id_tokens will be the same for both personal Microsoft Account users and work or school accounts.\n\nId_tokens are signed, but not encrypted at this time.  When your app receives an id_token, it must [validate the signature](#validating-tokens) to prove the token's authenticity and validate a few claims in the token to prove its validity.  The claims validated by an app vary depending on scenario requirements, but there are some [common claim validations](#validating-tokens) that your app must perform in every scenario.\n\nFull details on the claims in id_tokens are provided below, as well as a sample id_token.  Note that the claims in id_tokens are not returned in any particular order.  In addition, new claims can be introduced into id_tokens at any point in time - your app should not break as new claims are introduced.  The list below includes the claims that your app can reliably interpret at the time of this writing. For practice, try inspecting the claims in the sample id_token by pasting it into [calebb.net](https://calebb.net).  If necessary, even more detail can be found in the [OpenID Connect specification](http://openid.net/specs/openid-connect-core-1_0.html).\n\n#### Sample Id_Token\n```\n// Line breaks for display purposes only\n\neyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik1uQ19WWmNBVGZNNXBPWWlKSE1iYTlnb0VLWSIsImtpZCI6Ik1uQ\n19WWmNBVGZNNXBPWWlKSE1iYTlnb0VLWSJ9.eyJhdWQiOiI0OTIxMDI1My0wYmExLTRhOWEtYTQyNC02MTY5OTlmYWI2MjAiL\nCJpc3MiOiJodHRwczovL2xvZ2luLm1pY3Jvc29mdG9ubGluZS5jb20vYjk0MTAzMTgtMDlhZi00OWMyLWIwYzMtNjUzYWRjMW\nYzNzZlL3YyLjAvIiwiaWF0IjoxNDM4NTM1NTQzLCJuYmYiOjE0Mzg1MzU1NDMsImV4cCI6MTQzODUzOTQ0MywidmVyIjoiMi4\nwIiwidGlkIjoiYjk0MTAzMTgtMDlhZi00OWMyLWIwYzMtNjUzYWRjMWYzNzZlIiwib2lkIjoiYTFlYmRkZTgtZTRmOS00NTcx\nLWFkOTMtMzA1OWUzNzUwZDIzIiwicHJlZmVycmVkX3VzZXJuYW1lIjoic2FtcGxlLmFkbWluQHN0cm9ja2lzZGV2Lm9ubWljc\nm9zb2Z0LmNvbSIsInN1YiI6IjJvMmQ5SVBGVzI5MGo0RVkySXg0RUdoaEtlWnVGaC1LcFhHS2tuZkNxRWMiLCJuYW1lIjoiU2\nFtcGxlIEFkbWluIiwibm9uY2UiOiIxMjM0NSIsImNfaGFzaCI6IngxeU92VTZRaXE0Y1lVcVIxeDBvM2cifQ.Qk9exyv04I6a\nP6Sju2xNG9O2sj8dG-aEoJeS5dmnjdLo8k1ZzgZd7w-6yCrKXgPh4FJ1YY-08DZnHNmP3oxm3zmEv3RUIBEyTmo3598PRYLWl\nvttis1KD5PoNgAyKfHqiOCL5q_Owd0m9oAKDagbJhRVZOS89phllA0AQnaI6hJOKvMsbOYJt-w00y6TXf1Nkzp_Yey8EmRiwN\n7gqvudL1UfZ7_UbST2DBjPIyZsv0gT8gpApz6CecCOyX1NNWpUg8ZRkNnOjGL-IMhq4okPCTTfYriOo93z9Y9v6NmaJxV5bBN\nV-DIguXSzLVKnnflfSLyvhinsjLKCnu9L3oXHxw\n```\n\n#### Claims in Id_Tokens\n| Name | Claim | Example Value | Description |\n| ----------------------- | ------------------------------- | ------------ | --------------------------------- |\n| Audience | `aud` | `49210253-0ba1-4a9a-a424-616999fab620` | Identifies the intended recipient of the token.  In id_tokens, the audience is your app's Application Id, as assigned to your app in the app registration portal.  Your app should validate this value and reject the token if it does not match. |\n| Issuer | `iss` | `https://login.microsoftonline.com/b9410318-09af-49c2-b0c3-653adc1f376e/v2.0/` | Identifies the security token service (STS) that constructs and returns the token, as well as the Azure AD tenant in which the user was authenticated.  Your app should validate the issuer claim to ensure that the token came from the v2.0 endpoint.  It can also use the guid portion of the claim to restrict the set of tenants that are allowed to sign into the app. |\n| Issued At | `iat` | `1438535543` | The time at which the token was issued, represented in epoch time. |\n| Expiration Time | `exp` | `1438539443` | The time at which the token becomes invalid, represented in epoch time.  Your app should use this claim to verify the validity of the token lifetime.  |\n| Version | `ver` | `2.0` | The version of the id_token, as defined by Azure AD.  For app model v2.0, The value will be `2.0`. |\n| Tenant Id | `tid` | `b9410318-09af-49c2-b0c3-653adc1f376e` | A guid representing the Azure AD tenant which the user is from.  For work and school accounts, the guid will be the immutable tenant ID of the organization that the user belongs to.  For personal accounts, the value will be `9188040d-6c67-4c5b-b112-36a304b66dad`. |\n| Code Hash | `c_hash` | `SGCPtt01wxwfgnYZy2VJtQ` | The code hash is included in id_tokens only when the id_token is issued alongside an OAuth 2.0 authorization code.  It can be used to validate the authenticity of an authorization code.  See the [OpenID Connect specification](http://openid.net/specs/openid-connect-core-1_0.html) for more details on performing this validation. |\n| Access Token Hash | `at_hash` | `SGCPtt01wxwfgnYZy2VJtQ` | The access token hash is included in id_tokens only when the id_token is issued alongside an OAuth 2.0 access token.  It can be used to validate the authenticity of an access token.  See the [OpenID Connect specification](http://openid.net/specs/openid-connect-core-1_0.html) for more details on performing this validation. |\n| Nonce | `nonce` | `12345` | The nonce is a strategy for mitigating token replay attacks.  Your app can specify a nonce in an authorization request by using the `nonce` query parameter.  The value you provide in the request will be emitted in the id_token's `nonce` claim, unmodified.  This allows your app to verify the value against the value it specified on the request, which associates the app's session with a given id_token.  Your app should perform this validation during the id_token validation process. |\n| Name | `name` | `Leonardo DaVinci` | The name claim provides a human readable value that identifies the subject of the token. This value is not guaranteed to be unique, is mutable, and is designed to be used only for display purposes. |\n| Preferred Username | `preferred_username` | `leo@outlook.com` | The primary username that is used to represent the user in the v2.0 endpoint.  It could be an email address, phone number, or a generic username without a specified format.  Its value is mutable and may change for a given user over time. |\n| Subject | `sub` | `AAAAAAAAAAAAAAAAAAAAAOUtxUJsxQtHuMcFCIA1NC0` | The principal about which the token asserts information, such as the user of an app. This value is immutable and cannot be reassigned or reused, so it can be used to perform authorization checks safely, such as when the token is used to access a resource. Because the subject is always present in the tokens the Azure AD issues, we recommended using this value in a general purpose authorization system. |\n| ObjectId | `oid` | `27cb5cec-7c0c-40b4-a69a-22500b6ea853` | The object Id of the work or school account in the Azure AD system.  This claim will not be issued for personal Microsoft accounts. |\n\n<!---\n| Not Before | `nbf` | `1438535543` |  The time at which the token becomes valid, represented in epoch time. It is usually the same as the issuance time.  Your app should use this claim to verify the validity of the token lifetime.  |\n-->\n\n\n\n## Access Tokens\n\nAccess tokens issued by the v2.0 endpoint take two different formats.  Access tokens that are issued on behalf of work or school accounts are JWTs, similar to an id_token.  Access tokens that are issued on behalf of a personal Microsoft account are in a format known as \"compact tickets\".  For this reason, in development you may notice a different string format for access tokens issued by the v2.0 endpoint.  Over time, this difference in access tokens will be eliminated from the v2.0 endpoint.\n\nWith that said, access tokens issued by the v2.0 endpoint are only consumable by Microsoft Services at this point in time.  Your apps should not need to perform any validation or inspection of access tokens for any of the currently supported scenarios.  You can treat access tokens as completely opaque - they are just strings which your app can pass to Microsoft in HTTP requests.\n\nIn the near future, the v2.0 endpoint will introduce the ability for your app to receive access tokens from other clients.  At that time, this information will be updated with the information your app needs to perform access token validation and other similar tasks.\n\nWhen you request an access token from the v2.0 endpoint, the v2.0 endpoint also returns some metadata about the access token for your app's consumption.  This information includes the expiry time of the access token and the scopes for which it is valid.  This allows your app to perform intelligent caching of access tokens without having to parse open the access token itself.\n\n## Refresh Tokens\n\nRefresh tokens are security tokens which your app can use to acquire new access tokens in an OAuth 2.0 flow.  It allows your app to achieve long-term access to resources on behalf of a user without requiring interaction by the user.\n\nRefresh tokens are multi-resource.  That is to say that a refresh token received during a token request for one resource can be redeemed for access tokens to a completely different resource.\n\nIn order to receive a refresh  in a token response, your app must request & be granted the `offline_acesss` scope.   To learn more about the `offline_access` scope, refer to the [consent & scopes article here](active-directory-v2-scopes.md).\n\nRefresh tokens are, and will always be, completely opaque to your app.  They are issued by the Azure AD v2.0 endpoint and can only be inspected & interpreted by the v2.0 endpoint.  They are long-lived, but your app should not be written to expect that a refresh token will last for any period of time.  Refresh tokens can be invalidated at any moment in time for a variety of reasons.  The only way for your app to know if a refresh token is valid is to attempt to redeem it by making a token request to the v2.0 endpoint.\n\nWhen you redeem a refresh token for a new access token (and if your app had been granted the `offline_access` scope), you will receive a new refresh token in the token response.  You should  save the newly issued refresh token, replacing the one you used in the request.  This will guarantee that your refresh tokens remain valid for as long as possible.\n\n## Validating Tokens\n\nAt this point in time, the only token validation your apps should need to perform is validating id_tokens.  In order to validate an id_token, your app should validate both the id_token's signature and the claims in the id_token.\n\n<!-- TODO: Link -->\nWe provide libraries & code samples that show how to easily handle token validation - the below information is simply provided for those who wish to understand the underlying process.  There are also several 3rd party open source libraries available for JWT validation - there is at least one option for almost every platform & language out there.\n\n#### Validating the Signature\nA JWT contains three segments, which are separated by the `.` character.  The first segment is known as the **header**, the second as the **body**, and the third as the **signature**.  The signature segment can be used to validate the authenticity of the id_token so that it can be trusted by your app.\n\nId_Tokens are signed using industry standard asymmetric encryption algorithms, such as RSA 256. The header of the id_token contains information about the key and encryption method used to sign the token:\n\n```\n{\n        typ: \"JWT\",\n        alg: \"RS256\",\n        x5t: \"GvnPApfWMdLRi8PDmisFn7bprKg\"\n}\n```\n\nThe `alg` claim indicates the algorithm that was used to sign the token, while the `kid` or `x5t` claims indicate the particular public key that was used to sign the token.\n\nAt any given point in time, the v2.0 endpoint may sign an id_token using any one of a certain set of public-private key pairs.  The v2.0 endpoint rotates the possible set of keys on a periodic basis, so your app should be written to handle those key changes automatically.  A reasonable frequency to check for updates to the public keys used by the v2.0 endpoint is about 24 hours.\n\nYou can acquire the signing key data necessary to validate the signature by using the OpenID Connect metadata document located at:\n\n`https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration`\n\nThis metadata document is a JSON object containing several useful pieces of information, such as the location of the various endpoints required for performing OpenID Connect authentication.  It also includes a `jwks_uri`, which gives the location of the set of public keys used to sign tokens.  That location is provided below, but it is best to fetch that location dynamically by using the metadata document and parsing out the `jwks_uri`:\n\n`https://login.microsoftonline.com/common/discovery/v2.0/keys`\n\nThe JSON document located at this url contains all of the public key information in use at that particular moment in time.  Your app can use the `kid` or `x5t` claims in the JWT header to select which public key in this document has been used to sign a particular token.  It can then perform signature validation using the correct public key and the indicated algorithm.\n\nPerforming signature validation is outside the scope of this document - there are many open source libraries available for helping you do so if necessary.\n\n#### Validating the Claims\nWhen your app receives an id_token upon user sign-in, it should also perform a few checks against the claims in the id_token.  These include:\n\n- The **Audience** claim - to verify that the id_token was intended to be given to your app.\n- The **Issued At** and **Expiration Time** claims - to verify that the id_token has not expired.\n- The **Issuer** claim - to verify that the token was indeed issued to your app by the v2.0 endpoint.\n- The **Nonce** -  as a token replay attack mitigation.\n\nDetails of the expected values for these claims are included above in the [id_token section](#id_tokens).\n\n\n## Token Lifetimes\n\nThe following token lifetimes are provided purely for your understanding, as they can help in developing and debugging apps.  Your apps should not be written to expect any of these lifetimes to remain constant - they can and will change at any given point in time.\n\n| Token | Lifetime | Description |\n| ----------------------- | ------------------------------- | ------------ |\n| Id_Tokens (work or school accounts) | 1 hour | Id_Tokens are typically valid for an hour.  Your web app can use this same lifetime in maintaining its own session with the user (recommended), or choose a completely different session lifetime.  If your app needs to get a new id_token, it simply needs to make a new sign-in request to the v2.0 authorize endpoint.  If the user has a valid browser session with the v2.0 endpoint, they may not be required to enter their credentials again. |\n| Id_Tokens (personal accounts) | 24 hours | Id_Tokens for personal accounts are typically valid for 24 hours.  Your web app can use this same lifetime in maintaining its own session with the user (recommended), or choose a completely different session lifetime.  If your app needs to get a new id_token, it simply needs to make a new sign-in request to the v2.0 authorize endpoint.  If the user has a valid browser session with the v2.0 endpoint, they may not be required to enter their credentials again. |\n| Access Tokens (work or school accounts) | 1 hour | Indicated in token responses as part of the token metadata. |\n| Access Tokens (personal accounts) | 1 hour | Indicated in token responses as part of the token metadata.  Access_tokens issued on behalf of personal accounts may be configured for a different lifetime, but one hour is typically the case. |\n| Refresh Tokens (work or school account) | Up to 14 days | A single refresh token is valid for a maximum of 14 days.  However, the refresh token may become invalid at any time for any number of reasons, so your app should continue to try and use a refresh token until it fails, or until your app replaces it with a new refresh token.  A refresh token will also become invalid if it has been 90 days since the user has entered their credentials. |\n| Refresh Tokens (personal accounts) | Up to 1 year | A single refresh token is valid for a maximum of 1 year.  However, the refresh token may become invalid at any time for any number of reasons, so your app should continue to try and use a refresh token until it fails. |\n| Authorization Codes (work or school accounts) | 10 minutes | Authorization codes are purposefully short-lived, and should be immediately redeemed for access_tokens and refresh_tokens when they are received. |\n| Authorization Codes (personal accounts) | 5 minutes | Authorization codes are purposefully short-lived, and should be immediately redeemed for access_tokens and refresh_tokens when they are received.  Authorization codes issued on behalf of personal accounts are also one-time use. |\n\ntest\n"
}