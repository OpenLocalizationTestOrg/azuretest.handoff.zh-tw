<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Service Fabric Testability Scenarios: Service Communication</source>
          <target state="new">Service Fabric Testability Scenarios: Service Communication</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Service-to-service communication is a critical integration point of a Service Fabric application.</source>
          <target state="new">Service-to-service communication is a critical integration point of a Service Fabric application.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>This article discusses design consideration and testing techniques.</source>
          <target state="new">This article discusses design consideration and testing techniques.</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Service Fabric Testability Scenarios: Service Communication</source>
          <target state="new">Service Fabric Testability Scenarios: Service Communication</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Microservices and service-oriented architectural styles surface naturally in Service Fabric.</source>
          <target state="new">Microservices and service-oriented architectural styles surface naturally in Service Fabric.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>In these types of distributed architectures, componentized microservice applications are typically composed of multiple services that need to talk to each other.</source>
          <target state="new">In these types of distributed architectures, componentized microservice applications are typically composed of multiple services that need to talk to each other.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Even in the simplest case, you generally have at least a stateless web service and a stateful data storage service that need to communicate.</source>
          <target state="new">Even in the simplest case, you generally have at least a stateless web service and a stateful data storage service that need to communicate.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Service-to-service communication is a critical integration point of an application as each service exposes a remote API to other services.</source>
          <target state="new">Service-to-service communication is a critical integration point of an application as each service exposes a remote API to other services.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Working with a set of API boundaries involving I/O generally requires some care with a good amount of testing and validation.</source>
          <target state="new">Working with a set of API boundaries involving I/O generally requires some care with a good amount of testing and validation.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>There are numerous considerations to make when these service boundaries are wired together in a distributed system:</source>
          <target state="new">There are numerous considerations to make when these service boundaries are wired together in a distributed system:</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Transport protocol<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Transport protocol<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Will it be HTTP for increased interoperability, or a custom binary protocol for maximum throughput?</source>
          <target state="new">Will it be HTTP for increased interoperability, or a custom binary protocol for maximum throughput?</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Error handling<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Error handling<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>How are permanent and transient errors handled and what happens when a service moves to a different node?</source>
          <target state="new">How are permanent and transient errors handled and what happens when a service moves to a different node?</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Timeouts and latency<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Timeouts and latency<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>In multi-tiered applications, how does each service layer handle latency through the stack and up to the user?</source>
          <target state="new">In multi-tiered applications, how does each service layer handle latency through the stack and up to the user?</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Whether you're using one of the built-in service communication components provided by Service Fabric or building your own, testing the interaction between your services is a critical part of ensuring resiliency in your application.</source>
          <target state="new">Whether you're using one of the built-in service communication components provided by Service Fabric or building your own, testing the interaction between your services is a critical part of ensuring resiliency in your application.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Where's my service?</source>
          <target state="new">Where's my service?</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Service instances may move around over time, especially when configured with load metrics for custom-tailored optimal resource balancing.</source>
          <target state="new">Service instances may move around over time, especially when configured with load metrics for custom-tailored optimal resource balancing.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Upgrades, failovers, scale-out, and other various situations that occur over the lifetime of a distributed system are where Service Fabric moves your service instances to maximize availability.</source>
          <target state="new">Upgrades, failovers, scale-out, and other various situations that occur over the lifetime of a distributed system are where Service Fabric moves your service instances to maximize availability.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>As services move around in the cluster, there are two scenarios your clients and other services should be prepared to handle when talking to a service:</source>
          <target state="new">As services move around in the cluster, there are two scenarios your clients and other services should be prepared to handle when talking to a service:</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The service instance or partition replica has moved since the last time you talked to it.</source>
          <target state="new">The service instance or partition replica has moved since the last time you talked to it.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>This is a normal part of a service lifecycle and should be expected to happen during the lifetime of your application.</source>
          <target state="new">This is a normal part of a service lifecycle and should be expected to happen during the lifetime of your application.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The service instance or partition replica is in the process of moving.</source>
          <target state="new">The service instance or partition replica is in the process of moving.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Although failover of a service from one node to another occurs very quickly in Service Fabric, there may be a delay in availability if the communication component of your service is slow to start.</source>
          <target state="new">Although failover of a service from one node to another occurs very quickly in Service Fabric, there may be a delay in availability if the communication component of your service is slow to start.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Handling these scenarios gracefully is important for a smooth-running system.</source>
          <target state="new">Handling these scenarios gracefully is important for a smooth-running system.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>To do so, we need to make a few considerations:</source>
          <target state="new">To do so, we need to make a few considerations:</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Every service that can be connected to has an <bpt id="p1">*</bpt>address<ept id="p1">*</ept> that it listens on (HTTP, WebSockets, etc.).</source>
          <target state="new">Every service that can be connected to has an <bpt id="p1">*</bpt>address<ept id="p1">*</ept> that it listens on (HTTP, WebSockets, etc.).</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>When a service instance or partition has moved, its address endpoint will change (it's been moved to a different node with a different IP address).</source>
          <target state="new">When a service instance or partition has moved, its address endpoint will change (it's been moved to a different node with a different IP address).</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>If you're using the built-in communication components, they will handle re-resolving service addresses for you.</source>
          <target state="new">If you're using the built-in communication components, they will handle re-resolving service addresses for you.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>There may be a temporary increase in service latency as the service instance starts up its listener again, depending on how quickly the service opens it after being moved.</source>
          <target state="new">There may be a temporary increase in service latency as the service instance starts up its listener again, depending on how quickly the service opens it after being moved.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Any existing connections will need to be closed and re-opened again when the service opens on a new node.</source>
          <target state="new">Any existing connections will need to be closed and re-opened again when the service opens on a new node.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>A graceful node shut down or restart allows time for existing connections to be gracefully shut down.</source>
          <target state="new">A graceful node shut down or restart allows time for existing connections to be gracefully shut down.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Test it: move service instances</source>
          <target state="new">Test it: move service instances</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Using Service Fabric's Testability tools, we can author a test scenario to test these situations in different ways.</source>
          <target state="new">Using Service Fabric's Testability tools, we can author a test scenario to test these situations in different ways.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Move a stateful service's primary replica.</source>
          <target state="new">Move a stateful service's primary replica.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The primary replica of a stateful service partition can be moved for any number of reasons.</source>
          <target state="new">The primary replica of a stateful service partition can be moved for any number of reasons.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Use this to target the primary replica of a specific partition to see how your services react to the move in a very controlled manner.</source>
          <target state="new">Use this to target the primary replica of a specific partition to see how your services react to the move in a very controlled manner.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Stop a node.</source>
          <target state="new">Stop a node.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>When a node is stopped, Service Fabric will move all the services instances or partitions that were on that node to one of the other available nodes in the cluster.</source>
          <target state="new">When a node is stopped, Service Fabric will move all the services instances or partitions that were on that node to one of the other available nodes in the cluster.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Use this to test a stituation where a node is lost from your cluster and all of the service instances and replicas on that node have to move.</source>
          <target state="new">Use this to test a stituation where a node is lost from your cluster and all of the service instances and replicas on that node have to move.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>A node can be stopped using the Stop-ServiceFabricNode PowerShell cmdlet:</source>
          <target state="new">A node can be stopped using the Stop-ServiceFabricNode PowerShell cmdlet:</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Service Availability</source>
          <target state="new">Service Availability</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Service Fabric is a platform that is designed to provide high-availability of your services.</source>
          <target state="new">Service Fabric is a platform that is designed to provide high-availability of your services.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>However, underlying infrastructure problems can still cause unavailability in extreme cases.</source>
          <target state="new">However, underlying infrastructure problems can still cause unavailability in extreme cases.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Thus it is important to also test for such a scenario.</source>
          <target state="new">Thus it is important to also test for such a scenario.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Stateful services use a quorum-based system for replicating state for high-availability.</source>
          <target state="new">Stateful services use a quorum-based system for replicating state for high-availability.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>This means a quorum of replicas need to be available in order to perform write operations.</source>
          <target state="new">This means a quorum of replicas need to be available in order to perform write operations.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>In rare cases, such as widespread hardware failure, a quorum of replicas may not be available.</source>
          <target state="new">In rare cases, such as widespread hardware failure, a quorum of replicas may not be available.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>In this case, you will not be able to perform write operations, but you will still be able to perfom read operations.</source>
          <target state="new">In this case, you will not be able to perform write operations, but you will still be able to perfom read operations.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Test it: write operation unavailability</source>
          <target state="new">Test it: write operation unavailability</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Service Fabric's Testability tools allow you to inject a fault that induces quorum loss to test this type of scenario.</source>
          <target state="new">Service Fabric's Testability tools allow you to inject a fault that induces quorum loss to test this type of scenario.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Although rare, it is important that clients and services that depend on stateful service are prepared to handle situations where they cannot make write requests to the stateful service.</source>
          <target state="new">Although rare, it is important that clients and services that depend on stateful service are prepared to handle situations where they cannot make write requests to the stateful service.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>At the same time it is also important that the stateful service itself is aware of this possibiliy and can gracefully communicate it to callers.</source>
          <target state="new">At the same time it is also important that the stateful service itself is aware of this possibiliy and can gracefully communicate it to callers.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Quorum loss can be induced using the Invoke-ServiceFabricPartitionQuorumLoss PowerShell cmdlet:</source>
          <target state="new">Quorum loss can be induced using the Invoke-ServiceFabricPartitionQuorumLoss PowerShell cmdlet:</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>In this example, we set <ph id="ph1">`QuorumLossMode`</ph> to <ph id="ph2">`PartialQuorumLoss`</ph> to indicate we want to induce quorum loss without taking down all replicas, so that read operations are still possible.</source>
          <target state="new">In this example, we set <ph id="ph1">`QuorumLossMode`</ph> to <ph id="ph2">`PartialQuorumLoss`</ph> to indicate we want to induce quorum loss without taking down all replicas, so that read operations are still possible.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>To test a scenario where an entire partition is unavailable, you can set this switch to <ph id="ph1">`FullQuorumLoss`</ph>.</source>
          <target state="new">To test a scenario where an entire partition is unavailable, you can set this switch to <ph id="ph1">`FullQuorumLoss`</ph>.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="new">Next steps</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Learn more about Testability Actions</source>
          <target state="new">Learn more about Testability Actions</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Learn more about Testability Scenarios</source>
          <target state="new">Learn more about Testability Scenarios</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6f5bd7d8f2a06d06c9f951d90f8fa619a5a0be3a</xliffext:olfilehash>
  </header>
</xliff>