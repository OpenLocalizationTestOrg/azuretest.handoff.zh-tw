{
  "nodes": [
    {
      "content": "Query with DocumentDB SQL | Microsoft Azure",
      "pos": [
        28,
        71
      ]
    },
    {
      "content": "DocumentDB, a NoSQL document database service, supports queries using SQL-like grammar over hierarchical JSON documents without requiring explicit an schema or creation of secondary indexes.",
      "pos": [
        91,
        281
      ]
    },
    {
      "content": "Query DocumentDB",
      "pos": [
        601,
        617
      ]
    },
    {
      "content": "Microsoft Azure DocumentDB supports querying documents using SQL (Structured Query Language) over hierarchical JSON documents.",
      "pos": [
        618,
        744
      ]
    },
    {
      "content": "DocumentDB is truly schema-free.",
      "pos": [
        745,
        777
      ]
    },
    {
      "content": "By virtue of its commitment to the JSON data model directly within the database engine, it provides automatic indexing of JSON documents without requiring explicit schema or creation of secondary indexes.",
      "pos": [
        778,
        982
      ]
    },
    {
      "content": "While designing the query language for DocumentDB we had two goals in mind:",
      "pos": [
        985,
        1060
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Embrace SQL<ept id=\"p1\">**</ept> – Instead of inventing a new query language, we wanted to embrace SQL.",
      "pos": [
        1066,
        1152
      ]
    },
    {
      "content": "After all, SQL is one of the most familiar and popular query languages.",
      "pos": [
        1153,
        1224
      ]
    },
    {
      "content": "DocumentDB SQL provides a formal programming model for rich queries over JSON documents.",
      "pos": [
        1225,
        1313
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Extend SQL<ept id=\"p1\">**</ept> – As a JSON document database capable of executing JavaScript directly in the database engine, we wanted to use JavaScript's programming model as the foundation for our query language.",
      "pos": [
        1318,
        1517
      ]
    },
    {
      "content": "The DocumentDB SQL is rooted in JavaScript's type system, expression evaluation, and function invocation.",
      "pos": [
        1518,
        1623
      ]
    },
    {
      "content": "This in-turn provides a natural programming model for relational projections, hierarchical navigation across JSON documents, self joins, and invocation of user defined functions (UDFs) written entirely in JavaScript, among other features.",
      "pos": [
        1624,
        1862
      ]
    },
    {
      "content": "We believe that these capabilities are key to reducing the friction between the application and the database and are crucial for developer productivity.",
      "pos": [
        1865,
        2017
      ]
    },
    {
      "pos": [
        2019,
        2299
      ],
      "content": "We recommend getting started by watching the following video, where Aravind Ramachandran shows DocumentDB's querying capabilities, and by visiting our <bpt id=\"p1\">[</bpt>Query Playground<ept id=\"p1\">](http://www.documentdb.com/sql/demo)</ept>, where you can try out DocumentDB and run SQL queries against our dataset."
    },
    {
      "content": "Then, return to this article, where we'll start by walking through some simple JSON documents and queries.",
      "pos": [
        2348,
        2454
      ]
    },
    {
      "content": "Getting started",
      "pos": [
        2459,
        2474
      ]
    },
    {
      "content": "To see DocumentDB SQL at work, let's begin with a few simple JSON documents and walk through some simple queries against it.",
      "pos": [
        2475,
        2599
      ]
    },
    {
      "content": "Consider these two JSON documents about two families.",
      "pos": [
        2600,
        2653
      ]
    },
    {
      "content": "Note that with DocumentDB, we do not need to create any schemas or secondary indices explicitly.",
      "pos": [
        2654,
        2750
      ]
    },
    {
      "content": "We simply need to insert the JSON documents to a DocumentDB collection and subsequently query.",
      "pos": [
        2751,
        2845
      ]
    },
    {
      "content": "Here we have a simple JSON document for the Andersen family, the parents, children (and their pets), address and registration information.",
      "pos": [
        2847,
        2985
      ]
    },
    {
      "content": "The document has strings, numbers, booleans, arrays and nested properties.",
      "pos": [
        2986,
        3060
      ]
    },
    {
      "content": "Document",
      "pos": [
        3065,
        3073
      ]
    },
    {
      "pos": [
        3596,
        3726
      ],
      "content": "Here's a second document with one subtle difference – <ph id=\"ph1\">`givenName`</ph> and <ph id=\"ph2\">`familyName`</ph> are used instead of <ph id=\"ph3\">`firstName`</ph> and <ph id=\"ph4\">`lastName`</ph>."
    },
    {
      "content": "Document",
      "pos": [
        3730,
        3738
      ]
    },
    {
      "content": "Now let's try a few queries against this data to understand some of the key aspects of DocumentDB SQL.",
      "pos": [
        4579,
        4681
      ]
    },
    {
      "content": "For example, the following query will return the documents where the id field matches <ph id=\"ph1\">`AndersenFamily`</ph>.",
      "pos": [
        4682,
        4785
      ]
    },
    {
      "content": "Since it's a <ph id=\"ph1\">`SELECT *`</ph>, the output of the query is the complete JSON document:",
      "pos": [
        4786,
        4865
      ]
    },
    {
      "content": "Query",
      "pos": [
        4869,
        4874
      ]
    },
    {
      "content": "Results",
      "pos": [
        4950,
        4957
      ]
    },
    {
      "content": "Now consider the case where we need to reformat the JSON output in a different shape.",
      "pos": [
        5480,
        5565
      ]
    },
    {
      "content": "This query projects a new JSON object with two selected fields, Name and City, when the address' city has the same name as the state.",
      "pos": [
        5566,
        5699
      ]
    },
    {
      "content": "In this case, \"NY, NY\" matches.",
      "pos": [
        5700,
        5731
      ]
    },
    {
      "content": "Query",
      "pos": [
        5735,
        5740
      ]
    },
    {
      "content": "Results",
      "pos": [
        5873,
        5880
      ]
    },
    {
      "pos": [
        5995,
        6132
      ],
      "content": "The next query returns all the given names of children in the family whose id matches <ph id=\"ph1\">`WakefieldFamily`</ph> ordered by the city of residence."
    },
    {
      "content": "Query",
      "pos": [
        6136,
        6141
      ]
    },
    {
      "content": "Results",
      "pos": [
        6286,
        6293
      ]
    },
    {
      "content": "We would like to draw attention to a few noteworthy aspects of the DocumentDB query language through the examples we've seen so far:",
      "pos": [
        6373,
        6505
      ]
    },
    {
      "content": "Since DocumentDB SQL works on JSON values, it deals with tree shaped entities instead of rows and columns.",
      "pos": [
        6514,
        6620
      ]
    },
    {
      "content": "Therefore, the language lets you refer to nodes of the tree at any arbitrary depth, like <ph id=\"ph1\">`Node1.Node2.Node3…..Nodem`</ph>, similar to relational SQL referring to the two part reference of <ph id=\"ph2\">`&lt;table&gt;.&lt;column&gt;`</ph>.",
      "pos": [
        6621,
        6823
      ]
    },
    {
      "content": "The language works with schema-less data.",
      "pos": [
        6831,
        6872
      ]
    },
    {
      "content": "Therefore, the type system needs to be bound dynamically.",
      "pos": [
        6873,
        6930
      ]
    },
    {
      "content": "The same expression could yield different types on different documents.",
      "pos": [
        6931,
        7002
      ]
    },
    {
      "content": "The result of a query is a valid JSON value, but is not guaranteed to be of a fixed schema.",
      "pos": [
        7003,
        7094
      ]
    },
    {
      "content": "DocumentDB only supports strict JSON documents.",
      "pos": [
        7101,
        7148
      ]
    },
    {
      "content": "This means the type system and expressions are restricted to deal only with JSON types.",
      "pos": [
        7149,
        7236
      ]
    },
    {
      "content": "Please refer to the <bpt id=\"p1\">[</bpt>JSON specification<ept id=\"p1\">](http://www.json.org/)</ept> for more details.",
      "pos": [
        7237,
        7317
      ]
    },
    {
      "content": "A DocumentDB collection is a schema-free container of JSON documents.",
      "pos": [
        7324,
        7393
      ]
    },
    {
      "content": "The relations in data entities within and across documents in a collection are implicitly captured by containment and not by primary key and foreign key relations.",
      "pos": [
        7394,
        7557
      ]
    },
    {
      "content": "This is an important aspect worth pointing out in light of the intra-document joins discussed later in this article.",
      "pos": [
        7558,
        7674
      ]
    },
    {
      "content": "DocumentDB indexing",
      "pos": [
        7679,
        7698
      ]
    },
    {
      "content": "Before we get into the DocumentDB SQL grammar, it is worth exploring the indexing design in DocumentDB.",
      "pos": [
        7700,
        7803
      ]
    },
    {
      "content": "The purpose of database indexes is to serve queries in their various forms and shapes with minimum resource consumption (like CPU and input/output) while providing good throughput and low latency.",
      "pos": [
        7806,
        8002
      ]
    },
    {
      "content": "Often, the choice of the right index for querying a database requires much planning and experimentation.",
      "pos": [
        8003,
        8107
      ]
    },
    {
      "content": "This approach poses a challenge for schema-less databases where the data doesn’t conform to a strict schema and evolves rapidly.",
      "pos": [
        8108,
        8236
      ]
    },
    {
      "content": "Therefore, when we designed the DocumentDB indexing subsystem, we set the following goals:",
      "pos": [
        8239,
        8329
      ]
    },
    {
      "content": "Index documents without requiring schema: The indexing subsystem does not require any schema information or make any assumptions about schema of the documents.",
      "pos": [
        8335,
        8494
      ]
    },
    {
      "content": "Support for efficient, rich hierarchical, and relational queries: The index supports the DocumentDB query language efficiently, including support for hierarchical and relational projections.",
      "pos": [
        8501,
        8691
      ]
    },
    {
      "content": "Support for consistent queries in face of a sustained volume of writes: For high write throughput workloads with consistent queries, the index is updated incrementally, efficiently, and online in the face of a sustained volume of writes.",
      "pos": [
        8697,
        8934
      ]
    },
    {
      "content": "The consistent index update is crucial to serve the queries at the consistency level in which the user configured the document service.",
      "pos": [
        8935,
        9070
      ]
    },
    {
      "content": "Support for multi-tenancy: Given the reservation based model for resource governance across tenants, index updates are performed within the budget of system resources (CPU, memory, and input/output operations per second) allocated per replica.",
      "pos": [
        9076,
        9319
      ]
    },
    {
      "content": "Storage efficiency: For cost effectiveness, the on-disk storage overhead of the index is bounded and predictable.",
      "pos": [
        9326,
        9439
      ]
    },
    {
      "content": "This is crucial because DocumentDB allows the developer to make cost based tradeoffs between index overhead in relation to the query performance.",
      "pos": [
        9440,
        9585
      ]
    },
    {
      "content": "Refer to the <bpt id=\"p1\">[</bpt>DocumentDB samples<ept id=\"p1\">](https://github.com/Azure/azure-documentdb-net)</ept> on MSDN for samples showing how to configure the indexing policy for a collection.",
      "pos": [
        9589,
        9752
      ]
    },
    {
      "content": "Let’s now get into the details of the DocumentDB SQL grammar.",
      "pos": [
        9753,
        9814
      ]
    },
    {
      "content": "Basics of DocumentDB query",
      "pos": [
        9820,
        9846
      ]
    },
    {
      "content": "Every query consists of a SELECT clause and optional FROM and WHERE clauses per ANSI-SQL standards.",
      "pos": [
        9847,
        9946
      ]
    },
    {
      "content": "Typically, for each query, the source in the FROM clause is enumerated.",
      "pos": [
        9947,
        10018
      ]
    },
    {
      "content": "Then the filter in the WHERE clause is applied on the source to retrieve a subset of JSON documents.",
      "pos": [
        10019,
        10119
      ]
    },
    {
      "content": "Finally, the SELECT clause is used to project the requested JSON values in the select list.",
      "pos": [
        10120,
        10211
      ]
    },
    {
      "content": "FROM clause",
      "pos": [
        10316,
        10327
      ]
    },
    {
      "content": "The <ph id=\"ph1\">`FROM &lt;from_specification&gt;`</ph> clause is optional unless the source is filtered or projected later in the query.",
      "pos": [
        10328,
        10441
      ]
    },
    {
      "content": "The purpose of this clause is to specify the data source upon which the query must operate.",
      "pos": [
        10442,
        10533
      ]
    },
    {
      "content": "Commonly the whole collection is the source, but one can specify a subset of the collection instead.",
      "pos": [
        10534,
        10634
      ]
    },
    {
      "content": "A query like <ph id=\"ph1\">`SELECT * FROM Families`</ph> indicates that the entire Families collection is the source over which to enumerate.",
      "pos": [
        10637,
        10759
      ]
    },
    {
      "content": "A special identifier ROOT can be used to represent the collection instead of using the collection name.",
      "pos": [
        10760,
        10863
      ]
    },
    {
      "content": "The following list contains the rules that are enforced per query:",
      "pos": [
        10865,
        10931
      ]
    },
    {
      "content": "The collection can be aliased, such as <ph id=\"ph1\">`SELECT f.id FROM Families AS f`</ph> or simply <ph id=\"ph2\">`SELECT f.id FROM Families f`</ph>.",
      "pos": [
        10935,
        11047
      ]
    },
    {
      "content": "Here <ph id=\"ph1\">`f`</ph> is the equivalent of <ph id=\"ph2\">`Families`</ph>.",
      "pos": [
        11048,
        11089
      ]
    },
    {
      "content": "<ph id=\"ph1\">`AS`</ph> is an optional keyword to alias the identifier.",
      "pos": [
        11090,
        11142
      ]
    },
    {
      "content": "Note that once aliased, the original source cannot be bound.",
      "pos": [
        11148,
        11208
      ]
    },
    {
      "content": "For example, <ph id=\"ph1\">`SELECT Families.id FROM Families f`</ph> is syntactically invalid since the identifier \"Families\" cannot be resolved anymore.",
      "pos": [
        11209,
        11343
      ]
    },
    {
      "content": "All properties that need to be referenced must be fully qualified.",
      "pos": [
        11349,
        11415
      ]
    },
    {
      "content": "In the absence of strict schema adherence, this is enforced to avoid any ambiguous bindings.",
      "pos": [
        11416,
        11508
      ]
    },
    {
      "content": "Therefore, <ph id=\"ph1\">`SELECT id FROM Families f`</ph> is syntactically invalid since the property <ph id=\"ph2\">`id`</ph> is not bound.",
      "pos": [
        11509,
        11610
      ]
    },
    {
      "content": "Sub-documents",
      "pos": [
        11620,
        11633
      ]
    },
    {
      "content": "The source can also be reduced to a smaller subset.",
      "pos": [
        11634,
        11685
      ]
    },
    {
      "content": "For instance, to enumerating only a sub-tree in each document, the sub-root could then become the source, as shown in the following example.",
      "pos": [
        11686,
        11826
      ]
    },
    {
      "content": "Query",
      "pos": [
        11830,
        11835
      ]
    },
    {
      "content": "Results",
      "pos": [
        11883,
        11890
      ]
    },
    {
      "content": "While the above example used an array as the source, an object could also be used as the source, which is what's shown in the following example.",
      "pos": [
        12463,
        12607
      ]
    },
    {
      "content": "Any valid JSON value (not undefined) that can be found in the source will be considered for inclusion in the result of the query.",
      "pos": [
        12608,
        12737
      ]
    },
    {
      "content": "If some families don’t have an <ph id=\"ph1\">`address.state`</ph> value, they will be excluded in the query result.",
      "pos": [
        12738,
        12834
      ]
    },
    {
      "content": "Query",
      "pos": [
        12838,
        12843
      ]
    },
    {
      "content": "Results",
      "pos": [
        12896,
        12903
      ]
    },
    {
      "content": "WHERE clause",
      "pos": [
        12948,
        12960
      ]
    },
    {
      "content": "The WHERE clause (<bpt id=\"p1\">**</bpt><ph id=\"ph1\">`WHERE &lt;filter_condition&gt;`</ph><ept id=\"p1\">**</ept>) is optional.",
      "pos": [
        12961,
        13023
      ]
    },
    {
      "content": "It specifies the condition(s) that the JSON documents provided by the source must satisfy in order to be included as part of the result.",
      "pos": [
        13024,
        13160
      ]
    },
    {
      "content": "Any JSON document must evaluate the specified conditions to \"true\" to be considered for the result.",
      "pos": [
        13161,
        13260
      ]
    },
    {
      "content": "The WHERE clause is used by the index layer in order to determine the absolute smallest subset of source documents that can be part of the result.",
      "pos": [
        13261,
        13407
      ]
    },
    {
      "content": "The following query requests documents that contain a name property whose value is <ph id=\"ph1\">`AndersenFamily`</ph>.",
      "pos": [
        13410,
        13510
      ]
    },
    {
      "content": "Any other document that does not have a name property, or where the value does not match <ph id=\"ph1\">`AndersenFamily`</ph> is excluded.",
      "pos": [
        13511,
        13629
      ]
    },
    {
      "content": "Query",
      "pos": [
        13634,
        13639
      ]
    },
    {
      "content": "Results",
      "pos": [
        13722,
        13729
      ]
    },
    {
      "content": "The previous example showed a simple equality query.",
      "pos": [
        13853,
        13905
      ]
    },
    {
      "content": "DocumentDB SQL also supports a variety of scalar expressions.",
      "pos": [
        13906,
        13967
      ]
    },
    {
      "content": "The most commonly used are binary and unary expressions.",
      "pos": [
        13968,
        14024
      ]
    },
    {
      "content": "Property references from the source JSON object are also valid expressions.",
      "pos": [
        14025,
        14100
      ]
    },
    {
      "content": "The following binary operators are currently supported and can be used in queries as shown in the following examples:",
      "pos": [
        14103,
        14220
      ]
    },
    {
      "content": "Arithmetic",
      "pos": [
        14240,
        14250
      ]
    },
    {
      "content": "+,-,*,/,%",
      "pos": [
        14261,
        14270
      ]
    },
    {
      "content": "Bitwise",
      "pos": [
        14291,
        14298
      ]
    },
    {
      "content": "|, &amp;, ^, &lt;",
      "pos": [
        14312,
        14322
      ]
    },
    {
      "content": ", &gt;&gt;&gt; (zero-fill right shift)",
      "pos": [
        14327,
        14356
      ]
    },
    {
      "content": "Logical",
      "pos": [
        14378,
        14385
      ]
    },
    {
      "content": "AND, OR, NOT",
      "pos": [
        14395,
        14407
      ]
    },
    {
      "content": "Comparison",
      "pos": [
        14428,
        14438
      ]
    },
    {
      "content": "=, !=, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, &lt;&gt;",
      "pos": [
        14449,
        14484
      ]
    },
    {
      "content": "String",
      "pos": [
        14505,
        14511
      ]
    },
    {
      "content": "|| (concatenate)",
      "pos": [
        14522,
        14538
      ]
    },
    {
      "content": "Let’s take a look at some queries using binary operators.",
      "pos": [
        14562,
        14619
      ]
    },
    {
      "content": "The unary operators +,-, ~ and NOT are also supported, and can be used inside queries as shown in the following example:",
      "pos": [
        14931,
        15051
      ]
    },
    {
      "content": "In addition to binary and unary operators, property references are also allowed.",
      "pos": [
        15254,
        15334
      ]
    },
    {
      "content": "For example, <ph id=\"ph1\">`SELECT * FROM Families f WHERE f.isRegistered`</ph> returns the JSON document containing the property <ph id=\"ph2\">`isRegistered`</ph> where the property's value is equal to the JSON <ph id=\"ph3\">`true`</ph> value.",
      "pos": [
        15335,
        15522
      ]
    },
    {
      "content": "Any other values (false, null, Undefined, <ph id=\"ph1\">`&lt;number&gt;`</ph>, <ph id=\"ph2\">`&lt;string&gt;`</ph>, <ph id=\"ph3\">`&lt;object&gt;`</ph>, <ph id=\"ph4\">`&lt;array&gt;`</ph>, etc.) leads to the source document being excluded from the result.",
      "pos": [
        15523,
        15678
      ]
    },
    {
      "content": "Equality and comparison operators",
      "pos": [
        15685,
        15718
      ]
    },
    {
      "content": "The following table shows the result of equality comparisons in DocumentDB SQL between any two JSON types.",
      "pos": [
        15719,
        15825
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n            &lt;strong&gt;</ph>Op<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n         </ph>",
      "pos": [
        15904,
        15946
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n            &lt;strong&gt;</ph>Undefined<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n         </ph>",
      "pos": [
        15978,
        16027
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n            &lt;strong&gt;</ph>Null<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n         </ph>",
      "pos": [
        16059,
        16103
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n            &lt;strong&gt;</ph>Boolean<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n         </ph>",
      "pos": [
        16135,
        16182
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n            &lt;strong&gt;</ph>Number<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n         </ph>",
      "pos": [
        16214,
        16260
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n            &lt;strong&gt;</ph>String<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n         </ph>",
      "pos": [
        16292,
        16338
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n            &lt;strong&gt;</ph>Object<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n         </ph>",
      "pos": [
        16370,
        16416
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n            &lt;strong&gt;</ph>Array<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n         </ph>",
      "pos": [
        16448,
        16493
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n            &lt;strong&gt;</ph>Undefined<ph id=\"ph2\">&lt;strong&gt;</ph><ph id=\"ph3\">\n         </ph>",
      "pos": [
        16548,
        16596
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n            &lt;strong&gt;</ph>Null<ph id=\"ph2\">&lt;strong&gt;</ph><ph id=\"ph3\">\n         </ph>",
      "pos": [
        17099,
        17142
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n            &lt;strong&gt;</ph>OK<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n         </ph>",
      "pos": [
        17238,
        17280
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n            &lt;strong&gt;</ph>Boolean<ph id=\"ph2\">&lt;strong&gt;</ph><ph id=\"ph3\">\n         </ph>",
      "pos": [
        17655,
        17701
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n            &lt;strong&gt;</ph>OK<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n         </ph>",
      "pos": [
        17861,
        17903
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n            &lt;strong&gt;</ph>Number<ph id=\"ph2\">&lt;strong&gt;</ph><ph id=\"ph3\">\n         </ph>",
      "pos": [
        18214,
        18259
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n            &lt;strong&gt;</ph>OK<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n         </ph>",
      "pos": [
        18483,
        18525
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n            &lt;strong&gt;</ph>String<ph id=\"ph2\">&lt;strong&gt;</ph><ph id=\"ph3\">\n         </ph>",
      "pos": [
        18772,
        18817
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n            &lt;strong&gt;</ph>OK<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n         </ph>",
      "pos": [
        19105,
        19147
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n            &lt;strong&gt;</ph>Object<ph id=\"ph2\">&lt;strong&gt;</ph><ph id=\"ph3\">\n         </ph>",
      "pos": [
        19330,
        19375
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n            &lt;strong&gt;</ph>OK<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n         </ph>",
      "pos": [
        19727,
        19769
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n            &lt;strong&gt;</ph>Array<ph id=\"ph2\">&lt;strong&gt;</ph><ph id=\"ph3\">\n         </ph>",
      "pos": [
        19888,
        19932
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n            &lt;strong&gt;</ph>OK<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n         </ph>",
      "pos": [
        20348,
        20390
      ]
    },
    {
      "content": "For other comparison operators such as &gt;, &gt;=, !=, &lt; and &lt;=, the following rules apply:",
      "pos": [
        20430,
        20516
      ]
    },
    {
      "content": "Comparison across types results in Undefined.",
      "pos": [
        20525,
        20570
      ]
    },
    {
      "content": "Comparison between two objects or two arrays results in Undefined.",
      "pos": [
        20575,
        20641
      ]
    },
    {
      "content": "If the result of the scalar expression in the filter is Undefined, the corresponding document would not be included in the result, since Undefined doesn't logically equate to \"true\".",
      "pos": [
        20646,
        20828
      ]
    },
    {
      "content": "BETWEEN keyword",
      "pos": [
        20834,
        20849
      ]
    },
    {
      "content": "You can also use the BETWEEN keyword to express queries against ranges of values like in ANSI SQL.",
      "pos": [
        20850,
        20948
      ]
    },
    {
      "content": "BETWEEN can be used against any JSON primitive type (numbers, strings, Booleans and nulls).",
      "pos": [
        20949,
        21040
      ]
    },
    {
      "content": "For example, this query returns all family documents in which the first child's grade is between 1-5 (both inclusive).",
      "pos": [
        21043,
        21161
      ]
    },
    {
      "content": "Unlike in ANSI-SQL, you can also use the BETWEEN clause in the FROM clause like in the following example.",
      "pos": [
        21244,
        21349
      ]
    },
    {
      "content": "For faster query execution times, remember to create an indexing policy that uses a range index type against any numeric properties/paths that are filtered in the BETWEEN clause.",
      "pos": [
        21422,
        21600
      ]
    },
    {
      "content": "The main difference between using BETWEEN in DocumentDB and ANSI SQL is that you can express range queries against properties of mixed types – for example, you might have \"grade\" be a number (5) in some documents and strings in others (\"grade4\").",
      "pos": [
        21603,
        21849
      ]
    },
    {
      "content": "In these cases, like in JavaScript, a comparison between two different types results in \"undefined\", and the document will be skipped.",
      "pos": [
        21850,
        21984
      ]
    },
    {
      "content": "Logical (AND, OR and NOT) operators",
      "pos": [
        21990,
        22025
      ]
    },
    {
      "content": "Logical operators operate on Boolean values.",
      "pos": [
        22026,
        22070
      ]
    },
    {
      "content": "The logical truth tables for these operators are shown in the following tables.",
      "pos": [
        22071,
        22150
      ]
    },
    {
      "content": "OR",
      "pos": [
        22152,
        22154
      ]
    },
    {
      "content": "True",
      "pos": [
        22155,
        22159
      ]
    },
    {
      "content": "False",
      "pos": [
        22160,
        22165
      ]
    },
    {
      "content": "Undefined",
      "pos": [
        22166,
        22175
      ]
    },
    {
      "content": "True",
      "pos": [
        22192,
        22196
      ]
    },
    {
      "content": "True",
      "pos": [
        22197,
        22201
      ]
    },
    {
      "content": "True",
      "pos": [
        22202,
        22206
      ]
    },
    {
      "content": "True",
      "pos": [
        22207,
        22211
      ]
    },
    {
      "content": "False",
      "pos": [
        22212,
        22217
      ]
    },
    {
      "content": "True",
      "pos": [
        22218,
        22222
      ]
    },
    {
      "content": "False",
      "pos": [
        22223,
        22228
      ]
    },
    {
      "content": "Undefined",
      "pos": [
        22229,
        22238
      ]
    },
    {
      "content": "Undefined",
      "pos": [
        22239,
        22248
      ]
    },
    {
      "content": "True",
      "pos": [
        22249,
        22253
      ]
    },
    {
      "content": "Undefined",
      "pos": [
        22254,
        22263
      ]
    },
    {
      "content": "Undefined",
      "pos": [
        22264,
        22273
      ]
    },
    {
      "content": "AND",
      "pos": [
        22275,
        22278
      ]
    },
    {
      "content": "True",
      "pos": [
        22279,
        22283
      ]
    },
    {
      "content": "False",
      "pos": [
        22284,
        22289
      ]
    },
    {
      "content": "Undefined",
      "pos": [
        22290,
        22299
      ]
    },
    {
      "content": "True",
      "pos": [
        22316,
        22320
      ]
    },
    {
      "content": "True",
      "pos": [
        22321,
        22325
      ]
    },
    {
      "content": "False",
      "pos": [
        22326,
        22331
      ]
    },
    {
      "content": "Undefined",
      "pos": [
        22332,
        22341
      ]
    },
    {
      "content": "False",
      "pos": [
        22342,
        22347
      ]
    },
    {
      "content": "False",
      "pos": [
        22348,
        22353
      ]
    },
    {
      "content": "False",
      "pos": [
        22354,
        22359
      ]
    },
    {
      "content": "False",
      "pos": [
        22360,
        22365
      ]
    },
    {
      "content": "Undefined",
      "pos": [
        22366,
        22375
      ]
    },
    {
      "content": "Undefined",
      "pos": [
        22376,
        22385
      ]
    },
    {
      "content": "False",
      "pos": [
        22386,
        22391
      ]
    },
    {
      "content": "Undefined",
      "pos": [
        22392,
        22401
      ]
    },
    {
      "content": "NOT",
      "pos": [
        22403,
        22406
      ]
    },
    {
      "content": "True",
      "pos": [
        22419,
        22423
      ]
    },
    {
      "content": "False",
      "pos": [
        22424,
        22429
      ]
    },
    {
      "content": "False",
      "pos": [
        22430,
        22435
      ]
    },
    {
      "content": "True",
      "pos": [
        22436,
        22440
      ]
    },
    {
      "content": "Undefined",
      "pos": [
        22441,
        22450
      ]
    },
    {
      "content": "Undefined",
      "pos": [
        22451,
        22460
      ]
    },
    {
      "content": "IN keyword",
      "pos": [
        22466,
        22476
      ]
    },
    {
      "content": "The IN keyword can be used to check whether a specified value matches any value in a list.",
      "pos": [
        22477,
        22567
      ]
    },
    {
      "content": "For example, this query returns all family documents where the id is one of \"WakefieldFamily\" or \"AndersenFamily\".",
      "pos": [
        22568,
        22682
      ]
    },
    {
      "content": "This example returns all documents where the state is any of the specified values.",
      "pos": [
        22782,
        22864
      ]
    },
    {
      "pos": [
        22996,
        23216
      ],
      "content": "IN is equivalent to chaining multiple OR clauses, however since it can be served using a single index, DocumentDB supports a higher <bpt id=\"p1\">[</bpt>limit<ept id=\"p1\">](documentdb-limits.md)</ept> for the number of arguments specified within an IN clause."
    },
    {
      "content": "Ternary (?) and Coalesce (??) operators",
      "pos": [
        23224,
        23263
      ]
    },
    {
      "content": "The Ternary and Coalesce operators can be used to build conditional expressions, similar to popular programming languages like C# and JavaScript.",
      "pos": [
        23264,
        23409
      ]
    },
    {
      "content": "The Ternary (?) operator can be very handy when constructing new JSON properties on the fly.",
      "pos": [
        23412,
        23504
      ]
    },
    {
      "content": "For example, now you can write queries to classify the class levels into a human readable form like Beginner/Intermediate/Advanced as shown below.",
      "pos": [
        23505,
        23651
      ]
    },
    {
      "content": "You can also nest the calls to the operator like in the query below.",
      "pos": [
        23752,
        23820
      ]
    },
    {
      "content": "As with other query operators, if the referenced properties in the conditional expression are missing in any document, or if the types being compared are different, then those documents will be excluded in the query results.",
      "pos": [
        23946,
        24170
      ]
    },
    {
      "content": "The Coalesce (??) operator can be used to efficiently check for the presence of a property (a.k.a.",
      "pos": [
        24172,
        24270
      ]
    },
    {
      "content": "is defined) in a document.",
      "pos": [
        24271,
        24297
      ]
    },
    {
      "content": "This is useful when querying against semi-structured or data of mixed types.",
      "pos": [
        24298,
        24374
      ]
    },
    {
      "content": "For example, this query returns the \"lastName\" if present, or the \"surname\" if it isn't present.",
      "pos": [
        24375,
        24471
      ]
    },
    {
      "content": "Quoted property accessor",
      "pos": [
        24547,
        24571
      ]
    },
    {
      "content": "You can also access properties using the quoted property operator <ph id=\"ph1\">`[]`</ph>.",
      "pos": [
        24572,
        24643
      ]
    },
    {
      "content": "For example, <ph id=\"ph1\">`SELECT c.grade`</ph> and <ph id=\"ph2\">`SELECT c[\"grade\"]`</ph> are equivalent.",
      "pos": [
        24644,
        24713
      ]
    },
    {
      "content": "This syntax is useful when you need to escape a property that contains spaces, special characters, or happens to share the same name as a SQL keyword or reserved word.",
      "pos": [
        24714,
        24881
      ]
    },
    {
      "content": "SELECT clause",
      "pos": [
        24970,
        24983
      ]
    },
    {
      "content": "The SELECT clause (<bpt id=\"p1\">**</bpt><ph id=\"ph1\">`SELECT &lt;select_list&gt;`</ph><ept id=\"p1\">**</ept>) is mandatory and specifies what values will be retrieved from the query, just like in ANSI-SQL.",
      "pos": [
        24984,
        25126
      ]
    },
    {
      "content": "The subset that's been filtered on top of the source documents are passed onto the projection phase, where the specified JSON values are retrieved and a new JSON object is constructed, for each input passed onto it.",
      "pos": [
        25127,
        25342
      ]
    },
    {
      "content": "The following example shows a typical SELECT query.",
      "pos": [
        25345,
        25396
      ]
    },
    {
      "content": "Query",
      "pos": [
        25401,
        25406
      ]
    },
    {
      "content": "Results",
      "pos": [
        25489,
        25496
      ]
    },
    {
      "content": "Nested properties",
      "pos": [
        25624,
        25641
      ]
    },
    {
      "pos": [
        25642,
        25747
      ],
      "content": "In the following example, we are projecting two nested properties <ph id=\"ph1\">`f.address.state`</ph> and <ph id=\"ph2\">`f.address.city`</ph>."
    },
    {
      "content": "Query",
      "pos": [
        25751,
        25756
      ]
    },
    {
      "content": "Results",
      "pos": [
        25861,
        25868
      ]
    },
    {
      "content": "Projection also supports JSON expressions as shown in the following example.",
      "pos": [
        25934,
        26010
      ]
    },
    {
      "content": "Query",
      "pos": [
        26014,
        26019
      ]
    },
    {
      "content": "Results",
      "pos": [
        26159,
        26166
      ]
    },
    {
      "content": "Let's look at the role of <ph id=\"ph1\">`$1`</ph> here.",
      "pos": [
        26293,
        26329
      ]
    },
    {
      "content": "The <ph id=\"ph1\">`SELECT`</ph> clause needs to create a JSON object and since no key is provided, we use implicit argument variable names starting with <ph id=\"ph2\">`$1`</ph>.",
      "pos": [
        26330,
        26469
      ]
    },
    {
      "content": "For example, this query returns two implicit argument variables, labeled <ph id=\"ph1\">`$1`</ph> and <ph id=\"ph2\">`$2`</ph>.",
      "pos": [
        26470,
        26557
      ]
    },
    {
      "content": "Query",
      "pos": [
        26561,
        26566
      ]
    },
    {
      "content": "Results",
      "pos": [
        26722,
        26729
      ]
    },
    {
      "content": "Aliasing",
      "pos": [
        26882,
        26890
      ]
    },
    {
      "content": "Now let's extend the example above with explicit aliasing of values.",
      "pos": [
        26891,
        26959
      ]
    },
    {
      "content": "AS is the keyword used for aliasing.",
      "pos": [
        26960,
        26996
      ]
    },
    {
      "content": "Note that it's optional as shown while projecting the second value as <ph id=\"ph1\">`NameInfo`</ph>.",
      "pos": [
        26997,
        27078
      ]
    },
    {
      "content": "In case a query has two properties with the same name, aliasing must be used to rename one or both of the properties so that they are disambiguated in the projected result.",
      "pos": [
        27081,
        27253
      ]
    },
    {
      "content": "Query",
      "pos": [
        27257,
        27262
      ]
    },
    {
      "content": "Results",
      "pos": [
        27454,
        27461
      ]
    },
    {
      "content": "Scalar expressions",
      "pos": [
        27629,
        27647
      ]
    },
    {
      "content": "In addition to property references, the SELECT clause also supports scalar expressions like constants, arithmetic expressions, logical expressions, etc. For example, here's a simple \"Hello World\" query.",
      "pos": [
        27648,
        27850
      ]
    },
    {
      "content": "Query",
      "pos": [
        27854,
        27859
      ]
    },
    {
      "content": "Results",
      "pos": [
        27891,
        27898
      ]
    },
    {
      "content": "Here's a more complex example that uses a scalar expression.",
      "pos": [
        27944,
        28004
      ]
    },
    {
      "content": "Query",
      "pos": [
        28008,
        28013
      ]
    },
    {
      "content": "Results",
      "pos": [
        28053,
        28060
      ]
    },
    {
      "content": "In the following example, the result of the scalar expression is a Boolean.",
      "pos": [
        28100,
        28175
      ]
    },
    {
      "content": "Query",
      "pos": [
        28179,
        28184
      ]
    },
    {
      "content": "Results",
      "pos": [
        28280,
        28287
      ]
    },
    {
      "content": "Object and array creation",
      "pos": [
        28418,
        28443
      ]
    },
    {
      "content": "Another key feature of DocumentDB SQL is array/object creation.",
      "pos": [
        28444,
        28507
      ]
    },
    {
      "content": "In the previous example, note that we created a new JSON object.",
      "pos": [
        28508,
        28572
      ]
    },
    {
      "content": "Similarly, one can also construct arrays as shown in the following examples.",
      "pos": [
        28573,
        28649
      ]
    },
    {
      "content": "Query",
      "pos": [
        28653,
        28658
      ]
    },
    {
      "content": "Results",
      "pos": [
        28745,
        28752
      ]
    },
    {
      "content": "VALUE keyword",
      "pos": [
        28944,
        28957
      ]
    },
    {
      "content": "The <bpt id=\"p1\">**</bpt>VALUE<ept id=\"p1\">**</ept> keyword provides a way to return JSON value.",
      "pos": [
        28958,
        29016
      ]
    },
    {
      "content": "For example, the query shown below returns the scalar <ph id=\"ph1\">`\"Hello World\"`</ph> instead of <ph id=\"ph2\">`{$1: \"Hello World\"}`</ph>.",
      "pos": [
        29017,
        29120
      ]
    },
    {
      "content": "Query",
      "pos": [
        29124,
        29129
      ]
    },
    {
      "content": "Results",
      "pos": [
        29167,
        29174
      ]
    },
    {
      "pos": [
        29212,
        29300
      ],
      "content": "The following query returns the JSON value without the <ph id=\"ph1\">`\"address\"`</ph> label in the results."
    },
    {
      "content": "Query",
      "pos": [
        29304,
        29309
      ]
    },
    {
      "content": "Results",
      "pos": [
        29364,
        29371
      ]
    },
    {
      "content": "The following example extends this to show how to return JSON primitive values (the leaf level of the JSON tree).",
      "pos": [
        29578,
        29691
      ]
    },
    {
      "content": "Query",
      "pos": [
        29696,
        29701
      ]
    },
    {
      "content": "Results",
      "pos": [
        29762,
        29769
      ]
    },
    {
      "content": "* Operator",
      "pos": [
        29813,
        29823
      ]
    },
    {
      "content": "The special operator (*) is supported to project the document as-is.",
      "pos": [
        29824,
        29892
      ]
    },
    {
      "content": "When used, it must be the only projected field.",
      "pos": [
        29893,
        29940
      ]
    },
    {
      "content": "While a query like <ph id=\"ph1\">`SELECT * FROM Families f`</ph> is valid, <ph id=\"ph2\">`SELECT VALUE * FROM Families f `</ph> and  <ph id=\"ph3\">`SELECT *, f.id FROM Families f `</ph> are not valid.",
      "pos": [
        29941,
        30084
      ]
    },
    {
      "content": "Query",
      "pos": [
        30088,
        30093
      ]
    },
    {
      "content": "Results",
      "pos": [
        30169,
        30176
      ]
    },
    {
      "content": "ORDER BY clause",
      "pos": [
        30701,
        30716
      ]
    },
    {
      "content": "Like in ANSI-SQL, you can include an optional Order By clause while querying.",
      "pos": [
        30717,
        30794
      ]
    },
    {
      "content": "The clause can include an optional ASC/DESC argument to specify the order in which results must be retrieved.",
      "pos": [
        30795,
        30904
      ]
    },
    {
      "content": "For a more detailed look at Order By, refer to <bpt id=\"p1\">[</bpt>DocumentDB Order By Walkthrough<ept id=\"p1\">](documentdb-orderby.md)</ept>.",
      "pos": [
        30905,
        31009
      ]
    },
    {
      "content": "For example, here's a query that retrieves families in order of the resident city's name.",
      "pos": [
        31011,
        31100
      ]
    },
    {
      "content": "Query",
      "pos": [
        31104,
        31109
      ]
    },
    {
      "content": "Results",
      "pos": [
        31201,
        31208
      ]
    },
    {
      "content": "And here's a query that retrieves families in order of creation date, which is stored as a number representing the epoch time, i.e, elapsed time since Jan 1, 1970 in seconds.",
      "pos": [
        31377,
        31551
      ]
    },
    {
      "content": "Query",
      "pos": [
        31555,
        31560
      ]
    },
    {
      "content": "Results",
      "pos": [
        31657,
        31664
      ]
    },
    {
      "content": "Advanced concepts",
      "pos": [
        31862,
        31879
      ]
    },
    {
      "content": "Iteration",
      "pos": [
        31884,
        31893
      ]
    },
    {
      "content": "A new construct was added via the <bpt id=\"p1\">**</bpt>IN<ept id=\"p1\">**</ept> keyword in DocumentDB SQL to provide support for iterating over JSON arrays.",
      "pos": [
        31894,
        32011
      ]
    },
    {
      "content": "The FROM source provides support for iteration.",
      "pos": [
        32012,
        32059
      ]
    },
    {
      "content": "Let's start with the following example:",
      "pos": [
        32060,
        32099
      ]
    },
    {
      "content": "Query",
      "pos": [
        32103,
        32108
      ]
    },
    {
      "content": "Results",
      "pos": [
        32156,
        32163
      ]
    },
    {
      "content": "Now let's look at another query that performs iteration over children in the collection.",
      "pos": [
        32678,
        32766
      ]
    },
    {
      "content": "Note the difference in the output array.",
      "pos": [
        32767,
        32807
      ]
    },
    {
      "content": "This example splits <ph id=\"ph1\">`children`</ph> and flattens the results into a single array.",
      "pos": [
        32808,
        32884
      ]
    },
    {
      "content": "Query",
      "pos": [
        32890,
        32895
      ]
    },
    {
      "content": "Results",
      "pos": [
        32948,
        32955
      ]
    },
    {
      "content": "This can be further used to filter on each individual entry of the array as shown in the following example.",
      "pos": [
        33400,
        33507
      ]
    },
    {
      "content": "Query",
      "pos": [
        33511,
        33516
      ]
    },
    {
      "content": "Results",
      "pos": [
        33600,
        33607
      ]
    },
    {
      "content": "Joins",
      "pos": [
        33658,
        33663
      ]
    },
    {
      "content": "In a relational database, the need to join across tables is very important.",
      "pos": [
        33664,
        33739
      ]
    },
    {
      "content": "It's the logical corollary to designing normalized schemas.",
      "pos": [
        33740,
        33799
      ]
    },
    {
      "content": "Contrary to this, DocumentDB deals with the denormalized data model of schema-free documents.",
      "pos": [
        33800,
        33893
      ]
    },
    {
      "content": "This is the logical equivalent of a \"self-join\".",
      "pos": [
        33894,
        33942
      ]
    },
    {
      "content": "The syntax that the language supports is &lt;from_source1&gt; JOIN &lt;from_source2&gt; JOIN ... JOIN &lt;from_sourceN&gt;.",
      "pos": [
        33944,
        34049
      ]
    },
    {
      "content": "Overall, this returns a set of <bpt id=\"p1\">**</bpt>N<ept id=\"p1\">**</ept>-tuples (tuple with <bpt id=\"p2\">**</bpt>N<ept id=\"p2\">**</ept> values).",
      "pos": [
        34050,
        34120
      ]
    },
    {
      "content": "Each tuple has values produced by iterating all collection aliases over their respective sets.",
      "pos": [
        34121,
        34215
      ]
    },
    {
      "content": "In other words, this is a full cross product of the sets participating in the join.",
      "pos": [
        34216,
        34299
      ]
    },
    {
      "content": "The following examples show how the JOIN clause works.",
      "pos": [
        34301,
        34355
      ]
    },
    {
      "content": "In the following example, the result is empty since the cross product of each document from source and an empty set is empty.",
      "pos": [
        34356,
        34481
      ]
    },
    {
      "content": "Query",
      "pos": [
        34485,
        34490
      ]
    },
    {
      "content": "Results",
      "pos": [
        34556,
        34563
      ]
    },
    {
      "content": "In the following example, the join is between the document root and the <ph id=\"ph1\">`children`</ph> sub-root.",
      "pos": [
        34585,
        34677
      ]
    },
    {
      "content": "It's a cross product between two JSON objects.",
      "pos": [
        34678,
        34724
      ]
    },
    {
      "content": "The fact that children is an array is not effective in the JOIN since we are dealing with a single root that is the children array.",
      "pos": [
        34725,
        34856
      ]
    },
    {
      "content": "Hence the result contains only two results, since the cross product of each document with the array yields exactly only one document.",
      "pos": [
        34857,
        34990
      ]
    },
    {
      "content": "Query",
      "pos": [
        34994,
        34999
      ]
    },
    {
      "content": "Results",
      "pos": [
        35063,
        35070
      ]
    },
    {
      "content": "The following example shows a more conventional join:",
      "pos": [
        35185,
        35238
      ]
    },
    {
      "content": "Query",
      "pos": [
        35242,
        35247
      ]
    },
    {
      "content": "Results",
      "pos": [
        35316,
        35323
      ]
    },
    {
      "content": "The first thing to note is that the <ph id=\"ph1\">`from_source`</ph> of the <bpt id=\"p1\">**</bpt>JOIN<ept id=\"p1\">**</ept> clause is an iterator.",
      "pos": [
        35489,
        35577
      ]
    },
    {
      "content": "So, the flow in this case is as follows:",
      "pos": [
        35578,
        35618
      ]
    },
    {
      "pos": [
        35626,
        35671
      ],
      "content": "Expand each child element <bpt id=\"p1\">**</bpt>c<ept id=\"p1\">**</ept> in the array."
    },
    {
      "pos": [
        35676,
        35801
      ],
      "content": "Apply a cross product with the root of the document <bpt id=\"p1\">**</bpt>f<ept id=\"p1\">**</ept> with each child element <bpt id=\"p2\">**</bpt>c<ept id=\"p2\">**</ept> that was flattened in the first step."
    },
    {
      "pos": [
        35806,
        35865
      ],
      "content": "Finally, project the root object <bpt id=\"p1\">**</bpt>f<ept id=\"p1\">**</ept> name property alone."
    },
    {
      "content": "The first document (<ph id=\"ph1\">`AndersenFamily`</ph>) contains only one child element, so the result set contains only a single object corresponding to this document.",
      "pos": [
        35868,
        36018
      ]
    },
    {
      "content": "The second document (<ph id=\"ph1\">`WakefieldFamily`</ph>) contains two children.",
      "pos": [
        36019,
        36081
      ]
    },
    {
      "content": "So, the cross product produces a separate object for each child, thereby resulting in two objects, one for each child corresponding to this document.",
      "pos": [
        36082,
        36231
      ]
    },
    {
      "content": "Note that the root fields in both these documents will be same, just as you would expect in a cross product.",
      "pos": [
        36232,
        36340
      ]
    },
    {
      "content": "The real utility of the JOIN is to form tuples from the cross-product in a shape that's otherwise difficult to project.",
      "pos": [
        36342,
        36461
      ]
    },
    {
      "content": "Furthermore, as we will see in the example below, you could filter on the combination of a tuple that lets' the user chose a condition satisfied by the tuples overall.",
      "pos": [
        36462,
        36629
      ]
    },
    {
      "content": "Query",
      "pos": [
        36633,
        36638
      ]
    },
    {
      "content": "Results",
      "pos": [
        36864,
        36871
      ]
    },
    {
      "content": "This example is a natural extension of the preceding example, and performs a double join.",
      "pos": [
        37267,
        37356
      ]
    },
    {
      "content": "So, the cross product can be viewed as the following pseudo-code.",
      "pos": [
        37357,
        37422
      ]
    },
    {
      "content": "<ph id=\"ph1\">`AndersenFamily`</ph> has one child who has one pet.",
      "pos": [
        37795,
        37842
      ]
    },
    {
      "content": "So, the cross product yields one row (1<bpt id=\"p1\">*</bpt>1<ept id=\"p1\">*</ept>1) from this family.",
      "pos": [
        37843,
        37905
      ]
    },
    {
      "content": "WakefieldFamily however has two children, but only one child \"Jesse\" has pets.",
      "pos": [
        37906,
        37984
      ]
    },
    {
      "content": "Jesse has 2 pets though.",
      "pos": [
        37985,
        38009
      ]
    },
    {
      "content": "Hence the cross product yields 1<bpt id=\"p1\">*</bpt>1<ept id=\"p1\">*</ept>2 = 2 rows from this family.",
      "pos": [
        38010,
        38073
      ]
    },
    {
      "content": "In the next example, there is an additional filter on <ph id=\"ph1\">`pet`</ph>.",
      "pos": [
        38075,
        38135
      ]
    },
    {
      "content": "This excludes all the tuples where the pet name is not \"Shadow\".",
      "pos": [
        38136,
        38200
      ]
    },
    {
      "content": "Notice that we are able to build tuples from arrays, filter on any of the elements of the tuple, and project any combination of the elements.",
      "pos": [
        38201,
        38342
      ]
    },
    {
      "content": "Query",
      "pos": [
        38347,
        38352
      ]
    },
    {
      "content": "Results",
      "pos": [
        38610,
        38617
      ]
    },
    {
      "content": "JavaScript integration",
      "pos": [
        38757,
        38779
      ]
    },
    {
      "content": "DocumentDB provides a programming model for executing JavaScript based application logic directly on the collections in terms of stored procedures and triggers.",
      "pos": [
        38780,
        38940
      ]
    },
    {
      "content": "This allows for both:",
      "pos": [
        38941,
        38962
      ]
    },
    {
      "content": "Ability to do high performance transactional CRUD operations and queries against documents in a collection by virtue of the deep integration of JavaScript runtime directly within the database engine.",
      "pos": [
        38968,
        39167
      ]
    },
    {
      "content": "A natural modeling of control flow, variable scoping, and assignment and integration of exception handling primitives with database transactions.",
      "pos": [
        39173,
        39318
      ]
    },
    {
      "content": "For more details about DocumentDB support for JavaScript integration, please refer to the JavaScript server side programmability documentation.",
      "pos": [
        39319,
        39462
      ]
    },
    {
      "content": "User Defined Functions (UDFs)",
      "pos": [
        39467,
        39496
      ]
    },
    {
      "content": "Along with the types already defined in this article, DocumentDB SQL provides support for User Defined Functions (UDF).",
      "pos": [
        39497,
        39616
      ]
    },
    {
      "content": "In particular, scalar UDFs are supported where the developers can pass in zero or many arguments and return a single argument result back.",
      "pos": [
        39617,
        39755
      ]
    },
    {
      "content": "Each of these arguments are checked for being legal JSON values.",
      "pos": [
        39756,
        39820
      ]
    },
    {
      "content": "The DocumentDB SQL grammar is extended to support custom application logic using these User Defined Functions.",
      "pos": [
        39824,
        39934
      ]
    },
    {
      "content": "UDFs can be registered with DocumentDB and then be referenced as part of a SQL query.",
      "pos": [
        39935,
        40020
      ]
    },
    {
      "content": "In fact, the UDFs are exquisitely designed to be invoked by queries.",
      "pos": [
        40021,
        40089
      ]
    },
    {
      "content": "As a corollary to this choice, UDFs do not have access to the context object which the other JavaScript types (stored procedures and triggers) have.",
      "pos": [
        40090,
        40238
      ]
    },
    {
      "content": "Since queries execute as read-only, they can run either on primary or on secondary replicas.",
      "pos": [
        40239,
        40331
      ]
    },
    {
      "content": "Therefore, UDFs are designed to run on secondary replicas unlike other JavaScript types.",
      "pos": [
        40332,
        40420
      ]
    },
    {
      "content": "Below is an example of how a UDF can be registered at the DocumentDB database, specifically under a document collection.",
      "pos": [
        40422,
        40542
      ]
    },
    {
      "content": "The preceding example creates a UDF whose name is <ph id=\"ph1\">`REGEX_MATCH`</ph>.",
      "pos": [
        41066,
        41130
      ]
    },
    {
      "content": "It accepts two JSON string values <ph id=\"ph1\">`input`</ph> and <ph id=\"ph2\">`pattern`</ph> and checks if the first matches the pattern specified in the second using JavaScript's string.match() function.",
      "pos": [
        41131,
        41298
      ]
    },
    {
      "content": "We can now use this UDF in a query in a projection.",
      "pos": [
        41301,
        41352
      ]
    },
    {
      "content": "UDFs must be qualified with the case-sensitive prefix \"udf.\"",
      "pos": [
        41353,
        41413
      ]
    },
    {
      "content": "when called from within queries.",
      "pos": [
        41414,
        41446
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> Prior to 3/17/2015, DocumentDB supported UDF calls without the \"udf.\"",
      "pos": [
        41450,
        41532
      ]
    },
    {
      "content": "prefix like SELECT REGEX_MATCH().",
      "pos": [
        41533,
        41566
      ]
    },
    {
      "content": "This calling pattern has been deprecated.",
      "pos": [
        41567,
        41608
      ]
    },
    {
      "content": "Query",
      "pos": [
        41614,
        41619
      ]
    },
    {
      "content": "Results",
      "pos": [
        41706,
        41713
      ]
    },
    {
      "content": "The UDF can also be used inside a filter as shown in the example below, also qualified with the \"udf.\"",
      "pos": [
        41803,
        41905
      ]
    },
    {
      "content": "prefix :",
      "pos": [
        41906,
        41914
      ]
    },
    {
      "content": "Query",
      "pos": [
        41918,
        41923
      ]
    },
    {
      "content": "Results",
      "pos": [
        42055,
        42062
      ]
    },
    {
      "content": "In essence, UDFs are valid scalar expressions and can be used in both projections and filters.",
      "pos": [
        42140,
        42234
      ]
    },
    {
      "content": "To expand on the power of UDFs, let's look at another example with conditional logic:",
      "pos": [
        42237,
        42322
      ]
    },
    {
      "content": "Below is an example that exercises the UDF.",
      "pos": [
        42945,
        42988
      ]
    },
    {
      "content": "Query",
      "pos": [
        42992,
        42997
      ]
    },
    {
      "content": "Results",
      "pos": [
        43093,
        43100
      ]
    },
    {
      "content": "As the preceding examples showcase, UDFs integrate the power of JavaScript language with the DocumentDB SQL to provide a rich programmable interface to do complex procedural, conditional logic with the help of inbuilt JavaScript runtime capabilities.",
      "pos": [
        43252,
        43502
      ]
    },
    {
      "content": "DocumentDB SQL provides the arguments to the UDFs for each document in the source at the current stage (WHERE clause or SELECT clause) of processing the UDF.",
      "pos": [
        43504,
        43661
      ]
    },
    {
      "content": "The result is incorporated in the overall execution pipeline seamlessly.",
      "pos": [
        43662,
        43734
      ]
    },
    {
      "content": "If the properties referred to by the UDF parameters are not available in the JSON value, the parameter is considered as undefined and hence the UDF invocation is entirely skipped.",
      "pos": [
        43735,
        43914
      ]
    },
    {
      "content": "Similarly if the result of the UDF is undefined, it's not included in the result.",
      "pos": [
        43915,
        43996
      ]
    },
    {
      "content": "In summary, UDFs are great tools to do complex business logic as part of the query.",
      "pos": [
        43999,
        44082
      ]
    },
    {
      "content": "Operator evaluation",
      "pos": [
        44088,
        44107
      ]
    },
    {
      "content": "DocumentDB, by the virtue of being a JSON database, draws parallels with JavaScript operators and its evaluation semantics.",
      "pos": [
        44108,
        44231
      ]
    },
    {
      "content": "While DocumentDB tries to preserve JavaScript semantics in terms of JSON support, the operation evaluation deviates in some instances.",
      "pos": [
        44232,
        44366
      ]
    },
    {
      "content": "In DocumentDB SQL, unlike in traditional SQL, the types of values are often not known until the values are actually retrieved from database.",
      "pos": [
        44368,
        44508
      ]
    },
    {
      "content": "In order to efficiently execute queries, most of the operators have strict type requirements.",
      "pos": [
        44509,
        44602
      ]
    },
    {
      "content": "DocumentDB SQL doesn't perform implicit conversions, unlike JavaScript.",
      "pos": [
        44605,
        44676
      ]
    },
    {
      "content": "For instance, a query like <ph id=\"ph1\">`SELECT * FROM Person p WHERE p.Age = 21`</ph> matches documents which contain an Age property whose value is 21.",
      "pos": [
        44677,
        44812
      ]
    },
    {
      "content": "Any other document whose Age property matches string \"21\", or",
      "pos": [
        44813,
        44874
      ]
    },
    {
      "content": "other possibly infinite variations like \"021\", \"21.0\", \"0021\", \"00021\", etc. will not be matched.",
      "pos": [
        44875,
        44972
      ]
    },
    {
      "content": "This is in contrast to the JavaScript where the string values are implicitly casted to numbers (based on operator, ex: ==).",
      "pos": [
        44974,
        45097
      ]
    },
    {
      "content": "This choice is crucial for efficient index matching in DocumentDB SQL.",
      "pos": [
        45098,
        45168
      ]
    },
    {
      "content": "Parameterized SQL",
      "pos": [
        45174,
        45191
      ]
    },
    {
      "content": "DocumentDB supports queries with parameters expressed with the familiar @ notation.",
      "pos": [
        45192,
        45275
      ]
    },
    {
      "content": "Parameterized SQL provides robust handling and escaping of user input, preventing accidental exposure of data through SQL injection.",
      "pos": [
        45276,
        45408
      ]
    },
    {
      "content": "For example, you can write a query that takes last name and address state as parameters, and then execute it for various values of last name and address state based on user input.",
      "pos": [
        45411,
        45590
      ]
    },
    {
      "content": "This request can then be sent to DocumentDB as a parameterized JSON query like shown below.",
      "pos": [
        45696,
        45787
      ]
    },
    {
      "content": "Parameter values can be any valid JSON (strings, numbers, Booleans, null, even arrays or nested JSON).",
      "pos": [
        46099,
        46201
      ]
    },
    {
      "content": "Also since DocumentDB is schema-less, parameters are not validated against any type.",
      "pos": [
        46202,
        46286
      ]
    },
    {
      "content": "Built-in functions",
      "pos": [
        46290,
        46308
      ]
    },
    {
      "content": "DocumentDB also supports a number of built-in functions for common operations, that can be used inside queries like user defined functions (UDFs).",
      "pos": [
        46309,
        46455
      ]
    },
    {
      "content": "Mathematical functions",
      "pos": [
        46474,
        46496
      ]
    },
    {
      "content": "ABS, CEILING, EXP, FLOOR, LOG, LOG10, POWER, ROUND, SIGN, SQRT, SQUARE, TRUNC, ACOS, ASIN, ATAN, ATN2, COS, COT, DEGREES, PI, RADIANS, SIN, and TAN",
      "pos": [
        46507,
        46654
      ]
    },
    {
      "content": "Type checking functions",
      "pos": [
        46675,
        46698
      ]
    },
    {
      "content": "IS_ARRAY, IS_BOOL, IS_NULL, IS_NUMBER, IS_OBJECT, IS_STRING, IS_DEFINED, and IS_PRIMITIVE",
      "pos": [
        46712,
        46801
      ]
    },
    {
      "content": "String functions",
      "pos": [
        46822,
        46838
      ]
    },
    {
      "content": "CONCAT, CONTAINS, ENDSWITH, INDEX_OF, LEFT, LENGTH, LOWER, LTRIM, REPLACE, REPLICATE, REVERSE, RIGHT, RTRIM, STARTSWITH, SUBSTRING, and UPPER",
      "pos": [
        46851,
        46992
      ]
    },
    {
      "content": "Array functions",
      "pos": [
        47013,
        47028
      ]
    },
    {
      "content": "ARRAY_CONCAT, ARRAY_CONTAINS, ARRAY_LENGTH, and ARRAY_SLICE",
      "pos": [
        47042,
        47101
      ]
    },
    {
      "content": "Spatial functions",
      "pos": [
        47122,
        47139
      ]
    },
    {
      "content": "ST_DISTANCE, ST_WITHIN, ST_ISVALID, and ST_ISVALIDDETAILED",
      "pos": [
        47151,
        47209
      ]
    },
    {
      "content": "If you’re currently using a user defined function (UDF) for which a built-in function is now available, you should use the corresponding built-in function as it is going to be quicker to run and more efficiently.",
      "pos": [
        47233,
        47445
      ]
    },
    {
      "content": "Mathematical functions",
      "pos": [
        47452,
        47474
      ]
    },
    {
      "content": "The mathematical functions each perform a calculation, usually based on input values that are provided as arguments, and return a numeric value.",
      "pos": [
        47475,
        47619
      ]
    },
    {
      "content": "Here’s a table of supported built-in mathematical functions.",
      "pos": [
        47620,
        47680
      ]
    },
    {
      "content": "Usage",
      "pos": [
        47707,
        47712
      ]
    },
    {
      "content": "Description",
      "pos": [
        47739,
        47750
      ]
    },
    {
      "content": "ABS (num_expr)",
      "pos": [
        47852,
        47866
      ]
    },
    {
      "content": "Returns the absolute (positive) value of the specified numeric expression.",
      "pos": [
        47881,
        47955
      ]
    },
    {
      "content": "CEILING (num_expr)",
      "pos": [
        48052,
        48070
      ]
    },
    {
      "content": "Returns the smallest integer value greater than, or equal to, the specified numeric expression.",
      "pos": [
        48085,
        48180
      ]
    },
    {
      "content": "FLOOR (num_expr)",
      "pos": [
        48275,
        48291
      ]
    },
    {
      "content": "Returns the largest integer less than or equal to the specified numeric expression.",
      "pos": [
        48306,
        48389
      ]
    },
    {
      "content": "EXP (num_expr)",
      "pos": [
        48482,
        48496
      ]
    },
    {
      "content": "Returns the exponent of the specified numeric expression.",
      "pos": [
        48511,
        48568
      ]
    },
    {
      "content": "LOG (num_expr [,base])",
      "pos": [
        48661,
        48683
      ]
    },
    {
      "content": "Returns the natural logarithm of the specified numeric expression, or the logarithm using the specified base",
      "pos": [
        48698,
        48806
      ]
    },
    {
      "content": "LOG10 (num_expr)",
      "pos": [
        48901,
        48917
      ]
    },
    {
      "content": "Returns the base-10 logarithmic value of the specified numeric expression.",
      "pos": [
        48932,
        49006
      ]
    },
    {
      "content": "ROUND (num_expr)",
      "pos": [
        49101,
        49117
      ]
    },
    {
      "content": "Returns a numeric value, rounded to the closest integer value.",
      "pos": [
        49132,
        49194
      ]
    },
    {
      "content": "TRUNC (num_expr)",
      "pos": [
        49289,
        49305
      ]
    },
    {
      "content": "Returns a numeric value, truncated to the closest integer value.",
      "pos": [
        49320,
        49384
      ]
    },
    {
      "content": "SQRT (num_expr)",
      "pos": [
        49478,
        49493
      ]
    },
    {
      "content": "Returns the square root of the specified numeric expression.",
      "pos": [
        49510,
        49570
      ]
    },
    {
      "content": "SQUARE (num_expr)",
      "pos": [
        49666,
        49683
      ]
    },
    {
      "content": "Returns the square of the specified numeric expression.",
      "pos": [
        49700,
        49755
      ]
    },
    {
      "content": "POWER (num_expr, num_expr)",
      "pos": [
        49850,
        49876
      ]
    },
    {
      "content": "Returns the power of the specified numeric expression to the value specifed.",
      "pos": [
        49893,
        49969
      ]
    },
    {
      "content": "SIGN (num_expr)",
      "pos": [
        50063,
        50078
      ]
    },
    {
      "content": "Returns the sign value (-1, 0, 1) of the specified numeric expression.",
      "pos": [
        50095,
        50165
      ]
    },
    {
      "content": "ACOS (num_expr)",
      "pos": [
        50264,
        50279
      ]
    },
    {
      "content": "Returns the angle, in radians, whose cosine is the specified numeric expression; also called arccosine.",
      "pos": [
        50296,
        50399
      ]
    },
    {
      "content": "ASIN (num_expr)",
      "pos": [
        50493,
        50508
      ]
    },
    {
      "content": "Returns the angle, in radians, whose sine is the specified numeric expression.",
      "pos": [
        50525,
        50603
      ]
    },
    {
      "content": "This is also called arcsine.",
      "pos": [
        50604,
        50632
      ]
    },
    {
      "content": "ATAN (num_expr)",
      "pos": [
        50726,
        50741
      ]
    },
    {
      "content": "Returns the angle, in radians, whose tangent is the specified numeric expression.",
      "pos": [
        50758,
        50839
      ]
    },
    {
      "content": "This is also called arctangent.",
      "pos": [
        50840,
        50871
      ]
    },
    {
      "content": "ATN2 (num_expr)",
      "pos": [
        50965,
        50980
      ]
    },
    {
      "content": "Returns the angle, in radians, between the positive x-axis and the ray from the origin to the point (y, x), where x and y are the values of the two specified float expressions.",
      "pos": [
        50997,
        51173
      ]
    },
    {
      "content": "COS (num_expr)",
      "pos": [
        51266,
        51280
      ]
    },
    {
      "content": "Returns the trigonometric cosine of the specified angle, in radians, in the specified expression.",
      "pos": [
        51295,
        51392
      ]
    },
    {
      "content": "COT (num_expr)",
      "pos": [
        51485,
        51499
      ]
    },
    {
      "content": "Returns the trigonometric cotangent of the specified angle, in radians, in the specified numeric expression.",
      "pos": [
        51514,
        51622
      ]
    },
    {
      "content": "DEGREES (num_expr)",
      "pos": [
        51719,
        51737
      ]
    },
    {
      "content": "Returns the corresponding angle in degrees for an angle specified in radians.",
      "pos": [
        51752,
        51829
      ]
    },
    {
      "content": "PI ()",
      "pos": [
        51921,
        51926
      ]
    },
    {
      "content": "Returns the constant value of PI.",
      "pos": [
        51943,
        51976
      ]
    },
    {
      "content": "RADIANS (num_expr)",
      "pos": [
        52073,
        52091
      ]
    },
    {
      "content": "Returns radians when a numeric expression, in degrees, is entered.",
      "pos": [
        52106,
        52172
      ]
    },
    {
      "content": "SIN (num_expr)",
      "pos": [
        52265,
        52279
      ]
    },
    {
      "content": "Returns the trigonometric sine of the specified angle, in radians, in the specified expression.",
      "pos": [
        52294,
        52389
      ]
    },
    {
      "content": "TAN (num_expr)",
      "pos": [
        52482,
        52496
      ]
    },
    {
      "content": "Returns the tangent of the input expression, in the specified expression.",
      "pos": [
        52511,
        52584
      ]
    },
    {
      "content": "For example, you can now run queries like the following:",
      "pos": [
        52608,
        52664
      ]
    },
    {
      "content": "Query",
      "pos": [
        52668,
        52673
      ]
    },
    {
      "content": "Results",
      "pos": [
        52705,
        52712
      ]
    },
    {
      "content": "The main difference between DocumentDB’s functions compared to ANSI SQL is that they are designed to work well with schema-less and mixed schema data.",
      "pos": [
        52725,
        52875
      ]
    },
    {
      "content": "For example, if you have a document where the Size property is missing, or has a non-numeric value like “unknown”, then the document is skipped over, instead of returning an error.",
      "pos": [
        52876,
        53056
      ]
    },
    {
      "content": "Type checking functions",
      "pos": [
        53062,
        53085
      ]
    },
    {
      "content": "The type checking functions allow you to check the type of an expression within SQL queries.",
      "pos": [
        53086,
        53178
      ]
    },
    {
      "content": "Type checking functions can be used to determine the type of properties within documents on the fly when it is variable or unknown.",
      "pos": [
        53179,
        53310
      ]
    },
    {
      "content": "Here’s a table of supported built-in type checking functions.",
      "pos": [
        53311,
        53372
      ]
    },
    {
      "content": "Usage",
      "pos": [
        53401,
        53406
      ]
    },
    {
      "content": "Description",
      "pos": [
        53435,
        53446
      ]
    },
    {
      "content": "IS_ARRAY (expr)",
      "pos": [
        53555,
        53570
      ]
    },
    {
      "content": "Returns a Boolean indicating if the type of the value is an array.",
      "pos": [
        53586,
        53652
      ]
    },
    {
      "content": "IS_BOOL (expr)",
      "pos": [
        53751,
        53765
      ]
    },
    {
      "content": "Returns a Boolean indicating if the type of the value is a Boolean.",
      "pos": [
        53781,
        53848
      ]
    },
    {
      "content": "IS_NULL (expr)",
      "pos": [
        53947,
        53961
      ]
    },
    {
      "content": "Returns a Boolean indicating if the type of the value is null.",
      "pos": [
        53977,
        54039
      ]
    },
    {
      "content": "IS_NUMBER (expr)",
      "pos": [
        54140,
        54156
      ]
    },
    {
      "content": "Returns a Boolean indicating if the type of the value is a number.",
      "pos": [
        54172,
        54238
      ]
    },
    {
      "content": "IS_OBJECT (expr)",
      "pos": [
        54339,
        54355
      ]
    },
    {
      "content": "Returns a Boolean indicating if the type of the value is a JSON object.",
      "pos": [
        54371,
        54442
      ]
    },
    {
      "content": "IS_STRING (expr)",
      "pos": [
        54543,
        54559
      ]
    },
    {
      "content": "Returns a Boolean indicating if the type of the value is a string.",
      "pos": [
        54575,
        54641
      ]
    },
    {
      "content": "IS_DEFINED (expr)",
      "pos": [
        54743,
        54760
      ]
    },
    {
      "content": "Returns a Boolean indicating if the property has been assigned a value.",
      "pos": [
        54776,
        54847
      ]
    },
    {
      "content": "IS_PRIMITIVE (expr)",
      "pos": [
        54951,
        54970
      ]
    },
    {
      "content": "Returns a Boolean indicating if the type of the value is a string, number, Boolean or null.",
      "pos": [
        54986,
        55077
      ]
    },
    {
      "content": "Using these functions, you can now run queries like the following:",
      "pos": [
        55100,
        55166
      ]
    },
    {
      "content": "Query",
      "pos": [
        55170,
        55175
      ]
    },
    {
      "content": "Results",
      "pos": [
        55213,
        55220
      ]
    },
    {
      "content": "String functions",
      "pos": [
        55240,
        55256
      ]
    },
    {
      "content": "The following scalar functions perform an operation on a string input value and return a string, numeric or Boolean value.",
      "pos": [
        55257,
        55379
      ]
    },
    {
      "content": "Here's a table of built-in string functions:",
      "pos": [
        55380,
        55424
      ]
    },
    {
      "content": "Usage",
      "pos": [
        55426,
        55431
      ]
    },
    {
      "content": "Description",
      "pos": [
        55432,
        55443
      ]
    },
    {
      "content": "LENGTH (str_expr)",
      "pos": [
        55453,
        55470
      ]
    },
    {
      "content": "Returns the number of characters of the specified string expression",
      "pos": [
        55538,
        55605
      ]
    },
    {
      "content": "CONCAT (str_expr, str_expr [, str_expr])",
      "pos": [
        55607,
        55647
      ]
    },
    {
      "content": "Returns a string that is the result of concatenating two or more string values.",
      "pos": [
        55715,
        55794
      ]
    },
    {
      "content": "SUBSTRING (str_expr, num_expr, num_expr)",
      "pos": [
        55796,
        55836
      ]
    },
    {
      "content": "Returns part of a string expression.",
      "pos": [
        55907,
        55943
      ]
    },
    {
      "content": "STARTSWITH (str_expr, str_expr)",
      "pos": [
        55945,
        55976
      ]
    },
    {
      "content": "Returns a Boolean indicating whether the first string expression ends with the second",
      "pos": [
        56048,
        56133
      ]
    },
    {
      "content": "ENDSWITH (str_expr, str_expr)",
      "pos": [
        56135,
        56164
      ]
    },
    {
      "content": "Returns a Boolean indicating whether the first string expression ends with the second",
      "pos": [
        56234,
        56319
      ]
    },
    {
      "content": "CONTAINS (str_expr, str_expr)",
      "pos": [
        56321,
        56350
      ]
    },
    {
      "content": "Returns a Boolean indicating whether the first string expression contains the second.",
      "pos": [
        56420,
        56505
      ]
    },
    {
      "content": "INDEX_OF (str_expr, str_expr)",
      "pos": [
        56507,
        56536
      ]
    },
    {
      "content": "Returns the starting position of the first occurrence of the second string expression within the first specified string expression, or -1 if the string is not found.",
      "pos": [
        56606,
        56771
      ]
    },
    {
      "content": "LEFT (str_expr, num_expr)",
      "pos": [
        56773,
        56798
      ]
    },
    {
      "content": "Returns the left part of a string with the specified number of characters.",
      "pos": [
        56864,
        56938
      ]
    },
    {
      "content": "RIGHT (str_expr, num_expr)",
      "pos": [
        56940,
        56966
      ]
    },
    {
      "content": "Returns the right part of a string with the specified number of characters.",
      "pos": [
        57033,
        57108
      ]
    },
    {
      "content": "LTRIM (str_expr)",
      "pos": [
        57110,
        57126
      ]
    },
    {
      "content": "Returns a string expression after it removes leading blanks.",
      "pos": [
        57193,
        57253
      ]
    },
    {
      "content": "RTRIM (str_expr)",
      "pos": [
        57255,
        57271
      ]
    },
    {
      "content": "Returns a string expression after truncating all trailing blanks.",
      "pos": [
        57338,
        57403
      ]
    },
    {
      "content": "LOWER (str_expr)",
      "pos": [
        57405,
        57421
      ]
    },
    {
      "content": "Returns a string expression after converting uppercase character data to lowercase.",
      "pos": [
        57488,
        57571
      ]
    },
    {
      "content": "UPPER (str_expr)",
      "pos": [
        57573,
        57589
      ]
    },
    {
      "content": "Returns a string expression after converting lowercase character data to uppercase.",
      "pos": [
        57656,
        57739
      ]
    },
    {
      "content": "REPLACE (str_expr, str_expr, str_expr)",
      "pos": [
        57741,
        57779
      ]
    },
    {
      "content": "Replaces all occurrences of a specified string value with another string value.",
      "pos": [
        57848,
        57927
      ]
    },
    {
      "content": "REPLICATE (str_expr, num_expr)",
      "pos": [
        57929,
        57959
      ]
    },
    {
      "content": "Repeats a string value a specified number of times.",
      "pos": [
        58030,
        58081
      ]
    },
    {
      "content": "REVERSE (str_expr)",
      "pos": [
        58083,
        58101
      ]
    },
    {
      "content": "Returns the reverse order of a string value.",
      "pos": [
        58170,
        58214
      ]
    },
    {
      "content": "Using these functions, you can now run queries like the following.",
      "pos": [
        58216,
        58282
      ]
    },
    {
      "content": "For example, you can return the family name in uppercase as follows:",
      "pos": [
        58283,
        58351
      ]
    },
    {
      "content": "Query",
      "pos": [
        58355,
        58360
      ]
    },
    {
      "content": "Results",
      "pos": [
        58421,
        58428
      ]
    },
    {
      "content": "Or concatenate strings like in this example:",
      "pos": [
        58498,
        58542
      ]
    },
    {
      "content": "Query",
      "pos": [
        58546,
        58551
      ]
    },
    {
      "content": "Results",
      "pos": [
        58671,
        58678
      ]
    },
    {
      "content": "String functions can also be used in the WHERE clause to filter results, like in the following example:",
      "pos": [
        58829,
        58932
      ]
    },
    {
      "content": "Query",
      "pos": [
        58936,
        58941
      ]
    },
    {
      "content": "Results",
      "pos": [
        59059,
        59066
      ]
    },
    {
      "content": "Array functions",
      "pos": [
        59139,
        59154
      ]
    },
    {
      "content": "The following scalar functions perform an operation on an array input value and return numeric, Boolean or array value.",
      "pos": [
        59155,
        59274
      ]
    },
    {
      "content": "Here's a table of built-in array functions:",
      "pos": [
        59275,
        59318
      ]
    },
    {
      "content": "Usage",
      "pos": [
        59320,
        59325
      ]
    },
    {
      "content": "Description",
      "pos": [
        59326,
        59337
      ]
    },
    {
      "content": "ARRAY_LENGTH (arr_expr)",
      "pos": [
        59347,
        59370
      ]
    },
    {
      "content": "Returns the number of elements of the specified array expression.",
      "pos": [
        59444,
        59509
      ]
    },
    {
      "content": "ARRAY_CONCAT (arr_expr, arr_expr [, arr_expr])",
      "pos": [
        59511,
        59557
      ]
    },
    {
      "content": "Returns an array that is the result of concatenating two or more array values.",
      "pos": [
        59631,
        59709
      ]
    },
    {
      "content": "ARRAY_CONTAINS (arr_expr, expr)",
      "pos": [
        59711,
        59742
      ]
    },
    {
      "content": "Returns a Boolean indicating whether the array contains the specified value.",
      "pos": [
        59818,
        59894
      ]
    },
    {
      "content": "ARRAY_SLICE (arr_expr, num_expr [, num_expr])",
      "pos": [
        59896,
        59941
      ]
    },
    {
      "content": "Returns part of an array expression.",
      "pos": [
        60014,
        60050
      ]
    },
    {
      "content": "Array functions can be used to manipulate arrays within JSON.",
      "pos": [
        60052,
        60113
      ]
    },
    {
      "content": "For example, here's a query that returns all documents where one of the parents is \"Robin Wakefield\".",
      "pos": [
        60114,
        60215
      ]
    },
    {
      "content": "Query",
      "pos": [
        60220,
        60225
      ]
    },
    {
      "content": "Results",
      "pos": [
        60367,
        60374
      ]
    },
    {
      "content": "Here's another example that uses ARRAY_LENGTH to get the number of children per family.",
      "pos": [
        60423,
        60510
      ]
    },
    {
      "content": "Query",
      "pos": [
        60514,
        60519
      ]
    },
    {
      "content": "Results",
      "pos": [
        60621,
        60628
      ]
    },
    {
      "content": "That wraps up built-in functions, and the SQL grammar for DocumentDB.",
      "pos": [
        60777,
        60846
      ]
    },
    {
      "content": "Now let's take a look at how LINQ querying works and how it interacts with the grammar we've seen so far.",
      "pos": [
        60847,
        60952
      ]
    },
    {
      "content": "Spatial functions",
      "pos": [
        60958,
        60975
      ]
    },
    {
      "content": "DocumentDB supports the following Open Geospatial Consortium (OGC) built-in functions for geospatial querying.",
      "pos": [
        60977,
        61087
      ]
    },
    {
      "content": "For more details on geospatial support in DocumentDB, please see <bpt id=\"p1\">[</bpt>Working with geospatial data in Azure DocumentDB<ept id=\"p1\">](documentdb-geospatial.md)</ept>.",
      "pos": [
        61088,
        61230
      ]
    },
    {
      "content": "Usage",
      "pos": [
        61260,
        61265
      ]
    },
    {
      "content": "Description",
      "pos": [
        61294,
        61305
      ]
    },
    {
      "content": "ST_DISTANCE (point_expr, point_expr)",
      "pos": [
        61337,
        61373
      ]
    },
    {
      "content": "Returns the distance between the two GeoJSON point expressions.",
      "pos": [
        61385,
        61448
      ]
    },
    {
      "content": "ST_WITHIN (point_expr, polygon_expr)",
      "pos": [
        61471,
        61507
      ]
    },
    {
      "content": "Returns a Boolean expression indicating whether the GeoJSON point specified in the first argument is within the GeoJSON polygon in the second argument.",
      "pos": [
        61519,
        61670
      ]
    },
    {
      "content": "ST_ISVALID",
      "pos": [
        61693,
        61703
      ]
    },
    {
      "content": "Returns a Boolean value indicating whether the specified GeoJSON point or polygon expression is valid.",
      "pos": [
        61715,
        61817
      ]
    },
    {
      "content": "ST_ISVALIDDETAILED",
      "pos": [
        61840,
        61858
      ]
    },
    {
      "content": "Returns a JSON value containing a Boolean value if the specified GeoJSON point or polygon expression is valid, and if invalid, additionally the reason as a string value.",
      "pos": [
        61870,
        62039
      ]
    },
    {
      "content": "Spatial functions can be used to perform proximity querries against spatial data.",
      "pos": [
        62061,
        62142
      ]
    },
    {
      "content": "For example, here's a query that returns all family documents that are within 30 km of the specified location using the ST_DISTANCE built-in function.",
      "pos": [
        62143,
        62293
      ]
    },
    {
      "content": "Query",
      "pos": [
        62298,
        62303
      ]
    },
    {
      "content": "Results",
      "pos": [
        62437,
        62444
      ]
    },
    {
      "content": "If you include spatial indexing in your indexing policy, then \"distance queries\" will be served efficiently through the index.",
      "pos": [
        62493,
        62619
      ]
    },
    {
      "content": "For more details on spatial indexing, please see the section below.",
      "pos": [
        62620,
        62687
      ]
    },
    {
      "content": "If you don't have a spatial index for the specified paths, you can still perform spatial queries by specifying <ph id=\"ph1\">`x-ms-documentdb-query-enable-scan`</ph> request header with the value set to \"true\".",
      "pos": [
        62688,
        62879
      ]
    },
    {
      "content": "In .NET, this can be done by passing the optional <bpt id=\"p1\">**</bpt>FeedOptions<ept id=\"p1\">**</ept> argument to queries with <bpt id=\"p2\">[</bpt>EnableScanInQuery<ept id=\"p2\">](https://msdn.microsoft.com/library/microsoft.azure.documents.client.feedoptions.enablescaninquery.aspx#P:Microsoft.Azure.Documents.Client.FeedOptions.EnableScanInQuery)</ept> set to true.",
      "pos": [
        62880,
        63172
      ]
    },
    {
      "content": "ST_WITHIN can be used to check if a point lies within a polygon.",
      "pos": [
        63175,
        63239
      ]
    },
    {
      "content": "Commonly polygons are used to represent boundaries like zip codes, state boundaries, or natural formations.",
      "pos": [
        63240,
        63347
      ]
    },
    {
      "content": "Again if you include spatial indexing in your indexing policy, then \"within\" queries will be served efficiently through the index.",
      "pos": [
        63348,
        63478
      ]
    },
    {
      "content": "Polygon arguments in ST_WITHIN can contain only a single ring, i.e. the polygons must not contain holes in them.",
      "pos": [
        63481,
        63593
      ]
    },
    {
      "content": "Check the <bpt id=\"p1\">[</bpt>DocumentDB limits<ept id=\"p1\">](documentdb-limits.md)</ept> for the maximum number of points allowed in a polygon for an ST_WITHIN query.",
      "pos": [
        63594,
        63723
      ]
    },
    {
      "content": "Query",
      "pos": [
        63727,
        63732
      ]
    },
    {
      "content": "Results",
      "pos": [
        63928,
        63935
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> Similar to how mismatched types works in DocumentDB query, if the location value specified in either argument is malformed or invalid, then it will evaluate to <bpt id=\"p1\">**</bpt>undefined<ept id=\"p1\">**</ept> and the evaluated document to be skipped from the query results.",
      "pos": [
        63990,
        64241
      ]
    },
    {
      "content": "If your query returns no results, run ST_ISVALIDDETAILED To debug why the spatail type is invalid.",
      "pos": [
        64242,
        64340
      ]
    },
    {
      "content": "ST_ISVALID and ST_ISVALIDDETAILED can be used to check if a spatial object is valid.",
      "pos": [
        64347,
        64431
      ]
    },
    {
      "content": "For example, the following query checks the validity of a point with an out of range latitude value (-132.8).",
      "pos": [
        64432,
        64541
      ]
    },
    {
      "content": "ST_ISVALID returns just a Boolean value, and ST_ISVALIDDETAILED returns the Boolean and a string containing the reason why it is considered invalid.",
      "pos": [
        64542,
        64690
      ]
    },
    {
      "content": "Query",
      "pos": [
        64694,
        64699
      ]
    },
    {
      "content": "Results",
      "pos": [
        64780,
        64787
      ]
    },
    {
      "content": "These functions can also be used to validate polygons.",
      "pos": [
        64824,
        64878
      ]
    },
    {
      "content": "For example, here we use ST_ISVALIDDETAILED to validate a polygon that is not closed.",
      "pos": [
        64879,
        64964
      ]
    },
    {
      "content": "Query",
      "pos": [
        64969,
        64974
      ]
    },
    {
      "content": "Results",
      "pos": [
        65128,
        65135
      ]
    },
    {
      "content": "That wraps up built-in functions, and the SQL grammar for DocumentDB.",
      "pos": [
        65401,
        65470
      ]
    },
    {
      "content": "Now let's take a look at how LINQ querying works and how it interacts with the grammar we've seen so far.",
      "pos": [
        65471,
        65576
      ]
    },
    {
      "content": "LINQ to DocumentDB SQL",
      "pos": [
        65581,
        65603
      ]
    },
    {
      "content": "LINQ is a .NET programming model that expresses computation as queries on streams of objects.",
      "pos": [
        65604,
        65697
      ]
    },
    {
      "content": "DocumentDB provides a client side library to interface with LINQ by facilitating a conversion between JSON and .NET objects and a mapping from a subset of LINQ queries to DocumentDB queries.",
      "pos": [
        65698,
        65888
      ]
    },
    {
      "content": "The picture below shows the architecture of supporting LINQ queries using DocumentDB.",
      "pos": [
        65891,
        65976
      ]
    },
    {
      "content": "Using the DocumentDB client, developers can create an <bpt id=\"p1\">**</bpt>IQueryable<ept id=\"p1\">**</ept> object that directly queries the DocumentDB query provider, which then translates the LINQ query into a DocumentDB query.",
      "pos": [
        65978,
        66168
      ]
    },
    {
      "content": "The query is then passed to the DocumentDB server to retrieve a set of results in JSON format.",
      "pos": [
        66169,
        66263
      ]
    },
    {
      "content": "The returned results are deserialized into a stream of .NET objects on the client side.",
      "pos": [
        66264,
        66351
      ]
    },
    {
      "content": ".NET and JSON mapping",
      "pos": [
        66368,
        66389
      ]
    },
    {
      "content": "The mapping between .NET objects and JSON documents is natural - each data member field is mapped to a JSON object, where the field name is mapped to the \"key\" part of the object and the \"value\" part is recursively mapped to the value part of the object.",
      "pos": [
        66390,
        66644
      ]
    },
    {
      "content": "Consider the following example.",
      "pos": [
        66645,
        66676
      ]
    },
    {
      "content": "The Family object created is mapped to the JSON document as shown below.",
      "pos": [
        66677,
        66749
      ]
    },
    {
      "content": "And vice versa, the JSON document is mapped back to a .NET object.",
      "pos": [
        66750,
        66816
      ]
    },
    {
      "content": "C# Class",
      "pos": [
        66820,
        66828
      ]
    },
    {
      "content": "JSON",
      "pos": [
        68132,
        68136
      ]
    },
    {
      "content": "LINQ to SQL translation",
      "pos": [
        68965,
        68988
      ]
    },
    {
      "content": "The DocumentDB query provider performs a best effort mapping from a LINQ query into a DocumentDB SQL query.",
      "pos": [
        68989,
        69096
      ]
    },
    {
      "content": "In the following description, we assume the reader has a basic familiarity of LINQ.",
      "pos": [
        69097,
        69180
      ]
    },
    {
      "content": "First, for the type system, we support all JSON primitive types – numeric types, boolean, string, and null.",
      "pos": [
        69182,
        69289
      ]
    },
    {
      "content": "Only these JSON types are supported.",
      "pos": [
        69290,
        69326
      ]
    },
    {
      "content": "The following scalar expressions are supported.",
      "pos": [
        69327,
        69374
      ]
    },
    {
      "content": "Constant values – these includes constant values of the primitive data types at the time the query is evaluated.",
      "pos": [
        69380,
        69492
      ]
    },
    {
      "content": "Property/array index expressions – these expressions refer to the property of an object or an array element.",
      "pos": [
        69498,
        69606
      ]
    },
    {
      "content": "Arithmetic expressions - These include common arithmetic expressions on numerical and boolean values.",
      "pos": [
        69762,
        69863
      ]
    },
    {
      "content": "For the complete list, refer to the SQL specification.",
      "pos": [
        69864,
        69918
      ]
    },
    {
      "content": "String comparison expression - these include comparing a string value to some constant string value.",
      "pos": [
        69978,
        70078
      ]
    },
    {
      "content": "Object/array creation expression - these expressions return an object of compound value type or anonymous type or an array of such objects.",
      "pos": [
        70181,
        70320
      ]
    },
    {
      "content": "These values can be nested.",
      "pos": [
        70321,
        70348
      ]
    },
    {
      "content": "Query operators",
      "pos": [
        70547,
        70562
      ]
    },
    {
      "content": "Here are some examples that illustrate how some of the standard LINQ query operators are translated down to DocumentDB queries.",
      "pos": [
        70563,
        70690
      ]
    },
    {
      "content": "Select Operator",
      "pos": [
        70697,
        70712
      ]
    },
    {
      "pos": [
        70713,
        70787
      ],
      "content": "The syntax is <ph id=\"ph1\">`input.Select(x =&gt; f(x))`</ph>, where <ph id=\"ph2\">`f`</ph> is a scalar expression."
    },
    {
      "content": "LINQ lambda expression",
      "pos": [
        70791,
        70813
      ]
    },
    {
      "content": "SQL",
      "pos": [
        70878,
        70881
      ]
    },
    {
      "content": "LINQ lambda expression",
      "pos": [
        70952,
        70974
      ]
    },
    {
      "content": "SQL",
      "pos": [
        71064,
        71067
      ]
    },
    {
      "content": "LINQ lambda expression",
      "pos": [
        71139,
        71161
      ]
    },
    {
      "content": "SQL",
      "pos": [
        71305,
        71308
      ]
    },
    {
      "content": "SelectMany operator",
      "pos": [
        71446,
        71465
      ]
    },
    {
      "pos": [
        71466,
        71575
      ],
      "content": "The syntax is <ph id=\"ph1\">`input.SelectMany(x =&gt; f(x))`</ph>, where <ph id=\"ph2\">`f`</ph> is a scalar expression that returns a collection type."
    },
    {
      "content": "LINQ lambda expression",
      "pos": [
        71579,
        71601
      ]
    },
    {
      "content": "SQL",
      "pos": [
        71657,
        71660
      ]
    },
    {
      "content": "Where operator",
      "pos": [
        71732,
        71746
      ]
    },
    {
      "pos": [
        71747,
        71850
      ],
      "content": "The syntax is <ph id=\"ph1\">`input.Where(x =&gt; f(x))`</ph>, where <ph id=\"ph2\">`f`</ph> is a scalar expression which returns a Boolean value."
    },
    {
      "content": "LINQ lambda expression",
      "pos": [
        71854,
        71876
      ]
    },
    {
      "content": "SQL",
      "pos": [
        71950,
        71953
      ]
    },
    {
      "content": "LINQ lambda expression",
      "pos": [
        72041,
        72063
      ]
    },
    {
      "content": "SQL",
      "pos": [
        72188,
        72191
      ]
    },
    {
      "content": "Composite queries",
      "pos": [
        72311,
        72328
      ]
    },
    {
      "content": "The above operators can be composed to form more powerful queries.",
      "pos": [
        72329,
        72395
      ]
    },
    {
      "content": "Since DocumentDB supports nested collections, the composition can either be concatenated or nested.",
      "pos": [
        72396,
        72495
      ]
    },
    {
      "content": "Concatenation",
      "pos": [
        72502,
        72515
      ]
    },
    {
      "content": "The syntax is <ph id=\"ph1\">`input(.|.SelectMany())(.Select()|.Where())*`</ph>.",
      "pos": [
        72518,
        72578
      ]
    },
    {
      "content": "A concatenated query can start with an optional <ph id=\"ph1\">`SelectMany`</ph> query followed by multiple <ph id=\"ph2\">`Select`</ph> or <ph id=\"ph3\">`Where`</ph> operators.",
      "pos": [
        72579,
        72697
      ]
    },
    {
      "content": "LINQ lambda expression",
      "pos": [
        72702,
        72724
      ]
    },
    {
      "content": "SQL",
      "pos": [
        72814,
        72817
      ]
    },
    {
      "content": "LINQ lambda expression",
      "pos": [
        72903,
        72925
      ]
    },
    {
      "content": "SQL",
      "pos": [
        73045,
        73048
      ]
    },
    {
      "content": "LINQ lambda expression",
      "pos": [
        73153,
        73175
      ]
    },
    {
      "content": "SQL",
      "pos": [
        73299,
        73302
      ]
    },
    {
      "content": "LINQ lambda expression",
      "pos": [
        73396,
        73418
      ]
    },
    {
      "content": "SQL",
      "pos": [
        73529,
        73532
      ]
    },
    {
      "content": "Nesting",
      "pos": [
        73622,
        73629
      ]
    },
    {
      "pos": [
        73631,
        73731
      ],
      "content": "The syntax is <ph id=\"ph1\">`input.SelectMany(x=&gt;x.Q())`</ph> where Q is a <ph id=\"ph2\">`Select`</ph>, <ph id=\"ph3\">`SelectMany`</ph>, or <ph id=\"ph4\">`Where`</ph> operator."
    },
    {
      "content": "In a nested query, the inner query is applied to each element of the outer collection.",
      "pos": [
        73733,
        73819
      ]
    },
    {
      "content": "One important feature is that the inner query can refer to the fields of the elements in the outer collection like self-joins.",
      "pos": [
        73820,
        73946
      ]
    },
    {
      "content": "LINQ lambda expression",
      "pos": [
        73950,
        73972
      ]
    },
    {
      "content": "SQL",
      "pos": [
        74061,
        74064
      ]
    },
    {
      "content": "LINQ lambda expression",
      "pos": [
        74147,
        74169
      ]
    },
    {
      "content": "SQL",
      "pos": [
        74289,
        74292
      ]
    },
    {
      "content": "LINQ lambda expression",
      "pos": [
        74392,
        74414
      ]
    },
    {
      "content": "SQL",
      "pos": [
        74556,
        74559
      ]
    },
    {
      "content": "Executing queries",
      "pos": [
        74676,
        74693
      ]
    },
    {
      "content": "DocumentDB exposes resources through a REST API that can be called by any language capable of making HTTP/HTTPS requests.",
      "pos": [
        74694,
        74815
      ]
    },
    {
      "content": "Additionally, DocumentDB offers programming libraries for several popular languages like .NET, Node.js, JavaScript and Python.",
      "pos": [
        74816,
        74942
      ]
    },
    {
      "content": "The REST API and the various libraries all support querying through SQL.",
      "pos": [
        74943,
        75015
      ]
    },
    {
      "content": "The .NET SDK supports LINQ querying in addition to SQL.",
      "pos": [
        75016,
        75071
      ]
    },
    {
      "content": "The following examples show how to create a query and submit it against a DocumentDB database account.",
      "pos": [
        75073,
        75175
      ]
    },
    {
      "content": "REST API",
      "pos": [
        75181,
        75189
      ]
    },
    {
      "content": "DocumentDB offers an open RESTful programming model over HTTP.",
      "pos": [
        75190,
        75252
      ]
    },
    {
      "content": "Database accounts can be provisioned using an Azure subscription.",
      "pos": [
        75253,
        75318
      ]
    },
    {
      "content": "The DocumentDB resource model consists of a sets of resources under a database account, each  of which is addressable using a logical and stable URI.",
      "pos": [
        75319,
        75468
      ]
    },
    {
      "content": "A set of resources is referred to as a feed in this document.",
      "pos": [
        75469,
        75530
      ]
    },
    {
      "content": "A database account consists of a set of databases, each containing multiple collections, each of which in-turn contain documents, UDFs, and other resource types.",
      "pos": [
        75531,
        75692
      ]
    },
    {
      "content": "The basic interaction model with these resources is through the HTTP verbs GET, PUT, POST and DELETE with their standard interpretation.",
      "pos": [
        75694,
        75830
      ]
    },
    {
      "content": "The POST verb is used for creation of a new resource, for executing a stored procedure or for issuing a DocumentDB query.",
      "pos": [
        75831,
        75952
      ]
    },
    {
      "content": "Queries are always read only operations with no side-effects.",
      "pos": [
        75953,
        76014
      ]
    },
    {
      "content": "The following examples show a POST for a DocumentDB query made against a collection containing the two sample documents we've reviewed so far.",
      "pos": [
        76016,
        76158
      ]
    },
    {
      "content": "The query has a simple filter on the JSON name property.",
      "pos": [
        76159,
        76215
      ]
    },
    {
      "content": "Note the use of the <ph id=\"ph1\">`x-ms-documentdb-isquery`</ph> and Content-Type: <ph id=\"ph2\">`application/query+json`</ph> headers to denote that the operation is a query.",
      "pos": [
        76216,
        76353
      ]
    },
    {
      "content": "Request",
      "pos": [
        76358,
        76365
      ]
    },
    {
      "content": "Results",
      "pos": [
        76709,
        76716
      ]
    },
    {
      "content": "The second example shows a more complex query that returns multiple results from the join.",
      "pos": [
        78076,
        78166
      ]
    },
    {
      "content": "Request",
      "pos": [
        78170,
        78177
      ]
    },
    {
      "content": "Results",
      "pos": [
        78695,
        78702
      ]
    },
    {
      "content": "If a query's results cannot fit within a single page of results, then the REST API returns a continuation token through the <ph id=\"ph1\">`x-ms-continuation-token`</ph> response header.",
      "pos": [
        79434,
        79600
      ]
    },
    {
      "content": "Clients can paginate results by including the header in subsequent results.",
      "pos": [
        79601,
        79676
      ]
    },
    {
      "content": "The number of results per page can also be controlled through the <ph id=\"ph1\">`x-ms-max-item-count`</ph> number header.",
      "pos": [
        79677,
        79779
      ]
    },
    {
      "content": "To manage the data consistency policy for queries, use the <ph id=\"ph1\">`x-ms-consistency-level`</ph> header like all REST API requests.",
      "pos": [
        79781,
        79899
      ]
    },
    {
      "content": "For session consistency, it is required to also echo the latest <ph id=\"ph1\">`x-ms-session-token`</ph> Cookie header in the query request.",
      "pos": [
        79900,
        80020
      ]
    },
    {
      "content": "Note that the queried collection's indexing policy can also influence the consistency of query results.",
      "pos": [
        80021,
        80124
      ]
    },
    {
      "content": "With the default indexing policy settings, for collections the index is always current with the document contents and query results will match the consistency chosen for data.",
      "pos": [
        80125,
        80300
      ]
    },
    {
      "content": "If the indexing policy is relaxed to Lazy, then queries can return stale results.",
      "pos": [
        80301,
        80382
      ]
    },
    {
      "content": "For more information, refer to <bpt id=\"p1\">[</bpt>DocumentDB Consistency Levels<ept id=\"p1\">] [consistency-levels]</ept>.",
      "pos": [
        80383,
        80467
      ]
    },
    {
      "content": "If the configured indexing policy on the collection cannot support the specified query, the DocumentDB server returns 400 \"Bad Request\".",
      "pos": [
        80469,
        80605
      ]
    },
    {
      "content": "This is returned for range queries against paths configured for hash (equality) lookups, and for paths explicitly excluded from indexing.",
      "pos": [
        80606,
        80743
      ]
    },
    {
      "content": "The <ph id=\"ph1\">`x-ms-documentdb-query-enable-scan`</ph> header can be specified to allow the query to perform a scan when an index is not available.",
      "pos": [
        80744,
        80876
      ]
    },
    {
      "content": "C# (.NET) SDK",
      "pos": [
        80882,
        80895
      ]
    },
    {
      "content": "The .NET SDK supports both LINQ and SQL querying.",
      "pos": [
        80896,
        80945
      ]
    },
    {
      "content": "The following example shows how to perform the simple filter query introduced earlier in this document.",
      "pos": [
        80946,
        81049
      ]
    },
    {
      "content": "This sample compares two properties for equality within each document and uses anonymous projections.",
      "pos": [
        82104,
        82205
      ]
    },
    {
      "content": "The next sample shows joins, expressed through LINQ SelectMany.",
      "pos": [
        83074,
        83137
      ]
    },
    {
      "content": "The .NET client automatically iterates through all the pages of query results in the foreach blocks as shown above.",
      "pos": [
        83766,
        83881
      ]
    },
    {
      "content": "The query options introduced in the REST API section are also available in the .NET SDK using the <ph id=\"ph1\">`FeedOptions`</ph> and <ph id=\"ph2\">`FeedResponse`</ph> classes in the CreateDocumentQuery method.",
      "pos": [
        83882,
        84055
      ]
    },
    {
      "content": "The number of pages can be controlled using the <ph id=\"ph1\">`MaxItemCount`</ph> setting.",
      "pos": [
        84056,
        84127
      ]
    },
    {
      "content": "Developers can also explicitly control paging by creating <ph id=\"ph1\">`IDocumentQueryable`</ph> using the <ph id=\"ph2\">`IQueryable`</ph> object, then by reading the<ph id=\"ph3\">` ResponseContinuationToken`</ph> values and passing them back as <ph id=\"ph4\">`RequestContinuationToken`</ph> in <ph id=\"ph5\">`FeedOptions`</ph>.",
      "pos": [
        84130,
        84364
      ]
    },
    {
      "content": "<ph id=\"ph1\">`EnableScanInQuery`</ph> can be set to enable scans when the query cannot be supported by the configured indexing policy.",
      "pos": [
        84365,
        84481
      ]
    },
    {
      "pos": [
        84483,
        84601
      ],
      "content": "Refer to <bpt id=\"p1\">[</bpt>DocumentDB .NET samples<ept id=\"p1\">](https://github.com/Azure/azure-documentdb-net)</ept> for more samples containing queries."
    },
    {
      "content": "JavaScript server-side API",
      "pos": [
        84608,
        84634
      ]
    },
    {
      "content": "DocumentDB provides a programming model for executing JavaScript based application logic directly on the collections using stored procedures and triggers.",
      "pos": [
        84636,
        84790
      ]
    },
    {
      "content": "The JavaScript logic registered at a collection level can then issue database operations on the operations on the documents of the given collection.",
      "pos": [
        84791,
        84939
      ]
    },
    {
      "content": "These operations are wrapped in ambient ACID transactions.",
      "pos": [
        84940,
        84998
      ]
    },
    {
      "content": "The following example show how to use the queryDocuments in the JavaScript server API to make queries from inside stored procedures and triggers.",
      "pos": [
        85000,
        85145
      ]
    },
    {
      "content": "References",
      "pos": [
        86576,
        86586
      ]
    },
    {
      "content": "Introduction to Azure DocumentDB",
      "pos": [
        86592,
        86624
      ]
    },
    {
      "content": "DocumentDB SQL specification",
      "pos": [
        86645,
        86673
      ]
    },
    {
      "content": "DocumentDB .NET samples",
      "pos": [
        86729,
        86752
      ]
    },
    {
      "content": "DocumentDB Consistency Levels",
      "pos": [
        86806,
        86835
      ]
    },
    {
      "pos": [
        86861,
        87049
      ],
      "content": "ANSI SQL 2011 <bpt id=\"p1\">[</bpt>http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=53681<ept id=\"p1\">](http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=53681)</ept>"
    },
    {
      "pos": [
        87054,
        87095
      ],
      "content": "JSON <bpt id=\"p1\">[</bpt>http://json.org/<ept id=\"p1\">](http://json.org/)</ept>"
    },
    {
      "pos": [
        87100,
        87267
      ],
      "content": "Javascript Specification <bpt id=\"p1\">[</bpt>http://www.ecma-international.org/publications/standards/Ecma-262.htm<ept id=\"p1\">](http://www.ecma-international.org/publications/standards/Ecma-262.htm)</ept>"
    },
    {
      "pos": [
        87273,
        87376
      ],
      "content": "LINQ <bpt id=\"p1\">[</bpt>http://msdn.microsoft.com/library/bb308959.aspx<ept id=\"p1\">](http://msdn.microsoft.com/library/bb308959.aspx)</ept>"
    },
    {
      "pos": [
        87382,
        87514
      ],
      "content": "Query evaluation techniques for large databases <bpt id=\"p1\">[</bpt>http://dl.acm.org/citation.cfm?id=152611<ept id=\"p1\">](http://dl.acm.org/citation.cfm?id=152611)</ept>"
    },
    {
      "content": "Query Processing in Parallel Relational Database Systems, IEEE Computer Society Press, 1994",
      "pos": [
        87519,
        87610
      ]
    },
    {
      "content": "Lu, Ooi, Tan, Query Processing in Parallel Relational Database Systems, IEEE Computer Society Press, 1994.",
      "pos": [
        87615,
        87721
      ]
    },
    {
      "content": "Christopher Olston, Benjamin Reed, Utkarsh Srivastava, Ravi Kumar, Andrew Tomkins: Pig Latin: A Not-So-Foreign Language for Data Processing, SIGMOD 2008.",
      "pos": [
        87726,
        87879
      ]
    },
    {
      "content": "G.",
      "pos": [
        87888,
        87890
      ]
    },
    {
      "content": "Graefe.",
      "pos": [
        87891,
        87898
      ]
    },
    {
      "content": "The Cascades framework for query optimization.",
      "pos": [
        87899,
        87945
      ]
    },
    {
      "content": "IEEE Data Eng.",
      "pos": [
        87946,
        87960
      ]
    },
    {
      "content": "Bull., 18(3): 1995.",
      "pos": [
        87961,
        87980
      ]
    },
    {
      "content": "test",
      "pos": [
        88133,
        88137
      ]
    }
  ],
  "content": "<properties \n    pageTitle=\"Query with DocumentDB SQL | Microsoft Azure\" \n    description=\"DocumentDB, a NoSQL document database service, supports queries using SQL-like grammar over hierarchical JSON documents without requiring explicit an schema or creation of secondary indexes.\" \n    services=\"documentdb\" \n    documentationCenter=\"\" \n    authors=\"arramac\" \n    manager=\"jhubbard\" \n    editor=\"monicar\"/>\n\n<tags \n    ms.service=\"documentdb\" \n    ms.workload=\"data-services\" \n    ms.tgt_pltfrm=\"na\" \n    ms.devlang=\"na\" \n    ms.topic=\"article\" \n    ms.date=\"08/13/2015\" \n    ms.author=\"mimig\"/>\n\n# Query DocumentDB\nMicrosoft Azure DocumentDB supports querying documents using SQL (Structured Query Language) over hierarchical JSON documents. DocumentDB is truly schema-free. By virtue of its commitment to the JSON data model directly within the database engine, it provides automatic indexing of JSON documents without requiring explicit schema or creation of secondary indexes. \n\nWhile designing the query language for DocumentDB we had two goals in mind:\n\n-   **Embrace SQL** – Instead of inventing a new query language, we wanted to embrace SQL. After all, SQL is one of the most familiar and popular query languages. DocumentDB SQL provides a formal programming model for rich queries over JSON documents.\n-   **Extend SQL** – As a JSON document database capable of executing JavaScript directly in the database engine, we wanted to use JavaScript's programming model as the foundation for our query language. The DocumentDB SQL is rooted in JavaScript's type system, expression evaluation, and function invocation. This in-turn provides a natural programming model for relational projections, hierarchical navigation across JSON documents, self joins, and invocation of user defined functions (UDFs) written entirely in JavaScript, among other features. \n\nWe believe that these capabilities are key to reducing the friction between the application and the database and are crucial for developer productivity.\n\nWe recommend getting started by watching the following video, where Aravind Ramachandran shows DocumentDB's querying capabilities, and by visiting our [Query Playground](http://www.documentdb.com/sql/demo), where you can try out DocumentDB and run SQL queries against our dataset.\n\n> [AZURE.VIDEO dataexposedqueryingdocumentdb]\n\nThen, return to this article, where we'll start by walking through some simple JSON documents and queries.\n\n## Getting started\nTo see DocumentDB SQL at work, let's begin with a few simple JSON documents and walk through some simple queries against it. Consider these two JSON documents about two families. Note that with DocumentDB, we do not need to create any schemas or secondary indices explicitly. We simply need to insert the JSON documents to a DocumentDB collection and subsequently query. \nHere we have a simple JSON document for the Andersen family, the parents, children (and their pets), address and registration information. The document has strings, numbers, booleans, arrays and nested properties. \n\n**Document**  \n\n    {\n        \"id\": \"AndersenFamily\",\n        \"lastName\": \"Andersen\",\n        \"parents\": [\n           { \"firstName\": \"Thomas\" },\n           { \"firstName\": \"Mary Kay\"}\n        ],\n        \"children\": [\n           {\n               \"firstName\": \"Henriette Thaulow\", \"gender\": \"female\", \"grade\": 5,\n               \"pets\": [{ \"givenName\": \"Fluffy\" }]\n           }\n        ],\n        \"address\": { \"state\": \"WA\", \"county\": \"King\", \"city\": \"seattle\" },\n        \"creationDate\": 1431620472,\n        \"isRegistered\": true\n    }\n\n\nHere's a second document with one subtle difference – `givenName` and `familyName` are used instead of `firstName` and `lastName`.\n\n**Document**  \n\n    {\n        \"id\": \"WakefieldFamily\",\n        \"parents\": [\n            { \"familyName\": \"Wakefield\", \"givenName\": \"Robin\" },\n            { \"familyName\": \"Miller\", \"givenName\": \"Ben\" }\n        ],\n        \"children\": [\n            {\n                \"familyName\": \"Merriam\", \n                \"givenName\": \"Jesse\", \n                \"gender\": \"female\", \"grade\": 1,\n                \"pets\": [\n                    { \"givenName\": \"Goofy\" },\n                    { \"givenName\": \"Shadow\" }\n                ]\n            },\n            { \n                \"familyName\": \"Miller\", \n                 \"givenName\": \"Lisa\", \n                 \"gender\": \"female\", \n                 \"grade\": 8 }\n        ],\n        \"address\": { \"state\": \"NY\", \"county\": \"Manhattan\", \"city\": \"NY\" },\n        \"creationDate\": 1431620462,\n        \"isRegistered\": false\n    }\n\n\n\nNow let's try a few queries against this data to understand some of the key aspects of DocumentDB SQL. For example, the following query will return the documents where the id field matches `AndersenFamily`. Since it's a `SELECT *`, the output of the query is the complete JSON document:\n\n**Query**\n\n    SELECT * \n    FROM Families f \n    WHERE f.id = \"AndersenFamily\"\n\n**Results**\n\n    [{\n        \"id\": \"AndersenFamily\",\n        \"lastName\": \"Andersen\",\n        \"parents\": [\n           { \"firstName\": \"Thomas\" },\n           { \"firstName\": \"Mary Kay\"}\n        ],\n        \"children\": [\n           {\n               \"firstName\": \"Henriette Thaulow\", \"gender\": \"female\", \"grade\": 5,\n               \"pets\": [{ \"givenName\": \"Fluffy\" }]\n           }\n        ],\n        \"address\": { \"state\": \"WA\", \"county\": \"King\", \"city\": \"seattle\" },\n        \"creationDate\": 1431620472,\n        \"isRegistered\": true\n    }]\n\n\nNow consider the case where we need to reformat the JSON output in a different shape. This query projects a new JSON object with two selected fields, Name and City, when the address' city has the same name as the state. In this case, \"NY, NY\" matches.\n\n**Query**   \n\n    SELECT {\"Name\":f.id, \"City\":f.address.city} AS Family \n    FROM Families f \n    WHERE f.address.city = f.address.state\n\n**Results**\n\n    [{\n        \"Family\": {\n            \"Name\": \"WakefieldFamily\", \n            \"City\": \"NY\"\n        }\n    }]\n\n\nThe next query returns all the given names of children in the family whose id matches `WakefieldFamily` ordered by the city of residence.\n\n**Query**\n\n    SELECT c.givenName \n    FROM Families f \n    JOIN c IN f.children \n    WHERE f.id = 'WakefieldFamily'\n    ORDER BY f.address.city ASC\n\n**Results**\n\n    [\n      { \"givenName\": \"Jesse\" }, \n      { \"givenName\": \"Lisa\"}\n    ]\n\n\nWe would like to draw attention to a few noteworthy aspects of the DocumentDB query language through the examples we've seen so far:  \n \n-   Since DocumentDB SQL works on JSON values, it deals with tree shaped entities instead of rows and columns. Therefore, the language lets you refer to nodes of the tree at any arbitrary depth, like `Node1.Node2.Node3…..Nodem`, similar to relational SQL referring to the two part reference of `<table>.<column>`.   \n-   The language works with schema-less data. Therefore, the type system needs to be bound dynamically. The same expression could yield different types on different documents. The result of a query is a valid JSON value, but is not guaranteed to be of a fixed schema.  \n-   DocumentDB only supports strict JSON documents. This means the type system and expressions are restricted to deal only with JSON types. Please refer to the [JSON specification](http://www.json.org/) for more details.  \n-   A DocumentDB collection is a schema-free container of JSON documents. The relations in data entities within and across documents in a collection are implicitly captured by containment and not by primary key and foreign key relations. This is an important aspect worth pointing out in light of the intra-document joins discussed later in this article.\n\n## DocumentDB indexing\n\nBefore we get into the DocumentDB SQL grammar, it is worth exploring the indexing design in DocumentDB. \n\nThe purpose of database indexes is to serve queries in their various forms and shapes with minimum resource consumption (like CPU and input/output) while providing good throughput and low latency. Often, the choice of the right index for querying a database requires much planning and experimentation. This approach poses a challenge for schema-less databases where the data doesn’t conform to a strict schema and evolves rapidly. \n\nTherefore, when we designed the DocumentDB indexing subsystem, we set the following goals:\n\n-   Index documents without requiring schema: The indexing subsystem does not require any schema information or make any assumptions about schema of the documents. \n\n-   Support for efficient, rich hierarchical, and relational queries: The index supports the DocumentDB query language efficiently, including support for hierarchical and relational projections.\n\n-   Support for consistent queries in face of a sustained volume of writes: For high write throughput workloads with consistent queries, the index is updated incrementally, efficiently, and online in the face of a sustained volume of writes. The consistent index update is crucial to serve the queries at the consistency level in which the user configured the document service.\n\n-   Support for multi-tenancy: Given the reservation based model for resource governance across tenants, index updates are performed within the budget of system resources (CPU, memory, and input/output operations per second) allocated per replica. \n\n-   Storage efficiency: For cost effectiveness, the on-disk storage overhead of the index is bounded and predictable. This is crucial because DocumentDB allows the developer to make cost based tradeoffs between index overhead in relation to the query performance.  \n\nRefer to the [DocumentDB samples](https://github.com/Azure/azure-documentdb-net) on MSDN for samples showing how to configure the indexing policy for a collection. Let’s now get into the details of the DocumentDB SQL grammar.\n\n\n## Basics of DocumentDB query\nEvery query consists of a SELECT clause and optional FROM and WHERE clauses per ANSI-SQL standards. Typically, for each query, the source in the FROM clause is enumerated. Then the filter in the WHERE clause is applied on the source to retrieve a subset of JSON documents. Finally, the SELECT clause is used to project the requested JSON values in the select list.\n    \n    SELECT <select_list> \n    [FROM <from_specification>] \n    [WHERE <filter_condition>]    \n\n\n## FROM clause\nThe `FROM <from_specification>` clause is optional unless the source is filtered or projected later in the query. The purpose of this clause is to specify the data source upon which the query must operate. Commonly the whole collection is the source, but one can specify a subset of the collection instead. \n\nA query like `SELECT * FROM Families` indicates that the entire Families collection is the source over which to enumerate. A special identifier ROOT can be used to represent the collection instead of using the collection name. \nThe following list contains the rules that are enforced per query:\n\n- The collection can be aliased, such as `SELECT f.id FROM Families AS f` or simply `SELECT f.id FROM Families f`. Here `f` is the equivalent of `Families`. `AS` is an optional keyword to alias the identifier.\n\n-   Note that once aliased, the original source cannot be bound. For example, `SELECT Families.id FROM Families f` is syntactically invalid since the identifier \"Families\" cannot be resolved anymore.\n\n-   All properties that need to be referenced must be fully qualified. In the absence of strict schema adherence, this is enforced to avoid any ambiguous bindings. Therefore, `SELECT id FROM Families f` is syntactically invalid since the property `id` is not bound.\n    \n### Sub-documents\nThe source can also be reduced to a smaller subset. For instance, to enumerating only a sub-tree in each document, the sub-root could then become the source, as shown in the following example.\n\n**Query**\n\n    SELECT * \n    FROM Families.children\n\n**Results**  \n\n    [\n      [\n        {\n            \"firstName\": \"Henriette Thaulow\",\n            \"gender\": \"female\",\n            \"grade\": 5,\n            \"pets\": [\n              {\n                  \"givenName\": \"Fluffy\"\n              }\n            ]\n        }\n      ],\n      [\n        {\n            \"familyName\": \"Merriam\",\n            \"givenName\": \"Jesse\",\n            \"gender\": \"female\",\n            \"grade\": 1\n        },\n        {\n            \"familyName\": \"Miller\",\n            \"givenName\": \"Lisa\",\n            \"gender\": \"female\",\n            \"grade\": 8\n        }\n      ]\n    ]\n\nWhile the above example used an array as the source, an object could also be used as the source, which is what's shown in the following example. Any valid JSON value (not undefined) that can be found in the source will be considered for inclusion in the result of the query. If some families don’t have an `address.state` value, they will be excluded in the query result.\n\n**Query**\n\n    SELECT * \n    FROM Families.address.state\n\n**Results**\n\n    [\n      \"WA\", \n      \"NY\"\n    ]\n\n\n## WHERE clause\nThe WHERE clause (**`WHERE <filter_condition>`**) is optional. It specifies the condition(s) that the JSON documents provided by the source must satisfy in order to be included as part of the result. Any JSON document must evaluate the specified conditions to \"true\" to be considered for the result. The WHERE clause is used by the index layer in order to determine the absolute smallest subset of source documents that can be part of the result. \n\nThe following query requests documents that contain a name property whose value is `AndersenFamily`. Any other document that does not have a name property, or where the value does not match `AndersenFamily` is excluded. \n\n**Query**\n\n    SELECT f.address\n    FROM Families f \n    WHERE f.id = \"AndersenFamily\"\n\n**Results**\n\n    [{\n      \"address\": {\n        \"state\": \"WA\", \n        \"county\": \"King\", \n        \"city\": \"seattle\"\n      }\n    }]\n\n\nThe previous example showed a simple equality query. DocumentDB SQL also supports a variety of scalar expressions. The most commonly used are binary and unary expressions. Property references from the source JSON object are also valid expressions. \n\nThe following binary operators are currently supported and can be used in queries as shown in the following examples:  \n<table>\n<tr>\n<td>Arithmetic</td> \n<td>+,-,*,/,%</td>\n</tr>\n<tr>\n<td>Bitwise</td>    \n<td>|, &, ^, <<, >>, >>> (zero-fill right shift) </td>\n</tr>\n<tr>\n<td>Logical</td>\n<td>AND, OR, NOT</td>\n</tr>\n<tr>\n<td>Comparison</td> \n<td>=, !=, &lt;, &gt;, &lt;=, &gt;=, <></td>\n</tr>\n<tr>\n<td>String</td> \n<td>|| (concatenate)</td>\n</tr>\n</table>  \n\nLet’s take a look at some queries using binary operators.\n\n    SELECT * \n    FROM Families.children[0] c\n    WHERE c.grade % 2 = 1     -- matching grades == 5, 1\n    \n    SELECT * \n    FROM Families.children[0] c\n    WHERE c.grade ^ 4 = 1    -- matching grades == 5\n    \n    SELECT *\n    FROM Families.children[0] c\n    WHERE c.grade >= 5     -- matching grades == 5\n\n\nThe unary operators +,-, ~ and NOT are also supported, and can be used inside queries as shown in the following example:\n\n    SELECT *\n    FROM Families.children[0] c\n    WHERE NOT(c.grade = 5)  -- matching grades == 1\n    \n    SELECT *\n    FROM Families.children[0] c\n    WHERE (-c.grade = -5)  -- matching grades == 5\n\n\n\nIn addition to binary and unary operators, property references are also allowed. For example, `SELECT * FROM Families f WHERE f.isRegistered` returns the JSON document containing the property `isRegistered` where the property's value is equal to the JSON `true` value. Any other values (false, null, Undefined, `<number>`, `<string>`, `<object>`, `<array>`, etc.) leads to the source document being excluded from the result. \n\n### Equality and comparison operators\nThe following table shows the result of equality comparisons in DocumentDB SQL between any two JSON types.\n<table style = \"width:300px\">\n   <tbody>\n      <tr>\n         <td valign=\"top\">\n            <strong>Op</strong>\n         </td>\n         <td valign=\"top\">\n            <strong>Undefined</strong>\n         </td>\n         <td valign=\"top\">\n            <strong>Null</strong>\n         </td>\n         <td valign=\"top\">\n            <strong>Boolean</strong>\n         </td>\n         <td valign=\"top\">\n            <strong>Number</strong>\n         </td>\n         <td valign=\"top\">\n            <strong>String</strong>\n         </td>\n         <td valign=\"top\">\n            <strong>Object</strong>\n         </td>\n         <td valign=\"top\">\n            <strong>Array</strong>\n         </td>\n      </tr>\n      <tr>\n         <td valign=\"top\">\n            <strong>Undefined<strong>\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n      </tr>\n      <tr>\n         <td valign=\"top\">\n            <strong>Null<strong>\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            <strong>OK</strong>\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n      </tr>\n      <tr>\n         <td valign=\"top\">\n            <strong>Boolean<strong>\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            <strong>OK</strong>\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n      </tr>\n      <tr>\n         <td valign=\"top\">\n            <strong>Number<strong>\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            <strong>OK</strong>\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n      </tr>\n      <tr>\n         <td valign=\"top\">\n            <strong>String<strong>\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            <strong>OK</strong>\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n      </tr>\n      <tr>\n         <td valign=\"top\">\n            <strong>Object<strong>\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            <strong>OK</strong>\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n      </tr>\n      <tr>\n         <td valign=\"top\">\n            <strong>Array<strong>\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            Undefined\n         </td>\n         <td valign=\"top\">\n            <strong>OK</strong>\n         </td>\n      </tr>\n   </tbody>\n</table>\n\nFor other comparison operators such as >, >=, !=, < and <=, the following rules apply:   \n\n-   Comparison across types results in Undefined.\n-   Comparison between two objects or two arrays results in Undefined.   \n\nIf the result of the scalar expression in the filter is Undefined, the corresponding document would not be included in the result, since Undefined doesn't logically equate to \"true\".\n\n### BETWEEN keyword\nYou can also use the BETWEEN keyword to express queries against ranges of values like in ANSI SQL. BETWEEN can be used against any JSON primitive type (numbers, strings, Booleans and nulls). \n\nFor example, this query returns all family documents in which the first child's grade is between 1-5 (both inclusive). \n\n    SELECT *\n    FROM Families.children[0] c\n    WHERE c.grade BETWEEN 1 AND 5\n\nUnlike in ANSI-SQL, you can also use the BETWEEN clause in the FROM clause like in the following example.\n\n    SELECT (c.grade BETWEEN 0 AND 10)\n    FROM Families.children[0] c\n\nFor faster query execution times, remember to create an indexing policy that uses a range index type against any numeric properties/paths that are filtered in the BETWEEN clause. \n\nThe main difference between using BETWEEN in DocumentDB and ANSI SQL is that you can express range queries against properties of mixed types – for example, you might have \"grade\" be a number (5) in some documents and strings in others (\"grade4\"). In these cases, like in JavaScript, a comparison between two different types results in \"undefined\", and the document will be skipped.\n\n### Logical (AND, OR and NOT) operators\nLogical operators operate on Boolean values. The logical truth tables for these operators are shown in the following tables.\n\nOR|True|False|Undefined\n---|---|---|---\nTrue|True|True|True\nFalse|True|False|Undefined\nUndefined|True|Undefined|Undefined\n\nAND|True|False|Undefined\n---|---|---|---\nTrue|True|False|Undefined\nFalse|False|False|False\nUndefined|Undefined|False|Undefined\n\nNOT|  |\n---|---\nTrue|False\nFalse|True\nUndefined|Undefined\n\n### IN keyword\nThe IN keyword can be used to check whether a specified value matches any value in a list. For example, this query returns all family documents where the id is one of \"WakefieldFamily\" or \"AndersenFamily\". \n \n    SELECT *\n    FROM Families \n    WHERE Families.id IN ('AndersenFamily', 'WakefieldFamily')\n\nThis example returns all documents where the state is any of the specified values.\n\n    SELECT *\n    FROM Families \n    WHERE Families.address.state IN (\"NY\", \"WA\", \"CA\", \"PA\", \"OH\", \"OR\", \"MI\", \"WI\", \"MN\", \"FL\")\n\nIN is equivalent to chaining multiple OR clauses, however since it can be served using a single index, DocumentDB supports a higher [limit](documentdb-limits.md) for the number of arguments specified within an IN clause.  \n\n### Ternary (?) and Coalesce (??) operators\nThe Ternary and Coalesce operators can be used to build conditional expressions, similar to popular programming languages like C# and JavaScript. \n\nThe Ternary (?) operator can be very handy when constructing new JSON properties on the fly. For example, now you can write queries to classify the class levels into a human readable form like Beginner/Intermediate/Advanced as shown below.\n \n     SELECT (c.grade < 5)? \"elementary\": \"other\" AS gradeLevel \n     FROM Families.children[0] c\n\nYou can also nest the calls to the operator like in the query below.\n \n    SELECT (c.grade < 5)? \"elementary\": ((c.grade < 9)? \"junior\": \"high\")  AS gradeLevel \n    FROM Families.children[0] c\n\nAs with other query operators, if the referenced properties in the conditional expression are missing in any document, or if the types being compared are different, then those documents will be excluded in the query results.\n\nThe Coalesce (??) operator can be used to efficiently check for the presence of a property (a.k.a. is defined) in a document. This is useful when querying against semi-structured or data of mixed types. For example, this query returns the \"lastName\" if present, or the \"surname\" if it isn't present.\n\n    SELECT f.lastName ?? f.surname AS familyName\n    FROM Families f\n\n### Quoted property accessor\nYou can also access properties using the quoted property operator `[]`. For example, `SELECT c.grade` and `SELECT c[\"grade\"]` are equivalent. This syntax is useful when you need to escape a property that contains spaces, special characters, or happens to share the same name as a SQL keyword or reserved word.\n\n    SELECT f[\"lastName\"]\n    FROM Families f\n    WHERE f[\"id\"] = \"AndersenFamily\"\n\n\n## SELECT clause\nThe SELECT clause (**`SELECT <select_list>`**) is mandatory and specifies what values will be retrieved from the query, just like in ANSI-SQL. The subset that's been filtered on top of the source documents are passed onto the projection phase, where the specified JSON values are retrieved and a new JSON object is constructed, for each input passed onto it. \n\nThe following example shows a typical SELECT query. \n\n**Query**\n\n    SELECT f.address\n    FROM Families f \n    WHERE f.id = \"AndersenFamily\"\n\n**Results**\n\n    [{\n      \"address\": {\n        \"state\": \"WA\", \n        \"county\": \"King\", \n        \"city\": \"seattle\"\n      }\n    }]\n\n\n### Nested properties\nIn the following example, we are projecting two nested properties `f.address.state` and `f.address.city`.\n\n**Query**\n\n    SELECT f.address.state, f.address.city\n    FROM Families f \n    WHERE f.id = \"AndersenFamily\"\n\n**Results**\n\n    [{\n      \"state\": \"WA\", \n      \"city\": \"seattle\"\n    }]\n\n\nProjection also supports JSON expressions as shown in the following example.\n\n**Query**\n\n    SELECT { \"state\": f.address.state, \"city\": f.address.city, \"name\": f.id }\n    FROM Families f \n    WHERE f.id = \"AndersenFamily\"\n\n**Results**\n\n    [{\n      \"$1\": {\n        \"state\": \"WA\", \n        \"city\": \"seattle\", \n        \"name\": \"AndersenFamily\"\n      }\n    }]\n\n\nLet's look at the role of `$1` here. The `SELECT` clause needs to create a JSON object and since no key is provided, we use implicit argument variable names starting with `$1`. For example, this query returns two implicit argument variables, labeled `$1` and `$2`.\n\n**Query**\n\n    SELECT { \"state\": f.address.state, \"city\": f.address.city }, \n           { \"name\": f.id }\n    FROM Families f \n    WHERE f.id = \"AndersenFamily\"\n\n**Results**\n\n    [{\n      \"$1\": {\n        \"state\": \"WA\", \n        \"city\": \"seattle\"\n      }, \n      \"$2\": {\n        \"name\": \"AndersenFamily\"\n      }\n    }]\n\n\n### Aliasing\nNow let's extend the example above with explicit aliasing of values. AS is the keyword used for aliasing. Note that it's optional as shown while projecting the second value as `NameInfo`. \n\nIn case a query has two properties with the same name, aliasing must be used to rename one or both of the properties so that they are disambiguated in the projected result.\n\n**Query**\n\n    SELECT \n           { \"state\": f.address.state, \"city\": f.address.city } AS AddressInfo, \n           { \"name\": f.id } NameInfo\n    FROM Families f \n    WHERE f.id = \"AndersenFamily\"\n\n**Results**\n\n    [{\n      \"AddressInfo\": {\n        \"state\": \"WA\", \n        \"city\": \"seattle\"\n      }, \n      \"NameInfo\": {\n        \"name\": \"AndersenFamily\"\n      }\n    }]\n\n\n### Scalar expressions\nIn addition to property references, the SELECT clause also supports scalar expressions like constants, arithmetic expressions, logical expressions, etc. For example, here's a simple \"Hello World\" query.\n\n**Query**\n\n    SELECT \"Hello World\"\n\n**Results**\n\n    [{\n      \"$1\": \"Hello World\"\n    }]\n\n\nHere's a more complex example that uses a scalar expression.\n\n**Query**\n\n    SELECT ((2 + 11 % 7)-2)/3   \n\n**Results**\n\n    [{\n      \"$1\": 1.33333\n    }]\n\n\nIn the following example, the result of the scalar expression is a Boolean.\n\n**Query**\n\n    SELECT f.address.city = f.address.state AS AreFromSameCityState\n    FROM Families f \n\n**Results**\n\n    [\n      {\n        \"AreFromSameCityState\": false\n      }, \n      {\n        \"AreFromSameCityState\": true\n      }\n    ]\n\n\n### Object and array creation\nAnother key feature of DocumentDB SQL is array/object creation. In the previous example, note that we created a new JSON object. Similarly, one can also construct arrays as shown in the following examples.\n\n**Query**\n\n    SELECT [f.address.city, f.address.state] AS CityState \n    FROM Families f \n\n**Results**  \n\n    [\n      {\n        \"CityState\": [\n          \"seattle\", \n          \"WA\"\n        ]\n      }, \n      {\n        \"CityState\": [\n          \"NY\", \n          \"NY\"\n        ]\n      }\n    ]\n\n### VALUE keyword\nThe **VALUE** keyword provides a way to return JSON value. For example, the query shown below returns the scalar `\"Hello World\"` instead of `{$1: \"Hello World\"}`.\n\n**Query**\n\n    SELECT VALUE \"Hello World\"\n\n**Results**\n\n    [\n      \"Hello World\"\n    ]\n\n\nThe following query returns the JSON value without the `\"address\"` label in the results.\n\n**Query**\n\n    SELECT VALUE f.address\n    FROM Families f \n\n**Results**  \n\n    [\n      {\n        \"state\": \"WA\", \n        \"county\": \"King\", \n        \"city\": \"seattle\"\n      }, \n      {\n        \"state\": \"NY\", \n        \"county\": \"Manhattan\", \n        \"city\": \"NY\"\n      }\n    ]\n\nThe following example extends this to show how to return JSON primitive values (the leaf level of the JSON tree). \n\n**Query**\n\n    SELECT VALUE f.address.state\n    FROM Families f \n\n**Results**\n\n    [\n      \"WA\",\n      \"NY\"\n    ]\n\n\n###* Operator\nThe special operator (*) is supported to project the document as-is. When used, it must be the only projected field. While a query like `SELECT * FROM Families f` is valid, `SELECT VALUE * FROM Families f ` and  `SELECT *, f.id FROM Families f ` are not valid.\n\n**Query**\n\n    SELECT * \n    FROM Families f \n    WHERE f.id = \"AndersenFamily\"\n\n**Results**\n\n    [{\n        \"id\": \"AndersenFamily\",\n        \"lastName\": \"Andersen\",\n        \"parents\": [\n           { \"firstName\": \"Thomas\" },\n           { \"firstName\": \"Mary Kay\"}\n        ],\n        \"children\": [\n           {\n               \"firstName\": \"Henriette Thaulow\", \"gender\": \"female\", \"grade\": 5,\n               \"pets\": [{ \"givenName\": \"Fluffy\" }]\n           }\n        ],\n        \"address\": { \"state\": \"WA\", \"county\": \"King\", \"city\": \"seattle\" },\n        \"creationDate\": 1431620472,\n        \"isRegistered\": true\n    }]\n\n## ORDER BY clause\nLike in ANSI-SQL, you can include an optional Order By clause while querying. The clause can include an optional ASC/DESC argument to specify the order in which results must be retrieved. For a more detailed look at Order By, refer to [DocumentDB Order By Walkthrough](documentdb-orderby.md).\n\nFor example, here's a query that retrieves families in order of the resident city's name.\n\n**Query**\n\n    SELECT f.id, f.address.city\n    FROM Families f \n    ORDER BY f.address.city\n    \n**Results**\n    \n    [\n      {\n        \"id\": \"WakefieldFamily\",\n        \"city\": \"NY\"\n      },\n      {\n        \"id\": \"AndersenFamily\",\n        \"city\": \"Seattle\"   \n      }\n    ]\n\nAnd here's a query that retrieves families in order of creation date, which is stored as a number representing the epoch time, i.e, elapsed time since Jan 1, 1970 in seconds.\n\n**Query**\n\n    SELECT f.id, f.creationDate\n    FROM Families f \n    ORDER BY f.creationDate DESC\n    \n**Results**\n    \n    [\n      {\n        \"id\": \"WakefieldFamily\",\n        \"creationDate\": 1431620462\n      },\n      {\n        \"id\": \"AndersenFamily\",\n        \"creationDate\": 1431620472  \n      }\n    ]\n    \n## Advanced concepts\n### Iteration\nA new construct was added via the **IN** keyword in DocumentDB SQL to provide support for iterating over JSON arrays. The FROM source provides support for iteration. Let's start with the following example:\n\n**Query**\n\n    SELECT * \n    FROM Families.children\n\n**Results**  \n\n    [\n      [\n        {\n          \"firstName\": \"Henriette Thaulow\", \n          \"gender\": \"female\", \n          \"grade\": 5, \n          \"pets\": [{ \"givenName\": \"Fluffy\"}]\n        }\n      ], \n      [\n        {\n            \"familyName\": \"Merriam\", \n            \"givenName\": \"Jesse\", \n            \"gender\": \"female\", \n            \"grade\": 1\n        }, \n        {\n            \"familyName\": \"Miller\", \n            \"givenName\": \"Lisa\", \n            \"gender\": \"female\", \n            \"grade\": 8\n        }\n      ]\n    ]\n\nNow let's look at another query that performs iteration over children in the collection. Note the difference in the output array. This example splits `children` and flattens the results into a single array.  \n\n**Query**\n\n    SELECT * \n    FROM c IN Families.children\n\n**Results**  \n\n    [\n      {\n          \"firstName\": \"Henriette Thaulow\",\n          \"gender\": \"female\",\n          \"grade\": 5,\n          \"pets\": [{ \"givenName\": \"Fluffy\" }]\n      },\n      {\n          \"familyName\": \"Merriam\",\n          \"givenName\": \"Jesse\",\n          \"gender\": \"female\",\n          \"grade\": 1\n      },\n      {\n          \"familyName\": \"Miller\",\n          \"givenName\": \"Lisa\",\n          \"gender\": \"female\",\n          \"grade\": 8\n      }\n    ]\n\nThis can be further used to filter on each individual entry of the array as shown in the following example.\n\n**Query**\n\n    SELECT c.givenName\n    FROM c IN Families.children\n    WHERE c.grade = 8\n\n**Results**  \n\n    [{\n      \"givenName\": \"Lisa\"\n    }]\n\n### Joins\nIn a relational database, the need to join across tables is very important. It's the logical corollary to designing normalized schemas. Contrary to this, DocumentDB deals with the denormalized data model of schema-free documents. This is the logical equivalent of a \"self-join\".\n\nThe syntax that the language supports is <from_source1> JOIN <from_source2> JOIN ... JOIN <from_sourceN>. Overall, this returns a set of **N**-tuples (tuple with **N** values). Each tuple has values produced by iterating all collection aliases over their respective sets. In other words, this is a full cross product of the sets participating in the join.\n\nThe following examples show how the JOIN clause works. In the following example, the result is empty since the cross product of each document from source and an empty set is empty.\n\n**Query**\n\n    SELECT f.id\n    FROM Families f\n    JOIN f.NonExistent\n\n**Results**  \n\n    [{\n    }]\n\n\nIn the following example, the join is between the document root and the `children` sub-root. It's a cross product between two JSON objects. The fact that children is an array is not effective in the JOIN since we are dealing with a single root that is the children array. Hence the result contains only two results, since the cross product of each document with the array yields exactly only one document.\n\n**Query**\n\n    SELECT f.id\n    FROM Families f\n    JOIN f.children\n \n**Results**\n\n    [\n      {\n        \"id\": \"AndersenFamily\"\n      }, \n      {\n        \"id\": \"WakefieldFamily\"\n      }\n    ]\n\n\nThe following example shows a more conventional join:\n\n**Query**\n\n    SELECT f.id\n    FROM Families f\n    JOIN c IN f.children \n\n**Results**\n\n    [\n      {\n        \"id\": \"AndersenFamily\"\n      }, \n      {\n        \"id\": \"WakefieldFamily\"\n      }, \n      {\n        \"id\": \"WakefieldFamily\"\n      }\n    ]\n\n\n\nThe first thing to note is that the `from_source` of the **JOIN** clause is an iterator. So, the flow in this case is as follows:  \n\n-   Expand each child element **c** in the array.\n-   Apply a cross product with the root of the document **f** with each child element **c** that was flattened in the first step.\n-   Finally, project the root object **f** name property alone. \n\nThe first document (`AndersenFamily`) contains only one child element, so the result set contains only a single object corresponding to this document. The second document (`WakefieldFamily`) contains two children. So, the cross product produces a separate object for each child, thereby resulting in two objects, one for each child corresponding to this document. Note that the root fields in both these documents will be same, just as you would expect in a cross product.\n\nThe real utility of the JOIN is to form tuples from the cross-product in a shape that's otherwise difficult to project. Furthermore, as we will see in the example below, you could filter on the combination of a tuple that lets' the user chose a condition satisfied by the tuples overall.\n\n**Query**\n\n    SELECT \n        f.id AS familyName,\n        c.givenName AS childGivenName,\n        c.firstName AS childFirstName,\n        p.givenName AS petName \n    FROM Families f \n    JOIN c IN f.children \n    JOIN p IN c.pets\n \n**Results**\n\n    [\n      {\n        \"familyName\": \"AndersenFamily\", \n        \"childFirstName\": \"Henriette Thaulow\", \n        \"petName\": \"Fluffy\"\n      }, \n      {\n        \"familyName\": \"WakefieldFamily\", \n        \"childGivenName\": \"Jesse\", \n        \"petName\": \"Goofy\"\n      }, \n      {\n       \"familyName\": \"WakefieldFamily\", \n       \"childGivenName\": \"Jesse\", \n       \"petName\": \"Shadow\"\n      }\n    ]\n\n\n\nThis example is a natural extension of the preceding example, and performs a double join. So, the cross product can be viewed as the following pseudo-code.\n\n    for-each(Family f in Families)\n    {   \n        for-each(Child c in f.children)\n        {\n            for-each(Pet p in c.pets)\n            {\n                return (Tuple(f.id AS familyName, \n                  c.givenName AS childGivenName, \n                  c.firstName AS childFirstName,\n                  p.givenName AS petName));\n            }\n        }\n    }\n\n`AndersenFamily` has one child who has one pet. So, the cross product yields one row (1*1*1) from this family. WakefieldFamily however has two children, but only one child \"Jesse\" has pets. Jesse has 2 pets though. Hence the cross product yields 1*1*2 = 2 rows from this family.\n\nIn the next example, there is an additional filter on `pet`. This excludes all the tuples where the pet name is not \"Shadow\". Notice that we are able to build tuples from arrays, filter on any of the elements of the tuple, and project any combination of the elements. \n\n**Query**\n\n    SELECT \n        f.id AS familyName,\n        c.givenName AS childGivenName,\n        c.firstName AS childFirstName,\n        p.givenName AS petName \n    FROM Families f \n    JOIN c IN f.children \n    JOIN p IN c.pets\n    WHERE p.givenName = \"Shadow\"\n\n**Results**\n\n    [\n      {\n       \"familyName\": \"WakefieldFamily\", \n       \"childGivenName\": \"Jesse\", \n       \"petName\": \"Shadow\"\n      }\n    ]\n\n\n## JavaScript integration\nDocumentDB provides a programming model for executing JavaScript based application logic directly on the collections in terms of stored procedures and triggers. This allows for both:\n\n-   Ability to do high performance transactional CRUD operations and queries against documents in a collection by virtue of the deep integration of JavaScript runtime directly within the database engine. \n-   A natural modeling of control flow, variable scoping, and assignment and integration of exception handling primitives with database transactions. For more details about DocumentDB support for JavaScript integration, please refer to the JavaScript server side programmability documentation.\n\n###User Defined Functions (UDFs)\nAlong with the types already defined in this article, DocumentDB SQL provides support for User Defined Functions (UDF). In particular, scalar UDFs are supported where the developers can pass in zero or many arguments and return a single argument result back. Each of these arguments are checked for being legal JSON values.  \n\nThe DocumentDB SQL grammar is extended to support custom application logic using these User Defined Functions. UDFs can be registered with DocumentDB and then be referenced as part of a SQL query. In fact, the UDFs are exquisitely designed to be invoked by queries. As a corollary to this choice, UDFs do not have access to the context object which the other JavaScript types (stored procedures and triggers) have. Since queries execute as read-only, they can run either on primary or on secondary replicas. Therefore, UDFs are designed to run on secondary replicas unlike other JavaScript types.\n\nBelow is an example of how a UDF can be registered at the DocumentDB database, specifically under a document collection.\n\n   \n       UserDefinedFunction regexMatchUdf = new UserDefinedFunction\n       {\n           Id = \"REGEX_MATCH\",\n           Body = @\"function (input, pattern) { \n                       return input.match(pattern) !== null;\n                   };\",\n       };\n       \n       UserDefinedFunction createdUdf = client.CreateUserDefinedFunctionAsync(\n           collectionSelfLink/* link of the parent collection*/, \n           regexMatchUdf).Result;  \n                                                                             \nThe preceding example creates a UDF whose name is `REGEX_MATCH`. It accepts two JSON string values `input` and `pattern` and checks if the first matches the pattern specified in the second using JavaScript's string.match() function.\n\n\nWe can now use this UDF in a query in a projection. UDFs must be qualified with the case-sensitive prefix \"udf.\" when called from within queries. \n\n>[AZURE.NOTE] Prior to 3/17/2015, DocumentDB supported UDF calls without the \"udf.\" prefix like SELECT REGEX_MATCH(). This calling pattern has been deprecated.  \n\n**Query**\n\n    SELECT udf.REGEX_MATCH(Families.address.city, \".*eattle\")\n    FROM Families\n\n**Results**\n\n    [\n      {\n        \"$1\": true\n      }, \n      {\n        \"$1\": false\n      }\n    ]\n\nThe UDF can also be used inside a filter as shown in the example below, also qualified with the \"udf.\" prefix :\n\n**Query**\n\n    SELECT Families.id, Families.address.city\n    FROM Families\n    WHERE udf.REGEX_MATCH(Families.address.city, \".*eattle\")\n\n**Results**\n\n    [{\n        \"id\": \"AndersenFamily\",\n        \"city\": \"Seattle\"\n    }]\n\n\nIn essence, UDFs are valid scalar expressions and can be used in both projections and filters. \n\nTo expand on the power of UDFs, let's look at another example with conditional logic:\n\n       UserDefinedFunction seaLevelUdf = new UserDefinedFunction()\n       {\n           Id = \"SEALEVEL\",\n           Body = @\"function(city) {\n                switch (city) {\n                    case 'seattle':\n                        return 520;\n                    case 'NY':\n                        return 410;\n                    case 'Chicago':\n                        return 673;\n                    default:\n                        return -1;\n                    }\"\n            };\n\n            UserDefinedFunction createdUdf = await client.CreateUserDefinedFunctionAsync(collection.SelfLink, seaLevelUdf);\n    \n    \nBelow is an example that exercises the UDF.\n\n**Query**\n\n    SELECT f.address.city, udf.SEALEVEL(f.address.city) AS seaLevel\n    FROM Families f \n\n**Results**\n\n     [\n      {\n        \"city\": \"seattle\", \n        \"seaLevel\": 520\n      }, \n      {\n        \"city\": \"NY\", \n        \"seaLevel\": 410\n      }\n    ]\n\n\nAs the preceding examples showcase, UDFs integrate the power of JavaScript language with the DocumentDB SQL to provide a rich programmable interface to do complex procedural, conditional logic with the help of inbuilt JavaScript runtime capabilities.\n\nDocumentDB SQL provides the arguments to the UDFs for each document in the source at the current stage (WHERE clause or SELECT clause) of processing the UDF. The result is incorporated in the overall execution pipeline seamlessly. If the properties referred to by the UDF parameters are not available in the JSON value, the parameter is considered as undefined and hence the UDF invocation is entirely skipped. Similarly if the result of the UDF is undefined, it's not included in the result. \n\nIn summary, UDFs are great tools to do complex business logic as part of the query.\n\n### Operator evaluation\nDocumentDB, by the virtue of being a JSON database, draws parallels with JavaScript operators and its evaluation semantics. While DocumentDB tries to preserve JavaScript semantics in terms of JSON support, the operation evaluation deviates in some instances.\n\nIn DocumentDB SQL, unlike in traditional SQL, the types of values are often not known until the values are actually retrieved from database. In order to efficiently execute queries, most of the operators have strict type requirements. \n\nDocumentDB SQL doesn't perform implicit conversions, unlike JavaScript. For instance, a query like `SELECT * FROM Person p WHERE p.Age = 21` matches documents which contain an Age property whose value is 21. Any other document whose Age property matches string \"21\", or\nother possibly infinite variations like \"021\", \"21.0\", \"0021\", \"00021\", etc. will not be matched. \nThis is in contrast to the JavaScript where the string values are implicitly casted to numbers (based on operator, ex: ==). This choice is crucial for efficient index matching in DocumentDB SQL. \n\n## Parameterized SQL\nDocumentDB supports queries with parameters expressed with the familiar @ notation. Parameterized SQL provides robust handling and escaping of user input, preventing accidental exposure of data through SQL injection. \n\nFor example, you can write a query that takes last name and address state as parameters, and then execute it for various values of last name and address state based on user input.\n\n    SELECT * \n    FROM Families f\n    WHERE f.lastName = @lastName AND f.address.state = @addressState\n\nThis request can then be sent to DocumentDB as a parameterized JSON query like shown below.\n\n    {      \n        \"query\": \"SELECT * FROM Families f WHERE f.lastName = @lastName AND f.address.state = @addressState\",     \n        \"parameters\": [          \n            {\"name\": \"@lastName\", \"value\": \"Wakefield\"},         \n            {\"name\": \"@addressState\", \"value\": \"NY\"},           \n        ] \n    }\n\nParameter values can be any valid JSON (strings, numbers, Booleans, null, even arrays or nested JSON). Also since DocumentDB is schema-less, parameters are not validated against any type.\n\n##Built-in functions\nDocumentDB also supports a number of built-in functions for common operations, that can be used inside queries like user defined functions (UDFs).\n\n<table>\n<tr>\n<td>Mathematical functions</td> \n<td>ABS, CEILING, EXP, FLOOR, LOG, LOG10, POWER, ROUND, SIGN, SQRT, SQUARE, TRUNC, ACOS, ASIN, ATAN, ATN2, COS, COT, DEGREES, PI, RADIANS, SIN, and TAN</td>\n</tr>\n<tr>\n<td>Type checking functions</td>    \n<td>IS_ARRAY, IS_BOOL, IS_NULL, IS_NUMBER, IS_OBJECT, IS_STRING, IS_DEFINED, and IS_PRIMITIVE</td>\n</tr>\n<tr>\n<td>String functions</td>   \n<td>CONCAT, CONTAINS, ENDSWITH, INDEX_OF, LEFT, LENGTH, LOWER, LTRIM, REPLACE, REPLICATE, REVERSE, RIGHT, RTRIM, STARTSWITH, SUBSTRING, and UPPER</td>\n</tr>\n<tr>\n<td>Array functions</td>    \n<td>ARRAY_CONCAT, ARRAY_CONTAINS, ARRAY_LENGTH, and ARRAY_SLICE</td>\n</tr>\n<tr>\n<td>Spatial functions</td>  \n<td>ST_DISTANCE, ST_WITHIN, ST_ISVALID, and ST_ISVALIDDETAILED</td>\n</tr>\n</table>  \n\nIf you’re currently using a user defined function (UDF) for which a built-in function is now available, you should use the corresponding built-in function as it is going to be quicker to run and more efficiently. \n\n### Mathematical functions\nThe mathematical functions each perform a calculation, usually based on input values that are provided as arguments, and return a numeric value. Here’s a table of supported built-in mathematical functions.\n\n<table>\n<tr>\n<td><strong>Usage</strong></td>\n<td><strong>Description</strong></td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_abs\">ABS (num_expr)</a></td> \n<td>Returns the absolute (positive) value of the specified numeric expression.</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_ceiling\">CEILING (num_expr)</a></td> \n<td>Returns the smallest integer value greater than, or equal to, the specified numeric expression.</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_floor\">FLOOR (num_expr)</a></td> \n<td>Returns the largest integer less than or equal to the specified numeric expression.</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_exp\">EXP (num_expr)</a></td> \n<td>Returns the exponent of the specified numeric expression.</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_log\">LOG (num_expr [,base])</a></td> \n<td>Returns the natural logarithm of the specified numeric expression, or the logarithm using the specified base</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_log10\">LOG10 (num_expr)</a></td> \n<td>Returns the base-10 logarithmic value of the specified numeric expression.</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_round\">ROUND (num_expr)</a></td> \n<td>Returns a numeric value, rounded to the closest integer value.</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_trunc\">TRUNC (num_expr)</a></td> \n<td>Returns a numeric value, truncated to the closest integer value.</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_sqrt\">SQRT (num_expr)</a></td>   \n<td>Returns the square root of the specified numeric expression.</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_square\">SQUARE (num_expr)</a></td>   \n<td>Returns the square of the specified numeric expression.</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_power\">POWER (num_expr, num_expr)</a></td>   \n<td>Returns the power of the specified numeric expression to the value specifed.</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_sign\">SIGN (num_expr)</a></td>   \n<td>Returns the sign value (-1, 0, 1) of the specified numeric expression.</td>\n</tr>\n<tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_acos\">ACOS (num_expr)</a></td>   \n<td>Returns the angle, in radians, whose cosine is the specified numeric expression; also called arccosine.</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_asin\">ASIN (num_expr)</a></td>   \n<td>Returns the angle, in radians, whose sine is the specified numeric expression. This is also called arcsine.</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_atan\">ATAN (num_expr)</a></td>   \n<td>Returns the angle, in radians, whose tangent is the specified numeric expression. This is also called arctangent.</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_atn2\">ATN2 (num_expr)</a></td>   \n<td>Returns the angle, in radians, between the positive x-axis and the ray from the origin to the point (y, x), where x and y are the values of the two specified float expressions.</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_cos\">COS (num_expr)</a></td> \n<td>Returns the trigonometric cosine of the specified angle, in radians, in the specified expression.</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_cot\">COT (num_expr)</a></td> \n<td>Returns the trigonometric cotangent of the specified angle, in radians, in the specified numeric expression.</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_degrees\">DEGREES (num_expr)</a></td> \n<td>Returns the corresponding angle in degrees for an angle specified in radians.</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_pi\">PI ()</a></td>   \n<td>Returns the constant value of PI.</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_radians\">RADIANS (num_expr)</a></td> \n<td>Returns radians when a numeric expression, in degrees, is entered.</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_sin\">SIN (num_expr)</a></td> \n<td>Returns the trigonometric sine of the specified angle, in radians, in the specified expression.</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_tan\">TAN (num_expr)</a></td> \n<td>Returns the tangent of the input expression, in the specified expression.</td>\n</tr>\n\n</table> \n\nFor example, you can now run queries like the following:\n\n**Query**\n\n    SELECT VALUE ABS(-4)\n\n**Results**\n\n    [4]\n\nThe main difference between DocumentDB’s functions compared to ANSI SQL is that they are designed to work well with schema-less and mixed schema data. For example, if you have a document where the Size property is missing, or has a non-numeric value like “unknown”, then the document is skipped over, instead of returning an error.\n\n### Type checking functions\nThe type checking functions allow you to check the type of an expression within SQL queries. Type checking functions can be used to determine the type of properties within documents on the fly when it is variable or unknown. Here’s a table of supported built-in type checking functions.\n\n<table>\n<tr>\n  <td><strong>Usage</strong></td>\n  <td><strong>Description</strong></td>\n</tr>\n<tr>\n  <td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_is_array\">IS_ARRAY (expr)</a></td>\n  <td>Returns a Boolean indicating if the type of the value is an array.</td>\n</tr>\n<tr>\n  <td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_is_bool\">IS_BOOL (expr)</a></td>\n  <td>Returns a Boolean indicating if the type of the value is a Boolean.</td>\n</tr>\n<tr>\n  <td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_is_null\">IS_NULL (expr)</a></td>\n  <td>Returns a Boolean indicating if the type of the value is null.</td>\n</tr>\n<tr>\n  <td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_is_number\">IS_NUMBER (expr)</a></td>\n  <td>Returns a Boolean indicating if the type of the value is a number.</td>\n</tr>\n<tr>\n  <td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_is_object\">IS_OBJECT (expr)</a></td>\n  <td>Returns a Boolean indicating if the type of the value is a JSON object.</td>\n</tr>\n<tr>\n  <td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_is_string\">IS_STRING (expr)</a></td>\n  <td>Returns a Boolean indicating if the type of the value is a string.</td>\n</tr>\n<tr>\n  <td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_is_defined\">IS_DEFINED (expr)</a></td>\n  <td>Returns a Boolean indicating if the property has been assigned a value.</td>\n</tr>\n<tr>\n  <td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_is_primitive\">IS_PRIMITIVE (expr)</a></td>\n  <td>Returns a Boolean indicating if the type of the value is a string, number, Boolean or null.</td>\n</tr>\n\n</table>\n\nUsing these functions, you can now run queries like the following:\n\n**Query**\n\n    SELECT VALUE IS_NUMBER(-4)\n\n**Results**\n\n    [true]\n\n### String functions\nThe following scalar functions perform an operation on a string input value and return a string, numeric or Boolean value. Here's a table of built-in string functions:\n\nUsage|Description\n---|---\n[LENGTH (str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_length)|Returns the number of characters of the specified string expression\n[CONCAT (str_expr, str_expr [, str_expr])](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_concat)|Returns a string that is the result of concatenating two or more string values.\n[SUBSTRING (str_expr, num_expr, num_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_substring)|Returns part of a string expression.\n[STARTSWITH (str_expr, str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_startswith)|Returns a Boolean indicating whether the first string expression ends with the second\n[ENDSWITH (str_expr, str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_endswith)|Returns a Boolean indicating whether the first string expression ends with the second\n[CONTAINS (str_expr, str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_contains)|Returns a Boolean indicating whether the first string expression contains the second.\n[INDEX_OF (str_expr, str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_index_of)|Returns the starting position of the first occurrence of the second string expression within the first specified string expression, or -1 if the string is not found.\n[LEFT (str_expr, num_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_left)|Returns the left part of a string with the specified number of characters.\n[RIGHT (str_expr, num_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_right)|Returns the right part of a string with the specified number of characters.\n[LTRIM (str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_ltrim)|Returns a string expression after it removes leading blanks.\n[RTRIM (str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_rtrim)|Returns a string expression after truncating all trailing blanks.\n[LOWER (str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_lower)|Returns a string expression after converting uppercase character data to lowercase.\n[UPPER (str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_upper)|Returns a string expression after converting lowercase character data to uppercase.\n[REPLACE (str_expr, str_expr, str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_replace)|Replaces all occurrences of a specified string value with another string value.\n[REPLICATE (str_expr, num_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_replicate)|Repeats a string value a specified number of times.\n[REVERSE (str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_reverse)|Returns the reverse order of a string value.\n\nUsing these functions, you can now run queries like the following. For example, you can return the family name in uppercase as follows:\n\n**Query**\n\n    SELECT VALUE UPPER(Families.id)\n    FROM Families\n\n**Results**\n\n    [\n        \"WAKEFIELDFAMILY\", \n        \"ANDERSENFAMILY\"\n    ]\n\nOr concatenate strings like in this example:\n\n**Query**\n\n    SELECT Families.id, CONCAT(Families.address.city, \",\", Families.address.state) AS location\n    FROM Families\n\n**Results**\n\n    [{\n      \"id\": \"WakefieldFamily\",\n      \"location\": \"NY,NY\"\n    },\n    {\n      \"id\": \"AndersenFamily\",\n      \"location\": \"seattle,WA\"\n    }]\n\n\nString functions can also be used in the WHERE clause to filter results, like in the following example:\n\n**Query**\n\n    SELECT Families.id, Families.address.city\n    FROM Families\n    WHERE STARTSWITH(Families.id, \"Wakefield\")\n\n**Results**\n\n    [{\n      \"id\": \"WakefieldFamily\",\n      \"city\": \"NY\"\n    }]\n\n### Array functions\nThe following scalar functions perform an operation on an array input value and return numeric, Boolean or array value. Here's a table of built-in array functions:\n\nUsage|Description\n---|---\n[ARRAY_LENGTH (arr_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_array_length)|Returns the number of elements of the specified array expression.\n[ARRAY_CONCAT (arr_expr, arr_expr [, arr_expr])](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_array_concat)|Returns an array that is the result of concatenating two or more array values.\n[ARRAY_CONTAINS (arr_expr, expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_array_contains)|Returns a Boolean indicating whether the array contains the specified value.\n[ARRAY_SLICE (arr_expr, num_expr [, num_expr])](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_array_slice)|Returns part of an array expression.\n\nArray functions can be used to manipulate arrays within JSON. For example, here's a query that returns all documents where one of the parents is \"Robin Wakefield\". \n\n**Query**\n\n    SELECT Families.id \n    FROM Families \n    WHERE ARRAY_CONTAINS(Families.parents, { givenName: \"Robin\", familyName: \"Wakefield\" })\n\n**Results**\n\n    [{\n      \"id\": \"WakefieldFamily\"\n    }]\n\nHere's another example that uses ARRAY_LENGTH to get the number of children per family.\n\n**Query**\n\n    SELECT Families.id, ARRAY_LENGTH(Families.children) AS numberOfChildren\n    FROM Families \n\n**Results**\n\n    [{\n      \"id\": \"WakefieldFamily\",\n      \"numberOfChildren\": 2\n    },\n    {\n      \"id\": \"AndersenFamily\",\n      \"numberOfChildren\": 1\n    }]\n\nThat wraps up built-in functions, and the SQL grammar for DocumentDB. Now let's take a look at how LINQ querying works and how it interacts with the grammar we've seen so far.\n\n### Spatial functions\n\nDocumentDB supports the following Open Geospatial Consortium (OGC) built-in functions for geospatial querying. For more details on geospatial support in DocumentDB, please see [Working with geospatial data in Azure DocumentDB](documentdb-geospatial.md). \n\n<table>\n<tr>\n  <td><strong>Usage</strong></td>\n  <td><strong>Description</strong></td>\n</tr>\n<tr>\n  <td>ST_DISTANCE (point_expr, point_expr)</td>\n  <td>Returns the distance between the two GeoJSON point expressions.</td>\n</tr>\n<tr>\n  <td>ST_WITHIN (point_expr, polygon_expr)</td>\n  <td>Returns a Boolean expression indicating whether the GeoJSON point specified in the first argument is within the GeoJSON polygon in the second argument.</td>\n</tr>\n<tr>\n  <td>ST_ISVALID</td>\n  <td>Returns a Boolean value indicating whether the specified GeoJSON point or polygon expression is valid.</td>\n</tr>\n<tr>\n  <td>ST_ISVALIDDETAILED</td>\n  <td>Returns a JSON value containing a Boolean value if the specified GeoJSON point or polygon expression is valid, and if invalid, additionally the reason as a string value.</td>\n</tr>\n</table>\n\nSpatial functions can be used to perform proximity querries against spatial data. For example, here's a query that returns all family documents that are within 30 km of the specified location using the ST_DISTANCE built-in function. \n\n**Query**\n\n    SELECT f.id \n    FROM Families f \n    WHERE ST_DISTANCE(f.location, {'type': 'Point', 'coordinates':[31.9, -4.8]}) < 30000\n\n**Results**\n\n    [{\n      \"id\": \"WakefieldFamily\"\n    }]\n\nIf you include spatial indexing in your indexing policy, then \"distance queries\" will be served efficiently through the index. For more details on spatial indexing, please see the section below. If you don't have a spatial index for the specified paths, you can still perform spatial queries by specifying `x-ms-documentdb-query-enable-scan` request header with the value set to \"true\". In .NET, this can be done by passing the optional **FeedOptions** argument to queries with [EnableScanInQuery](https://msdn.microsoft.com/library/microsoft.azure.documents.client.feedoptions.enablescaninquery.aspx#P:Microsoft.Azure.Documents.Client.FeedOptions.EnableScanInQuery) set to true. \n\nST_WITHIN can be used to check if a point lies within a polygon. Commonly polygons are used to represent boundaries like zip codes, state boundaries, or natural formations. Again if you include spatial indexing in your indexing policy, then \"within\" queries will be served efficiently through the index. \n\nPolygon arguments in ST_WITHIN can contain only a single ring, i.e. the polygons must not contain holes in them. Check the [DocumentDB limits](documentdb-limits.md) for the maximum number of points allowed in a polygon for an ST_WITHIN query.\n\n**Query**\n\n    SELECT * \n    FROM Families f \n    WHERE ST_WITHIN(f.location, {\n        'type':'Polygon', \n        'coordinates': [[[31.8, -5], [32, -5], [32, -4.7], [31.8, -4.7], [31.8, -5]]]\n    })\n\n**Results**\n\n    [{\n      \"id\": \"WakefieldFamily\",\n    }]\n    \n>[AZURE.NOTE] Similar to how mismatched types works in DocumentDB query, if the location value specified in either argument is malformed or invalid, then it will evaluate to **undefined** and the evaluated document to be skipped from the query results. If your query returns no results, run ST_ISVALIDDETAILED To debug why the spatail type is invalid.     \n\nST_ISVALID and ST_ISVALIDDETAILED can be used to check if a spatial object is valid. For example, the following query checks the validity of a point with an out of range latitude value (-132.8). ST_ISVALID returns just a Boolean value, and ST_ISVALIDDETAILED returns the Boolean and a string containing the reason why it is considered invalid.\n\n**Query**\n\n    SELECT ST_ISVALID({ \"type\": \"Point\", \"coordinates\": [31.9, -132.8] })\n\n**Results**\n\n    [{\n      \"$1\": false\n    }]\n\nThese functions can also be used to validate polygons. For example, here we use ST_ISVALIDDETAILED to validate a polygon that is not closed. \n\n**Query**\n\n    SELECT ST_ISVALIDDETAILED({ \"type\": \"Polygon\", \"coordinates\": [[ \n        [ 31.8, -5 ], [ 31.8, -4.7 ], [ 32, -4.7 ], [ 32, -5 ] \n        ]]})\n\n**Results**\n\n    [{\n       \"$1\": { \n          \"valid\": false, \n          \"reason\": \"The Polygon input is not valid because the start and end points of the ring number 1 are not the same. Each ring of a polygon must have the same start and end points.\" \n        }\n    }]\n    \nThat wraps up built-in functions, and the SQL grammar for DocumentDB. Now let's take a look at how LINQ querying works and how it interacts with the grammar we've seen so far.\n\n## LINQ to DocumentDB SQL\nLINQ is a .NET programming model that expresses computation as queries on streams of objects. DocumentDB provides a client side library to interface with LINQ by facilitating a conversion between JSON and .NET objects and a mapping from a subset of LINQ queries to DocumentDB queries. \n\nThe picture below shows the architecture of supporting LINQ queries using DocumentDB.  Using the DocumentDB client, developers can create an **IQueryable** object that directly queries the DocumentDB query provider, which then translates the LINQ query into a DocumentDB query. The query is then passed to the DocumentDB server to retrieve a set of results in JSON format. The returned results are deserialized into a stream of .NET objects on the client side.\n\n![][1]\n \n\n\n### .NET and JSON mapping\nThe mapping between .NET objects and JSON documents is natural - each data member field is mapped to a JSON object, where the field name is mapped to the \"key\" part of the object and the \"value\" part is recursively mapped to the value part of the object. Consider the following example. The Family object created is mapped to the JSON document as shown below. And vice versa, the JSON document is mapped back to a .NET object.\n\n**C# Class**\n\n    public class Family\n    {\n        [JsonProperty(PropertyName=\"id\")]\n        public string Id;\n        public Parent[] parents;\n        public Child[] children;\n        public bool isRegistered;\n    };\n    \n    public struct Parent\n    {\n        public string familyName;\n        public string givenName;\n    };\n    \n    public class Child\n    {\n        public string familyName;\n        public string givenName;\n        public string gender;\n        public int grade;\n        public List<Pet> pets;\n    };\n    \n    public class Pet\n    {\n        public string givenName;\n    };\n    \n    public class Address\n    {\n        public string state;\n        public string county;\n        public string city;\n    };\n    \n    // Create a Family object.\n    Parent mother = new Parent { familyName= \"Wakefield\", givenName=\"Robin\" };\n    Parent father = new Parent { familyName = \"Miller\", givenName = \"Ben\" };\n    Child child = new Child { familyName=\"Merriam\", givenName=\"Jesse\", gender=\"female\", grade=1 };\n    Pet pet = new Pet { givenName = \"Fluffy\" };\n    Address address = new Address { state = \"NY\", county = \"Manhattan\", city = \"NY\" };\n    Family family = new Family { Id = \"WakefieldFamily\", parents = new Parent [] { mother, father}, children = new Child[] { child }, isRegistered = false };\n\n\n**JSON**  \n\n    {\n        \"id\": \"WakefieldFamily\",\n        \"parents\": [\n            { \"familyName\": \"Wakefield\", \"givenName\": \"Robin\" },\n            { \"familyName\": \"Miller\", \"givenName\": \"Ben\" }\n        ],\n        \"children\": [\n            {\n                \"familyName\": \"Merriam\", \n                \"givenName\": \"Jesse\", \n                \"gender\": \"female\", \n                \"grade\": 1,\n                \"pets\": [\n                    { \"givenName\": \"Goofy\" },\n                    { \"givenName\": \"Shadow\" }\n                ]\n            },\n            { \n              \"familyName\": \"Miller\", \n              \"givenName\": \"Lisa\", \n              \"gender\": \"female\", \n              \"grade\": 8 \n            }\n        ],\n        \"address\": { \"state\": \"NY\", \"county\": \"Manhattan\", \"city\": \"NY\" },\n        \"isRegistered\": false\n    };\n\n\n\n### LINQ to SQL translation\nThe DocumentDB query provider performs a best effort mapping from a LINQ query into a DocumentDB SQL query. In the following description, we assume the reader has a basic familiarity of LINQ.\n\nFirst, for the type system, we support all JSON primitive types – numeric types, boolean, string, and null. Only these JSON types are supported. The following scalar expressions are supported.\n\n-   Constant values – these includes constant values of the primitive data types at the time the query is evaluated.\n\n-   Property/array index expressions – these expressions refer to the property of an object or an array element.\n\n        family.Id;\n        family.children[0].familyName;\n        family.children[0].grade;\n        family.children[n].grade; //n is an int variable\n\n-   Arithmetic expressions - These include common arithmetic expressions on numerical and boolean values. For the complete list, refer to the SQL specification.\n\n        2 * family.children[0].grade;\n        x + y;\n\n-   String comparison expression - these include comparing a string value to some constant string value.  \n \n        mother.familyName == \"Smith\";\n        child.givenName == s; //s is a string variable\n\n-   Object/array creation expression - these expressions return an object of compound value type or anonymous type or an array of such objects. These values can be nested.\n\n        new Parent { familyName = \"Smith\", givenName = \"Joe\" };\n        new { first = 1, second = 2 }; //an anonymous type with 2 fields              \n        new int[] { 3, child.grade, 5 };\n\n### Query operators\nHere are some examples that illustrate how some of the standard LINQ query operators are translated down to DocumentDB queries.\n\n#### Select Operator\nThe syntax is `input.Select(x => f(x))`, where `f` is a scalar expression.\n\n**LINQ lambda expression**\n\n    input.Select(family => family.parents[0].familyName);\n\n**SQL** \n\n    SELECT VALUE f.parents[0].familyName\n    FROM Families f\n\n\n\n**LINQ lambda expression**\n\n    input.Select(family => family.children[0].grade + c); // c is an int variable\n\n\n**SQL** \n\n    SELECT VALUE f.children[0].grade + c\n    FROM Families f \n\n\n\n**LINQ lambda expression**\n\n    input.Select(family => new\n    {\n        name = family.children[0].familyName,\n        grade = family.children[0].grade + 3\n    });\n\n\n**SQL** \n\n    SELECT VALUE {\"name\":f.children[0].familyName, \n                  \"grade\": f.children[0].grade + 3 }\n    FROM Families f\n\n\n\n#### SelectMany operator\nThe syntax is `input.SelectMany(x => f(x))`, where `f` is a scalar expression that returns a collection type.\n\n**LINQ lambda expression**\n\n    input.SelectMany(family => family.children);\n\n**SQL** \n\n    SELECT VALUE child\n    FROM child IN Families.children\n\n\n\n#### Where operator\nThe syntax is `input.Where(x => f(x))`, where `f` is a scalar expression which returns a Boolean value.\n\n**LINQ lambda expression**\n\n    input.Where(family=> family.parents[0].familyName == \"Smith\");\n\n**SQL** \n\n    SELECT *\n    FROM Families f\n    WHERE f.parents[0].familyName = \"Smith\" \n\n\n\n**LINQ lambda expression**\n\n    input.Where(\n        family => family.parents[0].familyName == \"Smith\" && \n        family.children[0].grade < 3);\n\n**SQL** \n\n    SELECT *\n    FROM Families f\n    WHERE f.parents[0].familyName = \"Smith\"\n    AND f.children[0].grade < 3\n\n\n### Composite queries\nThe above operators can be composed to form more powerful queries. Since DocumentDB supports nested collections, the composition can either be concatenated or nested.\n\n#### Concatenation \n\nThe syntax is `input(.|.SelectMany())(.Select()|.Where())*`. A concatenated query can start with an optional `SelectMany` query followed by multiple `Select` or `Where` operators.\n\n\n**LINQ lambda expression**\n\n    input.Select(family=>family.parents[0])\n        .Where(familyName == \"Smith\");\n\n**SQL**\n\n    SELECT *\n    FROM Families f\n    WHERE f.parents[0].familyName = \"Smith\"\n\n\n\n**LINQ lambda expression**\n\n    input.Where(family => family.children[0].grade > 3)\n        .Select(family => family.parents[0].familyName);\n\n**SQL** \n\n    SELECT VALUE f.parents[0].familyName\n    FROM Families f\n    WHERE f.children[0].grade > 3\n\n\n\n**LINQ lambda expression**\n\n    input.Select(family => new { grade=family.children[0].grade}).\n        Where(anon=> anon.grade < 3);\n            \n**SQL** \n\n    SELECT *\n    FROM Families f\n    WHERE ({grade: f.children[0].grade}.grade > 3)\n\n\n\n**LINQ lambda expression**\n\n    input.SelectMany(family => family.parents)\n        .Where(parent => parents.familyName == \"Smith\");\n\n**SQL** \n\n    SELECT *\n    FROM p IN Families.parents\n    WHERE p.familyName = \"Smith\"\n\n\n\n#### Nesting\n\nThe syntax is `input.SelectMany(x=>x.Q())` where Q is a `Select`, `SelectMany`, or `Where` operator.\n\nIn a nested query, the inner query is applied to each element of the outer collection. One important feature is that the inner query can refer to the fields of the elements in the outer collection like self-joins.\n\n**LINQ lambda expression**\n\n    input.SelectMany(family=> \n        family.parents.Select(p => p.familyName));\n\n**SQL** \n\n    SELECT VALUE p.familyName\n    FROM Families f\n    JOIN p IN f.parents\n\n\n**LINQ lambda expression**\n\n    input.SelectMany(family => \n        family.children.Where(child => child.familyName == \"Jeff\"));\n            \n**SQL** \n\n    SELECT *\n    FROM Families f\n    JOIN c IN f.children\n    WHERE c.familyName = \"Jeff\"\n\n\n\n**LINQ lambda expression**\n            \n    input.SelectMany(family => family.children.Where(\n        child => child.familyName == family.parents[0].familyName));\n\n**SQL** \n\n    SELECT *\n    FROM Families f\n    JOIN c IN f.children\n    WHERE c.familyName = f.parents[0].familyName\n\n\n## Executing queries\nDocumentDB exposes resources through a REST API that can be called by any language capable of making HTTP/HTTPS requests. Additionally, DocumentDB offers programming libraries for several popular languages like .NET, Node.js, JavaScript and Python. The REST API and the various libraries all support querying through SQL. The .NET SDK supports LINQ querying in addition to SQL.\n\nThe following examples show how to create a query and submit it against a DocumentDB database account.\n\n### REST API\nDocumentDB offers an open RESTful programming model over HTTP. Database accounts can be provisioned using an Azure subscription. The DocumentDB resource model consists of a sets of resources under a database account, each  of which is addressable using a logical and stable URI. A set of resources is referred to as a feed in this document. A database account consists of a set of databases, each containing multiple collections, each of which in-turn contain documents, UDFs, and other resource types.\n\nThe basic interaction model with these resources is through the HTTP verbs GET, PUT, POST and DELETE with their standard interpretation. The POST verb is used for creation of a new resource, for executing a stored procedure or for issuing a DocumentDB query. Queries are always read only operations with no side-effects.\n\nThe following examples show a POST for a DocumentDB query made against a collection containing the two sample documents we've reviewed so far. The query has a simple filter on the JSON name property. Note the use of the `x-ms-documentdb-isquery` and Content-Type: `application/query+json` headers to denote that the operation is a query.\n\n\n**Request**\n\n    POST https://<REST URI>/docs HTTP/1.1\n    ...\n    x-ms-documentdb-isquery: True\n    Content-Type: application/query+json\n\n    {      \n        \"query\": \"SELECT * FROM Families f WHERE f.id = @familyId\",     \n        \"parameters\": [          \n            {\"name\": \"@familyId\", \"value\": \"AndersenFamily\"}         \n        ] \n    }\n    \n\n**Results**\n\n    HTTP/1.1 200 Ok\n    x-ms-activity-id: 8b4678fa-a947-47d3-8dd3-549a40da6eed\n    x-ms-item-count: 1\n    x-ms-request-charge: 0.32\n    \n    <indented for readability, results highlighted>\n    \n    {  \n       \"_rid\":\"u1NXANcKogE=\",\n       \"Documents\":[  \n          {  \n             \"id\":\"AndersenFamily\",\n             \"lastName\":\"Andersen\",\n             \"parents\":[  \n                {  \n                   \"firstName\":\"Thomas\"\n                },\n                {  \n                   \"firstName\":\"Mary Kay\"\n                }\n             ],\n             \"children\":[  \n                {  \n                   \"firstName\":\"Henriette Thaulow\",\n                   \"gender\":\"female\",\n                   \"grade\":5,\n                   \"pets\":[  \n                      {  \n                         \"givenName\":\"Fluffy\"\n                      }\n                   ]\n                }\n             ],\n             \"address\":{  \n                \"state\":\"WA\",\n                \"county\":\"King\",\n                \"city\":\"seattle\"\n             },\n             \"_rid\":\"u1NXANcKogEcAAAAAAAAAA==\",\n             \"_ts\":1407691744,\n             \"_self\":\"dbs\\/u1NXAA==\\/colls\\/u1NXANcKogE=\\/docs\\/u1NXANcKogEcAAAAAAAAAA==\\/\",\n             \"_etag\":\"00002b00-0000-0000-0000-53e7abe00000\",\n             \"_attachments\":\"_attachments\\/\"\n          }\n       ],\n       \"count\":1\n    }\n\n\nThe second example shows a more complex query that returns multiple results from the join.\n\n**Request**\n\n    POST https://<REST URI>/docs HTTP/1.1\n    ...\n    x-ms-documentdb-isquery: True\n    Content-Type: application/query+json\n    \n    {      \n        \"query\": \"SELECT \n                     f.id AS familyName, \n                     c.givenName AS childGivenName, \n                     c.firstName AS childFirstName, \n                     p.givenName AS petName \n                  FROM Families f \n                  JOIN c IN f.children \n                  JOIN p in c.pets\",     \n        \"parameters\": [] \n    }\n\n\n**Results**\n\n    HTTP/1.1 200 Ok\n    x-ms-activity-id: 568f34e3-5695-44d3-9b7d-62f8b83e509d\n    x-ms-item-count: 1\n    x-ms-request-charge: 7.84\n    \n    <indented for readability, results highlighted>\n    \n    {  \n       \"_rid\":\"u1NXANcKogE=\",\n       \"Documents\":[  \n          {  \n             \"familyName\":\"AndersenFamily\",\n             \"childFirstName\":\"Henriette Thaulow\",\n             \"petName\":\"Fluffy\"\n          },\n          {  \n             \"familyName\":\"WakefieldFamily\",\n             \"childGivenName\":\"Jesse\",\n             \"petName\":\"Goofy\"\n          },\n          {  \n             \"familyName\":\"WakefieldFamily\",\n             \"childGivenName\":\"Jesse\",\n             \"petName\":\"Shadow\"\n          }\n       ],\n       \"count\":3\n    }\n\n\nIf a query's results cannot fit within a single page of results, then the REST API returns a continuation token through the `x-ms-continuation-token` response header. Clients can paginate results by including the header in subsequent results. The number of results per page can also be controlled through the `x-ms-max-item-count` number header.\n\nTo manage the data consistency policy for queries, use the `x-ms-consistency-level` header like all REST API requests. For session consistency, it is required to also echo the latest `x-ms-session-token` Cookie header in the query request. Note that the queried collection's indexing policy can also influence the consistency of query results. With the default indexing policy settings, for collections the index is always current with the document contents and query results will match the consistency chosen for data. If the indexing policy is relaxed to Lazy, then queries can return stale results. For more information, refer to [DocumentDB Consistency Levels] [consistency-levels].\n\nIf the configured indexing policy on the collection cannot support the specified query, the DocumentDB server returns 400 \"Bad Request\". This is returned for range queries against paths configured for hash (equality) lookups, and for paths explicitly excluded from indexing. The `x-ms-documentdb-query-enable-scan` header can be specified to allow the query to perform a scan when an index is not available.\n\n### C# (.NET) SDK\nThe .NET SDK supports both LINQ and SQL querying. The following example shows how to perform the simple filter query introduced earlier in this document.\n\n\n    foreach (var family in client.CreateDocumentQuery(collectionLink, \n        \"SELECT * FROM Families f WHERE f.id = \\\"AndersenFamily\\\"\"))\n    {\n        Console.WriteLine(\"\\tRead {0} from SQL\", family);\n    }\n    \n    SqlQuerySpec query = new SqlQuerySpec(\"SELECT * FROM Families f WHERE f.id = @familyId\");\n    query.Parameters = new SqlParameterCollection();\n    query.Parameters.Add(new SqlParameter(\"@familyId\", \"AndersenFamily\"));\n\n    foreach (var family in client.CreateDocumentQuery(collectionLink, query))\n    {\n        Console.WriteLine(\"\\tRead {0} from parameterized SQL\", family);\n    }\n\n    foreach (var family in (\n        from f in client.CreateDocumentQuery(collectionLink)\n        where f.Id == \"AndersenFamily\"\n        select f))\n    {\n        Console.WriteLine(\"\\tRead {0} from LINQ query\", family);\n    }\n    \n    foreach (var family in client.CreateDocumentQuery(collectionLink)\n        .Where(f => f.Id == \"AndersenFamily\")\n        .Select(f => f))\n    {\n        Console.WriteLine(\"\\tRead {0} from LINQ lambda\", family);\n    }\n\n\nThis sample compares two properties for equality within each document and uses anonymous projections. \n\n\n    foreach (var family in client.CreateDocumentQuery(collectionLink,\n        @\"SELECT {\"\"Name\"\": f.id, \"\"City\"\":f.address.city} AS Family \n        FROM Families f \n        WHERE f.address.city = f.address.state\"))\n    {\n        Console.WriteLine(\"\\tRead {0} from SQL\", family);\n    }\n    \n    foreach (var family in (\n        from f in client.CreateDocumentQuery<Family>(collectionLink)\n        where f.address.city == f.address.state\n        select new { Name = f.Id, City = f.address.city }))\n    {\n        Console.WriteLine(\"\\tRead {0} from LINQ query\", family);\n    }\n    \n    foreach (var family in\n        client.CreateDocumentQuery<Family>(collectionLink)\n        .Where(f => f.address.city == f.address.state)\n        .Select(f => new { Name = f.Id, City = f.address.city }))\n    {\n        Console.WriteLine(\"\\tRead {0} from LINQ lambda\", family);\n    }\n\n\nThe next sample shows joins, expressed through LINQ SelectMany.\n\n\n    foreach (var pet in client.CreateDocumentQuery(collectionLink,\n          @\"SELECT p\n            FROM Families f \n                 JOIN c IN f.children \n                 JOIN p in c.pets \n            WHERE p.givenName = \"\"Shadow\"\"\"))\n    {\n        Console.WriteLine(\"\\tRead {0} from SQL\", pet);\n    }\n    \n    // Equivalent in Lambda expressions\n    foreach (var pet in\n        client.CreateDocumentQuery<Family>(collectionLink)\n        .SelectMany(f => f.children)\n        .SelectMany(c => c.pets)\n        .Where(p => p.givenName == \"Shadow\"))\n    {\n        Console.WriteLine(\"\\tRead {0} from LINQ lambda\", pet);\n    }\n\n\n\nThe .NET client automatically iterates through all the pages of query results in the foreach blocks as shown above. The query options introduced in the REST API section are also available in the .NET SDK using the `FeedOptions` and `FeedResponse` classes in the CreateDocumentQuery method. The number of pages can be controlled using the `MaxItemCount` setting. \n\nDevelopers can also explicitly control paging by creating `IDocumentQueryable` using the `IQueryable` object, then by reading the` ResponseContinuationToken` values and passing them back as `RequestContinuationToken` in `FeedOptions`. `EnableScanInQuery` can be set to enable scans when the query cannot be supported by the configured indexing policy.\n\nRefer to [DocumentDB .NET samples](https://github.com/Azure/azure-documentdb-net) for more samples containing queries. \n\n### JavaScript server-side API \nDocumentDB provides a programming model for executing JavaScript based application logic directly on the collections using stored procedures and triggers. The JavaScript logic registered at a collection level can then issue database operations on the operations on the documents of the given collection. These operations are wrapped in ambient ACID transactions.\n\nThe following example show how to use the queryDocuments in the JavaScript server API to make queries from inside stored procedures and triggers.\n\n\n    function businessLogic(name, author) {\n        var context = getContext();\n        var collectionManager = context.getCollection();\n        var collectionLink = collectionManager.getSelfLink()\n    \n        // create a new document.\n        collectionManager.createDocument(collectionLink,\n            { name: name, author: author },\n            function (err, documentCreated) {\n                if (err) throw new Error(err.message);\n    \n                // filter documents by author\n                var filterQuery = \"SELECT * from root r WHERE r.author = 'George R.'\";\n                collectionManager.queryDocuments(collectionLink,\n                    filterQuery,\n                    function (err, matchingDocuments) {\n                        if (err) throw new Error(err.message);\n    context.getResponse().setBody(matchingDocuments.length);\n    \n                        // Replace the author name for all documents that satisfied the query.\n                        for (var i = 0; i < matchingDocuments.length; i++) {\n                            matchingDocuments[i].author = \"George R. R. Martin\";\n                            // we don't need to execute a callback because they are in parallel\n                            collectionManager.replaceDocument(matchingDocuments[i]._self,\n                                matchingDocuments[i]);\n                        }\n                    })\n            });\n    }\n\n\n##References\n1.  [Introduction to Azure DocumentDB][introduction]\n2.  [DocumentDB SQL specification](http://go.microsoft.com/fwlink/p/?LinkID=510612)\n3.  [DocumentDB .NET samples](https://github.com/Azure/azure-documentdb-net)\n4.  [DocumentDB Consistency Levels][consistency-levels]\n5.  ANSI SQL 2011 [http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=53681](http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=53681)\n6.  JSON [http://json.org/](http://json.org/)\n7.  Javascript Specification [http://www.ecma-international.org/publications/standards/Ecma-262.htm](http://www.ecma-international.org/publications/standards/Ecma-262.htm) \n8.  LINQ [http://msdn.microsoft.com/library/bb308959.aspx](http://msdn.microsoft.com/library/bb308959.aspx) \n9.  Query evaluation techniques for large databases [http://dl.acm.org/citation.cfm?id=152611](http://dl.acm.org/citation.cfm?id=152611)\n10. Query Processing in Parallel Relational Database Systems, IEEE Computer Society Press, 1994\n11. Lu, Ooi, Tan, Query Processing in Parallel Relational Database Systems, IEEE Computer Society Press, 1994.\n12. Christopher Olston, Benjamin Reed, Utkarsh Srivastava, Ravi Kumar, Andrew Tomkins: Pig Latin: A Not-So-Foreign Language for Data Processing, SIGMOD 2008.\n13.     G. Graefe. The Cascades framework for query optimization. IEEE Data Eng. Bull., 18(3): 1995.\n\n\n[1]: ./media/documentdb-sql-query/sql-query1.png\n[introduction]: documentdb-introduction.md\n[consistency-levels]: documentdb-consistency-levels.md\n \n\ntest\n"
}