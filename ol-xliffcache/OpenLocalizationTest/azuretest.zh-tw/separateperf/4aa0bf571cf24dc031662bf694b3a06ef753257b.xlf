<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Create a MongoDB cluster on Ubuntu using a Azure Resource Manager template</source>
          <target state="new">Create a MongoDB cluster on Ubuntu using a Azure Resource Manager template</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Create a MongoDB cluster on Ubuntu using a Azure Resource Manager template via Azure PowerShell or the Azure CLI</source>
          <target state="new">Create a MongoDB cluster on Ubuntu using a Azure Resource Manager template via Azure PowerShell or the Azure CLI</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Create a MongoDB cluster on Ubuntu using a Azure Resource Manager template</source>
          <target state="new">Create a MongoDB cluster on Ubuntu using a Azure Resource Manager template</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>MongoDB is an open-source document database that provides high performance, high availability, and automatic scaling.</source>
          <target state="new">MongoDB is an open-source document database that provides high performance, high availability, and automatic scaling.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>MongoDB can be installed as a stand-alone database or within a cluster, leveraging built-in replication capabilities.</source>
          <target state="new">MongoDB can be installed as a stand-alone database or within a cluster, leveraging built-in replication capabilities.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>In some cases, you can use replication to increase read capacity.</source>
          <target state="new">In some cases, you can use replication to increase read capacity.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Clients have the ability to send read and write operations to different servers.</source>
          <target state="new">Clients have the ability to send read and write operations to different servers.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>You can also maintain copies in different data centers to increase the locality and availability of data for distributed applications.</source>
          <target state="new">You can also maintain copies in different data centers to increase the locality and availability of data for distributed applications.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>With MongoDB, replication also provides redundancy and increases data availability.</source>
          <target state="new">With MongoDB, replication also provides redundancy and increases data availability.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>With multiple copies of data on different database servers, replication protects a database from the loss of a single server.</source>
          <target state="new">With multiple copies of data on different database servers, replication protects a database from the loss of a single server.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Replication also allows you to recover from hardware failure and service interruptions.</source>
          <target state="new">Replication also allows you to recover from hardware failure and service interruptions.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>With additional copies of the data, you can dedicate one to disaster recovery, reporting, or backup.</source>
          <target state="new">With additional copies of the data, you can dedicate one to disaster recovery, reporting, or backup.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>In addition to the various flavors that were already available in the Azure Marketplace, now you can also easily deploy a new MongoDB cluster on Ubuntu VMs using a Azure Resource Manager template deployed through <bpt id="p1">[</bpt>Azure PowerShell<ept id="p1">](../powershell-install-configure.md)</ept> or the <bpt id="p2">[</bpt>Azure CLI<ept id="p2">](../xplat-cli.md)</ept>.</source>
          <target state="new">In addition to the various flavors that were already available in the Azure Marketplace, now you can also easily deploy a new MongoDB cluster on Ubuntu VMs using a Azure Resource Manager template deployed through <bpt id="p1">[</bpt>Azure PowerShell<ept id="p1">](../powershell-install-configure.md)</ept> or the <bpt id="p2">[</bpt>Azure CLI<ept id="p2">](../xplat-cli.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Newly deployed clusters based on this template will have the topology described in the following diagram, although other topologies can be easily achieved by customizing the template presented in this article.</source>
          <target state="new">Newly deployed clusters based on this template will have the topology described in the following diagram, although other topologies can be easily achieved by customizing the template presented in this article.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>cluster-architecture</source>
          <target state="new">cluster-architecture</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Through a parameter you can define the number of nodes that will be deployed in the new MongoDB cluster and, based on another parameter, a VM instance (Jumpbox) with a public IP address may be also deployed within the same VNET, giving you the ability to connect to the cluster from public Internet and perform any sort of administrative task related that cluster.</source>
          <target state="new">Through a parameter you can define the number of nodes that will be deployed in the new MongoDB cluster and, based on another parameter, a VM instance (Jumpbox) with a public IP address may be also deployed within the same VNET, giving you the ability to connect to the cluster from public Internet and perform any sort of administrative task related that cluster.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Another option available as a parameter, is the ability to add an Arbiter node to the replica set, that is typically suggested when that has an even number of members.</source>
          <target state="new">Another option available as a parameter, is the ability to add an Arbiter node to the replica set, that is typically suggested when that has an even number of members.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For more information on MongoDB replication topologies and details, see the official <bpt id="p1">[</bpt>MongoDB documentation<ept id="p1">](http://docs.mongodb.org/manual/core/replication-introduction/)</ept>.</source>
          <target state="new">For more information on MongoDB replication topologies and details, see the official <bpt id="p1">[</bpt>MongoDB documentation<ept id="p1">](http://docs.mongodb.org/manual/core/replication-introduction/)</ept>.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Once the deployment is complete you can access the Jumpbox using the configured DNS address on SSH port 22.</source>
          <target state="new">Once the deployment is complete you can access the Jumpbox using the configured DNS address on SSH port 22.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Before diving into more details related to the Azure Resource Manager and the template we will use for this deployment, make sure you have Azure PowerShell or the Azure CLI configured correctly.</source>
          <target state="new">Before diving into more details related to the Azure Resource Manager and the template we will use for this deployment, make sure you have Azure PowerShell or the Azure CLI configured correctly.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Create a MongoDB cluster with a Resource Manager template</source>
          <target state="new">Create a MongoDB cluster with a Resource Manager template</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Follow these steps to create a MongoDB cluster using a Resource Manager template from the Github template repository.</source>
          <target state="new">Follow these steps to create a MongoDB cluster using a Resource Manager template from the Github template repository.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Each step will include directions for both Azure PowerShell and the Azure CLI.</source>
          <target state="new">Each step will include directions for both Azure PowerShell and the Azure CLI.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Step 1-a: Download the template files using PowerShell</source>
          <target state="new">Step 1-a: Download the template files using PowerShell</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Create a local folder for the JSON template and other associated files (for example, C:\Azure\Templates\MongoDB).</source>
          <target state="new">Create a local folder for the JSON template and other associated files (for example, C:\Azure\Templates\MongoDB).</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>In the following example, substitute the folder name of your local folder and run the commands.</source>
          <target state="new">In the following example, substitute the folder name of your local folder and run the commands.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Step 1-b: Download the template files using the Azure CLI</source>
          <target state="new">Step 1-b: Download the template files using the Azure CLI</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The following example shows how to clone the entire template repository using a Git client of your choice.</source>
          <target state="new">The following example shows how to clone the entire template repository using a Git client of your choice.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>When completed, look for the mongodb-high-availability folder in your C:\Azure\Templates directory.</source>
          <target state="new">When completed, look for the mongodb-high-availability folder in your C:\Azure\Templates directory.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Step 2: (optional) Understand the template parameters</source>
          <target state="new">Step 2: (optional) Understand the template parameters</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>When you deploy non-trivial solutions like a MongoDB cluster, you must specify a set of configuration parameters to deal with a number of required settings.</source>
          <target state="new">When you deploy non-trivial solutions like a MongoDB cluster, you must specify a set of configuration parameters to deal with a number of required settings.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>By declaring these parameters in the template definition, it’s possible to specify values during deployment through an external file or in the command line.</source>
          <target state="new">By declaring these parameters in the template definition, it’s possible to specify values during deployment through an external file or in the command line.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>In the parameters section at the top of the azuredeploy.json file, you’ll find the set of parameters that are required by the template to configure a MongoDB cluster.</source>
          <target state="new">In the parameters section at the top of the azuredeploy.json file, you’ll find the set of parameters that are required by the template to configure a MongoDB cluster.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The following example shows the parameters section from this template's azuredeploy.json file.</source>
          <target state="new">The following example shows the parameters section from this template's azuredeploy.json file.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Each parameter has details such as data type and allowed values.</source>
          <target state="new">Each parameter has details such as data type and allowed values.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>This allows for validation of parameters passed during template execution in an interactive mode (for example, PowerShell or Azure CLI), as well as a self-discovery UI that could be dynamically-built by parsing the list of required parameters and their descriptions.</source>
          <target state="new">This allows for validation of parameters passed during template execution in an interactive mode (for example, PowerShell or Azure CLI), as well as a self-discovery UI that could be dynamically-built by parsing the list of required parameters and their descriptions.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Step 3-a: Deploy a MongoDB cluster with a template using PowerShell</source>
          <target state="new">Step 3-a: Deploy a MongoDB cluster with a template using PowerShell</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Prepare a parameters file for your deployment by creating a JSON file containing runtime values for all parameters.</source>
          <target state="new">Prepare a parameters file for your deployment by creating a JSON file containing runtime values for all parameters.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>This file will then be passed as a single entity to the deployment command.</source>
          <target state="new">This file will then be passed as a single entity to the deployment command.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>If you do not include a parameters file, PowerShell will use any default values specified in the template, and then prompt you to fill in the remaining values.</source>
          <target state="new">If you do not include a parameters file, PowerShell will use any default values specified in the template, and then prompt you to fill in the remaining values.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The following example shows the set of parameters from the azuredeploy-parameters.json file.</source>
          <target state="new">The following example shows the set of parameters from the azuredeploy-parameters.json file.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Fill in an Azure deployment name, resource group name, Azure location, and the folder of your saved JSON deployment file.</source>
          <target state="new">Fill in an Azure deployment name, resource group name, Azure location, and the folder of your saved JSON deployment file.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Then run the following commands.</source>
          <target state="new">Then run the following commands.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>When you run the <bpt id="p1">**</bpt>New-AzureResourceGroupDeployment<ept id="p1">**</ept> command, this will extract parameter values from the JSON parameters file, and will start executing the template accordingly.</source>
          <target state="new">When you run the <bpt id="p1">**</bpt>New-AzureResourceGroupDeployment<ept id="p1">**</ept> command, this will extract parameter values from the JSON parameters file, and will start executing the template accordingly.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Defining and using multiple parameter files with your different environments (for example, Test, Production, etc.) will promote template reuse and simplify complex multi-environment solutions.</source>
          <target state="new">Defining and using multiple parameter files with your different environments (for example, Test, Production, etc.) will promote template reuse and simplify complex multi-environment solutions.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>When deploying, keep in mind that a new Azure storage account needs to be created so the name you provide as the storage account parameter must be unique and meet all requirements for an Azure storage account (lowercase letters and numbers only).</source>
          <target state="new">When deploying, keep in mind that a new Azure storage account needs to be created so the name you provide as the storage account parameter must be unique and meet all requirements for an Azure storage account (lowercase letters and numbers only).</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>During and after deployment, you can check all the requests that were made during provisioning, including any errors that occurred.</source>
          <target state="new">During and after deployment, you can check all the requests that were made during provisioning, including any errors that occurred.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>To do that, go to the <bpt id="p1">[</bpt>Azure portal<ept id="p1">](https://portal.azure.com)</ept> and do the following:</source>
          <target state="new">To do that, go to the <bpt id="p1">[</bpt>Azure portal<ept id="p1">](https://portal.azure.com)</ept> and do the following:</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Click <bpt id="p1">**</bpt>Browse<ept id="p1">**</ept> on the left navigation bar, scroll down and then click <bpt id="p2">**</bpt>Resource Groups<ept id="p2">**</ept>.</source>
          <target state="new">Click <bpt id="p1">**</bpt>Browse<ept id="p1">**</ept> on the left navigation bar, scroll down and then click <bpt id="p2">**</bpt>Resource Groups<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>After clicking the resource group that you just created, it will bring up the Resource group blade.</source>
          <target state="new">After clicking the resource group that you just created, it will bring up the Resource group blade.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>By clicking the "Events” bar graph in the "Monitoring” part of the Resource group blade, you can see the events for your deployment.</source>
          <target state="new">By clicking the "Events” bar graph in the "Monitoring” part of the Resource group blade, you can see the events for your deployment.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Clicking an individual event lets you drill further down into the details of each individual operation made on behalf of the template.</source>
          <target state="new">Clicking an individual event lets you drill further down into the details of each individual operation made on behalf of the template.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>After your tests, if you need to remove this resource group and all of its resources (the storage account, virtual machine, and virtual network), use the following command.</source>
          <target state="new">After your tests, if you need to remove this resource group and all of its resources (the storage account, virtual machine, and virtual network), use the following command.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Step 3-b: Deploy a MongoDB cluster with a template using the Azure CLI</source>
          <target state="new">Step 3-b: Deploy a MongoDB cluster with a template using the Azure CLI</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>To deploy a MongoDB cluster via the Azure CLI, first create a resource group by specifying a name and a location with the following command.</source>
          <target state="new">To deploy a MongoDB cluster via the Azure CLI, first create a resource group by specifying a name and a location with the following command.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Pass this resource group name, the location of the JSON template file, and the location of the parameters file (see the earlier PowerShell section for details) into the following command.</source>
          <target state="new">Pass this resource group name, the location of the JSON template file, and the location of the parameters file (see the earlier PowerShell section for details) into the following command.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>You can check the status of individual resources deployments with the following command.</source>
          <target state="new">You can check the status of individual resources deployments with the following command.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>A tour of the MongoDB template structure and file organization</source>
          <target state="new">A tour of the MongoDB template structure and file organization</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>To design a robust and reusable Azure Resource Manager template, additional thinking is needed to organize the series of complex and interrelated tasks required during the deployment of a complex solution like MongoDB.</source>
          <target state="new">To design a robust and reusable Azure Resource Manager template, additional thinking is needed to organize the series of complex and interrelated tasks required during the deployment of a complex solution like MongoDB.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Leveraging Azure Resource Manager <bpt id="p1">*</bpt>template linking<ept id="p1">*</ept> and <bpt id="p2">*</bpt>resource looping<ept id="p2">*</ept> in addition to script execution through related extensions, it’s possible to implement a modular approach that can be reused with virtually any complex template-based deployment.</source>
          <target state="new">Leveraging Azure Resource Manager <bpt id="p1">*</bpt>template linking<ept id="p1">*</ept> and <bpt id="p2">*</bpt>resource looping<ept id="p2">*</ept> in addition to script execution through related extensions, it’s possible to implement a modular approach that can be reused with virtually any complex template-based deployment.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The following diagram describes the relationships between all the files downloaded from GitHub for this deployment.</source>
          <target state="new">The following diagram describes the relationships between all the files downloaded from GitHub for this deployment.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>mongodb-files</source>
          <target state="new">mongodb-files</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>This section steps you through the structure of the azuredeploy.json file for the MongoDB cluster.</source>
          <target state="new">This section steps you through the structure of the azuredeploy.json file for the MongoDB cluster.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Parameters section</source>
          <target state="new">Parameters section</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The parameters section of azuredeploy.json specifies modifiable parameters that are used in this template.</source>
          <target state="new">The parameters section of azuredeploy.json specifies modifiable parameters that are used in this template.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The  azuredeploy-parameters.json file described earlier in this article is used to pass values into the parameters section of azuredeploy.json during template execution.</source>
          <target state="new">The  azuredeploy-parameters.json file described earlier in this article is used to pass values into the parameters section of azuredeploy.json during template execution.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Variables section</source>
          <target state="new">Variables section</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The variables section specifies variables that can be used throughout this template.</source>
          <target state="new">The variables section specifies variables that can be used throughout this template.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>This contains a number of fields (JSON data types or fragments) that will be set to constants or calculated values at execution time.</source>
          <target state="new">This contains a number of fields (JSON data types or fragments) that will be set to constants or calculated values at execution time.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The following example shows the variables section for this MongoDB template.</source>
          <target state="new">The following example shows the variables section for this MongoDB template.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>In the previous example, you can see two different approaches.</source>
          <target state="new">In the previous example, you can see two different approaches.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>In this first fragment, the "osFamilyUbuntu" variable will be set to a JSON element containing 6 key value pairs.</source>
          <target state="new">In this first fragment, the "osFamilyUbuntu" variable will be set to a JSON element containing 6 key value pairs.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>In this second fragment, the "vmScripts" variable is assigned to a JSON array where single elements will be calculated at runtime using a template language function (concat) and the value of another variable plus string constants.</source>
          <target state="new">In this second fragment, the "vmScripts" variable is assigned to a JSON array where single elements will be calculated at runtime using a template language function (concat) and the value of another variable plus string constants.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>One important concept in this template is the way different “t-shirt sizes” for MongoDB clusters are defined.</source>
          <target state="new">One important concept in this template is the way different “t-shirt sizes” for MongoDB clusters are defined.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Looking at one of those “tshirtSizeXXXX” variables, you can notice that it describes important characteristics of how a cluster is deployed.</source>
          <target state="new">Looking at one of those “tshirtSizeXXXX” variables, you can notice that it describes important characteristics of how a cluster is deployed.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>In the following example, let’s take the Medium size as an example.</source>
          <target state="new">In the following example, let’s take the Medium size as an example.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>A “Medium” MongoDB cluster will use D2 as VM Size for the three MongoDB nodes hosting data, plus a fourth A1 VM that will be used as arbiter for replication purposes.</source>
          <target state="new">A “Medium” MongoDB cluster will use D2 as VM Size for the three MongoDB nodes hosting data, plus a fourth A1 VM that will be used as arbiter for replication purposes.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The corresponding sub-template invoked to deploy data nodes will be <ph id="ph1">`member-resources-D2.json`</ph> and data files (250 GB each) will be stored in two storage accounts.</source>
          <target state="new">The corresponding sub-template invoked to deploy data nodes will be <ph id="ph1">`member-resources-D2.json`</ph> and data files (250 GB each) will be stored in two storage accounts.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This variables will be used within the resources section to orchestrate node deployments and other tasks.</source>
          <target state="new">This variables will be used within the resources section to orchestrate node deployments and other tasks.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Resources section</source>
          <target state="new">Resources section</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The resources section is where most of the action is happening.</source>
          <target state="new">The resources section is where most of the action is happening.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Looking carefully inside this section, you can immediately identify two different cases: the first one is an element defined of type <ph id="ph1">`Microsoft.Resources/deployments`</ph> that basically means the invocation of a nested deployment within the main one.</source>
          <target state="new">Looking carefully inside this section, you can immediately identify two different cases: the first one is an element defined of type <ph id="ph1">`Microsoft.Resources/deployments`</ph> that basically means the invocation of a nested deployment within the main one.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Through the "templateLink" element (and related version property), it’s possible to specify a linked template file that will be invoked passing a set of parameters as input, as shown in the next example.</source>
          <target state="new">Through the "templateLink" element (and related version property), it’s possible to specify a linked template file that will be invoked passing a set of parameters as input, as shown in the next example.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>From the previous example, it is clear how azuredeploy.json in this scenario has been organized as a sort of orchestration mechanism, invoking a number of other template files, each one responsible for part of the required deployment activities.</source>
          <target state="new">From the previous example, it is clear how azuredeploy.json in this scenario has been organized as a sort of orchestration mechanism, invoking a number of other template files, each one responsible for part of the required deployment activities.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>In particular, the following linked templates will be used for this deployment:</source>
          <target state="new">In particular, the following linked templates will be used for this deployment:</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Shared-resource.json<ept id="p1">**</ept>: Contains the definition of all resources that will be shared across the deployment.</source>
          <target state="new"><bpt id="p1">**</bpt>Shared-resource.json<ept id="p1">**</ept>: Contains the definition of all resources that will be shared across the deployment.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Examples are storage accounts used to store VM’s OS disks and virtual networks.</source>
          <target state="new">Examples are storage accounts used to store VM’s OS disks and virtual networks.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Jumpbox-resources.json<ept id="p1">**</ept>: When enabled, is responsible for deploying all resources related to the Jumpbox VM, the one with a public IP address that can be used to access MongoDB cluster from public network.</source>
          <target state="new"><bpt id="p1">**</bpt>Jumpbox-resources.json<ept id="p1">**</ept>: When enabled, is responsible for deploying all resources related to the Jumpbox VM, the one with a public IP address that can be used to access MongoDB cluster from public network.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Arbiter-resources.json<ept id="p1">**</ept>: When enabled, this template deploys an arbiter member in the MongoDB cluster.</source>
          <target state="new"><bpt id="p1">**</bpt>Arbiter-resources.json<ept id="p1">**</ept>: When enabled, this template deploys an arbiter member in the MongoDB cluster.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>An arbiter doesn’t contain data, but is used when a replica set contains an even number of nodes to manage primary elections.</source>
          <target state="new">An arbiter doesn’t contain data, but is used when a replica set contains an even number of nodes to manage primary elections.</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Member-resources-Dx.json<ept id="p1">**</ept>: Specifies resource templates that are effectively deploying MongoDB nodes.</source>
          <target state="new"><bpt id="p1">**</bpt>Member-resources-Dx.json<ept id="p1">**</ept>: Specifies resource templates that are effectively deploying MongoDB nodes.</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>A specific file will be used based on the selected t-shirt size definition, where each file will only differ by the number of attached disks for each node.</source>
          <target state="new">A specific file will be used based on the selected t-shirt size definition, where each file will only differ by the number of attached disks for each node.</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Mongodb-ubuntu-install.sh<ept id="p1">**</ept>: A bash script file invoked by CustomScriptForLinux extension on every node in the cluster.</source>
          <target state="new"><bpt id="p1">**</bpt>Mongodb-ubuntu-install.sh<ept id="p1">**</ept>: A bash script file invoked by CustomScriptForLinux extension on every node in the cluster.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Responsible for mounting and formatting data disks, and installing MongoDB bits on the node.</source>
          <target state="new">Responsible for mounting and formatting data disks, and installing MongoDB bits on the node.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>To deploy a MongoDB cluster, a specific logic is required to be able to correctly set up a replica set.</source>
          <target state="new">To deploy a MongoDB cluster, a specific logic is required to be able to correctly set up a replica set.</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The following example shows the specific sequence you have to use during the deployment.</source>
          <target state="new">The following example shows the specific sequence you have to use during the deployment.</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>DEPLOY DATA MEMBERS (in parallel) =&gt; DEPLOY LAST DATA MEMBER =&gt; (optional) DEPLOY ARBITER</source>
          <target state="new">DEPLOY DATA MEMBERS (in parallel) =&gt; DEPLOY LAST DATA MEMBER =&gt; (optional) DEPLOY ARBITER</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>In this sequence, deploying multiple data nodes will happen in parallel, with the exception of the last node.</source>
          <target state="new">In this sequence, deploying multiple data nodes will happen in parallel, with the exception of the last node.</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>This is where the cluster will be formed and new replica set will be deployed, so all previous nodes will need to be up and running before that moment in time.</source>
          <target state="new">This is where the cluster will be formed and new replica set will be deployed, so all previous nodes will need to be up and running before that moment in time.</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Last step will be to deploy the optional Arbiter node (only for those t-shirt sizes where this is required).</source>
          <target state="new">Last step will be to deploy the optional Arbiter node (only for those t-shirt sizes where this is required).</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Looking again inside our main template (azuredeploy.json), let’s see how this logic is implemented, starting from all data members in the following example.</source>
          <target state="new">Looking again inside our main template (azuredeploy.json), let’s see how this logic is implemented, starting from all data members in the following example.</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>One important concept to highlight is how it is possible to deploy multiple copies of a single resource type, and for each instance can set unique values for required settings.</source>
          <target state="new">One important concept to highlight is how it is possible to deploy multiple copies of a single resource type, and for each instance can set unique values for required settings.</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>This concept is known as <bpt id="p1">*</bpt>Resource Looping<ept id="p1">*</ept>.</source>
          <target state="new">This concept is known as <bpt id="p1">*</bpt>Resource Looping<ept id="p1">*</ept>.</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>In the previous example, a parameter (number of nodes to deploy in the cluster) will be used to set a variable (“numberOfMembers”) which is then passed to the <bpt id="p1">**</bpt>“copy”<ept id="p1">**</ept> element to trigger a number (loop) of child deployments, each one will result in the instantiation of the template for each member in the cluster.</source>
          <target state="new">In the previous example, a parameter (number of nodes to deploy in the cluster) will be used to set a variable (“numberOfMembers”) which is then passed to the <bpt id="p1">**</bpt>“copy”<ept id="p1">**</ept> element to trigger a number (loop) of child deployments, each one will result in the instantiation of the template for each member in the cluster.</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>To be able to set all settings where unique values between instances are required, the <bpt id="p1">**</bpt>copyindex()<ept id="p1">**</ept> function can be used to obtain a numeric value indicating the current index in that particular resource loop creation.</source>
          <target state="new">To be able to set all settings where unique values between instances are required, the <bpt id="p1">**</bpt>copyindex()<ept id="p1">**</ept> function can be used to obtain a numeric value indicating the current index in that particular resource loop creation.</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Another important concept in resource creation is the ability to specify dependencies and precedencies between resources, as you can notice in the <bpt id="p1">**</bpt>dependsOn<ept id="p1">**</ept> JSON array.</source>
          <target state="new">Another important concept in resource creation is the ability to specify dependencies and precedencies between resources, as you can notice in the <bpt id="p1">**</bpt>dependsOn<ept id="p1">**</ept> JSON array.</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>In this particular template, deploying each node depends on the previous successful deployment of <bpt id="p1">**</bpt>shared resources<ept id="p1">**</ept>.</source>
          <target state="new">In this particular template, deploying each node depends on the previous successful deployment of <bpt id="p1">**</bpt>shared resources<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Attached disks are formatted as part of the node preparation activities triggered by the execution of the mongodb-ubuntu-install.sh script file.</source>
          <target state="new">Attached disks are formatted as part of the node preparation activities triggered by the execution of the mongodb-ubuntu-install.sh script file.</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Inside that file, in fact you’ll find an instance of the following call.</source>
          <target state="new">Inside that file, in fact you’ll find an instance of the following call.</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>vm-disk-utils-0.1.sh is part of the shared_scripts\ubuntu folder, within the azure-quickstart-tempates Github repository, and contains very useful functions for disk mounting, formatting, and striping that can be reused every time you need to execute similar tasks as part of your template creation.</source>
          <target state="new">vm-disk-utils-0.1.sh is part of the shared_scripts\ubuntu folder, within the azure-quickstart-tempates Github repository, and contains very useful functions for disk mounting, formatting, and striping that can be reused every time you need to execute similar tasks as part of your template creation.</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Another interesting fragment to explore, is the one related to CustomScriptForLinux VM extensions.</source>
          <target state="new">Another interesting fragment to explore, is the one related to CustomScriptForLinux VM extensions.</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>These are installed as a separate type of resource, with a dependency on each cluster node deployment template.</source>
          <target state="new">These are installed as a separate type of resource, with a dependency on each cluster node deployment template.</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>For example, see the following fragment at the end of each member-resources-Dx.json file.</source>
          <target state="new">For example, see the following fragment at the end of each member-resources-Dx.json file.</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>By familiarizing yourself with the other files included in this deployment, you will be able to understand all the details and best practices required to organize and orchestrate complex deployment strategies for multi-node solutions, based on any technology, leveraging Azure Resource Manager templates.</source>
          <target state="new">By familiarizing yourself with the other files included in this deployment, you will be able to understand all the details and best practices required to organize and orchestrate complex deployment strategies for multi-node solutions, based on any technology, leveraging Azure Resource Manager templates.</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>While not mandatory, a recommended approach is to structure your template files as shown in the following diagram.</source>
          <target state="new">While not mandatory, a recommended approach is to structure your template files as shown in the following diagram.</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>mongodb-template-structure</source>
          <target state="new">mongodb-template-structure</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>In essence, this approach suggests that you:</source>
          <target state="new">In essence, this approach suggests that you:</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Define your core template file as a central orchestration point for all specific deployment activities, leveraging template linking to invoke sub template executions.</source>
          <target state="new">Define your core template file as a central orchestration point for all specific deployment activities, leveraging template linking to invoke sub template executions.</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Create specific template files that will deploy all resources shared across all other specific deployment tasks (for example, storage accounts, vnet configuration, etc.).</source>
          <target state="new">Create specific template files that will deploy all resources shared across all other specific deployment tasks (for example, storage accounts, vnet configuration, etc.).</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>This can be heavily reused between deployments that have similar requirements in terms of common infrastructure.</source>
          <target state="new">This can be heavily reused between deployments that have similar requirements in terms of common infrastructure.</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Include optional resource templates for spot requirements specific of a given resource.</source>
          <target state="new">Include optional resource templates for spot requirements specific of a given resource.</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>For identical members of a group of resources (nodes in a cluster, etc.), create specific templates that leverage resource looping in order to deploy multiple instances with unique properties.</source>
          <target state="new">For identical members of a group of resources (nodes in a cluster, etc.), create specific templates that leverage resource looping in order to deploy multiple instances with unique properties.</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>For all post deployment tasks (for example, product installation, configurations, etc.), leverage script deployment extensions and create scripts specific to each technology.</source>
          <target state="new">For all post deployment tasks (for example, product installation, configurations, etc.), leverage script deployment extensions and create scripts specific to each technology.</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Azure Resource Manager Template Language<ept id="p1">](../resource-group-authoring-templates.md)</ept>.</source>
          <target state="new">For more information, see <bpt id="p1">[</bpt>Azure Resource Manager Template Language<ept id="p1">](../resource-group-authoring-templates.md)</ept>.</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4aa0bf571cf24dc031662bf694b3a06ef753257b</xliffext:olfilehash>
  </header>
</xliff>