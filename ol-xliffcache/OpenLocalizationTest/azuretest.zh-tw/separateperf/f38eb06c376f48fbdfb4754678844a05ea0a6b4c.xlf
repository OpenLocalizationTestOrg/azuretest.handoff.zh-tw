<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Managing Concurrency in Microsoft Azure Storage</source>
          <target state="new">Managing Concurrency in Microsoft Azure Storage</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>How to manage concurrency for the Blob, Queue, Table, and File services</source>
          <target state="new">How to manage concurrency for the Blob, Queue, Table, and File services</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Managing Concurrency in Microsoft Azure Storage</source>
          <target state="new">Managing Concurrency in Microsoft Azure Storage</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="new">Overview</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Modern Internet based applications usually have multiple users viewing and updating data simultaneously.</source>
          <target state="new">Modern Internet based applications usually have multiple users viewing and updating data simultaneously.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This requires application developers to think carefully about how to provide a predictable experience to their end users, particularly for scenarios where multiple users can update the same data.</source>
          <target state="new">This requires application developers to think carefully about how to provide a predictable experience to their end users, particularly for scenarios where multiple users can update the same data.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>There are three main data concurrency strategies developers will typically consider:</source>
          <target state="new">There are three main data concurrency strategies developers will typically consider:</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Optimistic concurrency – An application performing an update will as part of its update verify if the data has changed since the application last read that data.</source>
          <target state="new">Optimistic concurrency – An application performing an update will as part of its update verify if the data has changed since the application last read that data.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For example, if two users viewing a wiki page make an update to the same page then the wiki platform must ensure that the second update does not overwrite the first update – and that both users understand whether their update was successful or not.</source>
          <target state="new">For example, if two users viewing a wiki page make an update to the same page then the wiki platform must ensure that the second update does not overwrite the first update – and that both users understand whether their update was successful or not.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>This strategy is most often used in web applications.</source>
          <target state="new">This strategy is most often used in web applications.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Pessimistic concurrency – An application looking to perform an update will take a lock on an object preventing other users from updating the data until the lock is released.</source>
          <target state="new">Pessimistic concurrency – An application looking to perform an update will take a lock on an object preventing other users from updating the data until the lock is released.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>For example, in a master/slave data replication scenario where only the master will perform updates the master will typically hold an exclusive lock for an extended period of time on the data to ensure no one else can update it.</source>
          <target state="new">For example, in a master/slave data replication scenario where only the master will perform updates the master will typically hold an exclusive lock for an extended period of time on the data to ensure no one else can update it.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Last writer wins – An approach that allows any update operations to proceed without verifying if any other application has updated the data since the application first read the data.</source>
          <target state="new">Last writer wins – An approach that allows any update operations to proceed without verifying if any other application has updated the data since the application first read the data.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>This strategy (or lack of a formal strategy) is usually used where data is partitioned in such a way that there is no likelihood that multiple users will access the same data.</source>
          <target state="new">This strategy (or lack of a formal strategy) is usually used where data is partitioned in such a way that there is no likelihood that multiple users will access the same data.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>It can also be useful where short-lived data streams are being processed.</source>
          <target state="new">It can also be useful where short-lived data streams are being processed.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This article provides an overview of how the Azure Storage platform simplifies development by providing first class support for all three of these concurrency strategies.</source>
          <target state="new">This article provides an overview of how the Azure Storage platform simplifies development by providing first class support for all three of these concurrency strategies.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Azure Storage – Simplifies Cloud Development</source>
          <target state="new">Azure Storage – Simplifies Cloud Development</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The Azure storage service supports all three strategies, although it is distinctive in its ability to provide full support for optimistic and pessimistic concurrency because it was designed to embrace a strong consistency model which guarantees that when the Storage service commits a data insert or update operation all further accesses to that data will see the latest update.</source>
          <target state="new">The Azure storage service supports all three strategies, although it is distinctive in its ability to provide full support for optimistic and pessimistic concurrency because it was designed to embrace a strong consistency model which guarantees that when the Storage service commits a data insert or update operation all further accesses to that data will see the latest update.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Storage platforms that use an eventual consistency model have a lag between when a write is performed by one user and when the updated data can be seen by other users thus complicating development of client applications in order to prevent inconsistencies from affecting end users.</source>
          <target state="new">Storage platforms that use an eventual consistency model have a lag between when a write is performed by one user and when the updated data can be seen by other users thus complicating development of client applications in order to prevent inconsistencies from affecting end users.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>In addition to selecting an appropriate concurrency strategy developers should also be aware of how a storage platform isolates changes – particularly changes to the same object across transactions.</source>
          <target state="new">In addition to selecting an appropriate concurrency strategy developers should also be aware of how a storage platform isolates changes – particularly changes to the same object across transactions.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The Azure storage service uses snapshot isolation to allow read operations to happen concurrently with write operations within a single partition.</source>
          <target state="new">The Azure storage service uses snapshot isolation to allow read operations to happen concurrently with write operations within a single partition.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Unlike other isolation levels, snapshot isolation guarantees that all reads see a consistent snapshot of the data even while updates are occurring – essentially by returning the last committed values while an update transaction is being processed.</source>
          <target state="new">Unlike other isolation levels, snapshot isolation guarantees that all reads see a consistent snapshot of the data even while updates are occurring – essentially by returning the last committed values while an update transaction is being processed.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Managing Concurrency in the Blob Service</source>
          <target state="new">Managing Concurrency in the Blob Service</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>You can opt to use either optimistic or pessimistic concurrency models to manage access to blobs and containers in the blob service.</source>
          <target state="new">You can opt to use either optimistic or pessimistic concurrency models to manage access to blobs and containers in the blob service.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>If you do not explicitly specify a strategy last writes wins is the default.</source>
          <target state="new">If you do not explicitly specify a strategy last writes wins is the default.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Optimistic concurrency for blobs and containers</source>
          <target state="new">Optimistic concurrency for blobs and containers</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The Storage service assigns an identifier to every object stored.</source>
          <target state="new">The Storage service assigns an identifier to every object stored.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>This identifier is updated every time an update operation is performed on an object.</source>
          <target state="new">This identifier is updated every time an update operation is performed on an object.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The identifier is returned to the client as part of an HTTP GET response using the ETag (entity tag) header that is defined within the HTTP protocol.</source>
          <target state="new">The identifier is returned to the client as part of an HTTP GET response using the ETag (entity tag) header that is defined within the HTTP protocol.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>A user performing an update on such an object can send in the original ETag along with a conditional header to ensure that an update will only occur if a certain condition has been met – in this case the condition is an “If-Match” header which requires the Storage Service to ensure the value of the ETag specified in the update request is the same as that stored in the Storage Service.</source>
          <target state="new">A user performing an update on such an object can send in the original ETag along with a conditional header to ensure that an update will only occur if a certain condition has been met – in this case the condition is an “If-Match” header which requires the Storage Service to ensure the value of the ETag specified in the update request is the same as that stored in the Storage Service.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The outline of this process is as follows:</source>
          <target state="new">The outline of this process is as follows:</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Retrieve a blob from the storage service, the response includes an HTTP ETag Header value that identifies the current version of the object in the storage service.</source>
          <target state="new">Retrieve a blob from the storage service, the response includes an HTTP ETag Header value that identifies the current version of the object in the storage service.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>When you update the blob, include the ETag value you received in step 1 in the <bpt id="p1">**</bpt>If-Match<ept id="p1">**</ept> conditional header of the request you send to the service.</source>
          <target state="new">When you update the blob, include the ETag value you received in step 1 in the <bpt id="p1">**</bpt>If-Match<ept id="p1">**</ept> conditional header of the request you send to the service.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The service compares the ETag value in the request with the current ETag value of the blob.</source>
          <target state="new">The service compares the ETag value in the request with the current ETag value of the blob.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>If the current ETag value of the blob is a different version than the ETag in the <bpt id="p1">**</bpt>If-Match<ept id="p1">**</ept> conditional header in the request, the service returns a 412 error to the client.</source>
          <target state="new">If the current ETag value of the blob is a different version than the ETag in the <bpt id="p1">**</bpt>If-Match<ept id="p1">**</ept> conditional header in the request, the service returns a 412 error to the client.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>This indicates to the client that another process has updated the blob since the client retrieved it.</source>
          <target state="new">This indicates to the client that another process has updated the blob since the client retrieved it.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>If the current ETag value of the blob is the same version as the ETag in the <bpt id="p1">**</bpt>If-Match<ept id="p1">**</ept> conditional header in the request, the service performs the requested operation and updates the current ETag value of the blob to show that it has created a new version.</source>
          <target state="new">If the current ETag value of the blob is the same version as the ETag in the <bpt id="p1">**</bpt>If-Match<ept id="p1">**</ept> conditional header in the request, the service performs the requested operation and updates the current ETag value of the blob to show that it has created a new version.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The following C# snippet (using the Client Storage Library 4.2.0) shows a simple example of how to construct an <bpt id="p1">**</bpt>If-Match AccessCondition<ept id="p1">**</ept> based on the ETag value that is accessed from the properties of a blob that was previously either retrieved or inserted.</source>
          <target state="new">The following C# snippet (using the Client Storage Library 4.2.0) shows a simple example of how to construct an <bpt id="p1">**</bpt>If-Match AccessCondition<ept id="p1">**</ept> based on the ETag value that is accessed from the properties of a blob that was previously either retrieved or inserted.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>It then uses the <bpt id="p1">**</bpt>AccessCondition<ept id="p1">**</ept> object when it updating the blob: the <bpt id="p2">**</bpt>AccessCondition<ept id="p2">**</ept> object adds the <bpt id="p3">**</bpt>If-Match<ept id="p3">**</ept> header to the request.</source>
          <target state="new">It then uses the <bpt id="p1">**</bpt>AccessCondition<ept id="p1">**</ept> object when it updating the blob: the <bpt id="p2">**</bpt>AccessCondition<ept id="p2">**</ept> object adds the <bpt id="p3">**</bpt>If-Match<ept id="p3">**</ept> header to the request.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>If another process has updated the blob, the blob service returns an HTTP 412 (Precondition Failed) status message.</source>
          <target state="new">If another process has updated the blob, the blob service returns an HTTP 412 (Precondition Failed) status message.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The full sample can be downloaded <bpt id="p1">[</bpt>here<ept id="p1">](http://code.msdn.microsoft.com/windowsazure/Managing-Concurrency-using-56018114)</ept>.</source>
          <target state="new">The full sample can be downloaded <bpt id="p1">[</bpt>here<ept id="p1">](http://code.msdn.microsoft.com/windowsazure/Managing-Concurrency-using-56018114)</ept>.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The Storage Service also includes support for additional conditional headers such as <bpt id="p1">**</bpt>If-Modified-Since<ept id="p1">**</ept>, <bpt id="p2">**</bpt>If-Unmodified-Since<ept id="p2">**</ept> and <bpt id="p3">**</bpt>If-None-Match<ept id="p3">**</ept> as well as combinations thereof.</source>
          <target state="new">The Storage Service also includes support for additional conditional headers such as <bpt id="p1">**</bpt>If-Modified-Since<ept id="p1">**</ept>, <bpt id="p2">**</bpt>If-Unmodified-Since<ept id="p2">**</ept> and <bpt id="p3">**</bpt>If-None-Match<ept id="p3">**</ept> as well as combinations thereof.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>For more information see <bpt id="p1">[</bpt>Specifying Conditional Headers for Blob Service Operations<ept id="p1">](http://msdn.microsoft.com/library/azure/dd179371.aspx)</ept> on MSDN.</source>
          <target state="new">For more information see <bpt id="p1">[</bpt>Specifying Conditional Headers for Blob Service Operations<ept id="p1">](http://msdn.microsoft.com/library/azure/dd179371.aspx)</ept> on MSDN.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The following table summarizes the container operations that accept conditional headers such as <bpt id="p1">**</bpt>If-Match<ept id="p1">**</ept> in the request and that return an ETag value in the response.</source>
          <target state="new">The following table summarizes the container operations that accept conditional headers such as <bpt id="p1">**</bpt>If-Match<ept id="p1">**</ept> in the request and that return an ETag value in the response.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Operation</source>
          <target state="new">Operation</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Returns Container ETag value</source>
          <target state="new">Returns Container ETag value</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Accepts conditional headers</source>
          <target state="new">Accepts conditional headers</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Create Container</source>
          <target state="new">Create Container</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="new">No</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Get Container Properties</source>
          <target state="new">Get Container Properties</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="new">No</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Get Container Metadata</source>
          <target state="new">Get Container Metadata</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="new">No</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Set Container Metadata</source>
          <target state="new">Set Container Metadata</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Get Container ACL</source>
          <target state="new">Get Container ACL</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="new">No</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Set Container ACL</source>
          <target state="new">Set Container ACL</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Yes (*)</source>
          <target state="new">Yes (*)</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Delete Container</source>
          <target state="new">Delete Container</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="new">No</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Lease Container</source>
          <target state="new">Lease Container</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>List Blobs</source>
          <target state="new">List Blobs</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="new">No</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="new">No</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>(*) The permissions defined by SetContainerACL are cached and updates to these permissions take 30 seconds to propagate during which period updates are not guaranteed to be consistent.</source>
          <target state="new">(*) The permissions defined by SetContainerACL are cached and updates to these permissions take 30 seconds to propagate during which period updates are not guaranteed to be consistent.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The following table summarizes the blob operations that accept conditional headers such as <bpt id="p1">**</bpt>If-Match<ept id="p1">**</ept> in the request and that return an ETag value in the response.</source>
          <target state="new">The following table summarizes the blob operations that accept conditional headers such as <bpt id="p1">**</bpt>If-Match<ept id="p1">**</ept> in the request and that return an ETag value in the response.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Operation</source>
          <target state="new">Operation</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Returns ETag value</source>
          <target state="new">Returns ETag value</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Accepts conditional headers</source>
          <target state="new">Accepts conditional headers</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Put Blob</source>
          <target state="new">Put Blob</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Get Blob</source>
          <target state="new">Get Blob</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Get Blob Properties</source>
          <target state="new">Get Blob Properties</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Set Blob Properties</source>
          <target state="new">Set Blob Properties</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Get Blob Metadata</source>
          <target state="new">Get Blob Metadata</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Set Blob Metadata</source>
          <target state="new">Set Blob Metadata</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Lease Blob (*)</source>
          <target state="new">Lease Blob (*)</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Snapshot Blob</source>
          <target state="new">Snapshot Blob</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Copy Blob</source>
          <target state="new">Copy Blob</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Yes (for source and destination blob)</source>
          <target state="new">Yes (for source and destination blob)</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Abort Copy Blob</source>
          <target state="new">Abort Copy Blob</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="new">No</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="new">No</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Delete Blob</source>
          <target state="new">Delete Blob</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="new">No</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Put Block</source>
          <target state="new">Put Block</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="new">No</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="new">No</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Put Block List</source>
          <target state="new">Put Block List</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Get Block List</source>
          <target state="new">Get Block List</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="new">No</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Put Page</source>
          <target state="new">Put Page</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Get Page Ranges</source>
          <target state="new">Get Page Ranges</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>(*) Lease Blob does not change the ETag on a blob.</source>
          <target state="new">(*) Lease Blob does not change the ETag on a blob.</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Pessimistic concurrency for blobs</source>
          <target state="new">Pessimistic concurrency for blobs</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>To lock a blob for exclusive use, you can acquire a <bpt id="p1">[</bpt>lease<ept id="p1">](http://msdn.microsoft.com/library/azure/ee691972.aspx)</ept> on it.</source>
          <target state="new">To lock a blob for exclusive use, you can acquire a <bpt id="p1">[</bpt>lease<ept id="p1">](http://msdn.microsoft.com/library/azure/ee691972.aspx)</ept> on it.</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>When you acquire a lease, you specify for how long you need the lease: this can be for between 15 to 60 seconds or infinite which amounts to an exclusive lock.</source>
          <target state="new">When you acquire a lease, you specify for how long you need the lease: this can be for between 15 to 60 seconds or infinite which amounts to an exclusive lock.</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>You can renew a finite lease to extend it, and you can release any lease when you are finished with it.</source>
          <target state="new">You can renew a finite lease to extend it, and you can release any lease when you are finished with it.</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The blob service automatically releases finite leases when they expire.</source>
          <target state="new">The blob service automatically releases finite leases when they expire.</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Leases enable different synchronization strategies to be supported, including exclusive write / shared read, exclusive write / exclusive read and shared write / exclusive read.</source>
          <target state="new">Leases enable different synchronization strategies to be supported, including exclusive write / shared read, exclusive write / exclusive read and shared write / exclusive read.</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Where a lease exists the storage service enforces exclusive writes (put, set and delete operations) however ensuring exclusivity for read operations requires the developer to ensure that all client applications use a lease ID and that only one client at a time has a valid lease ID.</source>
          <target state="new">Where a lease exists the storage service enforces exclusive writes (put, set and delete operations) however ensuring exclusivity for read operations requires the developer to ensure that all client applications use a lease ID and that only one client at a time has a valid lease ID.</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Read operations that do not include a lease ID result in shared reads.</source>
          <target state="new">Read operations that do not include a lease ID result in shared reads.</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The following C# snippet shows an example of acquiring an exclusive lease for 30 seconds on a blob, updating the content of the blob, and then releasing the lease.</source>
          <target state="new">The following C# snippet shows an example of acquiring an exclusive lease for 30 seconds on a blob, updating the content of the blob, and then releasing the lease.</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>If there is already a valid lease on the blob when you try to acquire a new lease, the blob service returns an “HTTP (409) Conflict” status result.</source>
          <target state="new">If there is already a valid lease on the blob when you try to acquire a new lease, the blob service returns an “HTTP (409) Conflict” status result.</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The snippet below uses an <bpt id="p1">**</bpt>AccessCondition<ept id="p1">**</ept> object to encapsulate the lease information when it makes a request to update the blob in the storage service.</source>
          <target state="new">The snippet below uses an <bpt id="p1">**</bpt>AccessCondition<ept id="p1">**</ept> object to encapsulate the lease information when it makes a request to update the blob in the storage service.</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The full sample can be downloaded <bpt id="p1">[</bpt>here<ept id="p1">](http://code.msdn.microsoft.com/windowsazure/Managing-Concurrency-using-56018114)</ept>.</source>
          <target state="new">The full sample can be downloaded <bpt id="p1">[</bpt>here<ept id="p1">](http://code.msdn.microsoft.com/windowsazure/Managing-Concurrency-using-56018114)</ept>.</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>If you attempt a write operation on a leased blob without passing the lease ID, the request fails with a 412 error.</source>
          <target state="new">If you attempt a write operation on a leased blob without passing the lease ID, the request fails with a 412 error.</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Note that if the lease expires before calling the <bpt id="p1">**</bpt>UploadText<ept id="p1">**</ept> method but you still pass the lease ID, the request also fails with a <bpt id="p2">**</bpt>412<ept id="p2">**</ept> error.</source>
          <target state="new">Note that if the lease expires before calling the <bpt id="p1">**</bpt>UploadText<ept id="p1">**</ept> method but you still pass the lease ID, the request also fails with a <bpt id="p2">**</bpt>412<ept id="p2">**</ept> error.</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>For more information about managing lease expiry times and lease ids, see the <bpt id="p1">[</bpt>Lease Blob<ept id="p1">](http://msdn.microsoft.com/library/azure/ee691972.aspx)</ept> REST documentation.</source>
          <target state="new">For more information about managing lease expiry times and lease ids, see the <bpt id="p1">[</bpt>Lease Blob<ept id="p1">](http://msdn.microsoft.com/library/azure/ee691972.aspx)</ept> REST documentation.</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The following blob operations can use leases to manage pessimistic concurrency:</source>
          <target state="new">The following blob operations can use leases to manage pessimistic concurrency:</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Put Blob</source>
          <target state="new">Put Blob</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Get Blob</source>
          <target state="new">Get Blob</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Get Blob Properties</source>
          <target state="new">Get Blob Properties</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Set Blob Properties</source>
          <target state="new">Set Blob Properties</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Get Blob Metadata</source>
          <target state="new">Get Blob Metadata</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Set Blob Metadata</source>
          <target state="new">Set Blob Metadata</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Delete Blob</source>
          <target state="new">Delete Blob</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Put Block</source>
          <target state="new">Put Block</target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Put Block List</source>
          <target state="new">Put Block List</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Get Block List</source>
          <target state="new">Get Block List</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Put Page</source>
          <target state="new">Put Page</target>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Get Page Ranges</source>
          <target state="new">Get Page Ranges</target>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Snapshot Blob - lease ID optional if a lease exists</source>
          <target state="new">Snapshot Blob - lease ID optional if a lease exists</target>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Copy Blob - lease ID required if a lease exists on the destination blob</source>
          <target state="new">Copy Blob - lease ID required if a lease exists on the destination blob</target>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Abort Copy Blob - lease ID required if an infinite lease exists on the destination blob</source>
          <target state="new">Abort Copy Blob - lease ID required if an infinite lease exists on the destination blob</target>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Lease Blob</source>
          <target state="new">Lease Blob</target>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Pessimistic concurrency for containers</source>
          <target state="new">Pessimistic concurrency for containers</target>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Leases on containers enable the same synchronization strategies to be supported as on blobs (exclusive write / shared read, exclusive write / exclusive read and shared write / exclusive read) however unlike blobs the storage service only enforces exclusivity on delete operations.</source>
          <target state="new">Leases on containers enable the same synchronization strategies to be supported as on blobs (exclusive write / shared read, exclusive write / exclusive read and shared write / exclusive read) however unlike blobs the storage service only enforces exclusivity on delete operations.</target>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>To delete a container with an active lease, a client must include the active lease ID with the delete request.</source>
          <target state="new">To delete a container with an active lease, a client must include the active lease ID with the delete request.</target>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>All other container operations succeed on a leased container without including the lease ID in which case they are shared operations.</source>
          <target state="new">All other container operations succeed on a leased container without including the lease ID in which case they are shared operations.</target>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>If exclusivity of update (put or set) or read operations is required then developers should ensure all clients use a lease ID and that only one client at a time has a valid lease ID.</source>
          <target state="new">If exclusivity of update (put or set) or read operations is required then developers should ensure all clients use a lease ID and that only one client at a time has a valid lease ID.</target>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>The following container operations can use leases to manage pessimistic concurrency:</source>
          <target state="new">The following container operations can use leases to manage pessimistic concurrency:</target>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Delete Container</source>
          <target state="new">Delete Container</target>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Get Container Properties</source>
          <target state="new">Get Container Properties</target>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Get Container Metadata</source>
          <target state="new">Get Container Metadata</target>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Set Container Metadata</source>
          <target state="new">Set Container Metadata</target>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Get Container ACL</source>
          <target state="new">Get Container ACL</target>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Set Container ACL</source>
          <target state="new">Set Container ACL</target>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Lease Container</source>
          <target state="new">Lease Container</target>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>For more information see:</source>
          <target state="new">For more information see:</target>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Specifying Conditional Headers for Blob Service Operations</source>
          <target state="new">Specifying Conditional Headers for Blob Service Operations</target>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Lease Container</source>
          <target state="new">Lease Container</target>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Lease Blob</source>
          <target state="new">Lease Blob</target>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Managing Concurrency in the Table Service</source>
          <target state="new">Managing Concurrency in the Table Service</target>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>The table service uses optimistic concurrency checks as the default behavior when you are working with entities, unlike the blob service where you must explicitly choose to perform optimistic concurrency checks.</source>
          <target state="new">The table service uses optimistic concurrency checks as the default behavior when you are working with entities, unlike the blob service where you must explicitly choose to perform optimistic concurrency checks.</target>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>The other difference between the table and blob services is that you can only manage the concurrency behavior of entities whereas with the blob service you can manage the concurrency of both containers and blobs.</source>
          <target state="new">The other difference between the table and blob services is that you can only manage the concurrency behavior of entities whereas with the blob service you can manage the concurrency of both containers and blobs.</target>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>To use optimistic concurrency and to check if another process modified an entity since you retrieved it from the table storage service, you can use the ETag value you receive when the table service returns an entity.</source>
          <target state="new">To use optimistic concurrency and to check if another process modified an entity since you retrieved it from the table storage service, you can use the ETag value you receive when the table service returns an entity.</target>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>The outline of this process is as follows:</source>
          <target state="new">The outline of this process is as follows:</target>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Retrieve an entity from the table storage service, the response includes an ETag value that identifies the current identifier associated with that entity in the storage service.</source>
          <target state="new">Retrieve an entity from the table storage service, the response includes an ETag value that identifies the current identifier associated with that entity in the storage service.</target>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>When you update the entity, include the ETag value you received in step 1 in the mandatory <bpt id="p1">**</bpt>If-Match<ept id="p1">**</ept> header of the request you send to the service.</source>
          <target state="new">When you update the entity, include the ETag value you received in step 1 in the mandatory <bpt id="p1">**</bpt>If-Match<ept id="p1">**</ept> header of the request you send to the service.</target>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>The service compares the ETag value in the request with the current ETag value of the entity.</source>
          <target state="new">The service compares the ETag value in the request with the current ETag value of the entity.</target>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>If the current ETag value of the entity is different than the ETag in the mandatory <bpt id="p1">**</bpt>If-Match<ept id="p1">**</ept> header in the request, the service returns a 412 error to the client.</source>
          <target state="new">If the current ETag value of the entity is different than the ETag in the mandatory <bpt id="p1">**</bpt>If-Match<ept id="p1">**</ept> header in the request, the service returns a 412 error to the client.</target>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>This indicates to the client that another process has updated the entity since the client retrieved it.</source>
          <target state="new">This indicates to the client that another process has updated the entity since the client retrieved it.</target>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>If the current ETag value of the entity is the same as the ETag in the mandatory <bpt id="p1">**</bpt>If-Match<ept id="p1">**</ept> header in the request or the <bpt id="p2">**</bpt>If-Match<ept id="p2">**</ept> header contains the wildcard character (*), the service performs the requested operation and updates the current ETag value of the entity to show that it has been updated.</source>
          <target state="new">If the current ETag value of the entity is the same as the ETag in the mandatory <bpt id="p1">**</bpt>If-Match<ept id="p1">**</ept> header in the request or the <bpt id="p2">**</bpt>If-Match<ept id="p2">**</ept> header contains the wildcard character (*), the service performs the requested operation and updates the current ETag value of the entity to show that it has been updated.</target>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Note that unlike the blob service, the table service requires the client to include an <bpt id="p1">**</bpt>If-Match<ept id="p1">**</ept> header in update requests.</source>
          <target state="new">Note that unlike the blob service, the table service requires the client to include an <bpt id="p1">**</bpt>If-Match<ept id="p1">**</ept> header in update requests.</target>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>However, it is possible to force an unconditional update (last writer wins strategy) and bypass concurrency checks if the client sets the <bpt id="p1">**</bpt>If-Match<ept id="p1">**</ept> header to the wildcard character (*) in the request.</source>
          <target state="new">However, it is possible to force an unconditional update (last writer wins strategy) and bypass concurrency checks if the client sets the <bpt id="p1">**</bpt>If-Match<ept id="p1">**</ept> header to the wildcard character (*) in the request.</target>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>The following C# snippet shows a customer entity that was previously either created or retrieved having their email address updated.</source>
          <target state="new">The following C# snippet shows a customer entity that was previously either created or retrieved having their email address updated.</target>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>The initial insert or retrieve operation stores the ETag value in the customer object, and because the sample uses the same object instance when it executes the replace operation, it automatically sends the ETag value back to the table service, enabling the service to check for concurrency violations.</source>
          <target state="new">The initial insert or retrieve operation stores the ETag value in the customer object, and because the sample uses the same object instance when it executes the replace operation, it automatically sends the ETag value back to the table service, enabling the service to check for concurrency violations.</target>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>If another process has updated the entity in table storage, the service returns an HTTP 412 (Precondition Failed) status message.</source>
          <target state="new">If another process has updated the entity in table storage, the service returns an HTTP 412 (Precondition Failed) status message.</target>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The full sample can be downloaded <bpt id="p1">[</bpt>here<ept id="p1">](http://code.msdn.microsoft.com/windowsazure/Managing-Concurrency-using-56018114)</ept>.</source>
          <target state="new">The full sample can be downloaded <bpt id="p1">[</bpt>here<ept id="p1">](http://code.msdn.microsoft.com/windowsazure/Managing-Concurrency-using-56018114)</ept>.</target>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>To explicitly disable the concurrency check, you should set the <bpt id="p1">**</bpt>ETag<ept id="p1">**</ept> property of the <bpt id="p2">**</bpt>employee<ept id="p2">**</ept> object to “*” before you execute the replace operation.</source>
          <target state="new">To explicitly disable the concurrency check, you should set the <bpt id="p1">**</bpt>ETag<ept id="p1">**</ept> property of the <bpt id="p2">**</bpt>employee<ept id="p2">**</ept> object to “*” before you execute the replace operation.</target>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>customer.ETag = "*";</source>
          <target state="new">customer.ETag = "*";</target>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>The following table summarizes how the table entity operations use ETag values:</source>
          <target state="new">The following table summarizes how the table entity operations use ETag values:</target>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Operation</source>
          <target state="new">Operation</target>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Returns ETag value</source>
          <target state="new">Returns ETag value</target>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Requires If-Match request header</source>
          <target state="new">Requires If-Match request header</target>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Query Entities</source>
          <target state="new">Query Entities</target>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="new">No</target>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Insert Entity</source>
          <target state="new">Insert Entity</target>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="new">No</target>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Update Entity</source>
          <target state="new">Update Entity</target>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Merge Entity</source>
          <target state="new">Merge Entity</target>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Delete Entity</source>
          <target state="new">Delete Entity</target>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="new">No</target>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Insert or Replace Entity</source>
          <target state="new">Insert or Replace Entity</target>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="new">No</target>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Insert or Merge Entity</source>
          <target state="new">Insert or Merge Entity</target>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new">Yes</target>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="new">No</target>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Note that the <bpt id="p1">**</bpt>Insert or Replace Entity<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Insert or Merge Entity<ept id="p2">**</ept> operations do <bpt id="p3">*</bpt>not<ept id="p3">*</ept> perform any concurrency checks because they do not send an ETag value to the table service.</source>
          <target state="new">Note that the <bpt id="p1">**</bpt>Insert or Replace Entity<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Insert or Merge Entity<ept id="p2">**</ept> operations do <bpt id="p3">*</bpt>not<ept id="p3">*</ept> perform any concurrency checks because they do not send an ETag value to the table service.</target>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>In general developers using tables should rely on optimistic concurrency when developing scalable applications.</source>
          <target state="new">In general developers using tables should rely on optimistic concurrency when developing scalable applications.</target>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>If pessimistic locking is needed, one approach developers can take when accessing Tables is to assign a designated blob for each table and try to take a lease on the blob before operating on the table.</source>
          <target state="new">If pessimistic locking is needed, one approach developers can take when accessing Tables is to assign a designated blob for each table and try to take a lease on the blob before operating on the table.</target>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>This approach does require the application to ensure all data access paths obtain the lease prior to operating on the table.</source>
          <target state="new">This approach does require the application to ensure all data access paths obtain the lease prior to operating on the table.</target>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>You should also note that the minimum lease time is 15 seconds which requires careful consideration for scalability.</source>
          <target state="new">You should also note that the minimum lease time is 15 seconds which requires careful consideration for scalability.</target>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>For more information see:</source>
          <target state="new">For more information see:</target>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Operations on Entities</source>
          <target state="new">Operations on Entities</target>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Managing Concurrency in the Queue Service</source>
          <target state="new">Managing Concurrency in the Queue Service</target>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>One scenario in which concurrency is a concern in the queueing service is where multiple clients are retrieving messages from a queue.</source>
          <target state="new">One scenario in which concurrency is a concern in the queueing service is where multiple clients are retrieving messages from a queue.</target>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>When a message is retrieved from the queue, the response includes the message and a pop receipt value, which is required to delete the message.</source>
          <target state="new">When a message is retrieved from the queue, the response includes the message and a pop receipt value, which is required to delete the message.</target>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The message is not automatically deleted from the queue, but after it has been retrieved, it is not visible to other clients for the time interval specified by the visibilitytimeout parameter.</source>
          <target state="new">The message is not automatically deleted from the queue, but after it has been retrieved, it is not visible to other clients for the time interval specified by the visibilitytimeout parameter.</target>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The client that retrieves the message is expected to delete the message after it has been processed, and before the time specified by the TimeNextVisible element of the response, which is calculated based on the value of the visibilitytimeout parameter.</source>
          <target state="new">The client that retrieves the message is expected to delete the message after it has been processed, and before the time specified by the TimeNextVisible element of the response, which is calculated based on the value of the visibilitytimeout parameter.</target>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>The value of visibilitytimeout is added to the time at which the message is retrieved to determine the value of TimeNextVisible.</source>
          <target state="new">The value of visibilitytimeout is added to the time at which the message is retrieved to determine the value of TimeNextVisible.</target>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>The queue service does not have support for either optimistic or pessimistic concurrency and for this reason clients processing messages retrieved from a queue should ensure messages are processed in an idempotent manner.</source>
          <target state="new">The queue service does not have support for either optimistic or pessimistic concurrency and for this reason clients processing messages retrieved from a queue should ensure messages are processed in an idempotent manner.</target>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>A last writer wins strategy is used for update operations such as SetQueueServiceProperties, SetQueueMetaData, SetQueueACL and UpdateMessage.</source>
          <target state="new">A last writer wins strategy is used for update operations such as SetQueueServiceProperties, SetQueueMetaData, SetQueueACL and UpdateMessage.</target>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>For more information see:</source>
          <target state="new">For more information see:</target>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Queue Service REST API</source>
          <target state="new">Queue Service REST API</target>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>Get Messages</source>
          <target state="new">Get Messages</target>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Managing Concurrency in the File Service</source>
          <target state="new">Managing Concurrency in the File Service</target>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>The file service can be accessed using two different protocol endpoints – SMB and REST.</source>
          <target state="new">The file service can be accessed using two different protocol endpoints – SMB and REST.</target>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The REST service does not have support for either optimistic locking or pessimistic locking and all updates will follow a last writer wins strategy.</source>
          <target state="new">The REST service does not have support for either optimistic locking or pessimistic locking and all updates will follow a last writer wins strategy.</target>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>SMB clients that mount file shares can leverage file system locking mechanisms to manage access to shared files – including the ability to perform pessimistic locking.</source>
          <target state="new">SMB clients that mount file shares can leverage file system locking mechanisms to manage access to shared files – including the ability to perform pessimistic locking.</target>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>When an SMB client opens a file, it specifies both the file access and share mode.</source>
          <target state="new">When an SMB client opens a file, it specifies both the file access and share mode.</target>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Setting a File Access option of "Write" or "Read/Write" along with a File Share mode of "None" will result in the file being locked by an SMB client until the file is closed.</source>
          <target state="new">Setting a File Access option of "Write" or "Read/Write" along with a File Share mode of "None" will result in the file being locked by an SMB client until the file is closed.</target>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>If REST operation is attempted on a file where an SMB client has the file locked the REST service will return status code 409 (Conflict) with error code SharingViolation.</source>
          <target state="new">If REST operation is attempted on a file where an SMB client has the file locked the REST service will return status code 409 (Conflict) with error code SharingViolation.</target>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>When an SMB client opens a file for delete, it marks the file as pending delete until all other SMB client open handles on that file are closed.</source>
          <target state="new">When an SMB client opens a file for delete, it marks the file as pending delete until all other SMB client open handles on that file are closed.</target>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>While a file is marked as pending delete, any REST operation on that file will return status code 409 (Conflict) with error code SMBDeletePending.</source>
          <target state="new">While a file is marked as pending delete, any REST operation on that file will return status code 409 (Conflict) with error code SMBDeletePending.</target>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>Status code 404 (Not Found) is not returned since it is possible for the SMB client to remove the pending deletion flag prior to closing the file.</source>
          <target state="new">Status code 404 (Not Found) is not returned since it is possible for the SMB client to remove the pending deletion flag prior to closing the file.</target>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>In other words, status code 404 (Not Found) is only expected when the file has been removed.</source>
          <target state="new">In other words, status code 404 (Not Found) is only expected when the file has been removed.</target>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Note that while a file is in a SMB pending delete state, it will not be included in the List Files results.Also note that the REST Delete File and REST Delete Directory operations are committed atomically and do not result in pending delete state.</source>
          <target state="new">Note that while a file is in a SMB pending delete state, it will not be included in the List Files results.Also note that the REST Delete File and REST Delete Directory operations are committed atomically and do not result in pending delete state.</target>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>For more information see:</source>
          <target state="new">For more information see:</target>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Managing File Locks</source>
          <target state="new">Managing File Locks</target>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Summary and Next Steps</source>
          <target state="new">Summary and Next Steps</target>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>The Microsoft Azure Storage service has been designed to meet the needs of the most complex online applications without forcing developers to compromise or rethink key design assumptions such as concurrency and data consistency that they have come to take for granted.</source>
          <target state="new">The Microsoft Azure Storage service has been designed to meet the needs of the most complex online applications without forcing developers to compromise or rethink key design assumptions such as concurrency and data consistency that they have come to take for granted.</target>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>For the complete sample application referenced in this blog:</source>
          <target state="new">For the complete sample application referenced in this blog:</target>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Managing Concurrency using Azure Storage - Sample Application</source>
          <target state="new">Managing Concurrency using Azure Storage - Sample Application</target>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>For more information on Azure Storage see:</source>
          <target state="new">For more information on Azure Storage see:</target>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Microsoft Azure Storage Home Page</source>
          <target state="new">Microsoft Azure Storage Home Page</target>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Introduction to Azure Storage</source>
          <target state="new">Introduction to Azure Storage</target>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>Storage Getting Started for <bpt id="p1">[</bpt>Blob<ept id="p1">](storage-dotnet-how-to-use-blobs.md)</ept>, <bpt id="p2">[</bpt>Table<ept id="p2">](storage-dotnet-how-to-use-tables.md)</ept> and <bpt id="p3">[</bpt>Queues<ept id="p3">](storage-dotnet-how-to-use-queues.md)</ept></source>
          <target state="new">Storage Getting Started for <bpt id="p1">[</bpt>Blob<ept id="p1">](storage-dotnet-how-to-use-blobs.md)</ept>, <bpt id="p2">[</bpt>Table<ept id="p2">](storage-dotnet-how-to-use-tables.md)</ept> and <bpt id="p3">[</bpt>Queues<ept id="p3">](storage-dotnet-how-to-use-queues.md)</ept></target>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Storage Architecture – <bpt id="p1">[</bpt>Microsoft Azure Storage : A Highly Available Cloud Storage Service with Strong Consistency<ept id="p1">](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)</ept></source>
          <target state="new">Storage Architecture – <bpt id="p1">[</bpt>Microsoft Azure Storage : A Highly Available Cloud Storage Service with Strong Consistency<ept id="p1">](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)</ept></target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f38eb06c376f48fbdfb4754678844a05ea0a6b4c</xliffext:olfilehash>
  </header>
</xliff>