<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Create table as select (CTAS) in SQL Data Warehouse | Microsoft Azure</source>
          <target state="new">Create table as select (CTAS) in SQL Data Warehouse | Microsoft Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Tips for coding with the create table as select (CTAS) statement in Azure SQL Data Warehouse for developing solutions.</source>
          <target state="new">Tips for coding with the create table as select (CTAS) statement in Azure SQL Data Warehouse for developing solutions.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Create Table As Select (CTAS) in SQL Data Warehouse</source>
          <target state="new">Create Table As Select (CTAS) in SQL Data Warehouse</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Create table as select or CTAS is one of the most important T-SQL features available.</source>
          <target state="new">Create table as select or CTAS is one of the most important T-SQL features available.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>It is a fully parallelized operation that creates a new table based on the output of a Select statement.</source>
          <target state="new">It is a fully parallelized operation that creates a new table based on the output of a Select statement.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You can consider it to be a supercharged version of SELECT..INTO if you would like.</source>
          <target state="new">You can consider it to be a supercharged version of SELECT..INTO if you would like.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>CTAS can also be used to work around a number of the unsupported features listed above.</source>
          <target state="new">CTAS can also be used to work around a number of the unsupported features listed above.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>This can often prove to be a win/win situation as not only will your code be compliant but it will often execute faster on SQL Data Warehouse.</source>
          <target state="new">This can often prove to be a win/win situation as not only will your code be compliant but it will often execute faster on SQL Data Warehouse.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This is as a result of its fully parallelized design.</source>
          <target state="new">This is as a result of its fully parallelized design.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Try to think "CTAS first".</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Try to think "CTAS first".</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>If you think you can solve a problem using CTAS then that is generally the best way to approach it - even if you are writing more data as a result.</source>
          <target state="new">If you think you can solve a problem using CTAS then that is generally the best way to approach it - even if you are writing more data as a result.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Scenarios that can be worked around with CTAS include:</source>
          <target state="new">Scenarios that can be worked around with CTAS include:</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>SELECT..INTO</source>
          <target state="new">SELECT..INTO</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>ANSI JOINS on UPDATEs</source>
          <target state="new">ANSI JOINS on UPDATEs</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>ANSI JOINs on DELETEs</source>
          <target state="new">ANSI JOINs on DELETEs</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>MERGE statement</source>
          <target state="new">MERGE statement</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>This document also includes some best practices for when coding with CTAS.</source>
          <target state="new">This document also includes some best practices for when coding with CTAS.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>SELECT..INTO</source>
          <target state="new">SELECT..INTO</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>You may find SELECT..INTO appears in a number of places in your solution.</source>
          <target state="new">You may find SELECT..INTO appears in a number of places in your solution.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>An SELECT..INTO example is below:</source>
          <target state="new">An SELECT..INTO example is below:</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>To convert this to CTAS is quite straight-forward:</source>
          <target state="new">To convert this to CTAS is quite straight-forward:</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Using CTAS means you can also specify a data distribution preference and optional index the table as well.</source>
          <target state="new">Using CTAS means you can also specify a data distribution preference and optional index the table as well.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>ANSI join replacement for update statements</source>
          <target state="new">ANSI join replacement for update statements</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>You may find you have a complex update that joins more than two tables together using ANSI joining syntax to perform the UPDATE or DELETE.</source>
          <target state="new">You may find you have a complex update that joins more than two tables together using ANSI joining syntax to perform the UPDATE or DELETE.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Imagine you had to update this table:</source>
          <target state="new">Imagine you had to update this table:</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The original query might have looked something like this:</source>
          <target state="new">The original query might have looked something like this:</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>As SQL Data Warehouse does not support ANSI joins you cannot copy this code over without changing it slightly.</source>
          <target state="new">As SQL Data Warehouse does not support ANSI joins you cannot copy this code over without changing it slightly.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>You can use a combination of a CTAS and an implicit join to replace this code:</source>
          <target state="new">You can use a combination of a CTAS and an implicit join to replace this code:</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>ANSI join replacement for delete statements</source>
          <target state="new">ANSI join replacement for delete statements</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Sometimes the best approach for deleting data is to use CTAS.</source>
          <target state="new">Sometimes the best approach for deleting data is to use CTAS.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Rather than deleting the data simply select the data you want to keep.</source>
          <target state="new">Rather than deleting the data simply select the data you want to keep.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>This especially true for DELETE statements that use ansi joining syntax as this is not supported on SQL Data Warehouse.</source>
          <target state="new">This especially true for DELETE statements that use ansi joining syntax as this is not supported on SQL Data Warehouse.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>An example of a converted DELETE statement is available below:</source>
          <target state="new">An example of a converted DELETE statement is available below:</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Replace merge statements</source>
          <target state="new">Replace merge statements</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Merge statements can be replaced, at least in part, by using CTAS.</source>
          <target state="new">Merge statements can be replaced, at least in part, by using CTAS.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>You can consolidate the <ph id="ph1">`INSERT`</ph> and the <ph id="ph2">`UPDATE`</ph> into a single statement.</source>
          <target state="new">You can consolidate the <ph id="ph1">`INSERT`</ph> and the <ph id="ph2">`UPDATE`</ph> into a single statement.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Any deleted records would need to be closed off in a second statement.</source>
          <target state="new">Any deleted records would need to be closed off in a second statement.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>An example of an <ph id="ph1">`UPSERT`</ph> is available below:</source>
          <target state="new">An example of an <ph id="ph1">`UPSERT`</ph> is available below:</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>CTAS recommendation: Explicitly state data type and nullability of output</source>
          <target state="new">CTAS recommendation: Explicitly state data type and nullability of output</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>When migrating code you might find you run across this type of coding pattern:</source>
          <target state="new">When migrating code you might find you run across this type of coding pattern:</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Instinctively you might think you should migrate this code to a CTAS and you would be correct.</source>
          <target state="new">Instinctively you might think you should migrate this code to a CTAS and you would be correct.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>However, their is a hidden issue here.</source>
          <target state="new">However, their is a hidden issue here.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The following code does NOT yield the same result:</source>
          <target state="new">The following code does NOT yield the same result:</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Notice that the column "result" carries forward the data type and nullability values of the expression.</source>
          <target state="new">Notice that the column "result" carries forward the data type and nullability values of the expression.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>This can lead to subtle variances in values if you aren't careful.</source>
          <target state="new">This can lead to subtle variances in values if you aren't careful.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Try the following as an example:</source>
          <target state="new">Try the following as an example:</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The value stored for result is different.</source>
          <target state="new">The value stored for result is different.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>As the persisted value in the result column is used in other expressions the error becomes even more significant.</source>
          <target state="new">As the persisted value in the result column is used in other expressions the error becomes even more significant.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>![][1]</source>
          <target state="new">![][1]</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>This is particularly important for data migrations.</source>
          <target state="new">This is particularly important for data migrations.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Even though the second query is arguably more accurate there is a problem.</source>
          <target state="new">Even though the second query is arguably more accurate there is a problem.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The data would be different compared to the source system and that leads to questions of integrity in the migration.</source>
          <target state="new">The data would be different compared to the source system and that leads to questions of integrity in the migration.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>This is one of those rare cases where the "wrong" answer is actually the right one!</source>
          <target state="new">This is one of those rare cases where the "wrong" answer is actually the right one!</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The reason we see this disparity between the two results is down to implicit type casting.</source>
          <target state="new">The reason we see this disparity between the two results is down to implicit type casting.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>In the first example the table defines the column definition.</source>
          <target state="new">In the first example the table defines the column definition.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>When the row is inserted an implicit type conversion occurs.</source>
          <target state="new">When the row is inserted an implicit type conversion occurs.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In the second example there is no implicit type conversion as the expression defines data type of the column.</source>
          <target state="new">In the second example there is no implicit type conversion as the expression defines data type of the column.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Notice also that the column in the second example has been defined as a NULLable column whereas in the first example it has not.</source>
          <target state="new">Notice also that the column in the second example has been defined as a NULLable column whereas in the first example it has not.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>When the table was created in the first example column nullability was explicitly defined.</source>
          <target state="new">When the table was created in the first example column nullability was explicitly defined.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>In the second example it was just left to the expression and by default this would result in a NULL definition.</source>
          <target state="new">In the second example it was just left to the expression and by default this would result in a NULL definition.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>To resolve these issues you must explicitly set the type conversion and nullability in the SELECT portion of the CTAS statement.</source>
          <target state="new">To resolve these issues you must explicitly set the type conversion and nullability in the SELECT portion of the CTAS statement.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>You cannot set these properties in the create table part.</source>
          <target state="new">You cannot set these properties in the create table part.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The example below demonstrates how to fix the code:</source>
          <target state="new">The example below demonstrates how to fix the code:</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Note the following:</source>
          <target state="new">Note the following:</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>CAST or CONVERT could have been used</source>
          <target state="new">CAST or CONVERT could have been used</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>ISNULL is used to force NULLability not COALESCE</source>
          <target state="new">ISNULL is used to force NULLability not COALESCE</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>ISNULL is the outermost function</source>
          <target state="new">ISNULL is the outermost function</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The second part of the ISNULL is a constant i.e. 0</source>
          <target state="new">The second part of the ISNULL is a constant i.e. 0</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> For the nullability to be correctly set it is vital to use ISNULL and not COALESCE.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> For the nullability to be correctly set it is vital to use ISNULL and not COALESCE.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>COALESCE is not a deterministic function and so the result of the expression will always be NULLable.</source>
          <target state="new">COALESCE is not a deterministic function and so the result of the expression will always be NULLable.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>ISNULL is different.</source>
          <target state="new">ISNULL is different.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>It is deterministic.</source>
          <target state="new">It is deterministic.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Therefore when the second part of the ISNULL function is a constant or a literal then the resulting value will be NOT NULL.</source>
          <target state="new">Therefore when the second part of the ISNULL function is a constant or a literal then the resulting value will be NOT NULL.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>This tip is not just useful for ensuring the integrity of your calculations.</source>
          <target state="new">This tip is not just useful for ensuring the integrity of your calculations.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>It is also important for table partition switching.</source>
          <target state="new">It is also important for table partition switching.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Imagine you have this table defined as your fact:</source>
          <target state="new">Imagine you have this table defined as your fact:</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>However, the value field is a calculated expression it is not part of the source data.</source>
          <target state="new">However, the value field is a calculated expression it is not part of the source data.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>To create your partitioned dataset you might want to do this:</source>
          <target state="new">To create your partitioned dataset you might want to do this:</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The query would run perfectly fine.</source>
          <target state="new">The query would run perfectly fine.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The problem comes when you try to perform the partition switch.</source>
          <target state="new">The problem comes when you try to perform the partition switch.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The table definitions do not match.</source>
          <target state="new">The table definitions do not match.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>To make the table definitions match the CTAS needs to be modified.</source>
          <target state="new">To make the table definitions match the CTAS needs to be modified.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>You can see therefore that type consistency and maintaining nullability properties on a CTAS is a good engineering best practice.</source>
          <target state="new">You can see therefore that type consistency and maintaining nullability properties on a CTAS is a good engineering best practice.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>It helps to maintain integrity in your calculations and also ensures that partition switching is possible.</source>
          <target state="new">It helps to maintain integrity in your calculations and also ensures that partition switching is possible.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Please refer to MSDN for more information on using [CTAS][].</source>
          <target state="new">Please refer to MSDN for more information on using [CTAS][].</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>It is one of the most important statements in Azure SQL Data Warehouse.</source>
          <target state="new">It is one of the most important statements in Azure SQL Data Warehouse.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Make sure you thoroughly understand it.</source>
          <target state="new">Make sure you thoroughly understand it.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="new">Next steps</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For more development tips, see <bpt id="p1">[</bpt>development overview<ept id="p1">][]</ept>.</source>
          <target state="new">For more development tips, see <bpt id="p1">[</bpt>development overview<ept id="p1">][]</ept>.</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9d10a742edd01102a17166ac4e2aabf7f882f594</xliffext:olfilehash>
  </header>
</xliff>