<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Sorting DocumentDB data using Order By | Microsoft Azure</source>
          <target state="new">Sorting DocumentDB data using Order By | Microsoft Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Learn how to use ORDER BY in DocumentDB queries in LINQ and SQL, and how to specify an indexing policy for ORDER BY queries.</source>
          <target state="new">Learn how to use ORDER BY in DocumentDB queries in LINQ and SQL, and how to specify an indexing policy for ORDER BY queries.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Sorting DocumentDB data using Order By</source>
          <target state="new">Sorting DocumentDB data using Order By</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Microsoft Azure DocumentDB supports querying documents using SQL over JSON documents.</source>
          <target state="new">Microsoft Azure DocumentDB supports querying documents using SQL over JSON documents.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Query results can be ordered using the ORDER BY clause in SQL query statements.</source>
          <target state="new">Query results can be ordered using the ORDER BY clause in SQL query statements.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>After reading this article, you'll be able to answer the following questions:</source>
          <target state="new">After reading this article, you'll be able to answer the following questions:</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>How do I query with Order By?</source>
          <target state="new">How do I query with Order By?</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>How do I configure an indexing policy for Order By?</source>
          <target state="new">How do I configure an indexing policy for Order By?</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>What's coming next?</source>
          <target state="new">What's coming next?</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Samples<ept id="p1">](#samples)</ept> and an <bpt id="p2">[</bpt>FAQ<ept id="p2">](#faq)</ept> are also provided.</source>
          <target state="new"><bpt id="p1">[</bpt>Samples<ept id="p1">](#samples)</ept> and an <bpt id="p2">[</bpt>FAQ<ept id="p2">](#faq)</ept> are also provided.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For a complete reference on SQL querying, see the <bpt id="p1">[</bpt>DocumentDB Query tutorial<ept id="p1">](documentdb-sql-query.md)</ept>.</source>
          <target state="new">For a complete reference on SQL querying, see the <bpt id="p1">[</bpt>DocumentDB Query tutorial<ept id="p1">](documentdb-sql-query.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>How to Query with Order By</source>
          <target state="new">How to Query with Order By</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Like in ANSI-SQL, you can now include an optional Order By clause in SQL statements when querying DocumentDB.</source>
          <target state="new">Like in ANSI-SQL, you can now include an optional Order By clause in SQL statements when querying DocumentDB.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The clause can include an optional ASC/DESC argument to specify the order in which results must be retrieved.</source>
          <target state="new">The clause can include an optional ASC/DESC argument to specify the order in which results must be retrieved.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Ordering using SQL</source>
          <target state="new">Ordering using SQL</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>For example here's a query to retrieve books in descending order of their titles.</source>
          <target state="new">For example here's a query to retrieve books in descending order of their titles.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Ordering using SQL with Filtering</source>
          <target state="new">Ordering using SQL with Filtering</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You can order using any nested property within documents like Books.ShippingDetails.Weight, and you can specify additional filters in the WHERE clause in combination with Order By like in this example:</source>
          <target state="new">You can order using any nested property within documents like Books.ShippingDetails.Weight, and you can specify additional filters in the WHERE clause in combination with Order By like in this example:</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Ordering using the LINQ Provider for .NET</source>
          <target state="new">Ordering using the LINQ Provider for .NET</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Using the .NET SDK version 1.2.0 and higher, you can also use the OrderBy() or OrderByDescending() clause within LINQ queries like in this example:</source>
          <target state="new">Using the .NET SDK version 1.2.0 and higher, you can also use the OrderBy() or OrderByDescending() clause within LINQ queries like in this example:</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Ordering with paging using the .NET SDK</source>
          <target state="new">Ordering with paging using the .NET SDK</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Using the native paging support within the DocumentDB SDKs, you can retrieve results one page at a time like in the following .NET code snippet.</source>
          <target state="new">Using the native paging support within the DocumentDB SDKs, you can retrieve results one page at a time like in the following .NET code snippet.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Here we fetch results up to 10 at a time using the FeedOptions.MaxItemCount and the IDocumentQuery interface.</source>
          <target state="new">Here we fetch results up to 10 at a time using the FeedOptions.MaxItemCount and the IDocumentQuery interface.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>DocumentDB supports ordering with a single numeric, string or Boolean property per query, with additional query types coming soon.</source>
          <target state="new">DocumentDB supports ordering with a single numeric, string or Boolean property per query, with additional query types coming soon.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Please see <bpt id="p1">[</bpt>What's coming next<ept id="p1">](#Whats_coming_next)</ept> for more details.</source>
          <target state="new">Please see <bpt id="p1">[</bpt>What's coming next<ept id="p1">](#Whats_coming_next)</ept> for more details.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Configure an indexing policy for Order By</source>
          <target state="new">Configure an indexing policy for Order By</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Recall that DocumentDB supports two kinds of indexes (Hash and Range), which can be set for specific paths/properties, data types (strings/numbers) and at different precision values (either maximum precision or a fixed precision value).</source>
          <target state="new">Recall that DocumentDB supports two kinds of indexes (Hash and Range), which can be set for specific paths/properties, data types (strings/numbers) and at different precision values (either maximum precision or a fixed precision value).</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Since DocumentDB uses Hash indexing as default, you must create a new collection with a custom indexing policy with Range on numbers, strings or both, in order to use Order By.</source>
          <target state="new">Since DocumentDB uses Hash indexing as default, you must create a new collection with a custom indexing policy with Range on numbers, strings or both, in order to use Order By.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> String range indexes were introduced on July 7, 2015 with REST API version 2015-06-03.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> String range indexes were introduced on July 7, 2015 with REST API version 2015-06-03.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>In order to create policies for Order By against strings, you must use SDK version 1.2.0 of the .NET SDK, or version 1.1.0 of the Python, Node.js or Java SDK.</source>
          <target state="new">In order to create policies for Order By against strings, you must use SDK version 1.2.0 of the .NET SDK, or version 1.1.0 of the Python, Node.js or Java SDK.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Prior to REST API version 2015-06-03, the default collection indexing policy was Hash for both strings and numbers.</source>
          <target state="new">Prior to REST API version 2015-06-03, the default collection indexing policy was Hash for both strings and numbers.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>This has been changed to Hash for strings, and Range for numbers.</source>
          <target state="new">This has been changed to Hash for strings, and Range for numbers.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>For more details see <bpt id="p1">[</bpt>DocumentDB indexing policies<ept id="p1">](documentdb-indexing-policies.md)</ept>.</source>
          <target state="new">For more details see <bpt id="p1">[</bpt>DocumentDB indexing policies<ept id="p1">](documentdb-indexing-policies.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Indexing for Order By against all properties</source>
          <target state="new">Indexing for Order By against all properties</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Here's how you can create a collection with "All Range" indexing for Order By against any/all numeric or string properties that appear within JSON documents within it.</source>
          <target state="new">Here's how you can create a collection with "All Range" indexing for Order By against any/all numeric or string properties that appear within JSON documents within it.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Here, "/*" represents all JSON properties/paths within the collection, and -1 represents the maximum precision.</source>
          <target state="new">Here, "/*" represents all JSON properties/paths within the collection, and -1 represents the maximum precision.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Note that Order By only will return results of the data types (String and Number) that are indexed with a RangeIndex.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Note that Order By only will return results of the data types (String and Number) that are indexed with a RangeIndex.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>For example, if you have the default indexing policy which only has RangeIndex on numbers, an Order By against a path with string values will return no documents.</source>
          <target state="new">For example, if you have the default indexing policy which only has RangeIndex on numbers, an Order By against a path with string values will return no documents.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Indexing for Order By for a single property</source>
          <target state="new">Indexing for Order By for a single property</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Here's how you can create a collection with indexing for Order By against just the Title property, which is a string.</source>
          <target state="new">Here's how you can create a collection with indexing for Order By against just the Title property, which is a string.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>There are two paths, one for the Title property ("/Title/?") with Range indexing, and the other for every other property with the default indexing scheme, which is Hash for strings and Range for numbers.</source>
          <target state="new">There are two paths, one for the Title property ("/Title/?") with Range indexing, and the other for every other property with the default indexing scheme, which is Hash for strings and Range for numbers.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Samples</source>
          <target state="new">Samples</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Take a look at this <bpt id="p1">[</bpt>Github samples project<ept id="p1">](https://github.com/Azure/azure-documentdb-net/tree/master/samples/orderby)</ept> that demonstrates how to use Order By, including creating indexing policies and paging using Order By.</source>
          <target state="new">Take a look at this <bpt id="p1">[</bpt>Github samples project<ept id="p1">](https://github.com/Azure/azure-documentdb-net/tree/master/samples/orderby)</ept> that demonstrates how to use Order By, including creating indexing policies and paging using Order By.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The samples are open source and we encourage you to submit pull requests with contributions that could benefit other DocumentDB developers.</source>
          <target state="new">The samples are open source and we encourage you to submit pull requests with contributions that could benefit other DocumentDB developers.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Please refer to the <bpt id="p1">[</bpt>Contribution guidelines<ept id="p1">](https://github.com/Azure/azure-documentdb-net/blob/master/Contributing.md)</ept> for guidance on how to contribute.</source>
          <target state="new">Please refer to the <bpt id="p1">[</bpt>Contribution guidelines<ept id="p1">](https://github.com/Azure/azure-documentdb-net/blob/master/Contributing.md)</ept> for guidance on how to contribute.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>What's coming next?</source>
          <target state="new">What's coming next?</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Future service updates will expand on the Order By support introduced here.</source>
          <target state="new">Future service updates will expand on the Order By support introduced here.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>We are working on the following additions and will prioritize the release of these improvements based on your feedback:</source>
          <target state="new">We are working on the following additions and will prioritize the release of these improvements based on your feedback:</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Dynamic Indexing Policies: Support to modify indexing policy after collection creation and in the Azure Portal</source>
          <target state="new">Dynamic Indexing Policies: Support to modify indexing policy after collection creation and in the Azure Portal</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Support for Compound Indexes for more efficient Order By and Order By on multiple properties.</source>
          <target state="new">Support for Compound Indexes for more efficient Order By and Order By on multiple properties.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>FAQ</source>
          <target state="new">FAQ</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Which platforms/versions of the SDK support ordering?</source>
          <target state="new">Which platforms/versions of the SDK support ordering?</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>In order to create collections with the indexing policy required for Order By, you must download the latest drop of the SDK (1.2.0 for .NET and 1.1.0 for Node.js, JavaScript, Python and Java).</source>
          <target state="new">In order to create collections with the indexing policy required for Order By, you must download the latest drop of the SDK (1.2.0 for .NET and 1.1.0 for Node.js, JavaScript, Python and Java).</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The .NET SDK 1.2.0 is also required to use OrderBy() and OrderByDescending() within LINQ expressions.</source>
          <target state="new">The .NET SDK 1.2.0 is also required to use OrderBy() and OrderByDescending() within LINQ expressions.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>What is the expected Request Unit (RU) consumption of Order By queries?</source>
          <target state="new">What is the expected Request Unit (RU) consumption of Order By queries?</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Since Order By utilizes the DocumentDB index for lookups, the number of request units consumed by Order By queries will be similar to the equivalent queries without Order By.</source>
          <target state="new">Since Order By utilizes the DocumentDB index for lookups, the number of request units consumed by Order By queries will be similar to the equivalent queries without Order By.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Like any other operation on DocumentDB, the number of request units depends on the sizes/shapes of documents as well as the complexity of the query.</source>
          <target state="new">Like any other operation on DocumentDB, the number of request units depends on the sizes/shapes of documents as well as the complexity of the query.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>What is the expected indexing overhead for Order By?</source>
          <target state="new">What is the expected indexing overhead for Order By?</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The indexing storage overhead will be proportionate to the number of properties.</source>
          <target state="new">The indexing storage overhead will be proportionate to the number of properties.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>In the worst case scenario, the index overhead will be 100% of the data.</source>
          <target state="new">In the worst case scenario, the index overhead will be 100% of the data.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>There is no difference in throughput (Request Units) overhead between Range/Order By indexing and the default Hash indexing.</source>
          <target state="new">There is no difference in throughput (Request Units) overhead between Range/Order By indexing and the default Hash indexing.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>How do I query my existing data in DocumentDB using Order By?</source>
          <target state="new">How do I query my existing data in DocumentDB using Order By?</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>This will be supported with the availability of the  Dynamic Indexing Policies improvement mentioned in the <bpt id="p1">[</bpt>What's Coming Next<ept id="p1">](what's-coming-next)</ept> section.</source>
          <target state="new">This will be supported with the availability of the  Dynamic Indexing Policies improvement mentioned in the <bpt id="p1">[</bpt>What's Coming Next<ept id="p1">](what's-coming-next)</ept> section.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>In order to do this today, you have to export your data and re-import into a new DocumentDB collection created with a Range/Order By Index.</source>
          <target state="new">In order to do this today, you have to export your data and re-import into a new DocumentDB collection created with a Range/Order By Index.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The DocumentDB Import Tool can be used to migrate your data between collections.</source>
          <target state="new">The DocumentDB Import Tool can be used to migrate your data between collections.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>What are the current limitations of Order By?</source>
          <target state="new">What are the current limitations of Order By?</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Order By can be specified only against a property, either numeric or String when it is range indexed with the Maximum Precision (-1).</source>
          <target state="new">Order By can be specified only against a property, either numeric or String when it is range indexed with the Maximum Precision (-1).</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>You cannot perform the following:</source>
          <target state="new">You cannot perform the following:</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Order By with internal string properties like id, _rid, and _self (coming soon).</source>
          <target state="new">Order By with internal string properties like id, _rid, and _self (coming soon).</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Order By with properties derived from the result of an intra-document join (coming soon).</source>
          <target state="new">Order By with properties derived from the result of an intra-document join (coming soon).</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Order By multiple properties (coming soon).</source>
          <target state="new">Order By multiple properties (coming soon).</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Order By with queries on databases, collections, users, permissions or attachments (coming soon).</source>
          <target state="new">Order By with queries on databases, collections, users, permissions or attachments (coming soon).</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Order By with computed properties e.g. the result of an expression or a UDF/built-in function.</source>
          <target state="new">Order By with computed properties e.g. the result of an expression or a UDF/built-in function.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="new">Next steps</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Fork the <bpt id="p1">[</bpt>Github samples project<ept id="p1">](https://github.com/Azure/azure-documentdb-net/tree/master/samples/orderby)</ept> and start ordering your data!</source>
          <target state="new">Fork the <bpt id="p1">[</bpt>Github samples project<ept id="p1">](https://github.com/Azure/azure-documentdb-net/tree/master/samples/orderby)</ept> and start ordering your data!</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="new">References</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>DocumentDB Query Reference</source>
          <target state="new">DocumentDB Query Reference</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>DocumentDB Indexing Policy Reference</source>
          <target state="new">DocumentDB Indexing Policy Reference</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>DocumentDB SQL Reference</source>
          <target state="new">DocumentDB SQL Reference</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>DocumentDB Order By Samples</source>
          <target state="new">DocumentDB Order By Samples</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>test</source>
          <target state="new">test</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b13381ab52b2c0f16730e698ac7ed2ca749635c7</xliffext:olfilehash>
  </header>
</xliff>