<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Automatic Indexing in DocumentDB | Microsoft Azure</source>
          <target state="new">Automatic Indexing in DocumentDB | Microsoft Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Learn about how automatic indexing works in Azure DocumentDB.</source>
          <target state="new">Learn about how automatic indexing works in Azure DocumentDB.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Automatic Indexing in Azure DocumentDB</source>
          <target state="new">Automatic Indexing in Azure DocumentDB</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>This article is excerpted from the <bpt id="p1">[</bpt>"Schema-Agnostic Indexing with Azure DocumentDB"<ept id="p1">](http://www.vldb.org/pvldb/vol8/p1668-shukla.pdf)</ept> paper, which will be presented at the <bpt id="p2">[</bpt>41st Internal Conference on Very Large Databases<ept id="p2">](http://www.vldb.org/2015/)</ept> between August 31 - September 4, 2015, and is an introduction into how indexing works in Azure DocumentDB.</source>
          <target state="new">This article is excerpted from the <bpt id="p1">[</bpt>"Schema-Agnostic Indexing with Azure DocumentDB"<ept id="p1">](http://www.vldb.org/pvldb/vol8/p1668-shukla.pdf)</ept> paper, which will be presented at the <bpt id="p2">[</bpt>41st Internal Conference on Very Large Databases<ept id="p2">](http://www.vldb.org/2015/)</ept> between August 31 - September 4, 2015, and is an introduction into how indexing works in Azure DocumentDB.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>After reading this, you will be answer the following questions:</source>
          <target state="new">After reading this, you will be answer the following questions:</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>How does DocumentDB infer the schema from a JSON document?</source>
          <target state="new">How does DocumentDB infer the schema from a JSON document?</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>How does DocumentDB build an index across disparate docuemnts?</source>
          <target state="new">How does DocumentDB build an index across disparate docuemnts?</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>How does DocumentDB perform automatic indexing at scale?</source>
          <target state="new">How does DocumentDB perform automatic indexing at scale?</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a id="HowDocumentDBIndexingWorks"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> How DocumentDB indexing works</source>
          <target state="new"><ph id="ph1">&lt;a id="HowDocumentDBIndexingWorks"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> How DocumentDB indexing works</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Microsoft Azure DocumentDB<ept id="p1">](http://azure.microsoft.com/services/documentdb/)</ept> is a true schema-free database purpose built for JSON.</source>
          <target state="new"><bpt id="p1">[</bpt>Microsoft Azure DocumentDB<ept id="p1">](http://azure.microsoft.com/services/documentdb/)</ept> is a true schema-free database purpose built for JSON.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>It does not expect or require any schema or secondary index definitions to index data at scale.</source>
          <target state="new">It does not expect or require any schema or secondary index definitions to index data at scale.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This allows you to quickly define and iterate on application data models using DocumentDB.</source>
          <target state="new">This allows you to quickly define and iterate on application data models using DocumentDB.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>As you add documents to a collection, DocumentDB automatically indexes all document properties so they are available for you to query.</source>
          <target state="new">As you add documents to a collection, DocumentDB automatically indexes all document properties so they are available for you to query.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Automatic indexing allows you to store documents belonging to completely arbitrary schemas without worrying about schemas or secondary indexes.</source>
          <target state="new">Automatic indexing allows you to store documents belonging to completely arbitrary schemas without worrying about schemas or secondary indexes.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>With a goal to eliminate the impedance mismatch between the database and the application programming models, DocumentDB exploits the simplicity of JSON and its lack of a schema specification.</source>
          <target state="new">With a goal to eliminate the impedance mismatch between the database and the application programming models, DocumentDB exploits the simplicity of JSON and its lack of a schema specification.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>It makes no assumptions about the documents and allows documents within a DocumentDB collection to vary in schema, in addition to the instance specific values.</source>
          <target state="new">It makes no assumptions about the documents and allows documents within a DocumentDB collection to vary in schema, in addition to the instance specific values.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>In contrast to other document databases, DocumentDB’s database engine operates directly at the level of JSON grammar, remaining agnostic to the concept of a document schema and blurring the boundary between the structure and instance values of documents.</source>
          <target state="new">In contrast to other document databases, DocumentDB’s database engine operates directly at the level of JSON grammar, remaining agnostic to the concept of a document schema and blurring the boundary between the structure and instance values of documents.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>This, in-turn, enables it to automatically index documents without requiring schema or secondary indexes.</source>
          <target state="new">This, in-turn, enables it to automatically index documents without requiring schema or secondary indexes.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The indexing in DocumentDB takes advantage of the fact that JSON grammar allows documents to be <bpt id="p1">**</bpt>represented as trees<ept id="p1">**</ept>.</source>
          <target state="new">The indexing in DocumentDB takes advantage of the fact that JSON grammar allows documents to be <bpt id="p1">**</bpt>represented as trees<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>For a JSON document to be represented as a tree, a dummy root node needs to be created which parents the rest of the actual nodes in the document underneath.</source>
          <target state="new">For a JSON document to be represented as a tree, a dummy root node needs to be created which parents the rest of the actual nodes in the document underneath.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Each label including the array indices in a JSON document becomes a node of the tree.</source>
          <target state="new">Each label including the array indices in a JSON document becomes a node of the tree.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The figure below illustrates an example JSON document and its corresponding tree representation.</source>
          <target state="new">The figure below illustrates an example JSON document and its corresponding tree representation.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Since JSON is self-describing i.e. each document includes both schema (metadata) and data, e.g. <ph id="ph2">`{"locationId", 5, "city": "Moscow"}`</ph> reveals that there are two properties <ph id="ph3">`locationId`</ph> and <ph id="ph4">`city`</ph>, and that they have a numeric and string property values.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Since JSON is self-describing i.e. each document includes both schema (metadata) and data, e.g. <ph id="ph2">`{"locationId", 5, "city": "Moscow"}`</ph> reveals that there are two properties <ph id="ph3">`locationId`</ph> and <ph id="ph4">`city`</ph>, and that they have a numeric and string property values.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>DocumentDB is able to infer the schema of documents and index them when they are inserted or replaced, without you ever having to define schemas or secondary indexes.</source>
          <target state="new">DocumentDB is able to infer the schema of documents and index them when they are inserted or replaced, without you ever having to define schemas or secondary indexes.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>JSON Documents as Trees:</source>
          <target state="new">JSON Documents as Trees:</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Documents as Trees</source>
          <target state="new">Documents as Trees</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For example, in the example shown above:</source>
          <target state="new">For example, in the example shown above:</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The JSON property <ph id="ph1">`{"headquarters": "Belgium"}`</ph> property in the above example corresponds to the path/headquarters/Belgium.</source>
          <target state="new">The JSON property <ph id="ph1">`{"headquarters": "Belgium"}`</ph> property in the above example corresponds to the path/headquarters/Belgium.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The JSON array <ph id="ph1">`{"exports": [{"city": “Moscow"}`</ph>, <ph id="ph2">`{"city": Athens"}]}`</ph> corresponds to the paths <ph id="ph3">`/exports/[]/city/Moscow`</ph> and <ph id="ph4">`/exports/[]/city/Athens`</ph>.</source>
          <target state="new">The JSON array <ph id="ph1">`{"exports": [{"city": “Moscow"}`</ph>, <ph id="ph2">`{"city": Athens"}]}`</ph> corresponds to the paths <ph id="ph3">`/exports/[]/city/Moscow`</ph> and <ph id="ph4">`/exports/[]/city/Athens`</ph>.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>With automatic indexing, (1) every path in a document tree is indexed (unless the developer has explicitly configured the indexing policy to exclude certain path patterns).</source>
          <target state="new">With automatic indexing, (1) every path in a document tree is indexed (unless the developer has explicitly configured the indexing policy to exclude certain path patterns).</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>(2) Each update of a document to a DocumentDB collection leads to update of the structure of the index (i.e., causes addition or removal of nodes).</source>
          <target state="new">(2) Each update of a document to a DocumentDB collection leads to update of the structure of the index (i.e., causes addition or removal of nodes).</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>One of the primary requirements of automatic indexing of documents is to ensure that the cost to index and query a document with deeply nested structure, say 10 levels, is the same as that of a flat JSON document consisting of key-value pairs just one level deep.</source>
          <target state="new">One of the primary requirements of automatic indexing of documents is to ensure that the cost to index and query a document with deeply nested structure, say 10 levels, is the same as that of a flat JSON document consisting of key-value pairs just one level deep.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Therefore a normalized path representation is the foundation upon which both automatic indexing and query subsystems are built.</source>
          <target state="new">Therefore a normalized path representation is the foundation upon which both automatic indexing and query subsystems are built.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>An important implication of treating both the schema and instance values uniformly in terms of paths is that logically, just like the individual documents, an index of the two documents shown that keeps a map between paths and the document ids containing that path can also be represented as a tree.</source>
          <target state="new">An important implication of treating both the schema and instance values uniformly in terms of paths is that logically, just like the individual documents, an index of the two documents shown that keeps a map between paths and the document ids containing that path can also be represented as a tree.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>DocumentDB uses this fact to build an index tree which is constructed out of the union of all of the trees representing individual documents within the collection.</source>
          <target state="new">DocumentDB uses this fact to build an index tree which is constructed out of the union of all of the trees representing individual documents within the collection.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The index tree in DocumentDB collections grows over time as new documents get added or updated to the collection.</source>
          <target state="new">The index tree in DocumentDB collections grows over time as new documents get added or updated to the collection.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>DocumentDB Index as a Tree:</source>
          <target state="new">DocumentDB Index as a Tree:</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Index as a Tree</source>
          <target state="new">Index as a Tree</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Despite being schema-free, DocumentDB’s SQL and JavaScript query languages provide relational projections and filters, hierarchical navigation across documents, and invocation of UDFs written entirely in JavaScript.</source>
          <target state="new">Despite being schema-free, DocumentDB’s SQL and JavaScript query languages provide relational projections and filters, hierarchical navigation across documents, and invocation of UDFs written entirely in JavaScript.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The DocumentDB’s query runtime is able to support these queries since it can operate directly against this index tree representation of the data.</source>
          <target state="new">The DocumentDB’s query runtime is able to support these queries since it can operate directly against this index tree representation of the data.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The default indexing policy automatically indexes all properties of all documents and provides consistent queries (meaning the index is updated synchronously with the document write).</source>
          <target state="new">The default indexing policy automatically indexes all properties of all documents and provides consistent queries (meaning the index is updated synchronously with the document write).</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>How does DocumentDB support consistent updates to the index tree at scale?</source>
          <target state="new">How does DocumentDB support consistent updates to the index tree at scale?</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>DocumentDB uses write optimized, lock free, and log structured index maintenance techniques.</source>
          <target state="new">DocumentDB uses write optimized, lock free, and log structured index maintenance techniques.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>This means that DocumentDB can support a sustained volume of fast writes while still serving consistent queries.</source>
          <target state="new">This means that DocumentDB can support a sustained volume of fast writes while still serving consistent queries.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>DocumentDB’s indexing is designed for storage efficiency and to handle multi-tenancy.</source>
          <target state="new">DocumentDB’s indexing is designed for storage efficiency and to handle multi-tenancy.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>For cost effectiveness, the on-disk storage overhead of the index is low and predictable.</source>
          <target state="new">For cost effectiveness, the on-disk storage overhead of the index is low and predictable.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Index updates are also performed within the budget of system resources allocated per DocumentDB collection.</source>
          <target state="new">Index updates are also performed within the budget of system resources allocated per DocumentDB collection.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="NextSteps"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> Next steps</source>
          <target state="new"><ph id="ph1">&lt;a name="NextSteps"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> Next steps</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Download <bpt id="p1">[</bpt>"Schema-Agnostic Indexing with Azure DocumentDB"<ept id="p1">](http://www.vldb.org/pvldb/vol8/p1668-shukla.pdf)</ept>, to be presented at the 41st Internal Conference on Very Large Databases, August 31 - September 4, 2015.</source>
          <target state="new">Download <bpt id="p1">[</bpt>"Schema-Agnostic Indexing with Azure DocumentDB"<ept id="p1">](http://www.vldb.org/pvldb/vol8/p1668-shukla.pdf)</ept>, to be presented at the 41st Internal Conference on Very Large Databases, August 31 - September 4, 2015.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Query with DocumentDB SQL</source>
          <target state="new">Query with DocumentDB SQL</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Learn about how to customize the DocumentDB index <bpt id="p1">[</bpt>here<ept id="p1">](documentdb-indexing-policies.md)</ept></source>
          <target state="new">Learn about how to customize the DocumentDB index <bpt id="p1">[</bpt>here<ept id="p1">](documentdb-indexing-policies.md)</ept></target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>test</source>
          <target state="new">test</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9d3ca4e595a6458a7dd486630e6ed38d6392bac6</xliffext:olfilehash>
  </header>
</xliff>