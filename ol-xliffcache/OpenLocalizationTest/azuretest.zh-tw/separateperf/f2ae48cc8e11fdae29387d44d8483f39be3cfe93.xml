{
  "nodes": [
    {
      "content": "Scalability checklist | Microsoft Azure",
      "pos": [
        26,
        65
      ]
    },
    {
      "content": "Scalability checklist guidance for design concerns for Azure Autoscaling.",
      "pos": [
        83,
        156
      ]
    },
    {
      "content": "Scalability checklist",
      "pos": [
        444,
        465
      ]
    },
    {
      "content": "Service design",
      "pos": [
        532,
        546
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Partition the workload<ept id=\"p1\">**</ept>.",
      "pos": [
        549,
        576
      ]
    },
    {
      "content": "Design parts of the process to be discrete and decomposable, and minimize the size of each part while following the typical rules for separation of concerns and the single responsibility principle.",
      "pos": [
        577,
        774
      ]
    },
    {
      "content": "This allows the component parts to be distributed in a way that maximizes use of each compute unit (such as a role or database server) and makes it easier to scale the application by adding additional instances of specific resources.",
      "pos": [
        775,
        1008
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Compute Partitioning Guidance<ept id=\"p1\">](https://msdn.microsoft.com/library/dn568099.aspx)</ept>.",
      "pos": [
        1009,
        1117
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Design for scaling<ept id=\"p1\">**</ept>.",
      "pos": [
        1120,
        1143
      ]
    },
    {
      "content": "Scaling allows applications to react to variable load by increasing and decreasing the number of instances of roles, queues, and other services they use.",
      "pos": [
        1144,
        1297
      ]
    },
    {
      "content": "However, the application must be designed with this in mind.",
      "pos": [
        1298,
        1358
      ]
    },
    {
      "content": "For example, the application and the services it uses must be stateless to allow requests to be routed to any instance, and so that the addition or removal of specific instances does not adversely impact current users.",
      "pos": [
        1359,
        1577
      ]
    },
    {
      "content": "It is also necessary to implement configuration or auto-detection of instances as they are added and removed so that code in the application can perform the necessary routing.",
      "pos": [
        1578,
        1753
      ]
    },
    {
      "content": "For example, a web application might use a set of queues in a round-robin approach to route requests to background services running in worker roles.",
      "pos": [
        1754,
        1902
      ]
    },
    {
      "content": "The web application must be able to detect changes in the number of queues in order to successfully route requests and balance the load on the application.",
      "pos": [
        1903,
        2058
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Scale as a unit<ept id=\"p1\">**</ept>.",
      "pos": [
        2061,
        2081
      ]
    },
    {
      "content": "Plan for adding additional resources to accommodate growth.",
      "pos": [
        2082,
        2141
      ]
    },
    {
      "content": "For each resource, you should know the upper scaling limits and use sharding or decomposition to go beyond these limits.",
      "pos": [
        2142,
        2262
      ]
    },
    {
      "content": "Determine the scale units for the system in terms of well-defined sets of resources.",
      "pos": [
        2263,
        2347
      ]
    },
    {
      "content": "This makes applying scale out operations easier and less prone to negative impact on the application through limitations imposed by lack of resources in some part of the overall system.",
      "pos": [
        2348,
        2533
      ]
    },
    {
      "content": "For example, adding x number of web and worker roles might require y number of additional queues and z number of storage accounts to handle the additional workload generated by the roles , so a scale unit could consist of x web and worker roles, <bpt id=\"p1\">_</bpt>y<ept id=\"p1\">_</ept> queues, and <bpt id=\"p2\">_</bpt>z<ept id=\"p2\">_</ept> storage accounts.",
      "pos": [
        2535,
        2818
      ]
    },
    {
      "content": "Design the application so that it is easily scaled by adding one or more scale units.",
      "pos": [
        2819,
        2904
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Avoid client affinity<ept id=\"p1\">**</ept>.",
      "pos": [
        2907,
        2933
      ]
    },
    {
      "content": "Where possible, ensure that the application does not require affinity so that requests can be routed to any instance, and the number of instances is irrelevant.",
      "pos": [
        2934,
        3094
      ]
    },
    {
      "content": "This also avoids the overhead of storing, retrieving, and maintaining state information for each user.",
      "pos": [
        3095,
        3197
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Take advantage of platform autoscaling features<ept id=\"p1\">**</ept>.",
      "pos": [
        3200,
        3252
      ]
    },
    {
      "content": "Where the hosting platform supports an autoscaling capability, such as Azure Autoscaling, prefer it to custom or third party mechanisms unless the built-in mechanism cannot fulfil your requirements.",
      "pos": [
        3253,
        3451
      ]
    },
    {
      "content": "Use scheduled scaling rules where possible to ensure resources are available without a start-up delay, but add reactive autoscaling to the rules where appropriate to cope with unexpected changes in demand.",
      "pos": [
        3452,
        3657
      ]
    },
    {
      "content": "You can use the autoscaling operations in the Service Management API to fine tune autoscaling and add custom counters to rules beyond the configuration options available in the web portal.",
      "pos": [
        3658,
        3846
      ]
    },
    {
      "content": "For more information, see the page <bpt id=\"p1\">[</bpt>Auto-scaling guidance<ept id=\"p1\">](best-practices-auto-scaling.md)</ept>.",
      "pos": [
        3847,
        3938
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Offload intensive CPU/IO tasks as background tasks<ept id=\"p1\">**</ept>.",
      "pos": [
        3941,
        3996
      ]
    },
    {
      "content": "If a request to a service is expected to take a long time to run or absorb considerable resources, then offload the processing for this request to a separate task.",
      "pos": [
        3997,
        4160
      ]
    },
    {
      "content": "Use worker roles or background jobs (depending on the hosting platform) to execute these tasks.",
      "pos": [
        4161,
        4256
      ]
    },
    {
      "content": "This strategy enables the service to continue receiving further requests and remain responsive.",
      "pos": [
        4257,
        4352
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Background jobs guidance<ept id=\"p1\">](best-practices-background-jobs.md)</ept>.",
      "pos": [
        4354,
        4442
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Distribute the workload for background tasks<ept id=\"p1\">**</ept>.",
      "pos": [
        4445,
        4494
      ]
    },
    {
      "content": "Where there are many background tasks, or the tasks require considerable time or resources, spread the work across multiple compute units (such as worker roles or background jobs).",
      "pos": [
        4495,
        4675
      ]
    },
    {
      "content": "The <bpt id=\"p1\">[</bpt>Competing Consumers Pattern<ept id=\"p1\">](https://msdn.microsoft.com/library/dn568101.aspx)</ept> provides one possible solution.",
      "pos": [
        4676,
        4791
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Consider moving towards a <bpt id=\"p2\">_</bpt>shared nothing<ept id=\"p2\">_</ept> architecture<ept id=\"p1\">**</ept>.",
      "pos": [
        4794,
        4854
      ]
    },
    {
      "content": "A shared nothing architecture uses independent and self-sufficient nodes that have no single point of contention such as shared services or storage.",
      "pos": [
        4855,
        5003
      ]
    },
    {
      "content": "In theory, such a system can scale almost indefinitely.",
      "pos": [
        5004,
        5059
      ]
    },
    {
      "content": "While a fully shared nothing approach is generally not practical for most applications, it may provide opportunities to design for better scalability.",
      "pos": [
        5060,
        5210
      ]
    },
    {
      "content": "For example, avoiding the use of server-side session state, client affinity, and data partitioning are good examples of moving towards a shared nothing architecture.",
      "pos": [
        5211,
        5376
      ]
    },
    {
      "content": "Data management",
      "pos": [
        5381,
        5396
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Use data partitioning<ept id=\"p1\">**</ept>.",
      "pos": [
        5400,
        5426
      ]
    },
    {
      "content": "Divide the data across multiple databases and database servers, or design the application to use data storage services that can provide this partitioning transparently (examples include Azure SQL Database Elastic Scale, and Azure Table storage).",
      "pos": [
        5427,
        5672
      ]
    },
    {
      "content": "This approach can help to maximize performance and allow easier scaling.",
      "pos": [
        5673,
        5745
      ]
    },
    {
      "content": "There are different partitioning techniques such as horizontal, vertical, and functional partitioning, and you can use a combination of these to achieve maximum benefit from increased query performance, simpler scalability, more flexible management, better availability, and to match the type of store to the data it will hold.",
      "pos": [
        5746,
        6073
      ]
    },
    {
      "content": "Also, consider using different types of data store for different types of data, choosing the types based on how well they are optimized for the specific type of data.",
      "pos": [
        6074,
        6240
      ]
    },
    {
      "content": "This may include using table storage, a document database, or a column-family data store instead of or as well as a relational database.",
      "pos": [
        6241,
        6377
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Data partitioning guidance<ept id=\"p1\">](best-practices-data-partitioning.md)</ept>.",
      "pos": [
        6378,
        6470
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Design for eventual consistency<ept id=\"p1\">**</ept>.",
      "pos": [
        6473,
        6509
      ]
    },
    {
      "content": "Eventual consistency improves scalability by reducing or removing the time needed to synchronize related data partitioned across multiple stores.",
      "pos": [
        6510,
        6655
      ]
    },
    {
      "content": "The cost is that data is not always consistent when it is read, and some write operations may cause conflicts.",
      "pos": [
        6656,
        6766
      ]
    },
    {
      "content": "Eventual consistency is ideal for situations where the same data is read frequently but written infrequently.",
      "pos": [
        6767,
        6876
      ]
    },
    {
      "content": "For more information, see the [Data consistency guidance] (#insertlink#).",
      "pos": [
        6877,
        6950
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Reduce chatty interactions between components and services<ept id=\"p1\">**</ept>.",
      "pos": [
        6953,
        7016
      ]
    },
    {
      "content": "Avoid designing <bpt id=\"p1\">_</bpt>chatty<ept id=\"p1\">_</ept> interfaces for services, where an application is required to make multiple calls to a service (each of which returns a small amount of data) rather than a single call that can return all of the data.",
      "pos": [
        7017,
        7241
      ]
    },
    {
      "content": "Where possible, combine several related operations into a single request when the call is to a service or component that has noticeable latency.",
      "pos": [
        7242,
        7386
      ]
    },
    {
      "content": "This makes it easier to monitor performance and optimize complex operations - for example, use stored procedures in databases to encapsulate complex logic, reduce the number of round trips and resource locking.",
      "pos": [
        7387,
        7597
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Use queues to level the load for high velocity data writes<ept id=\"p1\">**</ept>.",
      "pos": [
        7601,
        7664
      ]
    },
    {
      "content": "Surges in demand for a service can overwhelm that service and cause escalating failures.",
      "pos": [
        7665,
        7753
      ]
    },
    {
      "content": "To prevent this, consider implementing the <bpt id=\"p1\">[</bpt>Queue-Based Load Leveling Pattern<ept id=\"p1\">](https://msdn.microsoft.com/library/dn589783.aspx)</ept>.",
      "pos": [
        7754,
        7883
      ]
    },
    {
      "content": "Use a queue that acts as a buffer between a task and a service that it invokes in order to smooth intermittent heavy loads that may otherwise cause the service to fail or the task to time out.",
      "pos": [
        7884,
        8076
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Minimize the load on the data store<ept id=\"p1\">**</ept>.",
      "pos": [
        8079,
        8119
      ]
    },
    {
      "content": "The data store is commonly a processing bottleneck, a costly resource, and  often not easy to scale out.",
      "pos": [
        8120,
        8224
      ]
    },
    {
      "content": "Where possible, remove logic (such as processing XML documents or JSON objects) from the data store and perform processing within the application.",
      "pos": [
        8225,
        8371
      ]
    },
    {
      "content": "For example, instead of passing XML to the database (other than as an opaque string for storage) serialize or deserialize the XML within the application layer and pass it in a form that is native to the data store.",
      "pos": [
        8372,
        8586
      ]
    },
    {
      "content": "It is typically much easier to scale out the application than the data store, and so you should attempt to do as much of the compute-intensive processing within the application.",
      "pos": [
        8587,
        8764
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Minimize the volume of data retrieved<ept id=\"p1\">**</ept>.",
      "pos": [
        8767,
        8809
      ]
    },
    {
      "content": "Retrieve only the data you require by specifying columns and using criteria to select rows.",
      "pos": [
        8810,
        8901
      ]
    },
    {
      "content": "Make use of table value parameters and the appropriate isolation level.",
      "pos": [
        8902,
        8973
      ]
    },
    {
      "content": "Use mechanisms like ETags to avoid retrieving data unnecessarily.",
      "pos": [
        8974,
        9039
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Aggressively use caching<ept id=\"p1\">**</ept>.",
      "pos": [
        9042,
        9071
      ]
    },
    {
      "content": "Use caching wherever possible to reduce the load on resources and services that generate or deliver data.",
      "pos": [
        9072,
        9177
      ]
    },
    {
      "content": "Caching is typically suited to data that is relatively static, or that requires considerable processing to obtain.",
      "pos": [
        9178,
        9292
      ]
    },
    {
      "content": "Caching should occur at all levels where appropriate in each layer of the application, including data access and UI generation.",
      "pos": [
        9293,
        9420
      ]
    },
    {
      "content": "For more information, see the <bpt id=\"p1\">[</bpt>Caching Guidance<ept id=\"p1\">](best-practices-caching.md)</ept>.",
      "pos": [
        9421,
        9497
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Handle data growth and retention<ept id=\"p1\">**</ept>.",
      "pos": [
        9500,
        9537
      ]
    },
    {
      "content": "The amount of data stored by an application will grow over time.",
      "pos": [
        9538,
        9602
      ]
    },
    {
      "content": "This growth will increase storage costs, and increase latency when accessing the data — which affects application throughput and performance.",
      "pos": [
        9603,
        9744
      ]
    },
    {
      "content": "It may be possible to periodically archive some of the old data that is no longer accessed, or move data that is rarely accessed into long-term storage that is more cost efficient, even if the access latency is higher.",
      "pos": [
        9745,
        9963
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Optimize DTOs using an efficient binary format<ept id=\"p1\">**</ept>.",
      "pos": [
        9966,
        10017
      ]
    },
    {
      "content": "Data Transfer Objects are passed between the layers of an application many times, and so minimizing the size will reduce the load on resources and the network.",
      "pos": [
        10018,
        10177
      ]
    },
    {
      "content": "However, balance the savings with the overhead of converting the data to the required format in each location where it is used, and adopt a format that has the maximum interoperability to enable easy reuse of a component.",
      "pos": [
        10178,
        10399
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Set cache control<ept id=\"p1\">**</ept>.",
      "pos": [
        10402,
        10424
      ]
    },
    {
      "content": "Design and configure the application to use output caching or fragment caching where possible to minimize processing load.",
      "pos": [
        10425,
        10547
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Enable client side caching<ept id=\"p1\">**</ept>.",
      "pos": [
        10550,
        10581
      ]
    },
    {
      "content": "Web applications should enable cache settings on the content that can be cached.",
      "pos": [
        10582,
        10662
      ]
    },
    {
      "content": "This is commonly disabled by default.",
      "pos": [
        10664,
        10701
      ]
    },
    {
      "content": "Configure the server to deliver the appropriate cache control headers to enable caching of content on proxy servers and clients.",
      "pos": [
        10702,
        10830
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Use Azure blob storage and the CDN to reduce the load on the application<ept id=\"p1\">**</ept>.",
      "pos": [
        10833,
        10910
      ]
    },
    {
      "content": "Consider storing static or relatively static public content such as images, resources, scripts, and style sheets in blob storage.",
      "pos": [
        10911,
        11040
      ]
    },
    {
      "content": "This approach relieves the application of the load caused by dynamically generating this content for each request.",
      "pos": [
        11041,
        11155
      ]
    },
    {
      "content": "Additionally, consider using the CDN to cache this content and deliver it to clients.",
      "pos": [
        11156,
        11241
      ]
    },
    {
      "content": "Using the CDN can improve performance at the client because the content is delivered from the geographically closest datacenter that contains a CDN cache.",
      "pos": [
        11242,
        11396
      ]
    },
    {
      "content": "For more information, see the <bpt id=\"p1\">[</bpt>CDN Guidance<ept id=\"p1\">](best-practices-cdn.md)</ept>.",
      "pos": [
        11397,
        11465
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Optimize and tune SQL queries and indexes<ept id=\"p1\">**</ept>.",
      "pos": [
        11469,
        11515
      ]
    },
    {
      "content": "Some T-SQL statements or constructs may have an impact on performance that can be reduced by optimizing the code in a stored procedure.",
      "pos": [
        11516,
        11651
      ]
    },
    {
      "content": "For example, converting <bpt id=\"p1\">**</bpt>datetime<ept id=\"p1\">**</ept> types to a <bpt id=\"p2\">**</bpt>varchar<ept id=\"p2\">**</ept> before comparing with a <bpt id=\"p3\">**</bpt>datetime<ept id=\"p3\">**</ept> literal value should be avoided — use date/time comparison functions instead.",
      "pos": [
        11652,
        11826
      ]
    },
    {
      "content": "Lack of appropriate indexes can also slow query execution.",
      "pos": [
        11827,
        11885
      ]
    },
    {
      "content": "If you use an object/relational mapping (ORM) framework, understand how it works and how it may affect performance of the data access layer.",
      "pos": [
        11886,
        12026
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Query Tuning<ept id=\"p1\">](https://technet.microsoft.com/library/ms176005.aspx)</ept>.",
      "pos": [
        12027,
        12121
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Consider de-normalizing data<ept id=\"p1\">**</ept>.",
      "pos": [
        12124,
        12157
      ]
    },
    {
      "content": "Data normalization helps to avoid duplication and inconsistency.",
      "pos": [
        12158,
        12222
      ]
    },
    {
      "content": "However, maintaining multiple indexes, checking for referential integrity, performing multiple accesses to small chunks of data, and joining tables to reassemble the data imposes an overhead that can affect performance.",
      "pos": [
        12223,
        12442
      ]
    },
    {
      "content": "Consider if some additional storage volume and duplication is acceptable in order to reduce the load on the data store.",
      "pos": [
        12443,
        12562
      ]
    },
    {
      "content": "Also, consider if the application itself (which will typically be easier to scale) can be relied upon to take over tasks such as managing referential integrity in order to reduce the load on the data store.",
      "pos": [
        12563,
        12769
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>Data partitioning guidance<ept id=\"p1\">](https://github.com/mspnp/azure-guidance/blob/master/Data%20partitioning.md)</ept>.",
      "pos": [
        12770,
        12901
      ]
    },
    {
      "content": "Service implementation",
      "pos": [
        12906,
        12928
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Use asynchronous calls<ept id=\"p1\">**</ept>.",
      "pos": [
        12931,
        12958
      ]
    },
    {
      "content": "Use asynchronous code wherever possible when accessing resources or services that may be limited by I/O or network bandwidth, or that have a noticeable latency, in order to avoid locking the calling thread.",
      "pos": [
        12959,
        13165
      ]
    },
    {
      "content": "Use the Task-based Asynchronous Pattern to implement asynchronous operations.",
      "pos": [
        13166,
        13243
      ]
    },
    {
      "content": "For more information, see the <bpt id=\"p1\">[</bpt>Task-based Asynchronous Pattern (TAP)<ept id=\"p1\">](https://msdn.microsoft.com/library/hh873175.aspx)</ept> page on the Microsoft website.",
      "pos": [
        13244,
        13394
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Avoid locking resources and use an optimistic approach instead<ept id=\"p1\">**</ept>.",
      "pos": [
        13397,
        13464
      ]
    },
    {
      "content": "Never lock access to resources such as storage or other services that have noticeable latency, because this is a primary cause of poor performance.",
      "pos": [
        13465,
        13612
      ]
    },
    {
      "content": "Always use optimistic approaches to managing concurrent operations such as writing to storage, and use features of the storage layer to manage conflicts.",
      "pos": [
        13613,
        13766
      ]
    },
    {
      "content": "In distributed applications, data may be only eventually consistent.",
      "pos": [
        13767,
        13835
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Compress highly compressible data over high latency, low bandwidth networks<ept id=\"p1\">**</ept>.",
      "pos": [
        13838,
        13918
      ]
    },
    {
      "content": "In the majority of cases in a web application, the largest volume of data generated by the application and passed over the network is HTTP responses to client requests.",
      "pos": [
        13919,
        14087
      ]
    },
    {
      "content": "HTTP compression can reduce this considerably, especially for static content.",
      "pos": [
        14088,
        14165
      ]
    },
    {
      "content": "This can offer a saving in cost as well as reducing the load on the network, though compressing dynamic content does apply a fractionally higher load on the server.",
      "pos": [
        14166,
        14330
      ]
    },
    {
      "content": "In other, more generalized environments, data compression can reduce the volume of data transmitted and minimize transfer time and costs, but the compression and decompression processes will incur overhead.",
      "pos": [
        14331,
        14537
      ]
    },
    {
      "content": "As such, compression should only be used  when there is a demonstrable gain in performance.",
      "pos": [
        14538,
        14629
      ]
    },
    {
      "content": "Other serialization methods such as JSON or binary encodings may reduce the payload size while having less impact on performance, whereas XML is likely to increase it.",
      "pos": [
        14630,
        14797
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Minimize the time that connections and resources are in use<ept id=\"p1\">**</ept>.",
      "pos": [
        14800,
        14864
      ]
    },
    {
      "content": "Maintain connections and resources only for as long as you need to use them.",
      "pos": [
        14865,
        14941
      ]
    },
    {
      "content": "For example, open connections as late as possible and allow them to be returned to the connection pool as soon as possible.",
      "pos": [
        14942,
        15065
      ]
    },
    {
      "content": "Acquire resources as late as possible and dispose of them as soon as possible.",
      "pos": [
        15066,
        15144
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Minimize the number of connections required<ept id=\"p1\">**</ept>.",
      "pos": [
        15147,
        15195
      ]
    },
    {
      "content": "Service connections absorb resources.",
      "pos": [
        15196,
        15233
      ]
    },
    {
      "content": "Where possible, limit the number that are required and ensure that existing connections are reused whenever possible.",
      "pos": [
        15234,
        15351
      ]
    },
    {
      "content": "For example, after performing authentication, use impersonation where appropriate to run code as a specific identity.",
      "pos": [
        15352,
        15469
      ]
    },
    {
      "content": "This can help to make best use of the connection pool by reusing connections.",
      "pos": [
        15470,
        15547
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph>:** APIs for some services automatically reuse connections provided service-specific guidelines are followed.",
      "pos": [
        15556,
        15677
      ]
    },
    {
      "content": "It is important that you understand the conditions that enable connection reuse for each service that your application uses.",
      "pos": [
        15678,
        15802
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Send requests in batches to optimize network use<ept id=\"p1\">**</ept>.",
      "pos": [
        15805,
        15858
      ]
    },
    {
      "content": "For example, send and read messages in batches when accessing a queue, and perform multiple reads or writes as a batch when accessing storage or a cache.",
      "pos": [
        15859,
        16012
      ]
    },
    {
      "content": "This can help to maximize efficiency of the services and data stores by reducing the number of calls across the network.",
      "pos": [
        16013,
        16133
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Avoid a requirement to store server-side session state<ept id=\"p1\">**</ept> where possible.",
      "pos": [
        16136,
        16210
      ]
    },
    {
      "content": "Server-side session state management typically requires client affinity (i.e., routing each request to the same server instance), which affects the ability of the system to scale.",
      "pos": [
        16211,
        16390
      ]
    },
    {
      "content": "Ideally, you should design clients to be stateless with respect to the servers that it uses.",
      "pos": [
        16391,
        16483
      ]
    },
    {
      "content": "However, if the application must maintain session state, store sensitive data or large volumes of per-client data in a distributed server-side cache that all instances of the application can access.",
      "pos": [
        16484,
        16682
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Optimize table storage schemas<ept id=\"p1\">**</ept>.",
      "pos": [
        16685,
        16720
      ]
    },
    {
      "content": "When using table stores such as Azure table storage that require the table and column names to be passed and processed with every query, consider using shorter names to reduce this overhead.",
      "pos": [
        16721,
        16911
      ]
    },
    {
      "content": "However, do not sacrifice readability or manageability though using un-intuitively compact names.",
      "pos": [
        16912,
        17009
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Leverage the TPL to perform asynchronous operations<ept id=\"p1\">**</ept>.",
      "pos": [
        17012,
        17068
      ]
    },
    {
      "content": "The Task Parallel Library (TPL) makes it easy to write asynchronous code that performs I/O-bound operations.",
      "pos": [
        17069,
        17177
      ]
    },
    {
      "content": "Use <bpt id=\"p1\">_</bpt>ConfigureAwait(false)<ept id=\"p1\">_</ept> wherever possible to eliminate the dependency of a continuation on a specific synchronization context and reduce the chances of thread-deadlock occurring.",
      "pos": [
        17178,
        17360
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Create resource dependencies during deployment or at application startup<ept id=\"p1\">**</ept>.",
      "pos": [
        17363,
        17440
      ]
    },
    {
      "content": "Avoid repeated calls to methods that test the existence of a resource and then create the resource if it does not exist (methods such as <bpt id=\"p1\">_</bpt>CloudTable.CreateIfNotExists<ept id=\"p1\">_</ept> and <bpt id=\"p2\">_</bpt>CloudQueue.CreateIfNotExists<ept id=\"p2\">_</ept> in the Azure Storage Client Library follow this pattern).",
      "pos": [
        17441,
        17701
      ]
    },
    {
      "content": "These methods can impose considerable overhead if they are invoked before each access to a storage table or storage queue.",
      "pos": [
        17702,
        17824
      ]
    },
    {
      "content": "Instead, create the required resources when the application is deployed or when it first starts (a single call to <bpt id=\"p1\">_</bpt>CreateIfNotExists<ept id=\"p1\">_</ept> for each resource in the startup code for a web or worker role is acceptable).",
      "pos": [
        17825,
        18037
      ]
    },
    {
      "content": "However, be sure to handle exceptions that may arise if your code attempts to access a resource that does not exist.",
      "pos": [
        18038,
        18154
      ]
    },
    {
      "content": "In these situations, you should log the exception, and possibly alert an operator that a resource is missing.",
      "pos": [
        18155,
        18264
      ]
    },
    {
      "content": "Under some circumstances it may be appropriate to create the missing resource as part of the exception handling code, but you should adopt this approach with caution as the non-existence of the resource might be indicative of a programming error (a misspelled resource name for example), or some other infrastructure-level issue.",
      "pos": [
        18265,
        18594
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Use lightweight frameworks<ept id=\"p1\">**</ept>.",
      "pos": [
        18597,
        18628
      ]
    },
    {
      "content": "Carefully choose the APIs and frameworks you use to minimize resource usage, execution time, and overall load on the application.",
      "pos": [
        18629,
        18758
      ]
    },
    {
      "content": "For example, using Web API to handle service requests can reduce the application footprint and increase execution speed, but it may not be suitable for advanced scenarios where the additional capabilities of WCF are required.",
      "pos": [
        18759,
        18984
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Consider minimizing the number of service accounts<ept id=\"p1\">**</ept>.",
      "pos": [
        18987,
        19042
      ]
    },
    {
      "content": "For example, use a specific account to access resources or services that impose a limit on connections, or perform better where fewer connections are maintained.",
      "pos": [
        19043,
        19204
      ]
    },
    {
      "content": "This approach is common for services such as databases, but it can affect the ability to accurately audit operations due to the impersonation of the original user.",
      "pos": [
        19205,
        19368
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Carry out performance profiling and load testing<ept id=\"p1\">**</ept> during development, as part of test routines, and before final release to ensure the application performs and scales as required.",
      "pos": [
        19371,
        19553
      ]
    },
    {
      "content": "This testing should occur on the same type of hardware as the production platform, and with the same types and quantities of data and user load as it will encounter in production.",
      "pos": [
        19554,
        19733
      ]
    },
    {
      "content": "For more information, see the page <bpt id=\"p1\">[</bpt>Testing the Performance of a Cloud Service<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/hh369930.aspx)</ept> on the Microsoft website.",
      "pos": [
        19734,
        19895
      ]
    },
    {
      "content": "test",
      "pos": [
        19897,
        19901
      ]
    }
  ],
  "content": "<properties\n   pageTitle=\"Scalability checklist | Microsoft Azure\"\n   description=\"Scalability checklist guidance for design concerns for Azure Autoscaling.\"\n   services=\"\"\n   documentationCenter=\"na\"\n   authors=\"dragon119\"\n   manager=\"masimms\"\n   editor=\"\"\n   tags=\"\"/>\n\n<tags\n   ms.service=\"best-practice\"\n   ms.devlang=\"na\"\n   ms.topic=\"article\"\n   ms.tgt_pltfrm=\"na\"\n   ms.workload=\"na\"\n   ms.date=\"04/28/2015\"\n   ms.author=\"masashin\"/>\n\n# Scalability checklist\n\n![](media/best-practices-scalability-checklist/pnp-logo.png)\n\n## Service design\n- **Partition the workload**. Design parts of the process to be discrete and decomposable, and minimize the size of each part while following the typical rules for separation of concerns and the single responsibility principle. This allows the component parts to be distributed in a way that maximizes use of each compute unit (such as a role or database server) and makes it easier to scale the application by adding additional instances of specific resources. For more information, see [Compute Partitioning Guidance](https://msdn.microsoft.com/library/dn568099.aspx).\n- **Design for scaling**. Scaling allows applications to react to variable load by increasing and decreasing the number of instances of roles, queues, and other services they use. However, the application must be designed with this in mind. For example, the application and the services it uses must be stateless to allow requests to be routed to any instance, and so that the addition or removal of specific instances does not adversely impact current users. It is also necessary to implement configuration or auto-detection of instances as they are added and removed so that code in the application can perform the necessary routing. For example, a web application might use a set of queues in a round-robin approach to route requests to background services running in worker roles. The web application must be able to detect changes in the number of queues in order to successfully route requests and balance the load on the application.\n- **Scale as a unit**. Plan for adding additional resources to accommodate growth. For each resource, you should know the upper scaling limits and use sharding or decomposition to go beyond these limits. Determine the scale units for the system in terms of well-defined sets of resources. This makes applying scale out operations easier and less prone to negative impact on the application through limitations imposed by lack of resources in some part of the overall system.  For example, adding x number of web and worker roles might require y number of additional queues and z number of storage accounts to handle the additional workload generated by the roles , so a scale unit could consist of x web and worker roles, _y_ queues, and _z_ storage accounts. Design the application so that it is easily scaled by adding one or more scale units.\n- **Avoid client affinity**. Where possible, ensure that the application does not require affinity so that requests can be routed to any instance, and the number of instances is irrelevant. This also avoids the overhead of storing, retrieving, and maintaining state information for each user.\n- **Take advantage of platform autoscaling features**. Where the hosting platform supports an autoscaling capability, such as Azure Autoscaling, prefer it to custom or third party mechanisms unless the built-in mechanism cannot fulfil your requirements. Use scheduled scaling rules where possible to ensure resources are available without a start-up delay, but add reactive autoscaling to the rules where appropriate to cope with unexpected changes in demand. You can use the autoscaling operations in the Service Management API to fine tune autoscaling and add custom counters to rules beyond the configuration options available in the web portal. For more information, see the page [Auto-scaling guidance](best-practices-auto-scaling.md).\n- **Offload intensive CPU/IO tasks as background tasks**. If a request to a service is expected to take a long time to run or absorb considerable resources, then offload the processing for this request to a separate task. Use worker roles or background jobs (depending on the hosting platform) to execute these tasks. This strategy enables the service to continue receiving further requests and remain responsive.  For more information, see [Background jobs guidance](best-practices-background-jobs.md).\n- **Distribute the workload for background tasks**. Where there are many background tasks, or the tasks require considerable time or resources, spread the work across multiple compute units (such as worker roles or background jobs). The [Competing Consumers Pattern](https://msdn.microsoft.com/library/dn568101.aspx) provides one possible solution.\n- **Consider moving towards a _shared nothing_ architecture**. A shared nothing architecture uses independent and self-sufficient nodes that have no single point of contention such as shared services or storage. In theory, such a system can scale almost indefinitely. While a fully shared nothing approach is generally not practical for most applications, it may provide opportunities to design for better scalability. For example, avoiding the use of server-side session state, client affinity, and data partitioning are good examples of moving towards a shared nothing architecture.\n\n## Data management\n\n- **Use data partitioning**. Divide the data across multiple databases and database servers, or design the application to use data storage services that can provide this partitioning transparently (examples include Azure SQL Database Elastic Scale, and Azure Table storage). This approach can help to maximize performance and allow easier scaling. There are different partitioning techniques such as horizontal, vertical, and functional partitioning, and you can use a combination of these to achieve maximum benefit from increased query performance, simpler scalability, more flexible management, better availability, and to match the type of store to the data it will hold. Also, consider using different types of data store for different types of data, choosing the types based on how well they are optimized for the specific type of data. This may include using table storage, a document database, or a column-family data store instead of or as well as a relational database. For more information, see [Data partitioning guidance](best-practices-data-partitioning.md).\n- **Design for eventual consistency**. Eventual consistency improves scalability by reducing or removing the time needed to synchronize related data partitioned across multiple stores. The cost is that data is not always consistent when it is read, and some write operations may cause conflicts. Eventual consistency is ideal for situations where the same data is read frequently but written infrequently. For more information, see the [Data consistency guidance] (#insertlink#).\n- **Reduce chatty interactions between components and services**. Avoid designing _chatty_ interfaces for services, where an application is required to make multiple calls to a service (each of which returns a small amount of data) rather than a single call that can return all of the data. Where possible, combine several related operations into a single request when the call is to a service or component that has noticeable latency. This makes it easier to monitor performance and optimize complex operations - for example, use stored procedures in databases to encapsulate complex logic, reduce the number of round trips and resource locking. \n- **Use queues to level the load for high velocity data writes**. Surges in demand for a service can overwhelm that service and cause escalating failures. To prevent this, consider implementing the [Queue-Based Load Leveling Pattern](https://msdn.microsoft.com/library/dn589783.aspx). Use a queue that acts as a buffer between a task and a service that it invokes in order to smooth intermittent heavy loads that may otherwise cause the service to fail or the task to time out.\n- **Minimize the load on the data store**. The data store is commonly a processing bottleneck, a costly resource, and  often not easy to scale out. Where possible, remove logic (such as processing XML documents or JSON objects) from the data store and perform processing within the application. For example, instead of passing XML to the database (other than as an opaque string for storage) serialize or deserialize the XML within the application layer and pass it in a form that is native to the data store. It is typically much easier to scale out the application than the data store, and so you should attempt to do as much of the compute-intensive processing within the application.\n- **Minimize the volume of data retrieved**. Retrieve only the data you require by specifying columns and using criteria to select rows. Make use of table value parameters and the appropriate isolation level. Use mechanisms like ETags to avoid retrieving data unnecessarily.\n- **Aggressively use caching**. Use caching wherever possible to reduce the load on resources and services that generate or deliver data. Caching is typically suited to data that is relatively static, or that requires considerable processing to obtain. Caching should occur at all levels where appropriate in each layer of the application, including data access and UI generation. For more information, see the [Caching Guidance](best-practices-caching.md).\n- **Handle data growth and retention**. The amount of data stored by an application will grow over time. This growth will increase storage costs, and increase latency when accessing the data — which affects application throughput and performance. It may be possible to periodically archive some of the old data that is no longer accessed, or move data that is rarely accessed into long-term storage that is more cost efficient, even if the access latency is higher.\n- **Optimize DTOs using an efficient binary format**. Data Transfer Objects are passed between the layers of an application many times, and so minimizing the size will reduce the load on resources and the network. However, balance the savings with the overhead of converting the data to the required format in each location where it is used, and adopt a format that has the maximum interoperability to enable easy reuse of a component.\n- **Set cache control**. Design and configure the application to use output caching or fragment caching where possible to minimize processing load.\n- **Enable client side caching**. Web applications should enable cache settings on the content that can be cached.  This is commonly disabled by default. Configure the server to deliver the appropriate cache control headers to enable caching of content on proxy servers and clients.\n- **Use Azure blob storage and the CDN to reduce the load on the application**. Consider storing static or relatively static public content such as images, resources, scripts, and style sheets in blob storage. This approach relieves the application of the load caused by dynamically generating this content for each request. Additionally, consider using the CDN to cache this content and deliver it to clients. Using the CDN can improve performance at the client because the content is delivered from the geographically closest datacenter that contains a CDN cache. For more information, see the [CDN Guidance](best-practices-cdn.md).\n\n- **Optimize and tune SQL queries and indexes**. Some T-SQL statements or constructs may have an impact on performance that can be reduced by optimizing the code in a stored procedure. For example, converting **datetime** types to a **varchar** before comparing with a **datetime** literal value should be avoided — use date/time comparison functions instead. Lack of appropriate indexes can also slow query execution. If you use an object/relational mapping (ORM) framework, understand how it works and how it may affect performance of the data access layer. For more information, see [Query Tuning](https://technet.microsoft.com/library/ms176005.aspx).\n- **Consider de-normalizing data**. Data normalization helps to avoid duplication and inconsistency. However, maintaining multiple indexes, checking for referential integrity, performing multiple accesses to small chunks of data, and joining tables to reassemble the data imposes an overhead that can affect performance. Consider if some additional storage volume and duplication is acceptable in order to reduce the load on the data store. Also, consider if the application itself (which will typically be easier to scale) can be relied upon to take over tasks such as managing referential integrity in order to reduce the load on the data store. For more information, see [Data partitioning guidance](https://github.com/mspnp/azure-guidance/blob/master/Data%20partitioning.md).\n\n## Service implementation\n- **Use asynchronous calls**. Use asynchronous code wherever possible when accessing resources or services that may be limited by I/O or network bandwidth, or that have a noticeable latency, in order to avoid locking the calling thread. Use the Task-based Asynchronous Pattern to implement asynchronous operations. For more information, see the [Task-based Asynchronous Pattern (TAP)](https://msdn.microsoft.com/library/hh873175.aspx) page on the Microsoft website.\n- **Avoid locking resources and use an optimistic approach instead**. Never lock access to resources such as storage or other services that have noticeable latency, because this is a primary cause of poor performance. Always use optimistic approaches to managing concurrent operations such as writing to storage, and use features of the storage layer to manage conflicts. In distributed applications, data may be only eventually consistent.\n- **Compress highly compressible data over high latency, low bandwidth networks**. In the majority of cases in a web application, the largest volume of data generated by the application and passed over the network is HTTP responses to client requests. HTTP compression can reduce this considerably, especially for static content. This can offer a saving in cost as well as reducing the load on the network, though compressing dynamic content does apply a fractionally higher load on the server. In other, more generalized environments, data compression can reduce the volume of data transmitted and minimize transfer time and costs, but the compression and decompression processes will incur overhead. As such, compression should only be used  when there is a demonstrable gain in performance. Other serialization methods such as JSON or binary encodings may reduce the payload size while having less impact on performance, whereas XML is likely to increase it.\n- **Minimize the time that connections and resources are in use**. Maintain connections and resources only for as long as you need to use them. For example, open connections as late as possible and allow them to be returned to the connection pool as soon as possible. Acquire resources as late as possible and dispose of them as soon as possible.\n- **Minimize the number of connections required**. Service connections absorb resources. Where possible, limit the number that are required and ensure that existing connections are reused whenever possible. For example, after performing authentication, use impersonation where appropriate to run code as a specific identity. This can help to make best use of the connection pool by reusing connections. \n\n    > [AZURE.NOTE]:** APIs for some services automatically reuse connections provided service-specific guidelines are followed. It is important that you understand the conditions that enable connection reuse for each service that your application uses.\n- **Send requests in batches to optimize network use**. For example, send and read messages in batches when accessing a queue, and perform multiple reads or writes as a batch when accessing storage or a cache. This can help to maximize efficiency of the services and data stores by reducing the number of calls across the network.\n- **Avoid a requirement to store server-side session state** where possible. Server-side session state management typically requires client affinity (i.e., routing each request to the same server instance), which affects the ability of the system to scale. Ideally, you should design clients to be stateless with respect to the servers that it uses. However, if the application must maintain session state, store sensitive data or large volumes of per-client data in a distributed server-side cache that all instances of the application can access.\n- **Optimize table storage schemas**. When using table stores such as Azure table storage that require the table and column names to be passed and processed with every query, consider using shorter names to reduce this overhead. However, do not sacrifice readability or manageability though using un-intuitively compact names.\n- **Leverage the TPL to perform asynchronous operations**. The Task Parallel Library (TPL) makes it easy to write asynchronous code that performs I/O-bound operations. Use _ConfigureAwait(false)_ wherever possible to eliminate the dependency of a continuation on a specific synchronization context and reduce the chances of thread-deadlock occurring.\n- **Create resource dependencies during deployment or at application startup**. Avoid repeated calls to methods that test the existence of a resource and then create the resource if it does not exist (methods such as _CloudTable.CreateIfNotExists_ and _CloudQueue.CreateIfNotExists_ in the Azure Storage Client Library follow this pattern). These methods can impose considerable overhead if they are invoked before each access to a storage table or storage queue. Instead, create the required resources when the application is deployed or when it first starts (a single call to _CreateIfNotExists_ for each resource in the startup code for a web or worker role is acceptable). However, be sure to handle exceptions that may arise if your code attempts to access a resource that does not exist. In these situations, you should log the exception, and possibly alert an operator that a resource is missing. Under some circumstances it may be appropriate to create the missing resource as part of the exception handling code, but you should adopt this approach with caution as the non-existence of the resource might be indicative of a programming error (a misspelled resource name for example), or some other infrastructure-level issue.\n- **Use lightweight frameworks**. Carefully choose the APIs and frameworks you use to minimize resource usage, execution time, and overall load on the application. For example, using Web API to handle service requests can reduce the application footprint and increase execution speed, but it may not be suitable for advanced scenarios where the additional capabilities of WCF are required.\n- **Consider minimizing the number of service accounts**. For example, use a specific account to access resources or services that impose a limit on connections, or perform better where fewer connections are maintained. This approach is common for services such as databases, but it can affect the ability to accurately audit operations due to the impersonation of the original user.\n- **Carry out performance profiling and load testing** during development, as part of test routines, and before final release to ensure the application performs and scales as required. This testing should occur on the same type of hardware as the production platform, and with the same types and quantities of data and user load as it will encounter in production. For more information, see the page [Testing the Performance of a Cloud Service](https://msdn.microsoft.com/library/azure/hh369930.aspx) on the Microsoft website.\n\ntest\n"
}