<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Service Fabric Reliable Actors Overview</source>
          <target state="new">Service Fabric Reliable Actors Overview</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Introduction to the Service Fabric Reliable Actors programming model</source>
          <target state="new">Introduction to the Service Fabric Reliable Actors programming model</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Introduction to Service Fabric Reliable Actors</source>
          <target state="new">Introduction to Service Fabric Reliable Actors</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The Reliable Actors API is one of two high-level frameworks provided by <bpt id="p1">[</bpt>Service Fabric<ept id="p1">](service-fabric-technical-overview.md)</ept>, along with the <bpt id="p2">[</bpt>Reliable Services API<ept id="p2">](service-fabric-reliable-services-introduction.md)</ept>.</source>
          <target state="new">The Reliable Actors API is one of two high-level frameworks provided by <bpt id="p1">[</bpt>Service Fabric<ept id="p1">](service-fabric-technical-overview.md)</ept>, along with the <bpt id="p2">[</bpt>Reliable Services API<ept id="p2">](service-fabric-reliable-services-introduction.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Based on the Actor pattern, the Reliable Actors API provides an asynchronous, single-threaded programming model that simplifies your code while still taking advantage of the scalability and reliability guarantees provided by Service Fabric.</source>
          <target state="new">Based on the Actor pattern, the Reliable Actors API provides an asynchronous, single-threaded programming model that simplifies your code while still taking advantage of the scalability and reliability guarantees provided by Service Fabric.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Actors</source>
          <target state="new">Actors</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Actors are isolated, single-threaded components that encapsulate both state and behavior.</source>
          <target state="new">Actors are isolated, single-threaded components that encapsulate both state and behavior.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>They are similar to .NET objects and hence provide a natural programming model.</source>
          <target state="new">They are similar to .NET objects and hence provide a natural programming model.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Every actor is an instance of an actor type, similar to the way a .NET object is an instance of a .NET type.</source>
          <target state="new">Every actor is an instance of an actor type, similar to the way a .NET object is an instance of a .NET type.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>For example, there may be an actor type that implements the functionality of a calculator and there could be many actors of that type that are distributed on various nodes across a cluster.</source>
          <target state="new">For example, there may be an actor type that implements the functionality of a calculator and there could be many actors of that type that are distributed on various nodes across a cluster.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Each such actor is uniquely identified by an actor ID.</source>
          <target state="new">Each such actor is uniquely identified by an actor ID.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Defining and implementing Actor interfaces</source>
          <target state="new">Defining and implementing Actor interfaces</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Actors interact with rest of the system, including other actors, by passing asynchronous messages using a request-response pattern.</source>
          <target state="new">Actors interact with rest of the system, including other actors, by passing asynchronous messages using a request-response pattern.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>These interactions are defined in an interface as asynchronous methods.</source>
          <target state="new">These interactions are defined in an interface as asynchronous methods.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For example, the interface for an actor type that implements the functionality of a calculator might be defined as follows:</source>
          <target state="new">For example, the interface for an actor type that implements the functionality of a calculator might be defined as follows:</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>An actor type could implement the above interface as follows:</source>
          <target state="new">An actor type could implement the above interface as follows:</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Because method invocations and their responses ultimately result in network requests across the cluster, the arguments and the result type of the Task that it returns must be serializable by the platform.</source>
          <target state="new">Because method invocations and their responses ultimately result in network requests across the cluster, the arguments and the result type of the Task that it returns must be serializable by the platform.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>In particular, they must be <bpt id="p1">[</bpt>data contract serializable<ept id="p1">](service-fabric-reliable-actors-notes-on-actor-type-serialization.md)</ept>.</source>
          <target state="new">In particular, they must be <bpt id="p1">[</bpt>data contract serializable<ept id="p1">](service-fabric-reliable-actors-notes-on-actor-type-serialization.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.TIP]</ph> The Fabric Actors runtime emits some <bpt id="p1">[</bpt>events and performance counters related to actor methods<ept id="p1">](service-fabric-reliable-actors-diagnostics.md#actor-method-events-and-performance-counters)</ept>.</source>
          <target state="new"><ph id="ph1">[AZURE.TIP]</ph> The Fabric Actors runtime emits some <bpt id="p1">[</bpt>events and performance counters related to actor methods<ept id="p1">](service-fabric-reliable-actors-diagnostics.md#actor-method-events-and-performance-counters)</ept>.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>They are useful in diagnostics and performance monitoring.</source>
          <target state="new">They are useful in diagnostics and performance monitoring.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The following rules pertaining to actor interface methods are worth mentioning:</source>
          <target state="new">The following rules pertaining to actor interface methods are worth mentioning:</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Actor interface methods cannot be overloaded.</source>
          <target state="new">Actor interface methods cannot be overloaded.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Actor interface methods must not have out, ref or optional parameters.</source>
          <target state="new">Actor interface methods must not have out, ref or optional parameters.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Actor Communication</source>
          <target state="new">Actor Communication</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The Actor Proxy</source>
          <target state="new">The Actor Proxy</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The Actors client API provides communication between an actor instance and an actor client.</source>
          <target state="new">The Actors client API provides communication between an actor instance and an actor client.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>To communicate with an actor, a client creates an actor proxy object that implements the actor interface.</source>
          <target state="new">To communicate with an actor, a client creates an actor proxy object that implements the actor interface.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The client interacts with the actor by invoking methods on the proxy object.</source>
          <target state="new">The client interacts with the actor by invoking methods on the proxy object.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The actor proxy can be used for client-to-actor as well as actor-to-actor communication.</source>
          <target state="new">The actor proxy can be used for client-to-actor as well as actor-to-actor communication.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Continuing our calculator example, the client code for a calculator actor could be written as shown below:</source>
          <target state="new">Continuing our calculator example, the client code for a calculator actor could be written as shown below:</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Note the two pieces of information used to create the actor proxy object - the actor ID and the application name.</source>
          <target state="new">Note the two pieces of information used to create the actor proxy object - the actor ID and the application name.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The actor ID is an identifier that uniquely identifies the actor, while the application name identifies the <bpt id="p1">[</bpt>Service Fabric application<ept id="p1">](service-fabric-reliable-actors-platform.md#service-fabric-application-model-concepts-for-actors)</ept> that the actor is deployed in.</source>
          <target state="new">The actor ID is an identifier that uniquely identifies the actor, while the application name identifies the <bpt id="p1">[</bpt>Service Fabric application<ept id="p1">](service-fabric-reliable-actors-platform.md#service-fabric-application-model-concepts-for-actors)</ept> that the actor is deployed in.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Actor Lifetime</source>
          <target state="new">Actor Lifetime</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Service Fabric actors are virtual, meaning that their lifetime is not tied to their in-memory representation.</source>
          <target state="new">Service Fabric actors are virtual, meaning that their lifetime is not tied to their in-memory representation.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>As a result, they do not need to be explicitly created or destroyed.</source>
          <target state="new">As a result, they do not need to be explicitly created or destroyed.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The Actors runtime automatically activates an actor the first time it receives a request for that actor.</source>
          <target state="new">The Actors runtime automatically activates an actor the first time it receives a request for that actor.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>If an actor is not used for certain time, the Actors runtime will garbage collect the in-memory object while maintaining knowledge of the actor's existence should it need to be reactivated later.</source>
          <target state="new">If an actor is not used for certain time, the Actors runtime will garbage collect the in-memory object while maintaining knowledge of the actor's existence should it need to be reactivated later.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>For more details, see <bpt id="p1">[</bpt>Actor lifecycle and Garbage Collection<ept id="p1">](service-fabric-reliable-actors-lifecycle.md)</ept>.</source>
          <target state="new">For more details, see <bpt id="p1">[</bpt>Actor lifecycle and Garbage Collection<ept id="p1">](service-fabric-reliable-actors-lifecycle.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Location Transparency and Automatic Failover</source>
          <target state="new">Location Transparency and Automatic Failover</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>To provide high scalability and reliability, Service Fabric distributes actors throughout the cluster and automatically migrates them from failed nodes to healthy ones as required.</source>
          <target state="new">To provide high scalability and reliability, Service Fabric distributes actors throughout the cluster and automatically migrates them from failed nodes to healthy ones as required.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ActorProxy`</ph> class on the client side performs the necessary resolution to locate the actor by ID <bpt id="p1">[</bpt>partition<ept id="p1">](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors)</ept> and open a communication channel with it.</source>
          <target state="new">The <ph id="ph1">`ActorProxy`</ph> class on the client side performs the necessary resolution to locate the actor by ID <bpt id="p1">[</bpt>partition<ept id="p1">](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors)</ept> and open a communication channel with it.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ActorProxy`</ph> also retries in the case of communication failures and failovers.</source>
          <target state="new">The <ph id="ph1">`ActorProxy`</ph> also retries in the case of communication failures and failovers.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>This ensures that messages will be reliably delivered despite the presence of faults but it also means that it is possible for an Actor implementation to get duplicate messages from the same client.</source>
          <target state="new">This ensures that messages will be reliably delivered despite the presence of faults but it also means that it is possible for an Actor implementation to get duplicate messages from the same client.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Concurrency</source>
          <target state="new">Concurrency</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Turn-based concurrency</source>
          <target state="new">Turn-based concurrency</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The Actors runtime provides a simple turn-based concurrency for actor methods.</source>
          <target state="new">The Actors runtime provides a simple turn-based concurrency for actor methods.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>This means that no more than one thread can be active inside the actor code at any time.</source>
          <target state="new">This means that no more than one thread can be active inside the actor code at any time.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>A turn consists of the complete execution of an actor method in response to the request from other actors or clients, or the complete execution of a <bpt id="p1">[</bpt>timer/reminder<ept id="p1">](service-fabric-reliable-actors-timers-reminders.md)</ept> callback.</source>
          <target state="new">A turn consists of the complete execution of an actor method in response to the request from other actors or clients, or the complete execution of a <bpt id="p1">[</bpt>timer/reminder<ept id="p1">](service-fabric-reliable-actors-timers-reminders.md)</ept> callback.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Even though these methods and callbacks are asynchronous, the Actors runtime does not interleave them - a turn must be fully completed before a new turn is allowed.</source>
          <target state="new">Even though these methods and callbacks are asynchronous, the Actors runtime does not interleave them - a turn must be fully completed before a new turn is allowed.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>In other words, an actor method or timer/reminder callback that is currently executing must be completed fully before a new call to a method or a callback is allowed.</source>
          <target state="new">In other words, an actor method or timer/reminder callback that is currently executing must be completed fully before a new call to a method or a callback is allowed.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>A method or callback is considered completed if execution has returned from the method or callback, and the Task returned by the method or callback has completed.</source>
          <target state="new">A method or callback is considered completed if execution has returned from the method or callback, and the Task returned by the method or callback has completed.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>It is worth emphasizing that turn-based concurrency is respected even across different methods, timers and callbacks.</source>
          <target state="new">It is worth emphasizing that turn-based concurrency is respected even across different methods, timers and callbacks.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The Actors runtime enforces turn-based concurrency by acquiring a per-actor lock at the beginning of a turn and releasing the lock at the end of the turn.</source>
          <target state="new">The Actors runtime enforces turn-based concurrency by acquiring a per-actor lock at the beginning of a turn and releasing the lock at the end of the turn.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Thus, turn-based concurrency is enforced on a per-actor basis and not across actors.</source>
          <target state="new">Thus, turn-based concurrency is enforced on a per-actor basis and not across actors.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Actor methods and timer/reminder callbacks can execute simultaneously on behalf of different actors.</source>
          <target state="new">Actor methods and timer/reminder callbacks can execute simultaneously on behalf of different actors.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The following example illustrates the above concepts.</source>
          <target state="new">The following example illustrates the above concepts.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Consider an actor type that implements two asynchronous methods (say <bpt id="p1">*</bpt>Method1<ept id="p1">*</ept> and <bpt id="p2">*</bpt>Method2<ept id="p2">*</ept>), a timer and a reminder.</source>
          <target state="new">Consider an actor type that implements two asynchronous methods (say <bpt id="p1">*</bpt>Method1<ept id="p1">*</ept> and <bpt id="p2">*</bpt>Method2<ept id="p2">*</ept>), a timer and a reminder.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The diagram below shows an example of a timeline for the execution of these methods and callbacks on behalf of two actors - <bpt id="p1">*</bpt>ActorId1<ept id="p1">*</ept> and <bpt id="p2">*</bpt>ActorId2<ept id="p2">*</ept> - that belong to this actor type.</source>
          <target state="new">The diagram below shows an example of a timeline for the execution of these methods and callbacks on behalf of two actors - <bpt id="p1">*</bpt>ActorId1<ept id="p1">*</ept> and <bpt id="p2">*</bpt>ActorId2<ept id="p2">*</ept> - that belong to this actor type.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>![][1]</source>
          <target state="new">![][1]</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The conventions followed by the above diagram are:</source>
          <target state="new">The conventions followed by the above diagram are:</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Each vertical line shows the logical flow of execution of a method or a callback on behalf of a particular actor.</source>
          <target state="new">Each vertical line shows the logical flow of execution of a method or a callback on behalf of a particular actor.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The events marked on each vertical line occur in chronological order with newer events occurring below the older ones.</source>
          <target state="new">The events marked on each vertical line occur in chronological order with newer events occurring below the older ones.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Different colors are used for timelines corresponding to different actors.</source>
          <target state="new">Different colors are used for timelines corresponding to different actors.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Highlighting is used to indicate the duration for which the per-actor lock is held on behalf of a method or callback.</source>
          <target state="new">Highlighting is used to indicate the duration for which the per-actor lock is held on behalf of a method or callback.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The following points about the above diagram are worth mentioning:</source>
          <target state="new">The following points about the above diagram are worth mentioning:</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>When <bpt id="p1">*</bpt>Method1<ept id="p1">*</ept> is executing on behalf of <bpt id="p2">*</bpt>ActorId2<ept id="p2">*</ept> in response to client request <bpt id="p3">*</bpt>xyz789<ept id="p3">*</ept>, another client request <bpt id="p4">*</bpt>abc123<ept id="p4">*</ept> arrives that also requires <bpt id="p5">*</bpt>Method1<ept id="p5">*</ept> to be executed by <bpt id="p6">*</bpt>ActorId2<ept id="p6">*</ept>.</source>
          <target state="new">When <bpt id="p1">*</bpt>Method1<ept id="p1">*</ept> is executing on behalf of <bpt id="p2">*</bpt>ActorId2<ept id="p2">*</ept> in response to client request <bpt id="p3">*</bpt>xyz789<ept id="p3">*</ept>, another client request <bpt id="p4">*</bpt>abc123<ept id="p4">*</ept> arrives that also requires <bpt id="p5">*</bpt>Method1<ept id="p5">*</ept> to be executed by <bpt id="p6">*</bpt>ActorId2<ept id="p6">*</ept>.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>However, the latter execution of <bpt id="p1">*</bpt>Method1<ept id="p1">*</ept> does not begin until the former execution has completed.</source>
          <target state="new">However, the latter execution of <bpt id="p1">*</bpt>Method1<ept id="p1">*</ept> does not begin until the former execution has completed.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Similarly, a reminder registered by <bpt id="p1">*</bpt>ActorId2<ept id="p1">*</ept> fires while <bpt id="p2">*</bpt>Method1<ept id="p2">*</ept> is being executed in response to client request <bpt id="p3">*</bpt>xyz789<ept id="p3">*</ept>.</source>
          <target state="new">Similarly, a reminder registered by <bpt id="p1">*</bpt>ActorId2<ept id="p1">*</ept> fires while <bpt id="p2">*</bpt>Method1<ept id="p2">*</ept> is being executed in response to client request <bpt id="p3">*</bpt>xyz789<ept id="p3">*</ept>.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The reminder callback is executed only after both executions of <bpt id="p1">*</bpt>Method1<ept id="p1">*</ept> are complete.</source>
          <target state="new">The reminder callback is executed only after both executions of <bpt id="p1">*</bpt>Method1<ept id="p1">*</ept> are complete.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>All of this is due to turn-based concurrency being enforced for <bpt id="p1">*</bpt>ActorId2<ept id="p1">*</ept>.</source>
          <target state="new">All of this is due to turn-based concurrency being enforced for <bpt id="p1">*</bpt>ActorId2<ept id="p1">*</ept>.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Similarly, turn-based concurrency is also enforced for <bpt id="p1">*</bpt>ActorId1<ept id="p1">*</ept>, as demonstrated by the execution of <bpt id="p2">*</bpt>Method1<ept id="p2">*</ept>, <bpt id="p3">*</bpt>Method2<ept id="p3">*</ept> and the timer callback on behalf of <bpt id="p4">*</bpt>ActorId1<ept id="p4">*</ept> happening in a serial fashion.</source>
          <target state="new">Similarly, turn-based concurrency is also enforced for <bpt id="p1">*</bpt>ActorId1<ept id="p1">*</ept>, as demonstrated by the execution of <bpt id="p2">*</bpt>Method1<ept id="p2">*</ept>, <bpt id="p3">*</bpt>Method2<ept id="p3">*</ept> and the timer callback on behalf of <bpt id="p4">*</bpt>ActorId1<ept id="p4">*</ept> happening in a serial fashion.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Execution of <bpt id="p1">*</bpt>Method1<ept id="p1">*</ept> on behalf of <bpt id="p2">*</bpt>ActorId1<ept id="p2">*</ept> overlaps with its execution on behalf of <bpt id="p3">*</bpt>ActorId2<ept id="p3">*</ept>.</source>
          <target state="new">Execution of <bpt id="p1">*</bpt>Method1<ept id="p1">*</ept> on behalf of <bpt id="p2">*</bpt>ActorId1<ept id="p2">*</ept> overlaps with its execution on behalf of <bpt id="p3">*</bpt>ActorId2<ept id="p3">*</ept>.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>This is because turn-based concurrency is only enforced within an actor and not across actors.</source>
          <target state="new">This is because turn-based concurrency is only enforced within an actor and not across actors.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>In some of the method/callback executions, the <ph id="ph1">`Task`</ph> returned by the method/callback completes after the method returns.</source>
          <target state="new">In some of the method/callback executions, the <ph id="ph1">`Task`</ph> returned by the method/callback completes after the method returns.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>In some others, the <ph id="ph1">`Task`</ph> is already complete by the time the method/callback returns.</source>
          <target state="new">In some others, the <ph id="ph1">`Task`</ph> is already complete by the time the method/callback returns.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>In either case, the per-actor lock is released only after the both of these happen, i.e. after the method/callback returns and the <ph id="ph1">`Task`</ph> completes.</source>
          <target state="new">In either case, the per-actor lock is released only after the both of these happen, i.e. after the method/callback returns and the <ph id="ph1">`Task`</ph> completes.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Reentrancy</source>
          <target state="new">Reentrancy</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The Actors runtime allows reentrancy by default.</source>
          <target state="new">The Actors runtime allows reentrancy by default.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This means that if an actor method of Actor A calls method on Actor B which in turn calls another method on actor A, that method is allowed to run as it is part of the same logical call chain context.</source>
          <target state="new">This means that if an actor method of Actor A calls method on Actor B which in turn calls another method on actor A, that method is allowed to run as it is part of the same logical call chain context.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>All timer and reminder calls start with the new logical call context.</source>
          <target state="new">All timer and reminder calls start with the new logical call context.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Reentrancy<ept id="p1">](service-fabric-reliable-actors-reentrancy.md)</ept> section for more details.</source>
          <target state="new">See <bpt id="p1">[</bpt>Reentrancy<ept id="p1">](service-fabric-reliable-actors-reentrancy.md)</ept> section for more details.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Scope of concurrency guarantees</source>
          <target state="new">Scope of concurrency guarantees</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The Actors runtime provides these concurrency guarantees in situations where it controls the invocation of these methods.</source>
          <target state="new">The Actors runtime provides these concurrency guarantees in situations where it controls the invocation of these methods.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For example, it provides these guarantees for the method invocations that are done in response to receiving a client request and for timer and reminder callbacks.</source>
          <target state="new">For example, it provides these guarantees for the method invocations that are done in response to receiving a client request and for timer and reminder callbacks.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>However, if the actor code directly invokes these methods outside of the mechanisms provided by the Actors runtime, then the runtime cannot provide any concurrency guarantees.</source>
          <target state="new">However, if the actor code directly invokes these methods outside of the mechanisms provided by the Actors runtime, then the runtime cannot provide any concurrency guarantees.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>For example, if the method is invoked in the context of some Task that is not associated with the Task returned by the actor methods, or if it is invoked from a thread that the actor creates on its own, then the runtime cannot provide concurrency guarantees.</source>
          <target state="new">For example, if the method is invoked in the context of some Task that is not associated with the Task returned by the actor methods, or if it is invoked from a thread that the actor creates on its own, then the runtime cannot provide concurrency guarantees.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Therefore, to perform background operations, actors should use <bpt id="p1">[</bpt>Actor Timers or Actor Reminders<ept id="p1">](service-fabric-reliable-actors-timers-reminders.md)</ept> that respect the turn-based concurrency.</source>
          <target state="new">Therefore, to perform background operations, actors should use <bpt id="p1">[</bpt>Actor Timers or Actor Reminders<ept id="p1">](service-fabric-reliable-actors-timers-reminders.md)</ept> that respect the turn-based concurrency.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.TIP]</ph> The Fabric Actors runtime emits some <bpt id="p1">[</bpt>events and performance counters related to concurrency<ept id="p1">](service-fabric-reliable-actors-diagnostics.md#concurrency-events-and-performance-counters)</ept>.</source>
          <target state="new"><ph id="ph1">[AZURE.TIP]</ph> The Fabric Actors runtime emits some <bpt id="p1">[</bpt>events and performance counters related to concurrency<ept id="p1">](service-fabric-reliable-actors-diagnostics.md#concurrency-events-and-performance-counters)</ept>.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>They are useful in diagnostics and performance monitoring.</source>
          <target state="new">They are useful in diagnostics and performance monitoring.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Actor State Management</source>
          <target state="new">Actor State Management</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Fabric Actors allows you to create the actors that are either stateless or stateful.</source>
          <target state="new">Fabric Actors allows you to create the actors that are either stateless or stateful.</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Stateless Actors</source>
          <target state="new">Stateless Actors</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Stateless actors, which are derived from the <ph id="ph1">``Actor``</ph> base class, do not have any state that is managed by the Actors runtime.</source>
          <target state="new">Stateless actors, which are derived from the <ph id="ph1">``Actor``</ph> base class, do not have any state that is managed by the Actors runtime.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Their member variables are preserved throughout their in-memory lifetime just like any other .NET type.</source>
          <target state="new">Their member variables are preserved throughout their in-memory lifetime just like any other .NET type.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>However, when they are garbage collected after a period of inactivity, their state is lost.</source>
          <target state="new">However, when they are garbage collected after a period of inactivity, their state is lost.</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Similarly, state can be lost due to failovers, which occur during upgrades, resource-balancing operations or as the result of failures in the actor process or its hosting node.</source>
          <target state="new">Similarly, state can be lost due to failovers, which occur during upgrades, resource-balancing operations or as the result of failures in the actor process or its hosting node.</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The following is an example of a stateless actor.</source>
          <target state="new">The following is an example of a stateless actor.</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Stateful Actors</source>
          <target state="new">Stateful Actors</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Stateful  actors have a state that needs to be preserved across garbage collections and failovers.</source>
          <target state="new">Stateful  actors have a state that needs to be preserved across garbage collections and failovers.</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>They derive from the <ph id="ph1">`Actor&lt;TState&gt;`</ph> base class, where <ph id="ph2">`TState`</ph> is the type of the state that needs to be preserved.</source>
          <target state="new">They derive from the <ph id="ph1">`Actor&lt;TState&gt;`</ph> base class, where <ph id="ph2">`TState`</ph> is the type of the state that needs to be preserved.</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The state can be accessed in the actor methods via <ph id="ph1">`State`</ph> property on the base class.</source>
          <target state="new">The state can be accessed in the actor methods via <ph id="ph1">`State`</ph> property on the base class.</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The following is an example of a stateful actor accessing the state.</source>
          <target state="new">The following is an example of a stateful actor accessing the state.</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Actor state is preserved across garbage collections and failovers by persisting it on disk and replicating it across multiple nodes in the cluster.</source>
          <target state="new">Actor state is preserved across garbage collections and failovers by persisting it on disk and replicating it across multiple nodes in the cluster.</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>This means that, like method arguments and return values, the actor state's type must be  <bpt id="p1">[</bpt>data contract serializable<ept id="p1">](service-fabric-reliable-actors-notes-on-actor-type-serialization.md)</ept>.</source>
          <target state="new">This means that, like method arguments and return values, the actor state's type must be  <bpt id="p1">[</bpt>data contract serializable<ept id="p1">](service-fabric-reliable-actors-notes-on-actor-type-serialization.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Please refer to the <bpt id="p1">[</bpt>Reliable Actors notes on serialization<ept id="p1">](service-fabric-reliable-actors-notes-on-actor-type-serialization.md)</ept> article for mode details on how interfaces and Actor State types should be defined.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Please refer to the <bpt id="p1">[</bpt>Reliable Actors notes on serialization<ept id="p1">](service-fabric-reliable-actors-notes-on-actor-type-serialization.md)</ept> article for mode details on how interfaces and Actor State types should be defined.</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Actor state providers</source>
          <target state="new">Actor state providers</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The storage and retrieval of the state is provided by an actor state provider.</source>
          <target state="new">The storage and retrieval of the state is provided by an actor state provider.</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>State providers can be configured per actor or for all actors within an assembly by the state provider specific attribute.</source>
          <target state="new">State providers can be configured per actor or for all actors within an assembly by the state provider specific attribute.</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>When an actor is activated its state is loaded in memory.</source>
          <target state="new">When an actor is activated its state is loaded in memory.</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>When an actor method completes, the modified state is automatically saved by the Actors runtime by calling a method on the state provider.</source>
          <target state="new">When an actor method completes, the modified state is automatically saved by the Actors runtime by calling a method on the state provider.</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>If failure occurs during the save operation, the Actors runtime creates a new actor instance and loads the last consistent state from the state provider.</source>
          <target state="new">If failure occurs during the save operation, the Actors runtime creates a new actor instance and loads the last consistent state from the state provider.</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>By default, stateful actors use the key-value store actor state provider, which is built on the distributed key-value store provided by the Service Fabric platform.</source>
          <target state="new">By default, stateful actors use the key-value store actor state provider, which is built on the distributed key-value store provided by the Service Fabric platform.</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>For more information, please see the topic on <bpt id="p1">[</bpt>state provider choices<ept id="p1">](service-fabric-reliable-actors-platform.md#actor-state-provider-choices)</ept>.</source>
          <target state="new">For more information, please see the topic on <bpt id="p1">[</bpt>state provider choices<ept id="p1">](service-fabric-reliable-actors-platform.md#actor-state-provider-choices)</ept>.</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.TIP]</ph> The Actors runtime emits some <bpt id="p1">[</bpt>events and performance counters related to actor state management<ept id="p1">](service-fabric-reliable-actors-diagnostics.md#actor-state-management-events-and-performance-counters)</ept>.</source>
          <target state="new"><ph id="ph1">[AZURE.TIP]</ph> The Actors runtime emits some <bpt id="p1">[</bpt>events and performance counters related to actor state management<ept id="p1">](service-fabric-reliable-actors-diagnostics.md#actor-state-management-events-and-performance-counters)</ept>.</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>They are useful in diagnostics and performance monitoring.</source>
          <target state="new">They are useful in diagnostics and performance monitoring.</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Readonly Methods</source>
          <target state="new">Readonly Methods</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>By default the Actors runtime saves Actor state upon the completion of an actor method call, timer callback or reminder callback.</source>
          <target state="new">By default the Actors runtime saves Actor state upon the completion of an actor method call, timer callback or reminder callback.</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>No other actor call is allowed until the save state is complete.</source>
          <target state="new">No other actor call is allowed until the save state is complete.</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>There may be actor methods that do not modify the state and in that case the additional time spent on saving the state can affect the overall throughput of the system.</source>
          <target state="new">There may be actor methods that do not modify the state and in that case the additional time spent on saving the state can affect the overall throughput of the system.</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>To avoid that you can mark the methods and timer callbacks that do not modify the state as read-only.</source>
          <target state="new">To avoid that you can mark the methods and timer callbacks that do not modify the state as read-only.</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The example below shows how to mark an actor method as read-only using <ph id="ph1">`Readonly`</ph> attribute.</source>
          <target state="new">The example below shows how to mark an actor method as read-only using <ph id="ph1">`Readonly`</ph> attribute.</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Timer callbacks can be marked with the <ph id="ph1">`Readonly`</ph> attribute in a similar way.</source>
          <target state="new">Timer callbacks can be marked with the <ph id="ph1">`Readonly`</ph> attribute in a similar way.</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>For reminders, the read-only flag is passed in as an argument to the <ph id="ph1">`RegisterReminder`</ph> method that is invoked to register the reminder.</source>
          <target state="new">For reminders, the read-only flag is passed in as an argument to the <ph id="ph1">`RegisterReminder`</ph> method that is invoked to register the reminder.</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="new">Next steps</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Concepts</source>
          <target state="new">Concepts</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Actor Lifecycle and Garbage Collection</source>
          <target state="new">Actor Lifecycle and Garbage Collection</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Actor Timers &amp; Reminders</source>
          <target state="new">Actor Timers &amp; Reminders</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Actor Events</source>
          <target state="new">Actor Events</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Actor Reentrancy</source>
          <target state="new">Actor Reentrancy</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>How Fabric Actors use the Service Fabric platform</source>
          <target state="new">How Fabric Actors use the Service Fabric platform</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Configuring KVSActorStateProvider Actor</source>
          <target state="new">Configuring KVSActorStateProvider Actor</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Actor Diagnostics and Performance Monitoring</source>
          <target state="new">Actor Diagnostics and Performance Monitoring</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6b627a3267433ae924ffff8e2b7f42a98a59d2db</xliffext:olfilehash>
  </header>
</xliff>