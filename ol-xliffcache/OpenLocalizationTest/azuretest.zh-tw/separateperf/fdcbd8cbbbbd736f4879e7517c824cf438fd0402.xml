{
  "nodes": [
    {
      "content": "Connecting Azure SQL Database to Azure Search Using Indexers",
      "pos": [
        28,
        88
      ]
    },
    {
      "content": "Learn how to pull data from Azure SQL Database to an Azure Search index using indexers.",
      "pos": [
        108,
        195
      ]
    },
    {
      "content": "Connecting Azure SQL Database to Azure Search Using Indexers",
      "pos": [
        504,
        564
      ]
    },
    {
      "content": "Azure Search service makes it easy to provide a great search experience, but before you can search, you need to populate an Azure Search index with your data.",
      "pos": [
        567,
        725
      ]
    },
    {
      "content": "If the data lives in an Azure SQL database, the new <bpt id=\"p1\">**</bpt>Azure Search indexer for Azure SQL Database<ept id=\"p1\">**</ept> (or <bpt id=\"p2\">**</bpt>Azure SQL indexer<ept id=\"p2\">**</ept> for short) feature in Azure Search can automate the indexing process.",
      "pos": [
        726,
        921
      ]
    },
    {
      "content": "This means you have less code to write and less infrastructure to maintain.",
      "pos": [
        922,
        997
      ]
    },
    {
      "content": "Currently, indexers only work with Azure SQL Database, SQL Server on Azure VMs, and Azure DocumentDB.",
      "pos": [
        999,
        1100
      ]
    },
    {
      "content": "In this article, we’ll focus on indexers that work with Azure SQL Database.",
      "pos": [
        1101,
        1176
      ]
    },
    {
      "content": "If you would like to see support for additional data sources, please provide your feedback on the <bpt id=\"p1\">[</bpt>Azure Search feedback forum<ept id=\"p1\">](http://feedback.azure.com/forums/263029-azure-search)</ept>.",
      "pos": [
        1177,
        1359
      ]
    },
    {
      "content": "This article will cover the mechanics of using indexers, but we’ll also drill down into features and behaviors that are only available with SQL databases (for example, integrated change tracking).",
      "pos": [
        1361,
        1557
      ]
    },
    {
      "content": "Indexers and Data Sources",
      "pos": [
        1562,
        1587
      ]
    },
    {
      "content": "To set up and configure an Azure SQL indexer, you can call the <bpt id=\"p1\">[</bpt>Azure Search REST API<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkID=528173)</ept> to create and manage <bpt id=\"p2\">**</bpt>indexers<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>data sources<ept id=\"p3\">**</ept>.",
      "pos": [
        1592,
        1783
      ]
    },
    {
      "content": "In the future, this functionality will also be available in Azure management portal and in Azure Search .NET SDK.",
      "pos": [
        1784,
        1897
      ]
    },
    {
      "content": "A <bpt id=\"p1\">**</bpt>data source<ept id=\"p1\">**</ept> specifies which data to index, credentials needed to access the data, and policies that enable Azure Search to efficiently identify changes in the data (new, modified or deleted rows).",
      "pos": [
        1900,
        2102
      ]
    },
    {
      "content": "It's defined as an independent resource so that it can be used by multiple indexers.",
      "pos": [
        2103,
        2187
      ]
    },
    {
      "content": "An <bpt id=\"p1\">**</bpt>indexer<ept id=\"p1\">**</ept> is a resource that connects data sources with target search indexes.",
      "pos": [
        2189,
        2272
      ]
    },
    {
      "content": "An indexer is used in the following ways:",
      "pos": [
        2273,
        2314
      ]
    },
    {
      "content": "Perform a one-time copy of the data to populate an index.",
      "pos": [
        2319,
        2376
      ]
    },
    {
      "content": "Update an index with changes in the data source on a schedule.",
      "pos": [
        2379,
        2441
      ]
    },
    {
      "content": "Run on-demand to update an index as needed.",
      "pos": [
        2444,
        2487
      ]
    },
    {
      "content": "When to Use Azure SQL Indexer",
      "pos": [
        2493,
        2522
      ]
    },
    {
      "content": "Depending on several factors relating to your data, the use of Azure SQL indexer may or may not be appropriate.",
      "pos": [
        2527,
        2638
      ]
    },
    {
      "content": "If your data fits the following requirements, you can use Azure SQL indexer:",
      "pos": [
        2639,
        2715
      ]
    },
    {
      "content": "All the data comes from a single table or view",
      "pos": [
        2720,
        2766
      ]
    },
    {
      "content": "If the data is scattered across multiple tables, you can create a view and use that view with the indexer.",
      "pos": [
        2773,
        2879
      ]
    },
    {
      "content": "However, be aware that if you use a view, you won’t be able to use SQL Server integrated change detection.",
      "pos": [
        2880,
        2986
      ]
    },
    {
      "content": "See this section for more details.",
      "pos": [
        2987,
        3021
      ]
    },
    {
      "content": "The data types used in the data source are supported by the indexer.",
      "pos": [
        3025,
        3093
      ]
    },
    {
      "content": "Most but not all of the SQL types are supported.",
      "pos": [
        3094,
        3142
      ]
    },
    {
      "content": "For details, see <bpt id=\"p1\">[</bpt>Mapping data types in Azure Search<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkID=528105)</ept>.",
      "pos": [
        3143,
        3246
      ]
    },
    {
      "content": "You don’t need near real-time updates to the index when a row changes.",
      "pos": [
        3250,
        3320
      ]
    },
    {
      "content": "The indexer can re-index your table at most every 5 minutes.",
      "pos": [
        3328,
        3388
      ]
    },
    {
      "content": "If your data changes frequently and the changes need to be reflected in the index within seconds or single minutes, we recommend using <bpt id=\"p1\">[</bpt>Azure Search Index API<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn798930.aspx)</ept> directly.",
      "pos": [
        3389,
        3614
      ]
    },
    {
      "content": "If you have a large data set and plan to run the indexer on a schedule, your schema allows to us to efficiently identify changed (and deleted, if applicable) rows.",
      "pos": [
        3618,
        3781
      ]
    },
    {
      "content": "For more details, see \"Capturing Changed and Deleted Rows\" below.",
      "pos": [
        3782,
        3847
      ]
    },
    {
      "content": "The size of the indexed fields in a row doesn’t exceed the maximum size of an Azure Search indexing request, which is 16 MB.",
      "pos": [
        3851,
        3975
      ]
    },
    {
      "content": "Create and Use an Azure SQL Indexer",
      "pos": [
        3981,
        4016
      ]
    },
    {
      "content": "First, create the data source:",
      "pos": [
        4021,
        4051
      ]
    },
    {
      "pos": [
        4609,
        4737
      ],
      "content": "You can get the connection string from the <bpt id=\"p1\">[</bpt>Azure portal<ept id=\"p1\">](https://portal.azure.com)</ept>; use the <ph id=\"ph1\">`ADO.NET connection string`</ph> option."
    },
    {
      "content": "Then, create the target Azure Search index if you don’t have one already.",
      "pos": [
        4739,
        4812
      ]
    },
    {
      "content": "You can do this from the <bpt id=\"p1\">[</bpt>portal UI<ept id=\"p1\">](https://portal.azure.com)</ept> or by using the <bpt id=\"p2\">[</bpt>Create Index API<ept id=\"p2\">](https://msdn.microsoft.com/library/azure/dn798941.aspx)</ept>.",
      "pos": [
        4813,
        4967
      ]
    },
    {
      "content": "Ensure that the schema of your target index is compatible with the schema of the source table.",
      "pos": [
        4969,
        5063
      ]
    },
    {
      "content": "See the following table for the mapping between SQL and Azure search data types.",
      "pos": [
        5064,
        5144
      ]
    },
    {
      "content": "Mapping between SQL Data Types and Azure Search Data Types",
      "pos": [
        5148,
        5206
      ]
    },
    {
      "content": "SQL data type",
      "pos": [
        5211,
        5224
      ]
    },
    {
      "content": "Allowed target index field types",
      "pos": [
        5227,
        5259
      ]
    },
    {
      "content": "Notes",
      "pos": [
        5261,
        5266
      ]
    },
    {
      "content": "bit",
      "pos": [
        5289,
        5292
      ]
    },
    {
      "content": "Edm.Boolean, Edm.String",
      "pos": [
        5293,
        5316
      ]
    },
    {
      "content": "int, smallint, tinyint",
      "pos": [
        5321,
        5343
      ]
    },
    {
      "content": "Edm.Int32, Edm.Int64, Edm.String",
      "pos": [
        5345,
        5377
      ]
    },
    {
      "content": "bigint",
      "pos": [
        5383,
        5389
      ]
    },
    {
      "content": "Edm.Int64, Edm.String",
      "pos": [
        5392,
        5413
      ]
    },
    {
      "content": "real, float",
      "pos": [
        5420,
        5431
      ]
    },
    {
      "content": "Edm.Double, Edm.String",
      "pos": [
        5433,
        5455
      ]
    },
    {
      "content": "smallmoney, money decimal numeric",
      "pos": [
        5462,
        5495
      ]
    },
    {
      "content": "Edm.String",
      "pos": [
        5498,
        5508
      ]
    },
    {
      "content": "Azure Search does not support converting decimal types into Edm.Double because this would lose precision",
      "pos": [
        5510,
        5614
      ]
    },
    {
      "content": "char, nchar, varchar, nvarchar",
      "pos": [
        5619,
        5649
      ]
    },
    {
      "content": "Edm.String",
      "pos": [
        5652,
        5662
      ]
    },
    {
      "content": "Collection(Edm.String)",
      "pos": [
        5667,
        5689
      ]
    },
    {
      "content": "Transforming a string column into Collection(Edm.String) requires using a preview API version 2015-02-28-Preview.",
      "pos": [
        5690,
        5803
      ]
    },
    {
      "content": "See <bpt id=\"p1\">[</bpt>this article<ept id=\"p1\">](search-api-indexers-2015-02-28-Preview.md#create-indexer)</ept> for details",
      "pos": [
        5804,
        5892
      ]
    },
    {
      "content": "smalldatetime, datetime, datetime2, date, datetimeoffset",
      "pos": [
        5896,
        5952
      ]
    },
    {
      "content": "Edm.DateTimeOffset, Edm.String",
      "pos": [
        5954,
        5984
      ]
    },
    {
      "content": "uniqueidentifer",
      "pos": [
        5989,
        6004
      ]
    },
    {
      "content": "Edm.String",
      "pos": [
        6007,
        6017
      ]
    },
    {
      "content": "geography",
      "pos": [
        6023,
        6032
      ]
    },
    {
      "content": "Edm.GeographyPoint",
      "pos": [
        6035,
        6053
      ]
    },
    {
      "content": "Only geography instances of type POINT with SRID 4326 (which is the default) are supported",
      "pos": [
        6056,
        6146
      ]
    },
    {
      "content": "rowversion",
      "pos": [
        6153,
        6163
      ]
    },
    {
      "content": "N/A",
      "pos": [
        6165,
        6168
      ]
    },
    {
      "content": "Row-version columns cannot be stored in the search index, but they can be used for change tracking",
      "pos": [
        6170,
        6268
      ]
    },
    {
      "content": "time, timespan, binary, varbinary, image, xml, geometry, CLR types",
      "pos": [
        6275,
        6341
      ]
    },
    {
      "content": "N/A",
      "pos": [
        6344,
        6347
      ]
    },
    {
      "content": "Not supported",
      "pos": [
        6349,
        6362
      ]
    },
    {
      "content": "Finally, create the indexer by giving it a name and referencing the data source and target index:",
      "pos": [
        6366,
        6463
      ]
    },
    {
      "content": "An indexer created in this way doesn’t have a schedule.",
      "pos": [
        6750,
        6805
      ]
    },
    {
      "content": "It automatically runs once as soon as it’s created.",
      "pos": [
        6806,
        6857
      ]
    },
    {
      "content": "You can run it again at any time using a <bpt id=\"p1\">**</bpt>run indexer<ept id=\"p1\">**</ept> request:",
      "pos": [
        6858,
        6923
      ]
    },
    {
      "content": "You may need to allow Azure services to connect to your database.",
      "pos": [
        7043,
        7108
      ]
    },
    {
      "content": "See <bpt id=\"p1\">[</bpt>Connecting From Azure<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/ee621782.aspx#ConnectingFromAzure)</ept> for instructions on how to do that.",
      "pos": [
        7109,
        7248
      ]
    },
    {
      "pos": [
        7250,
        7379
      ],
      "content": "To monitor the indexer status and execution history (number of items indexed, failures, etc.), use an <bpt id=\"p1\">**</bpt>indexer status<ept id=\"p1\">**</ept> request:"
    },
    {
      "content": "The response should look similar to the following:",
      "pos": [
        7501,
        7551
      ]
    },
    {
      "content": "Execution history contains up to 50 of the most recently completed executions, which are sorted in the reverse chronological order (so that the latest execution comes first in the response).",
      "pos": [
        8591,
        8781
      ]
    },
    {
      "content": "Additional information about the response can be found in <bpt id=\"p1\">[</bpt>Get Indexer Status<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkId=528198)</ept>",
      "pos": [
        8783,
        8910
      ]
    },
    {
      "content": "Run Indexers on a Schedule",
      "pos": [
        8915,
        8941
      ]
    },
    {
      "content": "You can also arrange the indexer to run periodically on a schedule.",
      "pos": [
        8946,
        9013
      ]
    },
    {
      "content": "To do this, just add the <bpt id=\"p1\">**</bpt>schedule<ept id=\"p1\">**</ept> property when creating or updating the indexer.",
      "pos": [
        9014,
        9099
      ]
    },
    {
      "content": "The example below shows a PUT request to update the indexer:",
      "pos": [
        9100,
        9160
      ]
    },
    {
      "content": "The <bpt id=\"p1\">**</bpt>interval<ept id=\"p1\">**</ept> parameter is required.",
      "pos": [
        9508,
        9547
      ]
    },
    {
      "content": "The interval refers to the time between the start of two consecutive indexer executions.",
      "pos": [
        9548,
        9636
      ]
    },
    {
      "content": "The smallest allowed interval is 5 minutes; the longest is one day.",
      "pos": [
        9637,
        9704
      ]
    },
    {
      "content": "It must be formatted as an XSD \"dayTimeDuration\" value (a restricted subset of an <bpt id=\"p1\">[</bpt>ISO 8601 duration<ept id=\"p1\">](http://www.w3.org/TR/xmlschema11-2/#dayTimeDuration)</ept> value).",
      "pos": [
        9705,
        9867
      ]
    },
    {
      "content": "The pattern for this is: <ph id=\"ph1\">`P(nD)(T(nH)(nM))`</ph>.",
      "pos": [
        9868,
        9912
      ]
    },
    {
      "content": "Examples: <ph id=\"ph1\">`PT15M`</ph> for every 15 minutes, <ph id=\"ph2\">`PT2H`</ph> for every 2 hours.",
      "pos": [
        9913,
        9978
      ]
    },
    {
      "content": "The optional <bpt id=\"p1\">**</bpt>startTime<ept id=\"p1\">**</ept> indicates when the scheduled executions should commence; if it is omitted, the current UTC time will be used.",
      "pos": [
        9980,
        10116
      ]
    },
    {
      "content": "This time can be in the past – in which case the first execution will be scheduled as if the indexer has been running continuously since the startTime.",
      "pos": [
        10117,
        10268
      ]
    },
    {
      "content": "Only one execution of a given indexer can run at a time.",
      "pos": [
        10272,
        10328
      ]
    },
    {
      "content": "If an indexer is already executing when the next one is supposed to start, the execution is skipped and resumes at the next interval, assuming no other indexer job is running.",
      "pos": [
        10329,
        10504
      ]
    },
    {
      "content": "Let’s consider an example to make this more concrete.",
      "pos": [
        10506,
        10559
      ]
    },
    {
      "content": "Suppose we the following hourly schedule configured:",
      "pos": [
        10560,
        10612
      ]
    },
    {
      "content": "Here’s what happens:",
      "pos": [
        10695,
        10715
      ]
    },
    {
      "content": "The first indexer execution starts at or around March 1, 2015 12:00 a.m.",
      "pos": [
        10721,
        10793
      ]
    },
    {
      "content": "UTC.",
      "pos": [
        10794,
        10798
      ]
    },
    {
      "content": "Assume this execution takes 20 minutes (or any time less than 1 hour).",
      "pos": [
        10802,
        10872
      ]
    },
    {
      "content": "The second execution starts at or around March 1, 2015 1:00 a.m.",
      "pos": [
        10876,
        10940
      ]
    },
    {
      "content": "Now suppose that this execution takes more than an hour (this would require a huge number of documents for this to actually occur, but it’s a useful illustration) – for example, 70 minutes – so that it completes around 2:10 a.m.",
      "pos": [
        10945,
        11173
      ]
    },
    {
      "content": "It’s now 2:00 a.m., time for the third execution to start.",
      "pos": [
        11177,
        11235
      ]
    },
    {
      "content": "However, because the second execution from 1 a.m.",
      "pos": [
        11236,
        11285
      ]
    },
    {
      "content": "is still running, the third execution is skipped.",
      "pos": [
        11286,
        11335
      ]
    },
    {
      "content": "The third execution starts at 3 a.m.",
      "pos": [
        11336,
        11372
      ]
    },
    {
      "pos": [
        11374,
        11475
      ],
      "content": "You can add, change, or delete a schedule for an existing indexer by using a <bpt id=\"p1\">**</bpt>PUT indexer<ept id=\"p1\">**</ept> request."
    },
    {
      "content": "Capturing New, Changed and Deleted Rows",
      "pos": [
        11481,
        11520
      ]
    },
    {
      "content": "If you’re using a schedule and your table contains a non-trivial number of rows, you should use a data change detection policy, so that the indexer can efficiently retrieve only the new or changed rows without having to re-index the entire table.",
      "pos": [
        11525,
        11771
      ]
    },
    {
      "content": "SQL Integrated Change Tracking Policy",
      "pos": [
        11777,
        11814
      ]
    },
    {
      "content": "If your SQL database supports <bpt id=\"p1\">[</bpt>change tracking<ept id=\"p1\">](https://msdn.microsoft.com/library/bb933875.aspx)</ept>, we recommend using <bpt id=\"p2\">**</bpt>SQL Integrated Change Tracking Policy<ept id=\"p2\">**</ept>.",
      "pos": [
        11820,
        11980
      ]
    },
    {
      "content": "This policy enables the most efficient change tracking, and it also allows Azure Search to identify deleted rows without you having to add an explicit \"soft delete\" column to your table.",
      "pos": [
        11981,
        12167
      ]
    },
    {
      "content": "Integrated change tracking is supported starting with the following SQL Server database versions:",
      "pos": [
        12169,
        12266
      ]
    },
    {
      "content": "SQL Server 2008 R2 and later, if you're using SQL Server on Azure VMs.",
      "pos": [
        12271,
        12341
      ]
    },
    {
      "content": "Azure SQL Database V12, if you're using Azure SQL Database.",
      "pos": [
        12345,
        12404
      ]
    },
    {
      "content": "When using SQL integrated change tracking policy, do not specify a separate data deletion detection policy - this policy has built-in support for identifying deleted rows.",
      "pos": [
        12406,
        12577
      ]
    },
    {
      "content": "This policy can only be used with tables; it cannot be used with views.",
      "pos": [
        12579,
        12650
      ]
    },
    {
      "content": "You need to enable change tracking for the table you're using before you can use this policy.",
      "pos": [
        12651,
        12744
      ]
    },
    {
      "content": "See <bpt id=\"p1\">[</bpt>Enable and disable change tracking<ept id=\"p1\">](https://msdn.microsoft.com/library/bb964713.aspx)</ept> for instructions.",
      "pos": [
        12745,
        12853
      ]
    },
    {
      "content": "To use this policy, create or update your data source like this:",
      "pos": [
        12856,
        12920
      ]
    },
    {
      "content": "High Water Mark Change Detection Policy",
      "pos": [
        13275,
        13314
      ]
    },
    {
      "content": "While the SQL Integrated Change Tracking policy is recommended, you won’t be able to use it if your data is in a view, or if you’re using an older version of Azure SQL database.",
      "pos": [
        13320,
        13497
      ]
    },
    {
      "content": "In such a case, consider using the high water mark policy.",
      "pos": [
        13498,
        13556
      ]
    },
    {
      "content": "This policy can be used if your table contains a column that meets the following criteria:",
      "pos": [
        13557,
        13647
      ]
    },
    {
      "content": "All inserts specify a value for the column.",
      "pos": [
        13651,
        13694
      ]
    },
    {
      "content": "All updates to an item also change the value of the column.",
      "pos": [
        13698,
        13757
      ]
    },
    {
      "content": "The value of this column increases with each change.",
      "pos": [
        13761,
        13813
      ]
    },
    {
      "pos": [
        13816,
        13956
      ],
      "content": "Queries that use a <ph id=\"ph1\">`WHERE`</ph> clause similar to <ph id=\"ph2\">`WHERE [High Water Mark Column] &gt; [Current High Water Mark Value]`</ph> can be executed efficiently."
    },
    {
      "content": "For example, an indexed <bpt id=\"p1\">**</bpt>rowversion<ept id=\"p1\">**</ept> column is an ideal candidate for the high water mark column.",
      "pos": [
        13958,
        14057
      ]
    },
    {
      "content": "To use this policy, create or update your data source like this:",
      "pos": [
        14059,
        14123
      ]
    },
    {
      "content": "Soft Delete Column Deletion Detection Policy",
      "pos": [
        14565,
        14609
      ]
    },
    {
      "content": "When rows are deleted from the source table, you probably want to delete those rows from the search index as well.",
      "pos": [
        14615,
        14729
      ]
    },
    {
      "content": "If you use the SQL integrated change tracking policy, this is taken care of for you.",
      "pos": [
        14730,
        14814
      ]
    },
    {
      "content": "However, the high water mark change tracking policy doesn’t help you with deleted rows.",
      "pos": [
        14815,
        14902
      ]
    },
    {
      "content": "What to do?",
      "pos": [
        14903,
        14914
      ]
    },
    {
      "content": "If the rows are physically removed from the table, you’re out of luck – there’s no way to infer the presence of records that no longer exist.",
      "pos": [
        14917,
        15058
      ]
    },
    {
      "content": "However, you can use the “soft-delete” technique to mark rows as logically deleted without removing them from the table by adding a column and marking rows as deleted using a marker value in that column.",
      "pos": [
        15060,
        15263
      ]
    },
    {
      "content": "When using the soft-delete technique, you can specify the soft delete policy as follows when creating or updating the data source:",
      "pos": [
        15265,
        15395
      ]
    },
    {
      "content": "Note that the <bpt id=\"p1\">**</bpt>softDeleteMarkerValue<ept id=\"p1\">**</ept> must be a string – use the string representation of your actual value.",
      "pos": [
        15716,
        15826
      ]
    },
    {
      "content": "For example, if you have an integer column where deleted rows are marked with the value 1, use <ph id=\"ph1\">`\"1\"`</ph>; if you have a BIT column where deleted rows are marked with the Boolean true value, use <ph id=\"ph2\">`\"True\"`</ph>.",
      "pos": [
        15827,
        16026
      ]
    },
    {
      "content": "Customize Azure SQL Indexer",
      "pos": [
        16032,
        16059
      ]
    },
    {
      "content": "You can customize certain aspects of indexer behavior (for example, batch size, how many documents can be skipped before an indexer execution will be failed, etc.).",
      "pos": [
        16065,
        16229
      ]
    },
    {
      "content": "For more details, see <bpt id=\"p1\">[</bpt>Indexer API documentation<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkId=528173)</ept>.",
      "pos": [
        16230,
        16329
      ]
    },
    {
      "content": "Frequently Asked Questions",
      "pos": [
        16335,
        16361
      ]
    },
    {
      "pos": [
        16366,
        16449
      ],
      "content": "<bpt id=\"p1\">**</bpt>Q:<ept id=\"p1\">**</ept> Can I use Azure SQL indexer with SQL databases running on IaaS VMs in Azure?"
    },
    {
      "content": "A: Yes, as long as you allow Azure services to connect to your database by opening appropriate ports.",
      "pos": [
        16451,
        16552
      ]
    },
    {
      "pos": [
        16554,
        16628
      ],
      "content": "<bpt id=\"p1\">**</bpt>Q:<ept id=\"p1\">**</ept> Can I use Azure SQL indexer with SQL databases running on-premises?"
    },
    {
      "content": "A: We do not recommend or support this, as doing this would require you to open your databases to Internet traffic.",
      "pos": [
        16631,
        16746
      ]
    },
    {
      "pos": [
        16749,
        16846
      ],
      "content": "<bpt id=\"p1\">**</bpt>Q:<ept id=\"p1\">**</ept> Can I use Azure SQL indexer with databases other than SQL Server running in IaaS on Azure?"
    },
    {
      "content": "A: We don’t support this scenario, because we haven’t tested the indexer with any databases other than SQL Server.",
      "pos": [
        16849,
        16963
      ]
    },
    {
      "pos": [
        16967,
        17027
      ],
      "content": "<bpt id=\"p1\">**</bpt>Q:<ept id=\"p1\">**</ept> Can I create multiple indexers running on a schedule?"
    },
    {
      "content": "A: Yes.",
      "pos": [
        17030,
        17037
      ]
    },
    {
      "content": "However, only one indexer can be running on one node at one time.",
      "pos": [
        17038,
        17103
      ]
    },
    {
      "content": "If you need multiple indexers running concurrently, consider scaling up your search service to more than one search unit.",
      "pos": [
        17104,
        17225
      ]
    },
    {
      "pos": [
        17228,
        17284
      ],
      "content": "<bpt id=\"p1\">**</bpt>Q:<ept id=\"p1\">**</ept> Does running an indexer affect my query workload?"
    },
    {
      "content": "A: Yes.",
      "pos": [
        17287,
        17294
      ]
    },
    {
      "content": "Indexer runs on one of the nodes in your search service, and that node’s resources are shared between indexing and serving query traffic and other API requests.",
      "pos": [
        17295,
        17455
      ]
    },
    {
      "content": "If you run intensive indexing and query workloads and encounter a high rate of 503 errors or increasing response times, consider scaling up your search service.",
      "pos": [
        17456,
        17616
      ]
    }
  ],
  "content": "<properties \n    pageTitle=\"Connecting Azure SQL Database to Azure Search Using Indexers\" \n    description=\"Learn how to pull data from Azure SQL Database to an Azure Search index using indexers.\" \n    services=\"search\" \n    documentationCenter=\"\" \n    authors=\"chaosrealm\" \n    manager=\"pablocas\" \n    editor=\"\"/>\n\n<tags \n    ms.service=\"search\" \n    ms.devlang=\"rest-api\" \n    ms.workload=\"search\" \n    ms.topic=\"article\" \n    ms.tgt_pltfrm=\"na\" \n    ms.date=\"07/08/2015\" \n    ms.author=\"eugenesh\"/>\n\n#Connecting Azure SQL Database to Azure Search Using Indexers#\n\nAzure Search service makes it easy to provide a great search experience, but before you can search, you need to populate an Azure Search index with your data. If the data lives in an Azure SQL database, the new **Azure Search indexer for Azure SQL Database** (or **Azure SQL indexer** for short) feature in Azure Search can automate the indexing process. This means you have less code to write and less infrastructure to maintain.\n\nCurrently, indexers only work with Azure SQL Database, SQL Server on Azure VMs, and Azure DocumentDB. In this article, we’ll focus on indexers that work with Azure SQL Database. If you would like to see support for additional data sources, please provide your feedback on the [Azure Search feedback forum](http://feedback.azure.com/forums/263029-azure-search).\n\nThis article will cover the mechanics of using indexers, but we’ll also drill down into features and behaviors that are only available with SQL databases (for example, integrated change tracking).\n\n## Indexers and Data Sources ##\n\nTo set up and configure an Azure SQL indexer, you can call the [Azure Search REST API](http://go.microsoft.com/fwlink/p/?LinkID=528173) to create and manage **indexers** and **data sources**. In the future, this functionality will also be available in Azure management portal and in Azure Search .NET SDK. \n\nA **data source** specifies which data to index, credentials needed to access the data, and policies that enable Azure Search to efficiently identify changes in the data (new, modified or deleted rows). It's defined as an independent resource so that it can be used by multiple indexers.\n\nAn **indexer** is a resource that connects data sources with target search indexes. An indexer is used in the following ways:\n \n- Perform a one-time copy of the data to populate an index.\n- Update an index with changes in the data source on a schedule.\n- Run on-demand to update an index as needed. \n\n## When to Use Azure SQL Indexer ##\n\nDepending on several factors relating to your data, the use of Azure SQL indexer may or may not be appropriate. If your data fits the following requirements, you can use Azure SQL indexer: \n\n- All the data comes from a single table or view\n    - If the data is scattered across multiple tables, you can create a view and use that view with the indexer. However, be aware that if you use a view, you won’t be able to use SQL Server integrated change detection. See this section for more details. \n- The data types used in the data source are supported by the indexer. Most but not all of the SQL types are supported. For details, see [Mapping data types in Azure Search](http://go.microsoft.com/fwlink/p/?LinkID=528105). \n- You don’t need near real-time updates to the index when a row changes. \n    - The indexer can re-index your table at most every 5 minutes. If your data changes frequently and the changes need to be reflected in the index within seconds or single minutes, we recommend using [Azure Search Index API](https://msdn.microsoft.com/library/azure/dn798930.aspx) directly. \n- If you have a large data set and plan to run the indexer on a schedule, your schema allows to us to efficiently identify changed (and deleted, if applicable) rows. For more details, see \"Capturing Changed and Deleted Rows\" below. \n- The size of the indexed fields in a row doesn’t exceed the maximum size of an Azure Search indexing request, which is 16 MB. \n\n## Create and Use an Azure SQL Indexer ##\n\nFirst, create the data source: \n\n    POST https://myservice.search.windows.net/datasources?api-version=2015-02-28 \n    Content-Type: application/json\n    api-key: admin-key\n    \n    { \n        \"name\" : \"myazuresqldatasource\",\n        \"type\" : \"azuresql\",\n        \"credentials\" : { \"connectionString\" : \"Server=tcp:<your server>.database.windows.net,1433;Database=<your database>;User ID=<your user name>;Password=<your password>;Trusted_Connection=False;Encrypt=True;Connection Timeout=30;\" },\n        \"container\" : { \"name\" : \"name of the table or view that you want to index\" }\n    }\n\n\nYou can get the connection string from the [Azure portal](https://portal.azure.com); use the `ADO.NET connection string` option.\n\nThen, create the target Azure Search index if you don’t have one already. You can do this from the [portal UI](https://portal.azure.com) or by using the [Create Index API](https://msdn.microsoft.com/library/azure/dn798941.aspx).  Ensure that the schema of your target index is compatible with the schema of the source table. See the following table for the mapping between SQL and Azure search data types.\n\n**Mapping between SQL Data Types and Azure Search Data Types**\n\n|SQL data type | Allowed target index field types |Notes \n|------|-----|----|\n|bit|Edm.Boolean, Edm.String| |\n|int, smallint, tinyint |Edm.Int32, Edm.Int64, Edm.String| |\n| bigint | Edm.Int64, Edm.String | |\n| real, float |Edm.Double, Edm.String | |\n| smallmoney, money decimal numeric | Edm.String| Azure Search does not support converting decimal types into Edm.Double because this would lose precision |\n| char, nchar, varchar, nvarchar | Edm.String<br/>Collection(Edm.String)|Transforming a string column into Collection(Edm.String) requires using a preview API version 2015-02-28-Preview. See [this article](search-api-indexers-2015-02-28-Preview.md#create-indexer) for details| \n|smalldatetime, datetime, datetime2, date, datetimeoffset |Edm.DateTimeOffset, Edm.String| |\n|uniqueidentifer | Edm.String | |\n|geography | Edm.GeographyPoint | Only geography instances of type POINT with SRID 4326 (which is the default) are supported | | \n|rowversion| N/A |Row-version columns cannot be stored in the search index, but they can be used for change tracking | |\n| time, timespan, binary, varbinary, image, xml, geometry, CLR types | N/A |Not supported |\n\nFinally, create the indexer by giving it a name and referencing the data source and target index:\n\n    POST https://myservice.search.windows.net/indexers?api-version=2015-02-28 \n    Content-Type: application/json\n    api-key: admin-key\n    \n    { \n        \"name\" : \"myindexer\",\n        \"dataSourceName\" : \"myazuresqldatasource\",\n        \"targetIndexName\" : \"target index name\"\n    }\n\nAn indexer created in this way doesn’t have a schedule. It automatically runs once as soon as it’s created. You can run it again at any time using a **run indexer** request:\n\n    POST https://myservice.search.windows.net/indexers/myindexer/run?api-version=2015-02-28 \n    api-key: admin-key\n \nYou may need to allow Azure services to connect to your database. See [Connecting From Azure](https://msdn.microsoft.com/library/azure/ee621782.aspx#ConnectingFromAzure) for instructions on how to do that.\n\nTo monitor the indexer status and execution history (number of items indexed, failures, etc.), use an **indexer status** request: \n\n    GET https://myservice.search.windows.net/indexers/myindexer/status?api-version=2015-02-28 \n    api-key: admin-key\n\nThe response should look similar to the following: \n\n    {\n        \"@odata.context\":\"https://myservice.search.windows.net/$metadata#Microsoft.Azure.Search.V2015_02_28.IndexerExecutionInfo\",\n        \"status\":\"running\",\n        \"lastResult\": {\n            \"status\":\"success\",\n            \"errorMessage\":null,\n            \"startTime\":\"2015-02-21T00:23:24.957Z\",\n            \"endTime\":\"2015-02-21T00:36:47.752Z\",\n            \"errors\":[],\n            \"itemsProcessed\":1599501,\n            \"itemsFailed\":0,\n            \"initialTrackingState\":null,\n            \"finalTrackingState\":null \n        },\n        \"executionHistory\":\n        [\n            {\n                \"status\":\"success\",\n                \"errorMessage\":null,\n                \"startTime\":\"2015-02-21T00:23:24.957Z\",\n                \"endTime\":\"2015-02-21T00:36:47.752Z\",\n                \"errors\":[],\n                \"itemsProcessed\":1599501,\n                \"itemsFailed\":0,\n                \"initialTrackingState\":null,\n                \"finalTrackingState\":null \n            },\n            ... earlier history items \n        ]\n    }\n\nExecution history contains up to 50 of the most recently completed executions, which are sorted in the reverse chronological order (so that the latest execution comes first in the response). \nAdditional information about the response can be found in [Get Indexer Status](http://go.microsoft.com/fwlink/p/?LinkId=528198)\n\n## Run Indexers on a Schedule ##\n\nYou can also arrange the indexer to run periodically on a schedule. To do this, just add the **schedule** property when creating or updating the indexer. The example below shows a PUT request to update the indexer:\n\n    PUT https://myservice.search.windows.net/indexers/myindexer?api-version=2015-02-28 \n    Content-Type: application/json\n    api-key: admin-key \n\n    { \n        \"dataSourceName\" : \"myazuresqldatasource\",\n        \"targetIndexName\" : \"target index name\",\n        \"schedule\" : { \"interval\" : \"PT10M\", \"startTime\" : \"2015-01-01T00:00:00Z\" }\n    }\n\nThe **interval** parameter is required. The interval refers to the time between the start of two consecutive indexer executions. The smallest allowed interval is 5 minutes; the longest is one day. It must be formatted as an XSD \"dayTimeDuration\" value (a restricted subset of an [ISO 8601 duration](http://www.w3.org/TR/xmlschema11-2/#dayTimeDuration) value). The pattern for this is: `P(nD)(T(nH)(nM))`. Examples: `PT15M` for every 15 minutes, `PT2H` for every 2 hours.\n\nThe optional **startTime** indicates when the scheduled executions should commence; if it is omitted, the current UTC time will be used. This time can be in the past – in which case the first execution will be scheduled as if the indexer has been running continuously since the startTime.  \n\nOnly one execution of a given indexer can run at a time. If an indexer is already executing when the next one is supposed to start, the execution is skipped and resumes at the next interval, assuming no other indexer job is running.\n\nLet’s consider an example to make this more concrete. Suppose we the following hourly schedule configured: \n\n    \"schedule\" : { \"interval\" : \"PT1H\", \"startTime\" : \"2015-03-01T00:00:00Z\" }\n\nHere’s what happens: \n\n1. The first indexer execution starts at or around March 1, 2015 12:00 a.m. UTC.\n1. Assume this execution takes 20 minutes (or any time less than 1 hour).\n1. The second execution starts at or around March 1, 2015 1:00 a.m. \n1. Now suppose that this execution takes more than an hour (this would require a huge number of documents for this to actually occur, but it’s a useful illustration) – for example, 70 minutes – so that it completes around 2:10 a.m.\n1. It’s now 2:00 a.m., time for the third execution to start. However, because the second execution from 1 a.m. is still running, the third execution is skipped. The third execution starts at 3 a.m.\n\nYou can add, change, or delete a schedule for an existing indexer by using a **PUT indexer** request. \n\n## Capturing New, Changed and Deleted Rows ##\n\nIf you’re using a schedule and your table contains a non-trivial number of rows, you should use a data change detection policy, so that the indexer can efficiently retrieve only the new or changed rows without having to re-index the entire table.\n\n### SQL Integrated Change Tracking Policy ###\n\nIf your SQL database supports [change tracking](https://msdn.microsoft.com/library/bb933875.aspx), we recommend using **SQL Integrated Change Tracking Policy**. This policy enables the most efficient change tracking, and it also allows Azure Search to identify deleted rows without you having to add an explicit \"soft delete\" column to your table.\n\nIntegrated change tracking is supported starting with the following SQL Server database versions:\n \n- SQL Server 2008 R2 and later, if you're using SQL Server on Azure VMs. \n- Azure SQL Database V12, if you're using Azure SQL Database.\n\nWhen using SQL integrated change tracking policy, do not specify a separate data deletion detection policy - this policy has built-in support for identifying deleted rows.\n\nThis policy can only be used with tables; it cannot be used with views. You need to enable change tracking for the table you're using before you can use this policy. See [Enable and disable change tracking](https://msdn.microsoft.com/library/bb964713.aspx) for instructions. \n\nTo use this policy, create or update your data source like this:\n \n    { \n        \"name\" : \"myazuresqldatasource\",\n        \"type\" : \"azuresql\",\n        \"credentials\" : { \"connectionString\" : \"connection string\" },\n        \"container\" : { \"name\" : \"table or view name\" }, \n        \"dataChangeDetectionPolicy\" : {\n           \"@odata.type\" : \"#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy\" \n      }\n    }\n\n### High Water Mark Change Detection Policy ###\n\nWhile the SQL Integrated Change Tracking policy is recommended, you won’t be able to use it if your data is in a view, or if you’re using an older version of Azure SQL database. In such a case, consider using the high water mark policy. This policy can be used if your table contains a column that meets the following criteria:\n\n- All inserts specify a value for the column. \n- All updates to an item also change the value of the column. \n- The value of this column increases with each change.\n- Queries that use a `WHERE` clause similar to `WHERE [High Water Mark Column] > [Current High Water Mark Value]` can be executed efficiently.\n\nFor example, an indexed **rowversion** column is an ideal candidate for the high water mark column. \nTo use this policy, create or update your data source like this: \n\n    { \n        \"name\" : \"myazuresqldatasource\",\n        \"type\" : \"azuresql\",\n        \"credentials\" : { \"connectionString\" : \"connection string\" },\n        \"container\" : { \"name\" : \"table or view name\" }, \n        \"dataChangeDetectionPolicy\" : {\n           \"@odata.type\" : \"#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy\",\n           \"highWaterMarkColumnName\" : \"[a row version or last_updated column name]\" \n      }\n    }\n\n### Soft Delete Column Deletion Detection Policy ###\n\nWhen rows are deleted from the source table, you probably want to delete those rows from the search index as well. If you use the SQL integrated change tracking policy, this is taken care of for you. However, the high water mark change tracking policy doesn’t help you with deleted rows. What to do? \n\nIf the rows are physically removed from the table, you’re out of luck – there’s no way to infer the presence of records that no longer exist.  However, you can use the “soft-delete” technique to mark rows as logically deleted without removing them from the table by adding a column and marking rows as deleted using a marker value in that column.\n\nWhen using the soft-delete technique, you can specify the soft delete policy as follows when creating or updating the data source: \n\n    { \n        …, \n        \"dataDeletionDetectionPolicy\" : { \n           \"@odata.type\" : \"#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy\",\n           \"softDeleteColumnName\" : \"[a column name]\", \n           \"softDeleteMarkerValue\" : \"[the value that indicates that a row is deleted]\" \n        }\n    }\n\nNote that the **softDeleteMarkerValue** must be a string – use the string representation of your actual value. For example, if you have an integer column where deleted rows are marked with the value 1, use `\"1\"`; if you have a BIT column where deleted rows are marked with the Boolean true value, use `\"True\"`. \n\n## Customize Azure SQL Indexer ##\n \nYou can customize certain aspects of indexer behavior (for example, batch size, how many documents can be skipped before an indexer execution will be failed, etc.). For more details, see [Indexer API documentation](http://go.microsoft.com/fwlink/p/?LinkId=528173). \n\n## Frequently Asked Questions ##\n\n**Q:** Can I use Azure SQL indexer with SQL databases running on IaaS VMs in Azure?\n\nA: Yes, as long as you allow Azure services to connect to your database by opening appropriate ports.\n\n**Q:** Can I use Azure SQL indexer with SQL databases running on-premises? \n\nA: We do not recommend or support this, as doing this would require you to open your databases to Internet traffic. \n\n**Q:** Can I use Azure SQL indexer with databases other than SQL Server running in IaaS on Azure? \n\nA: We don’t support this scenario, because we haven’t tested the indexer with any databases other than SQL Server.  \n\n**Q:** Can I create multiple indexers running on a schedule? \n\nA: Yes. However, only one indexer can be running on one node at one time. If you need multiple indexers running concurrently, consider scaling up your search service to more than one search unit. \n\n**Q:** Does running an indexer affect my query workload? \n\nA: Yes. Indexer runs on one of the nodes in your search service, and that node’s resources are shared between indexing and serving query traffic and other API requests. If you run intensive indexing and query workloads and encounter a high rate of 503 errors or increasing response times, consider scaling up your search service. \n\n\n\n \n"
}