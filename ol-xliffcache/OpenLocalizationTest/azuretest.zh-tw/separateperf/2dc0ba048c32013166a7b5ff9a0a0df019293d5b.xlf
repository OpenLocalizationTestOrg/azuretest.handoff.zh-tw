<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Build a service using an existing SQL database with the Mobile Services .NET backend | Microsoft Azure</source>
          <target state="new">Build a service using an existing SQL database with the Mobile Services .NET backend | Microsoft Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Learn how to use an existing cloud or on-premises SQL database with your .NET based mobile service</source>
          <target state="new">Learn how to use an existing cloud or on-premises SQL database with your .NET based mobile service</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Build a service using an existing SQL database with the Mobile Services .NET backend</source>
          <target state="new">Build a service using an existing SQL database with the Mobile Services .NET backend</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The Mobile Services .NET backend makes it easy to take advantage of existing assets in building a mobile service.</source>
          <target state="new">The Mobile Services .NET backend makes it easy to take advantage of existing assets in building a mobile service.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>One particularly interesting scenario is using an existing SQL database (either on-premises or in the cloud), that may already be used by other applications, to make existing data available to mobile clients.</source>
          <target state="new">One particularly interesting scenario is using an existing SQL database (either on-premises or in the cloud), that may already be used by other applications, to make existing data available to mobile clients.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>In this case it's a requirement that database model (or <bpt id="p1">*</bpt>schema<ept id="p1">*</ept>) remain unchanged, in order for existing solutions to continue working.</source>
          <target state="new">In this case it's a requirement that database model (or <bpt id="p1">*</bpt>schema<ept id="p1">*</ept>) remain unchanged, in order for existing solutions to continue working.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Exploring the existing database model</source>
          <target state="new">Exploring the existing database model</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>For this tutorial we will use the database that was created with your mobile service, but we will not use the default model that is created.</source>
          <target state="new">For this tutorial we will use the database that was created with your mobile service, but we will not use the default model that is created.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Instead, we will manually create an arbitrary model that will represent an existing application that you may have.</source>
          <target state="new">Instead, we will manually create an arbitrary model that will represent an existing application that you may have.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>For full details about how to connect to an on-premises database instead, check out <bpt id="p1">[</bpt>Connect to an on-premises SQL Server from an Azure mobile service using Hybrid Connections<ept id="p1">](mobile-services-dotnet-backend-hybrid-connections-get-started.md)</ept>.</source>
          <target state="new">For full details about how to connect to an on-premises database instead, check out <bpt id="p1">[</bpt>Connect to an on-premises SQL Server from an Azure mobile service using Hybrid Connections<ept id="p1">](mobile-services-dotnet-backend-hybrid-connections-get-started.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Start by creating a Mobile Services server project in <bpt id="p1">**</bpt>Visual Studio 2013 Update 2<ept id="p1">**</ept> or by using the quickstart project that you can download on the Mobile Services tab for your service in the <bpt id="p2">[</bpt>Azure Management Portal<ept id="p2">](http://manage.windowsazure.com)</ept>.</source>
          <target state="new">Start by creating a Mobile Services server project in <bpt id="p1">**</bpt>Visual Studio 2013 Update 2<ept id="p1">**</ept> or by using the quickstart project that you can download on the Mobile Services tab for your service in the <bpt id="p2">[</bpt>Azure Management Portal<ept id="p2">](http://manage.windowsazure.com)</ept>.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>For the purposes of this tutorial, we will assume your server project name is <bpt id="p1">**</bpt>ShoppingService<ept id="p1">**</ept>.</source>
          <target state="new">For the purposes of this tutorial, we will assume your server project name is <bpt id="p1">**</bpt>ShoppingService<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Create a <bpt id="p1">**</bpt>Customer.cs<ept id="p1">**</ept> file inside the <bpt id="p2">**</bpt>Models<ept id="p2">**</ept> folder and use the following implementation.</source>
          <target state="new">Create a <bpt id="p1">**</bpt>Customer.cs<ept id="p1">**</ept> file inside the <bpt id="p2">**</bpt>Models<ept id="p2">**</ept> folder and use the following implementation.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>You will need to add an assembly reference to <bpt id="p1">**</bpt>System.ComponentModel.DataAnnotations<ept id="p1">**</ept> to your project.</source>
          <target state="new">You will need to add an assembly reference to <bpt id="p1">**</bpt>System.ComponentModel.DataAnnotations<ept id="p1">**</ept> to your project.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Create an <bpt id="p1">**</bpt>Order.cs<ept id="p1">**</ept> file inside the <bpt id="p2">**</bpt>Models<ept id="p2">**</ept> folder and use the following implementation:</source>
          <target state="new">Create an <bpt id="p1">**</bpt>Order.cs<ept id="p1">**</ept> file inside the <bpt id="p2">**</bpt>Models<ept id="p2">**</ept> folder and use the following implementation:</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You will note that these two classes have a <bpt id="p1">*</bpt>relationship<ept id="p1">*</ept>: every <bpt id="p2">**</bpt>Order<ept id="p2">**</ept> is associated with a single <bpt id="p3">**</bpt>Customer<ept id="p3">**</ept> and a <bpt id="p4">**</bpt>Customer<ept id="p4">**</ept> can be associated with multiple <bpt id="p5">**</bpt>Orders<ept id="p5">**</ept>.</source>
          <target state="new">You will note that these two classes have a <bpt id="p1">*</bpt>relationship<ept id="p1">*</ept>: every <bpt id="p2">**</bpt>Order<ept id="p2">**</ept> is associated with a single <bpt id="p3">**</bpt>Customer<ept id="p3">**</ept> and a <bpt id="p4">**</bpt>Customer<ept id="p4">**</ept> can be associated with multiple <bpt id="p5">**</bpt>Orders<ept id="p5">**</ept>.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Having relationships is common in existing data models.</source>
          <target state="new">Having relationships is common in existing data models.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Create an <bpt id="p1">**</bpt>ExistingContext.cs<ept id="p1">**</ept> file inside the <bpt id="p2">**</bpt>Models<ept id="p2">**</ept> folder and implement it as so:</source>
          <target state="new">Create an <bpt id="p1">**</bpt>ExistingContext.cs<ept id="p1">**</ept> file inside the <bpt id="p2">**</bpt>Models<ept id="p2">**</ept> folder and implement it as so:</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The structure above approximates an existing Entity Framework model that you may already be using for an existing application.</source>
          <target state="new">The structure above approximates an existing Entity Framework model that you may already be using for an existing application.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Please note that the model is not aware of Mobile Services in any way at this stage.</source>
          <target state="new">Please note that the model is not aware of Mobile Services in any way at this stage.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Creating data transfer objects (DTOs) for your mobile service</source>
          <target state="new">Creating data transfer objects (DTOs) for your mobile service</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The data model you would like to use with your mobile service may be arbitrarily complex; it could contain hundreds of entities with a variety of relationships between them.</source>
          <target state="new">The data model you would like to use with your mobile service may be arbitrarily complex; it could contain hundreds of entities with a variety of relationships between them.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>When building a mobile app, it is usually desirable to simplify the data model and eliminate relationships (or handle them manually) in order to minimize the payload being sent back and forth between the app and the service.</source>
          <target state="new">When building a mobile app, it is usually desirable to simplify the data model and eliminate relationships (or handle them manually) in order to minimize the payload being sent back and forth between the app and the service.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>In this section, we will create a set of simplified objects (known as "data transfer objects" or "DTOs"), that are mapped to the data you have in your database, yet contain only the minimal set of properties needed by your mobile app.</source>
          <target state="new">In this section, we will create a set of simplified objects (known as "data transfer objects" or "DTOs"), that are mapped to the data you have in your database, yet contain only the minimal set of properties needed by your mobile app.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Create the <bpt id="p1">**</bpt>MobileCustomer.cs<ept id="p1">**</ept> file in the <bpt id="p2">**</bpt>DataObjects<ept id="p2">**</ept> folder of your service project and use the following implementation:</source>
          <target state="new">Create the <bpt id="p1">**</bpt>MobileCustomer.cs<ept id="p1">**</ept> file in the <bpt id="p2">**</bpt>DataObjects<ept id="p2">**</ept> folder of your service project and use the following implementation:</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Note that this class is similar to the <bpt id="p1">**</bpt>Customer<ept id="p1">**</ept> class in the model, except the relationship property to <bpt id="p2">**</bpt>Order<ept id="p2">**</ept> is removed.</source>
          <target state="new">Note that this class is similar to the <bpt id="p1">**</bpt>Customer<ept id="p1">**</ept> class in the model, except the relationship property to <bpt id="p2">**</bpt>Order<ept id="p2">**</ept> is removed.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For an object to work correctly with Mobile Services offline sync, it needs a set of <bpt id="p1">*</bpt>system properties<ept id="p1">*</ept> for optimistic concurrency, so you will notice that the DTO inherits from <bpt id="p2">[</bpt><bpt id="p3">**</bpt>EntityData<ept id="p3">**</ept><ept id="p2">](http://msdn.microsoft.com/library/microsoft.windowsazure.mobile.service.entitydata.aspx)</ept>, which contains those properties.</source>
          <target state="new">For an object to work correctly with Mobile Services offline sync, it needs a set of <bpt id="p1">*</bpt>system properties<ept id="p1">*</ept> for optimistic concurrency, so you will notice that the DTO inherits from <bpt id="p2">[</bpt><bpt id="p3">**</bpt>EntityData<ept id="p3">**</ept><ept id="p2">](http://msdn.microsoft.com/library/microsoft.windowsazure.mobile.service.entitydata.aspx)</ept>, which contains those properties.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The int-based <bpt id="p1">**</bpt>CustomerId<ept id="p1">**</ept> property from the original model is replaced by the string-based <bpt id="p2">**</bpt>Id<ept id="p2">**</ept> property from <bpt id="p3">**</bpt>EntityData<ept id="p3">**</ept>, which will be the <bpt id="p4">**</bpt>Id<ept id="p4">**</ept> that Mobile Services will use.</source>
          <target state="new">The int-based <bpt id="p1">**</bpt>CustomerId<ept id="p1">**</ept> property from the original model is replaced by the string-based <bpt id="p2">**</bpt>Id<ept id="p2">**</ept> property from <bpt id="p3">**</bpt>EntityData<ept id="p3">**</ept>, which will be the <bpt id="p4">**</bpt>Id<ept id="p4">**</ept> that Mobile Services will use.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Create the <bpt id="p1">**</bpt>MobileOrder.cs<ept id="p1">**</ept> file in the <bpt id="p2">**</bpt>DataObjects<ept id="p2">**</ept> folder of your service project.</source>
          <target state="new">Create the <bpt id="p1">**</bpt>MobileOrder.cs<ept id="p1">**</ept> file in the <bpt id="p2">**</bpt>DataObjects<ept id="p2">**</ept> folder of your service project.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Customer<ept id="p1">**</ept> relationship property has been replaced with the <bpt id="p2">**</bpt>Customer<ept id="p2">**</ept> name and a <bpt id="p3">**</bpt>MobileCustomerId<ept id="p3">**</ept> property that can be used to manually model the relationship on the client.</source>
          <target state="new">The <bpt id="p1">**</bpt>Customer<ept id="p1">**</ept> relationship property has been replaced with the <bpt id="p2">**</bpt>Customer<ept id="p2">**</ept> name and a <bpt id="p3">**</bpt>MobileCustomerId<ept id="p3">**</ept> property that can be used to manually model the relationship on the client.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For now you can ignore the <bpt id="p1">**</bpt>CustomerId<ept id="p1">**</ept> property, it is only used later on.</source>
          <target state="new">For now you can ignore the <bpt id="p1">**</bpt>CustomerId<ept id="p1">**</ept> property, it is only used later on.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>You might notice that with the addition of the system properties on the <bpt id="p1">**</bpt>EntityData<ept id="p1">**</ept> base class, our DTOs now have more properties than the model types.</source>
          <target state="new">You might notice that with the addition of the system properties on the <bpt id="p1">**</bpt>EntityData<ept id="p1">**</ept> base class, our DTOs now have more properties than the model types.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Clearly we need a place to store these properties, so we will add a few extra columns to the original database.</source>
          <target state="new">Clearly we need a place to store these properties, so we will add a few extra columns to the original database.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>While this does change the database, it will not break existing applications since the changes are purely additive (adding new columns to the schema).</source>
          <target state="new">While this does change the database, it will not break existing applications since the changes are purely additive (adding new columns to the schema).</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>To do that, add the following statements to the top of <bpt id="p1">**</bpt>Customer.cs<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Order.cs<ept id="p2">**</ept>:</source>
          <target state="new">To do that, add the following statements to the top of <bpt id="p1">**</bpt>Customer.cs<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Order.cs<ept id="p2">**</ept>:</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Next, add these extra properties to each of the classes:</source>
          <target state="new">Next, add these extra properties to each of the classes:</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The system properties just added have some built-in behaviors (for example automatic update of created/updated at) that happen transparently with database operations.</source>
          <target state="new">The system properties just added have some built-in behaviors (for example automatic update of created/updated at) that happen transparently with database operations.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>To enable these behaviors, we need to make a change to <bpt id="p1">**</bpt>ExistingContext.cs<ept id="p1">**</ept>.</source>
          <target state="new">To enable these behaviors, we need to make a change to <bpt id="p1">**</bpt>ExistingContext.cs<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>At the top of the file, add the following:</source>
          <target state="new">At the top of the file, add the following:</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In the body of <bpt id="p1">**</bpt>ExistingContext<ept id="p1">**</ept>, override <bpt id="p2">[</bpt><bpt id="p3">**</bpt>OnModelCreating<ept id="p3">**</ept><ept id="p2">](http://msdn.microsoft.com/library/system.data.entity.dbcontext.onmodelcreating.aspx)</ept>:</source>
          <target state="new">In the body of <bpt id="p1">**</bpt>ExistingContext<ept id="p1">**</ept>, override <bpt id="p2">[</bpt><bpt id="p3">**</bpt>OnModelCreating<ept id="p3">**</ept><ept id="p2">](http://msdn.microsoft.com/library/system.data.entity.dbcontext.onmodelcreating.aspx)</ept>:</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Let's populate the database with some example data.</source>
          <target state="new">Let's populate the database with some example data.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Open the file <bpt id="p1">**</bpt>WebApiConfig.cs<ept id="p1">**</ept>.</source>
          <target state="new">Open the file <bpt id="p1">**</bpt>WebApiConfig.cs<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Create a new <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IDatabaseInitializer<ept id="p2">**</ept><ept id="p1">](http://msdn.microsoft.com/library/gg696323.aspx)</ept> and configure it in the <bpt id="p3">**</bpt>Register<ept id="p3">**</ept> method as shown below.</source>
          <target state="new">Create a new <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IDatabaseInitializer<ept id="p2">**</ept><ept id="p1">](http://msdn.microsoft.com/library/gg696323.aspx)</ept> and configure it in the <bpt id="p3">**</bpt>Register<ept id="p3">**</ept> method as shown below.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Establishing a mapping between DTOs and model</source>
          <target state="new">Establishing a mapping between DTOs and model</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>We now have the model types <bpt id="p1">**</bpt>Customer<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Order<ept id="p2">**</ept> and the DTOs <bpt id="p3">**</bpt>MobileCustomer<ept id="p3">**</ept> and <bpt id="p4">**</bpt>MobileOrder<ept id="p4">**</ept>, but we  need to instruct the backend to automatically transform between the two.</source>
          <target state="new">We now have the model types <bpt id="p1">**</bpt>Customer<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Order<ept id="p2">**</ept> and the DTOs <bpt id="p3">**</bpt>MobileCustomer<ept id="p3">**</ept> and <bpt id="p4">**</bpt>MobileOrder<ept id="p4">**</ept>, but we  need to instruct the backend to automatically transform between the two.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Here Mobile Services relies on <bpt id="p1">[</bpt><bpt id="p2">**</bpt>AutoMapper<ept id="p2">**</ept><ept id="p1">](http://automapper.org/)</ept>, an object relational mapper, which is already referenced in the project.</source>
          <target state="new">Here Mobile Services relies on <bpt id="p1">[</bpt><bpt id="p2">**</bpt>AutoMapper<ept id="p2">**</ept><ept id="p1">](http://automapper.org/)</ept>, an object relational mapper, which is already referenced in the project.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Add the following to the top of <bpt id="p1">**</bpt>WebApiConfig.cs<ept id="p1">**</ept>:</source>
          <target state="new">Add the following to the top of <bpt id="p1">**</bpt>WebApiConfig.cs<ept id="p1">**</ept>:</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>To define the mapping, add the following to the <bpt id="p1">**</bpt>Register<ept id="p1">**</ept> method of the <bpt id="p2">**</bpt>WebApiConfig<ept id="p2">**</ept> class.</source>
          <target state="new">To define the mapping, add the following to the <bpt id="p1">**</bpt>Register<ept id="p1">**</ept> method of the <bpt id="p2">**</bpt>WebApiConfig<ept id="p2">**</ept> class.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>AutoMapper will now map the objects to one another.</source>
          <target state="new">AutoMapper will now map the objects to one another.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>All properties with corresponding names will be matched, for example <bpt id="p1">**</bpt>MobileOrder.CustomerId<ept id="p1">**</ept> will get automatically mapped to <bpt id="p2">**</bpt>Order.CustomerId<ept id="p2">**</ept>.</source>
          <target state="new">All properties with corresponding names will be matched, for example <bpt id="p1">**</bpt>MobileOrder.CustomerId<ept id="p1">**</ept> will get automatically mapped to <bpt id="p2">**</bpt>Order.CustomerId<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Custom mappings can be configured as shown above, where we map the <bpt id="p1">**</bpt>MobileCustomerName<ept id="p1">**</ept> property to the <bpt id="p2">**</bpt>Name<ept id="p2">**</ept> property of the <bpt id="p3">**</bpt>Customer<ept id="p3">**</ept> relationship property.</source>
          <target state="new">Custom mappings can be configured as shown above, where we map the <bpt id="p1">**</bpt>MobileCustomerName<ept id="p1">**</ept> property to the <bpt id="p2">**</bpt>Name<ept id="p2">**</ept> property of the <bpt id="p3">**</bpt>Customer<ept id="p3">**</ept> relationship property.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Implementing domain-specific logic</source>
          <target state="new">Implementing domain-specific logic</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The next step is to implement a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>MappedEntityDomainManager<ept id="p2">**</ept><ept id="p1">](http://msdn.microsoft.com/library/dn643300.aspx)</ept>, which serves as an abstraction layer between our mapped data store and the controller which will serve HTTP traffic from our clients.</source>
          <target state="new">The next step is to implement a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>MappedEntityDomainManager<ept id="p2">**</ept><ept id="p1">](http://msdn.microsoft.com/library/dn643300.aspx)</ept>, which serves as an abstraction layer between our mapped data store and the controller which will serve HTTP traffic from our clients.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>We will be able to write our controller in the next section purely in terms of the DTOs and the <bpt id="p1">**</bpt>MappedEntityDomainManager<ept id="p1">**</ept> we add here will handle the communication with the original data store, while also giving us a place to implement any logic specific to it.</source>
          <target state="new">We will be able to write our controller in the next section purely in terms of the DTOs and the <bpt id="p1">**</bpt>MappedEntityDomainManager<ept id="p1">**</ept> we add here will handle the communication with the original data store, while also giving us a place to implement any logic specific to it.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Add a <bpt id="p1">**</bpt>MobileCustomerDomainManager.cs<ept id="p1">**</ept> to the <bpt id="p2">**</bpt>Models<ept id="p2">**</ept> folder of your project.</source>
          <target state="new">Add a <bpt id="p1">**</bpt>MobileCustomerDomainManager.cs<ept id="p1">**</ept> to the <bpt id="p2">**</bpt>Models<ept id="p2">**</ept> folder of your project.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Paste in the following implementation:</source>
          <target state="new">Paste in the following implementation:</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>An important part of this class is the <bpt id="p1">**</bpt>GetKey<ept id="p1">**</ept> method where we indicate how to locate the ID property of the object in the original data model.</source>
          <target state="new">An important part of this class is the <bpt id="p1">**</bpt>GetKey<ept id="p1">**</ept> method where we indicate how to locate the ID property of the object in the original data model.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Add a <bpt id="p1">**</bpt>MobileOrderDomainManager.cs<ept id="p1">**</ept> to the <bpt id="p2">**</bpt>Models<ept id="p2">**</ept> folder of your project:</source>
          <target state="new">Add a <bpt id="p1">**</bpt>MobileOrderDomainManager.cs<ept id="p1">**</ept> to the <bpt id="p2">**</bpt>Models<ept id="p2">**</ept> folder of your project:</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>In this case the <bpt id="p1">**</bpt>InsertAsync<ept id="p1">**</ept> and <bpt id="p2">**</bpt>UpdateAsync<ept id="p2">**</ept> methods are interesting; that's where we enforce the relationship that each <bpt id="p3">**</bpt>Order<ept id="p3">**</ept> must have a valid associated <bpt id="p4">**</bpt>Customer<ept id="p4">**</ept>.</source>
          <target state="new">In this case the <bpt id="p1">**</bpt>InsertAsync<ept id="p1">**</ept> and <bpt id="p2">**</bpt>UpdateAsync<ept id="p2">**</ept> methods are interesting; that's where we enforce the relationship that each <bpt id="p3">**</bpt>Order<ept id="p3">**</ept> must have a valid associated <bpt id="p4">**</bpt>Customer<ept id="p4">**</ept>.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>In <bpt id="p1">**</bpt>InsertAsync<ept id="p1">**</ept> you'll notice that we populate the <bpt id="p2">**</bpt>MobileOrder.CustomerId<ept id="p2">**</ept> property, which maps to the <bpt id="p3">**</bpt>Order.CustomerId<ept id="p3">**</ept> property.</source>
          <target state="new">In <bpt id="p1">**</bpt>InsertAsync<ept id="p1">**</ept> you'll notice that we populate the <bpt id="p2">**</bpt>MobileOrder.CustomerId<ept id="p2">**</ept> property, which maps to the <bpt id="p3">**</bpt>Order.CustomerId<ept id="p3">**</ept> property.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>We get that value by based looking up the <bpt id="p1">**</bpt>Customer<ept id="p1">**</ept> with the matching <bpt id="p2">**</bpt>MobileOrder.MobileCustomerId<ept id="p2">**</ept>.</source>
          <target state="new">We get that value by based looking up the <bpt id="p1">**</bpt>Customer<ept id="p1">**</ept> with the matching <bpt id="p2">**</bpt>MobileOrder.MobileCustomerId<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>This is because by default the client is only aware of the Mobile Services ID (<bpt id="p1">**</bpt>MobileOrder.MobileCustomerId<ept id="p1">**</ept>) of the <bpt id="p2">**</bpt>Customer<ept id="p2">**</ept>, which is different than its actual primary key needed to set the foreign key (<bpt id="p3">**</bpt>MobileOrder.CustomerId<ept id="p3">**</ept>) from <bpt id="p4">**</bpt>Order<ept id="p4">**</ept> to <bpt id="p5">**</bpt>Customer<ept id="p5">**</ept>.</source>
          <target state="new">This is because by default the client is only aware of the Mobile Services ID (<bpt id="p1">**</bpt>MobileOrder.MobileCustomerId<ept id="p1">**</ept>) of the <bpt id="p2">**</bpt>Customer<ept id="p2">**</ept>, which is different than its actual primary key needed to set the foreign key (<bpt id="p3">**</bpt>MobileOrder.CustomerId<ept id="p3">**</ept>) from <bpt id="p4">**</bpt>Order<ept id="p4">**</ept> to <bpt id="p5">**</bpt>Customer<ept id="p5">**</ept>.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>This is only used internally within the service to facilitate the insert operation.</source>
          <target state="new">This is only used internally within the service to facilitate the insert operation.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>We are now ready to create controllers to expose our DTOs to our clients.</source>
          <target state="new">We are now ready to create controllers to expose our DTOs to our clients.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Implementing a TableController using DTOs</source>
          <target state="new">Implementing a TableController using DTOs</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">**</bpt>Controllers<ept id="p1">**</ept> folder, add the file <bpt id="p2">**</bpt>MobileCustomerController.cs<ept id="p2">**</ept>:</source>
          <target state="new">In the <bpt id="p1">**</bpt>Controllers<ept id="p1">**</ept> folder, add the file <bpt id="p2">**</bpt>MobileCustomerController.cs<ept id="p2">**</ept>:</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>You will note the use of the AuthorizeLevel attribute to restrict public access to the Insert/Update/Delete operations on the controller.</source>
          <target state="new">You will note the use of the AuthorizeLevel attribute to restrict public access to the Insert/Update/Delete operations on the controller.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>For the purposes of this scenario, the list of Customers will be read-only, but we will allow the creation of new Orders and associating them with existing customers.</source>
          <target state="new">For the purposes of this scenario, the list of Customers will be read-only, but we will allow the creation of new Orders and associating them with existing customers.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">**</bpt>Controllers<ept id="p1">**</ept> folder, add the file <bpt id="p2">**</bpt>MobileOrderController.cs<ept id="p2">**</ept>:</source>
          <target state="new">In the <bpt id="p1">**</bpt>Controllers<ept id="p1">**</ept> folder, add the file <bpt id="p2">**</bpt>MobileOrderController.cs<ept id="p2">**</ept>:</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>You are now ready to run your service.</source>
          <target state="new">You are now ready to run your service.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Press <bpt id="p1">**</bpt>F5<ept id="p1">**</ept> and use the test client built into the help page to modify the data.</source>
          <target state="new">Press <bpt id="p1">**</bpt>F5<ept id="p1">**</ept> and use the test client built into the help page to modify the data.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Please note that both controller implementations make exclusive use of the DTOs <bpt id="p1">**</bpt>MobileCustomer<ept id="p1">**</ept> and <bpt id="p2">**</bpt>MobileOrder<ept id="p2">**</ept> and are agnostic of the underlying model.</source>
          <target state="new">Please note that both controller implementations make exclusive use of the DTOs <bpt id="p1">**</bpt>MobileCustomer<ept id="p1">**</ept> and <bpt id="p2">**</bpt>MobileOrder<ept id="p2">**</ept> and are agnostic of the underlying model.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>These DTOs are readily serialized to JSON and can be used to exchange data with the  Mobile Services client SDK on all platforms.</source>
          <target state="new">These DTOs are readily serialized to JSON and can be used to exchange data with the  Mobile Services client SDK on all platforms.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>For example, if building a Windows Store app, the corresponding client-side type would look as shown below.</source>
          <target state="new">For example, if building a Windows Store app, the corresponding client-side type would look as shown below.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The type would be analogous on other client platforms.</source>
          <target state="new">The type would be analogous on other client platforms.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>As a next step, you can now build out the client app to access the service.</source>
          <target state="new">As a next step, you can now build out the client app to access the service.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Add Mobile Services to an existing app<ept id="p1">](mobile-services-dotnet-backend-windows-universal-dotnet-get-started-data.md#update-the-app-to-use-the-mobile-service)</ept>.</source>
          <target state="new">For more information, see <bpt id="p1">[</bpt>Add Mobile Services to an existing app<ept id="p1">](mobile-services-dotnet-backend-windows-universal-dotnet-get-started-data.md#update-the-app-to-use-the-mobile-service)</ept>.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>test</source>
          <target state="new">test</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2dc0ba048c32013166a7b5ff9a0a0df019293d5b</xliffext:olfilehash>
  </header>
</xliff>