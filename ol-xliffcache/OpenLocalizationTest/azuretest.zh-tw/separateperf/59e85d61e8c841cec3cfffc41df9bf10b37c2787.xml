{
  "nodes": [
    {
      "content": "DocumentDB Indexing Policies | Microsoft Azure",
      "pos": [
        28,
        74
      ]
    },
    {
      "content": "Understand how indexing works in DocumentDB and learn how to configure and change the indexing policy.",
      "pos": [
        94,
        196
      ]
    },
    {
      "content": "DocumentDB indexing policies",
      "pos": [
        517,
        545
      ]
    },
    {
      "content": "While many customers are happy to let DocumentDB automatically handle <bpt id=\"p1\">[</bpt>all aspects of indexing<ept id=\"p1\">](documentdb-indexing.md)</ept>, DocumentDB also supports specifying a custom <bpt id=\"p2\">**</bpt>indexing policy<ept id=\"p2\">**</ept> for collections during creation.",
      "pos": [
        547,
        765
      ]
    },
    {
      "content": "Indexing policies in DocumentDB are more flexible and powerful than secondary indexes offered in other database platforms, in that they let you design and customize the shape of the index without sacrificing schema flexibility.",
      "pos": [
        766,
        993
      ]
    },
    {
      "content": "By managing indexing policy, you can make fine-grained tradeoffs between index storage overhead, write and query throughput, and query consistency.",
      "pos": [
        994,
        1141
      ]
    },
    {
      "content": "In this article, we take a close look at DocumentDB indexing policies, how you can customize indexing policy, and the associated trade-offs.",
      "pos": [
        1145,
        1285
      ]
    },
    {
      "content": "After reading this article, you'll be able to answer the following questions:",
      "pos": [
        1288,
        1365
      ]
    },
    {
      "content": "How does DocumentDB support automatic indexing by default?",
      "pos": [
        1369,
        1427
      ]
    },
    {
      "content": "How can I override the properties to include or exclude from indexing?",
      "pos": [
        1430,
        1500
      ]
    },
    {
      "content": "How can I configure the index for eventual updates?",
      "pos": [
        1503,
        1554
      ]
    },
    {
      "content": "How can I configure indexing to perform Order By or range queries?",
      "pos": [
        1557,
        1623
      ]
    },
    {
      "content": "How do I make changes to a collection’s indexing policy?",
      "pos": [
        1626,
        1682
      ]
    },
    {
      "content": "How do I compare storage and performance of different indexing policies?",
      "pos": [
        1685,
        1757
      ]
    },
    {
      "pos": [
        1761,
        1847
      ],
      "content": "<ph id=\"ph1\">&lt;a id=\"CustomizingIndexingPolicy\"&gt;</ph><ph id=\"ph2\">&lt;/a&gt;</ph> Customizing the indexing policy of a collection"
    },
    {
      "content": "Developers can customize the trade-offs between storage, write/query performance, and query consistency, by overriding the default indexing policy on a DocumentDB collection and configuring the following aspects.",
      "pos": [
        1849,
        2061
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Including/Excluding documents and paths to/from index<ept id=\"p1\">**</ept>.",
      "pos": [
        2065,
        2123
      ]
    },
    {
      "content": "Developers can choose certain documents to be excluded or included in the index at the time of inserting or replacing them to the collection.",
      "pos": [
        2124,
        2265
      ]
    },
    {
      "content": "Developers can also choose to include or exclude certain JSON properties a.k.a.",
      "pos": [
        2266,
        2345
      ]
    },
    {
      "content": "paths (including wildcard patterns) to be indexed across documents which are included in an index.",
      "pos": [
        2346,
        2444
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Configuring Various Index Types<ept id=\"p1\">**</ept>.",
      "pos": [
        2447,
        2483
      ]
    },
    {
      "content": "For each of the included paths, developers can also specify the type of index they require over a collection based on their data and expected query workload and the numeric/string “precision” for each path.",
      "pos": [
        2484,
        2690
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Configuring Index Update Modes<ept id=\"p1\">**</ept>.",
      "pos": [
        2693,
        2728
      ]
    },
    {
      "content": "DocumentDB supports three indexing modes which can be configured via the indexing policy on a DocumentDB collection: Consistent, Lazy and None.",
      "pos": [
        2729,
        2872
      ]
    },
    {
      "content": "The following .NET code snippet shows how to set a custom indexing policy during the creation of a collection.",
      "pos": [
        2875,
        2985
      ]
    },
    {
      "content": "Here we set the policy with Range index for strings and numbers at the maximum precision.",
      "pos": [
        2986,
        3075
      ]
    },
    {
      "content": "This policy lets us execute Order By queries against strings.",
      "pos": [
        3076,
        3137
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> The JSON schema for indexing policy was changed with the release of REST API version 2015-06-03 to support Range indexes against strings.",
      "pos": [
        3686,
        3836
      ]
    },
    {
      "content": ".NET SDK 1.2.0 and Java, Python, and Node.js SDKs 1.1.0 support the new policy schema.",
      "pos": [
        3837,
        3923
      ]
    },
    {
      "content": "Older SDKs use the REST API version 2015-04-08 and support the older schema of Indexing Policy.",
      "pos": [
        3924,
        4019
      ]
    },
    {
      "content": "By default, DocumentDB indexes all string properties within documents consistently with a Hash index, and numeric properties with a Range index.",
      "pos": [
        4023,
        4167
      ]
    },
    {
      "content": "Indexing modes",
      "pos": [
        4175,
        4189
      ]
    },
    {
      "content": "DocumentDB supports three indexing modes which can be configured via the indexing policy on a DocumentDB collection – Consistent, Lazy and None.",
      "pos": [
        4191,
        4335
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Consistent<ept id=\"p1\">**</ept>: If a DocumentDB collection’s policy is designated as \"consistent\", the queries on a given DocumentDB collection follow the same consistency level as specified for the point-reads (i.e. strong, bounded-staleness, session or eventual).",
      "pos": [
        4337,
        4586
      ]
    },
    {
      "content": "The index is updated synchronously as part of the document update (i.e. insert, replace, update, and delete of a document in a DocumentDB collection).",
      "pos": [
        4587,
        4737
      ]
    },
    {
      "content": "Consistent indexing supports consistent queries at the cost of possible reduction in write throughput.",
      "pos": [
        4739,
        4841
      ]
    },
    {
      "content": "This reduction is a function of the unique paths that need to be indexed and the “consistency level”.",
      "pos": [
        4842,
        4943
      ]
    },
    {
      "content": "Consistent indexing mode is designed for “write quickly, query immediately” workloads.",
      "pos": [
        4944,
        5030
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Lazy<ept id=\"p1\">**</ept>: To allow maximum document ingestion throughput, a DocumentDB collection can be configured with lazy consistency; meaning queries are eventually consistent.",
      "pos": [
        5032,
        5197
      ]
    },
    {
      "content": "The index is updated asynchronously when a DocumentDB collection is quiescent i.e. when the collection’s throughput capacity is not fully utilized to serve user requests.",
      "pos": [
        5198,
        5368
      ]
    },
    {
      "content": "For \"ingest now, query later\" workloads requiring unhindered document ingestion, \"lazy\" indexing mode may be suitable.",
      "pos": [
        5369,
        5487
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>None<ept id=\"p1\">**</ept>: A collection marked with index mode of “None” has no index associated with it.",
      "pos": [
        5489,
        5577
      ]
    },
    {
      "content": "Configuring the indexing policy with \"None\" has the side effect of dropping any existing index.",
      "pos": [
        5578,
        5673
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> Configuring the indexing policy with “None” has the side effect of dropping any existing index.",
      "pos": [
        5676,
        5784
      ]
    },
    {
      "content": "Use this if your access patterns are only require “id” and/or “self-link”.",
      "pos": [
        5785,
        5859
      ]
    },
    {
      "content": "The following sample show how create a DocumentDB collection using the .NET SDK with consistent automatic indexing on all document insertions.",
      "pos": [
        5861,
        6003
      ]
    },
    {
      "content": "The following table shows the consistency for queries based on the indexing mode (Consistent and Lazy) configured for the collection and the consistency level specified for the query request.",
      "pos": [
        6005,
        6196
      ]
    },
    {
      "content": "This applies to queries made using any interface - REST API, SDKs or from within stored procedures and triggers.",
      "pos": [
        6197,
        6309
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n                    &lt;strong&gt;</ph>Consistent<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n                </ph>",
      "pos": [
        6526,
        6591
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n                    &lt;strong&gt;</ph>Lazy<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n                </ph>",
      "pos": [
        6663,
        6722
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n                    &lt;strong&gt;</ph>Strong<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n                </ph>",
      "pos": [
        6833,
        6894
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n                    &lt;strong&gt;</ph>Bounded Staleness<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n                </ph>",
      "pos": [
        7246,
        7318
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n                    &lt;strong&gt;</ph>Session<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n                </ph>",
      "pos": [
        7684,
        7746
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n                    &lt;strong&gt;</ph>Eventual<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n                </ph>",
      "pos": [
        8098,
        8161
      ]
    },
    {
      "content": "By default, an error is returned for all queries if the collection is setup with None indexing mode in order to signal that a scan might be necessary to serve the query.",
      "pos": [
        8478,
        8647
      ]
    },
    {
      "content": "These queries can be performed without a range index using the <ph id=\"ph1\">`x-ms-documentdb-enable-scans`</ph> header in the REST API or the <ph id=\"ph2\">`EnableScanInQuery`</ph> request option using the .NET SDK.",
      "pos": [
        8648,
        8826
      ]
    },
    {
      "content": "Some queries for example, that use ORDER BY will not be allowed with None even with <ph id=\"ph1\">`EnableScanInQuery`</ph>.",
      "pos": [
        8827,
        8931
      ]
    },
    {
      "content": "The following table shows the consistency for queries based on the indexing mode (Consistent, Lazy, and None) when EnableScanInQuery is specified.",
      "pos": [
        8933,
        9079
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n                    &lt;strong&gt;</ph>Consistent<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n                </ph>",
      "pos": [
        9295,
        9360
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n                    &lt;strong&gt;</ph>Lazy<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n                </ph>",
      "pos": [
        9432,
        9491
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n                    &lt;strong&gt;</ph>None<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n                </ph>",
      "pos": [
        9570,
        9629
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n                    &lt;strong&gt;</ph>Strong<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n                </ph>",
      "pos": [
        9741,
        9802
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n                    &lt;strong&gt;</ph>Bounded Staleness<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n                </ph>",
      "pos": [
        10278,
        10350
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n                    &lt;strong&gt;</ph>Session<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n                </ph>",
      "pos": [
        10838,
        10900
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n                    &lt;strong&gt;</ph>Eventual<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n                </ph>",
      "pos": [
        11373,
        11436
      ]
    },
    {
      "content": "The following code sample show how create a DocumentDB collection using the .NET SDK with consistent indexing on all document insertions.",
      "pos": [
        11879,
        12016
      ]
    },
    {
      "content": "Index paths",
      "pos": [
        12462,
        12473
      ]
    },
    {
      "content": "DocumentDB models JSON documents and the index as trees, and allows you to tune to policies for paths within the tree.",
      "pos": [
        12475,
        12593
      ]
    },
    {
      "content": "You can find more details in this <bpt id=\"p1\">[</bpt>introduction to DocumentDB indexing<ept id=\"p1\">](documentdb-indexing.md)</ept>.",
      "pos": [
        12594,
        12690
      ]
    },
    {
      "content": "Within documents, you can choose which paths must be included or excluded from indexing.",
      "pos": [
        12691,
        12779
      ]
    },
    {
      "content": "This can offer improved write performance and lower index storage for scenarios when the query patterns are known beforehand.",
      "pos": [
        12780,
        12905
      ]
    },
    {
      "content": "Index paths start with the root (/) and typically end with the ?",
      "pos": [
        12907,
        12971
      ]
    },
    {
      "content": "wildcard operator, denoting that there are multiple possible values for the prefix.",
      "pos": [
        12972,
        13055
      ]
    },
    {
      "content": "For example, to serve SELECT * FROM Families F WHERE F.familyName = \"Andersen\", you must include an index path for /familyName/?",
      "pos": [
        13056,
        13184
      ]
    },
    {
      "content": "in the collection’s index policy.",
      "pos": [
        13185,
        13218
      ]
    },
    {
      "content": "Index paths can also use the * wildcard operator to specify the behavior for paths recursively under the prefix.",
      "pos": [
        13220,
        13332
      ]
    },
    {
      "content": "For example, /payload/* can be used to exclude everything under the payload property from indexing.",
      "pos": [
        13333,
        13432
      ]
    },
    {
      "content": "Here are the common patterns for specifying index paths:",
      "pos": [
        13434,
        13490
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n                    &lt;strong&gt;</ph>Path<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n                </ph>",
      "pos": [
        13617,
        13676
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n                    &lt;strong&gt;</ph>Description/use case<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n                </ph>",
      "pos": [
        13748,
        13823
      ]
    },
    {
      "pos": [
        17662,
        17825
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> While setting custom index paths, you are required to specify the default indexing rule for the entire document tree denoted by the special path \"/*\"."
    },
    {
      "content": "The following example configures a specific path with range indexing and a custom precision value of 20 bytes:",
      "pos": [
        17828,
        17938
      ]
    },
    {
      "content": "Index data types, kinds and precisions",
      "pos": [
        18724,
        18762
      ]
    },
    {
      "content": "Now that we've taken a look at how to specify paths, let's look at the options we can use to configure the indexing policy for a path.",
      "pos": [
        18764,
        18898
      ]
    },
    {
      "content": "You can specify one or more indexing definitions for every path:",
      "pos": [
        18899,
        18963
      ]
    },
    {
      "pos": [
        18967,
        19065
      ],
      "content": "Data type: <bpt id=\"p1\">**</bpt>String<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>Number<ept id=\"p2\">**</ept> or <bpt id=\"p3\">**</bpt>Point<ept id=\"p3\">**</ept> (can contain only one entry per data type per path)"
    },
    {
      "pos": [
        19068,
        19190
      ],
      "content": "Index kind: <bpt id=\"p1\">**</bpt>Hash<ept id=\"p1\">**</ept> (equality queries), <bpt id=\"p2\">**</bpt>Range<ept id=\"p2\">**</ept> (equality, range or Order By queries), or <bpt id=\"p3\">**</bpt>Spatial<ept id=\"p3\">**</ept> (spatial queries)"
    },
    {
      "content": "Precision: 1-8 or -1 (Maximum precision) for numbers, 1-100 (Maximum precision) for string",
      "pos": [
        19194,
        19284
      ]
    },
    {
      "content": "Index kind",
      "pos": [
        19291,
        19301
      ]
    },
    {
      "content": "DocumentDB supports Hash and Range index kinds for every path (that can configured for strings, numbers or both).",
      "pos": [
        19303,
        19416
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Hash<ept id=\"p1\">**</ept> supports efficient equality and JOIN queries.",
      "pos": [
        19420,
        19474
      ]
    },
    {
      "content": "For most use cases, hash indexes do not need a higher precision than the default value of 3 bytes.",
      "pos": [
        19475,
        19573
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Range<ept id=\"p1\">**</ept> supports efficient equality queries, range queries (using &gt;, &lt;, &gt;=, &lt;=, !=), and Order By queries.",
      "pos": [
        19576,
        19684
      ]
    },
    {
      "content": "Order By queries by default also require maximum index precision (-1).",
      "pos": [
        19685,
        19755
      ]
    },
    {
      "content": "DocumentDB also supporst the Spatial index kind for every path, that can be specified for the Point data type.",
      "pos": [
        19757,
        19867
      ]
    },
    {
      "content": "The value at the specified path must be a valid GeoJSON point like <ph id=\"ph1\">`{\"type\": \"Point\", \"coordinates\": [0.0, 10.0]}`</ph>.",
      "pos": [
        19868,
        19983
      ]
    },
    {
      "pos": [
        19987,
        20056
      ],
      "content": "<bpt id=\"p1\">**</bpt>Spatial<ept id=\"p1\">**</ept> supports efficient spatial (within and distance) queries."
    },
    {
      "content": "Here are the supported index kinds and examples of queries that they can be used to serve:",
      "pos": [
        20058,
        20148
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n                    &lt;strong&gt;</ph>Index kind<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n                </ph>",
      "pos": [
        20275,
        20340
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n                    &lt;strong&gt;</ph>Description/use case<ph id=\"ph2\">&lt;/strong&gt;</ph><ph id=\"ph3\">\n                </ph>",
      "pos": [
        20412,
        20487
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n                    Range over /prop/? (or /*) can be used to serve the following queries efficiently:\n                        SELECT * FROM collection c \n                        WHERE ST_DISTANCE(c.prop, {\"type\": \"Point\", \"coordinates\": [0.0, 10.0]})</ph> &lt; 40",
      "pos": [
        21853,
        22110
      ]
    },
    {
      "content": "SELECT * FROM collection c WHERE ST_WITHIN(c.prop, {\"type\": \"Polygon\", ... })",
      "pos": [
        22135,
        22212
      ]
    },
    {
      "content": "By default, an error is returned for queries with range operators such as &gt;= if there is no range index (of any precision) in order to signal that a scan might be necessary to serve the query.",
      "pos": [
        22297,
        22489
      ]
    },
    {
      "content": "Range queries can be performed without a range index using the x-ms-documentdb-enable-scans header in the REST API or the EnableScanInQuery request option using the .NET SDK.",
      "pos": [
        22490,
        22664
      ]
    },
    {
      "content": "If there are any other filters in the query that DocumentDB can use the index to filter against, then no error will be returned.",
      "pos": [
        22665,
        22793
      ]
    },
    {
      "content": "The same rules apply for spatial queries.",
      "pos": [
        22795,
        22836
      ]
    },
    {
      "content": "By default, an error is returned for spatial queries if there is no spatial index.",
      "pos": [
        22837,
        22919
      ]
    },
    {
      "content": "They can be performed as a scan using x-ms-documentdb-enable-scan/EnableScanInQuery.",
      "pos": [
        22920,
        23004
      ]
    },
    {
      "content": "Index precision",
      "pos": [
        23011,
        23026
      ]
    },
    {
      "content": "Index precision lets you tradeoff between index storage overhead and query performance.",
      "pos": [
        23028,
        23115
      ]
    },
    {
      "content": "For numbers, we recommend using the default precision configuration of -1 (\"maximum\").",
      "pos": [
        23117,
        23203
      ]
    },
    {
      "content": "Since numbers are 8 bytes in JSON, this is equivalent to a configuration of 8 bytes.",
      "pos": [
        23204,
        23288
      ]
    },
    {
      "content": "Picking a lower value for precision, such as 1-7, means that values within some ranges map to the same index entry.",
      "pos": [
        23289,
        23404
      ]
    },
    {
      "content": "Therefore you will reduce index storage space, but query execution might have to process more documents and consequently consume more throughput i.e., request units.",
      "pos": [
        23405,
        23570
      ]
    },
    {
      "content": "Index precision configuration is more useful with string ranges.",
      "pos": [
        23572,
        23636
      ]
    },
    {
      "content": "Since strings can be any arbitrary length, the choice of the index precision can impact the performance of string range queries, and impact the amount of index storage space required.",
      "pos": [
        23637,
        23820
      ]
    },
    {
      "content": "String range indexes can be configured with 1-100 or -1 (\"maximum\").",
      "pos": [
        23821,
        23889
      ]
    },
    {
      "content": "If you would like to perform Order By queries against string properties, then you must specify a precision of -1 for the corresponding paths.",
      "pos": [
        23890,
        24031
      ]
    },
    {
      "content": "Spatial indexes always use the default index precision for points and cannot be overriden.",
      "pos": [
        24033,
        24123
      ]
    },
    {
      "content": "The following example shows how to increase the precision for range indexes in a collection using the .NET SDK.",
      "pos": [
        24126,
        24237
      ]
    },
    {
      "content": "Note that this uses the default path \"/*\".",
      "pos": [
        24238,
        24280
      ]
    },
    {
      "content": "Create a collection with a custom index precision",
      "pos": [
        24284,
        24333
      ]
    },
    {
      "pos": [
        24819,
        24971
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> DocumentDB returns an error when a query uses Order By but does not have a range index against the queried path with the maximum precision."
    },
    {
      "content": "Similarly, paths can be completely excluded from indexing.",
      "pos": [
        24974,
        25032
      ]
    },
    {
      "content": "The next example shows how to exclude an entire section of the documents (a.k.a.",
      "pos": [
        25033,
        25113
      ]
    },
    {
      "content": "a sub-tree) from indexing using the \"*\" wildcard.",
      "pos": [
        25114,
        25163
      ]
    },
    {
      "content": "Opting in and opting out of indexing",
      "pos": [
        25525,
        25561
      ]
    },
    {
      "content": "You can choose whether you want the collection to automatically index all documents.",
      "pos": [
        25563,
        25647
      ]
    },
    {
      "content": "By default, all documents are automatically indexed, but you can choose to turn it off.",
      "pos": [
        25648,
        25735
      ]
    },
    {
      "content": "When indexing is turned off, documents can be accessed only through their self-links or by queries using ID.",
      "pos": [
        25736,
        25844
      ]
    },
    {
      "content": "With automatic indexing turned off, you can still selectively add only specific documents to the index.",
      "pos": [
        25846,
        25949
      ]
    },
    {
      "content": "Conversely, you can leave automatic indexing on and selectively choose to exclude only specific documents.",
      "pos": [
        25950,
        26056
      ]
    },
    {
      "content": "Indexing on/off configurations are useful when you have only a subset of documents that need to be queried.",
      "pos": [
        26057,
        26164
      ]
    },
    {
      "pos": [
        26166,
        26481
      ],
      "content": "For example, the following sample shows how to include a document explicitly using the <bpt id=\"p1\">[</bpt>DocumentDB .NET SDK<ept id=\"p1\">](https://github.com/Azure/azure-documentdb-java)</ept> and the <bpt id=\"p2\">[</bpt>RequestOptions.IndexingDirective<ept id=\"p2\">](http://msdn.microsoft.com/library/microsoft.azure.documents.client.requestoptions.indexingdirective.aspx)</ept> property."
    },
    {
      "content": "Modifying the indexing policy of a collection",
      "pos": [
        26870,
        26915
      ]
    },
    {
      "content": "DocumentDB allows you to make changes to the indexing policy of a collection on the fly.",
      "pos": [
        26917,
        27005
      ]
    },
    {
      "content": "A change in indexing policy on a DocumentDB collection can lead to a change in the shape of the index including the paths can be indexed, their precision, as well as the consistency model of the index itself.",
      "pos": [
        27006,
        27214
      ]
    },
    {
      "content": "Thus a change in indexing policy, effectively requires a transformation of the old index into a new one.",
      "pos": [
        27215,
        27319
      ]
    },
    {
      "content": "Online Index Transformations",
      "pos": [
        27324,
        27352
      ]
    },
    {
      "content": "Online Index Transformations",
      "pos": [
        27358,
        27386
      ]
    },
    {
      "content": "Index transformations are made online, meaning that the documents indexed per the old policy are efficiently transformed per the new policy <bpt id=\"p1\">**</bpt>without affecting the write availability or the provisioned throughput<ept id=\"p1\">**</ept> of the collection.",
      "pos": [
        27451,
        27684
      ]
    },
    {
      "content": "The consistency of read and write operations made using the REST API, SDKs or from within stored procedures and triggers is not impacted during index transformation.",
      "pos": [
        27685,
        27850
      ]
    },
    {
      "content": "This means that there is no performance degradation or downtime to your apps when you make an indexing policy change.",
      "pos": [
        27851,
        27968
      ]
    },
    {
      "content": "However, during the time that index transformation is progress, queries are eventually consistent regardless of the indexing mode configuration (Consistent or Lazy).",
      "pos": [
        27970,
        28135
      ]
    },
    {
      "content": "This also applies to queries from all interfaces – REST API, SDKs, and from within stored procedures and triggers.",
      "pos": [
        28136,
        28250
      ]
    },
    {
      "content": "Just like with Lazy indexing, index transformation is performed asynchronously in the background on the replicas using the spare resources available for a given replica.",
      "pos": [
        28251,
        28420
      ]
    },
    {
      "content": "Index transformations are also made <bpt id=\"p1\">**</bpt>in-situ<ept id=\"p1\">**</ept> (in place), i.e. DocumentDB does not maintain two copies of the index and swap the old index out with the new one.",
      "pos": [
        28423,
        28585
      ]
    },
    {
      "content": "This means that no additional disk space is required or consumed in your collections while performing index transformations.",
      "pos": [
        28586,
        28710
      ]
    },
    {
      "content": "When you change indexing policy, how the changes are applied to move from the old index to the new one depend primarily on the indexing mode configurations more so than the other values like included/excluded paths, index kinds and precisions.",
      "pos": [
        28712,
        28955
      ]
    },
    {
      "content": "If both your old and new policies use consistent indexing, then DocumentDB performs an online index transformation.",
      "pos": [
        28956,
        29071
      ]
    },
    {
      "content": "You cannot apply another indexing policy change with consistent indexing mode while the transformation is in progress.",
      "pos": [
        29072,
        29190
      ]
    },
    {
      "content": "You can however move to Lazy or None indexing mode while a transformation is in progress.",
      "pos": [
        29192,
        29281
      ]
    },
    {
      "content": "When you move to Lazy, the index policy change is made effective immediately and DocumentDB starts recreating the index asynchronously.",
      "pos": [
        29286,
        29421
      ]
    },
    {
      "content": "When you move to None, then the index is dropped effective immediately.",
      "pos": [
        29425,
        29496
      ]
    },
    {
      "content": "Moving to None is useful when you want to cancel an in progress transformation and start fresh with a different indexing policy.",
      "pos": [
        29497,
        29625
      ]
    },
    {
      "content": "If you’re using the .NET SDK, you can kick of an indexing policy change using the new <bpt id=\"p1\">**</bpt>ReplaceDocumentCollectionAsync<ept id=\"p1\">**</ept> method and track the percentage progress of the index transformation using the <bpt id=\"p2\">**</bpt>IndexTransformationProgress<ept id=\"p2\">**</ept> response property from a <bpt id=\"p3\">**</bpt>ReadDocumentCollectionAsync<ept id=\"p3\">**</ept> call.",
      "pos": [
        29628,
        29922
      ]
    },
    {
      "content": "Other SDKs and the REST API support equivalent properties and methods for making indexing policy changes.",
      "pos": [
        29923,
        30028
      ]
    },
    {
      "content": "Here's a code snippet that shows how to modify a collection's indexing policy from Consistent indexing mode to Lazy.",
      "pos": [
        30030,
        30146
      ]
    },
    {
      "content": "Modify Indexing Policy from Consistent to Lazy",
      "pos": [
        30150,
        30196
      ]
    },
    {
      "content": "You can check the progress of an index transformation by calling ReadDocumentCollectionAsync, for example, as shown below.",
      "pos": [
        30431,
        30553
      ]
    },
    {
      "content": "Track Progress of Index Transformation",
      "pos": [
        30557,
        30595
      ]
    },
    {
      "content": "You can drop the index for a collection by moving to the None indexing mode.",
      "pos": [
        30995,
        31071
      ]
    },
    {
      "content": "This might be a useful operational tool if you want to cancel an in-progress transformation and start a new one immediately.",
      "pos": [
        31072,
        31196
      ]
    },
    {
      "content": "Dropping the index for a collection",
      "pos": [
        31200,
        31235
      ]
    },
    {
      "content": "When would you make indexing policy changes to your DocumentDB collections?",
      "pos": [
        31481,
        31556
      ]
    },
    {
      "content": "The following are the most common use cases:",
      "pos": [
        31557,
        31601
      ]
    },
    {
      "content": "Serve consistent results during normal operation, but fall back to lazy indexing during bulk data imports",
      "pos": [
        31605,
        31710
      ]
    },
    {
      "content": "Start using new indexing features on your current DocumentDB collections, e.g., like geospatial querying which require the Spatial index kind, or Order By/string range queries which require the string Range index kind",
      "pos": [
        31713,
        31930
      ]
    },
    {
      "content": "Hand select the properties to be indexed and change them over time",
      "pos": [
        31933,
        31999
      ]
    },
    {
      "content": "Tune indexing precision to improve query performance or reduce storage consumed",
      "pos": [
        32002,
        32081
      ]
    },
    {
      "pos": [
        32084,
        32202
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> To modify indexing policy using ReplaceDocumentCollectionAsync, you need version &gt;= 1.3.0 of the .NET SDK"
    },
    {
      "content": "Performance tuning",
      "pos": [
        32207,
        32225
      ]
    },
    {
      "content": "The DocumentDB APIs provide information about performance metrics such as the index storage used, and the throughput cost (request units) for every operation.",
      "pos": [
        32227,
        32385
      ]
    },
    {
      "content": "This information can be used to compare various indexing policies and for performance tuning.",
      "pos": [
        32386,
        32479
      ]
    },
    {
      "content": "To check the storage quota and usage of a collection, run a HEAD or GET request against the collection resource, and inspect the x-ms-request-quota and the x-ms-request-usage headers.",
      "pos": [
        32481,
        32664
      ]
    },
    {
      "content": "In the .NET SDK, the <bpt id=\"p1\">[</bpt>DocumentSizeQuota<ept id=\"p1\">](http://msdn.microsoft.com/library/dn850325.aspx)</ept> and <bpt id=\"p2\">[</bpt>DocumentSizeUsage<ept id=\"p2\">](http://msdn.microsoft.com/library/azure/dn850324.aspx)</ept> properties in <bpt id=\"p3\">[</bpt>ResourceResponse&lt;T\\&gt;<ept id=\"p3\">](http://msdn.microsoft.com/library/dn799209.aspx)</ept> contain these corresponding values.",
      "pos": [
        32665,
        32955
      ]
    },
    {
      "pos": [
        33325,
        33706
      ],
      "content": "To measure the overhead of indexing on each write operation (create, update, or delete), inspect the x-ms-request-charge header (or the equivalent <bpt id=\"p1\">[</bpt>RequestCharge<ept id=\"p1\">](http://msdn.microsoft.com/library/dn799099.aspx)</ept> property in <bpt id=\"p2\">[</bpt>ResourceResponse&lt;T\\&gt;<ept id=\"p2\">](http://msdn.microsoft.com/library/dn799209.aspx)</ept> in the .NET SDK) to measure the number of request units consumed by these operations."
    },
    {
      "content": "Changes to the indexing policy specification",
      "pos": [
        34652,
        34696
      ]
    },
    {
      "content": "A change in the schema for indexing policy was introduced on July 7, 2015 with REST API version 2015-06-03.",
      "pos": [
        34697,
        34804
      ]
    },
    {
      "content": "The corresponding classes in the SDK versions have new implementations to match the schema.",
      "pos": [
        34805,
        34896
      ]
    },
    {
      "content": "The following changes were implemented in the JSON specification:",
      "pos": [
        34899,
        34964
      ]
    },
    {
      "content": "Indexing Policy supports Range indexes for strings",
      "pos": [
        34968,
        35018
      ]
    },
    {
      "content": "Each path can have multiple index definitions, one for each data type",
      "pos": [
        35021,
        35090
      ]
    },
    {
      "content": "Indexing precision supports 1-8 for numbers, 1-100 for strings, and -1 (maximum precision)",
      "pos": [
        35093,
        35183
      ]
    },
    {
      "content": "Paths segments do not require a double quotation to escape each path.",
      "pos": [
        35186,
        35255
      ]
    },
    {
      "content": "For example, you can add a path for /title/?",
      "pos": [
        35256,
        35300
      ]
    },
    {
      "content": "instead of /\"title\"/?",
      "pos": [
        35301,
        35322
      ]
    },
    {
      "content": "The root path representing \"all paths\" can be represented as /* (in addition to /)",
      "pos": [
        35325,
        35407
      ]
    },
    {
      "content": "If you have code that provisions collections with a custom indexing policy written with version 1.1.0 of the .NET SDK or older, you will need to change your application code to handle these changes in order to move to SDK version 1.2.0.",
      "pos": [
        35409,
        35645
      ]
    },
    {
      "content": "If you do not have code that configures indexing policy, or plan to continue using an older SDK version, no changes are required.",
      "pos": [
        35646,
        35775
      ]
    },
    {
      "content": "For a practical comparison, here is one example custom indexing policy written using the REST API version 2015-06-03 as well as the previous version 2015-04-08.",
      "pos": [
        35777,
        35937
      ]
    },
    {
      "content": "Previous Indexing Policy JSON",
      "pos": [
        35941,
        35970
      ]
    },
    {
      "content": "Current Indexing Policy JSON",
      "pos": [
        36306,
        36334
      ]
    },
    {
      "content": "Next Steps",
      "pos": [
        36928,
        36938
      ]
    },
    {
      "content": "Follow the links below for index policy management samples and to learn more about DocumentDB's query language.",
      "pos": [
        36940,
        37051
      ]
    },
    {
      "content": "DocumentDB .NET Index Management code samples",
      "pos": [
        37058,
        37103
      ]
    },
    {
      "content": "DocumentDB REST API Collection Operations",
      "pos": [
        37217,
        37258
      ]
    },
    {
      "content": "Query with DocumentDB SQL",
      "pos": [
        37321,
        37346
      ]
    },
    {
      "content": "test",
      "pos": [
        37378,
        37382
      ]
    }
  ],
  "content": "<properties \n    pageTitle=\"DocumentDB Indexing Policies | Microsoft Azure\" \n    description=\"Understand how indexing works in DocumentDB and learn how to configure and change the indexing policy.\" \n    services=\"documentdb\" \n    documentationCenter=\"\" \n    authors=\"arramac\" \n    manager=\"jhubbard\" \n    editor=\"monicar\"/>\n\n<tags \n    ms.service=\"documentdb\" \n    ms.devlang=\"na\" \n    ms.topic=\"article\" \n    ms.tgt_pltfrm=\"na\" \n    ms.workload=\"data-services\" \n    ms.date=\"08/03/2015\" \n    ms.author=\"mimig\"/>\n\n\n# DocumentDB indexing policies\n\nWhile many customers are happy to let DocumentDB automatically handle [all aspects of indexing](documentdb-indexing.md), DocumentDB also supports specifying a custom **indexing policy** for collections during creation. Indexing policies in DocumentDB are more flexible and powerful than secondary indexes offered in other database platforms, in that they let you design and customize the shape of the index without sacrificing schema flexibility. By managing indexing policy, you can make fine-grained tradeoffs between index storage overhead, write and query throughput, and query consistency.  \n\nIn this article, we take a close look at DocumentDB indexing policies, how you can customize indexing policy, and the associated trade-offs. \n\nAfter reading this article, you'll be able to answer the following questions:\n\n- How does DocumentDB support automatic indexing by default?\n- How can I override the properties to include or exclude from indexing?\n- How can I configure the index for eventual updates?\n- How can I configure indexing to perform Order By or range queries?\n- How do I make changes to a collection’s indexing policy?\n- How do I compare storage and performance of different indexing policies?\n\n##<a id=\"CustomizingIndexingPolicy\"></a> Customizing the indexing policy of a collection\n\nDevelopers can customize the trade-offs between storage, write/query performance, and query consistency, by overriding the default indexing policy on a DocumentDB collection and configuring the following aspects.\n\n- **Including/Excluding documents and paths to/from index**. Developers can choose certain documents to be excluded or included in the index at the time of inserting or replacing them to the collection. Developers can also choose to include or exclude certain JSON properties a.k.a. paths (including wildcard patterns) to be indexed across documents which are included in an index.\n- **Configuring Various Index Types**. For each of the included paths, developers can also specify the type of index they require over a collection based on their data and expected query workload and the numeric/string “precision” for each path.\n- **Configuring Index Update Modes**. DocumentDB supports three indexing modes which can be configured via the indexing policy on a DocumentDB collection: Consistent, Lazy and None. \n\nThe following .NET code snippet shows how to set a custom indexing policy during the creation of a collection. Here we set the policy with Range index for strings and numbers at the maximum precision. This policy lets us execute Order By queries against strings.\n\n    var collection = new DocumentCollection { Id = \"myCollection\" };\n    \n    collection.IndexingPolicy.IndexingMode = IndexingMode.Consistent;\n    \n    collection.IndexingPolicy.IncludedPaths.Add(\n        new IncludedPath { \n            Path = \"/*\", \n            Indexes = new Collection<Index> { \n                new RangeIndex(DataType.String) { Precision = -1 }, \n                new RangeIndex(DataType.Number) { Precision = -1 }\n            }\n        });\n\n    await client.CreateDocumentCollectionAsync(database.SelfLink, collection);   \n\n\n>[AZURE.NOTE] The JSON schema for indexing policy was changed with the release of REST API version 2015-06-03 to support Range indexes against strings. .NET SDK 1.2.0 and Java, Python, and Node.js SDKs 1.1.0 support the new policy schema. Older SDKs use the REST API version 2015-04-08 and support the older schema of Indexing Policy.\n>\n>By default, DocumentDB indexes all string properties within documents consistently with a Hash index, and numeric properties with a Range index.  \n\n### Indexing modes\n\nDocumentDB supports three indexing modes which can be configured via the indexing policy on a DocumentDB collection – Consistent, Lazy and None.\n\n**Consistent**: If a DocumentDB collection’s policy is designated as \"consistent\", the queries on a given DocumentDB collection follow the same consistency level as specified for the point-reads (i.e. strong, bounded-staleness, session or eventual). The index is updated synchronously as part of the document update (i.e. insert, replace, update, and delete of a document in a DocumentDB collection).  Consistent indexing supports consistent queries at the cost of possible reduction in write throughput. This reduction is a function of the unique paths that need to be indexed and the “consistency level”. Consistent indexing mode is designed for “write quickly, query immediately” workloads.\n\n**Lazy**: To allow maximum document ingestion throughput, a DocumentDB collection can be configured with lazy consistency; meaning queries are eventually consistent. The index is updated asynchronously when a DocumentDB collection is quiescent i.e. when the collection’s throughput capacity is not fully utilized to serve user requests. For \"ingest now, query later\" workloads requiring unhindered document ingestion, \"lazy\" indexing mode may be suitable.\n\n**None**: A collection marked with index mode of “None” has no index associated with it. Configuring the indexing policy with \"None\" has the side effect of dropping any existing index.\n\n>[AZURE.NOTE] Configuring the indexing policy with “None” has the side effect of dropping any existing index. Use this if your access patterns are only require “id” and/or “self-link”.\n\nThe following sample show how create a DocumentDB collection using the .NET SDK with consistent automatic indexing on all document insertions.\n\nThe following table shows the consistency for queries based on the indexing mode (Consistent and Lazy) configured for the collection and the consistency level specified for the query request. This applies to queries made using any interface - REST API, SDKs or from within stored procedures and triggers. \n\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"0\">\n    <tbody>\n        <tr>\n            <td valign=\"top\">\n                <p>\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    <strong>Consistent</strong>\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    <strong>Lazy</strong>\n                </p>\n            </td>            \n        </tr>\n        <tr>\n            <td valign=\"top\">\n                <p>\n                    <strong>Strong</strong>\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Strong\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Eventual\n                </p>\n            </td>            \n        </tr>       \n        <tr>\n            <td valign=\"top\">\n                <p>\n                    <strong>Bounded Staleness</strong>\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Bounded Staleness\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Eventual\n                </p>\n            </td>            \n        </tr>          \n        <tr>\n            <td valign=\"top\">\n                <p>\n                    <strong>Session</strong>\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Session\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Eventual\n                </p>\n            </td>            \n        </tr>      \n        <tr>\n            <td valign=\"top\">\n                <p>\n                    <strong>Eventual</strong>\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Eventual\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Eventual\n                </p>\n            </td>            \n        </tr>         \n    </tbody>\n</table>\n\nBy default, an error is returned for all queries if the collection is setup with None indexing mode in order to signal that a scan might be necessary to serve the query. These queries can be performed without a range index using the `x-ms-documentdb-enable-scans` header in the REST API or the `EnableScanInQuery` request option using the .NET SDK. Some queries for example, that use ORDER BY will not be allowed with None even with `EnableScanInQuery`.\n\nThe following table shows the consistency for queries based on the indexing mode (Consistent, Lazy, and None) when EnableScanInQuery is specified.\n\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"0\">\n    <tbody>\n        <tr>\n            <td valign=\"top\">\n                <p>\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    <strong>Consistent</strong>\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    <strong>Lazy</strong>\n                </p>\n            </td>       \n            <td valign=\"top\">\n                <p>\n                    <strong>None</strong>\n                </p>\n            </td>             \n        </tr>\n        <tr>\n            <td valign=\"top\">\n                <p>\n                    <strong>Strong</strong>\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Strong\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Eventual\n                </p>\n            </td>    \n            <td valign=\"top\">\n                <p>\n                    Strong\n                </p>\n            </td>                \n        </tr>       \n        <tr>\n            <td valign=\"top\">\n                <p>\n                    <strong>Bounded Staleness</strong>\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Bounded Staleness\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Eventual\n                </p>\n            </td>      \n            <td valign=\"top\">\n                <p>\n                    Bounded Staleness\n                </p>\n            </td> \n        </tr>          \n        <tr>\n            <td valign=\"top\">\n                <p>\n                    <strong>Session</strong>\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Session\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Eventual\n                </p>\n            </td>   \n            <td valign=\"top\">\n                <p>\n                    Session\n                </p>\n            </td>             \n        </tr>      \n        <tr>\n            <td valign=\"top\">\n                <p>\n                    <strong>Eventual</strong>\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Eventual\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Eventual\n                </p>\n            </td>      \n            <td valign=\"top\">\n                <p>\n                    Eventual\n                </p>\n            </td>              \n        </tr>         \n    </tbody>\n</table>\n\nThe following code sample show how create a DocumentDB collection using the .NET SDK with consistent indexing on all document insertions.\n\n     // Default collection creates a hash index for all string and numeric    \n     // fields. Hash indexes are compact and offer efficient\n     // performance for equality queries.\n     \n     var collection = new DocumentCollection { Id =\"defaultCollection\" };\n     \n     collection.IndexingPolicy.IndexingMode = IndexingMode.Consistent;\n     \n     collection = await client.CreateDocumentCollectionAsync(database.SelfLink, collection);\n\n\n### Index paths\n\nDocumentDB models JSON documents and the index as trees, and allows you to tune to policies for paths within the tree. You can find more details in this [introduction to DocumentDB indexing](documentdb-indexing.md). Within documents, you can choose which paths must be included or excluded from indexing. This can offer improved write performance and lower index storage for scenarios when the query patterns are known beforehand.\n\nIndex paths start with the root (/) and typically end with the ? wildcard operator, denoting that there are multiple possible values for the prefix. For example, to serve SELECT * FROM Families F WHERE F.familyName = \"Andersen\", you must include an index path for /familyName/? in the collection’s index policy.\n\nIndex paths can also use the * wildcard operator to specify the behavior for paths recursively under the prefix. For example, /payload/* can be used to exclude everything under the payload property from indexing.\n\nHere are the common patterns for specifying index paths:\n\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"0\">\n    <tbody>\n        <tr>\n            <td valign=\"top\">\n                <p>\n                    <strong>Path</strong>\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    <strong>Description/use case</strong>\n                </p>\n            </td>\n        </tr>\n        <tr>\n            <td valign=\"top\">\n                <p>\n                    /*\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Default path for collection. Recursive and applies to whole document tree.\n                </p>\n            </td>\n        </tr>\n        <tr>\n            <td valign=\"top\">\n                <p>\n                    /prop/?\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Index path required to serve queries like the following (with Hash or Range types respectively):\n                </p>\n                <p>\n                    SELECT * FROM collection c WHERE c.prop = \"value\"\n                </p>\n                <p>\n                    SELECT * FROM collection c WHERE c.prop &gt; 5\n                </p>\n                <p>\n                    SELECT * FROM collection c ORDER BY c.prop\n                </p>                \n            </td>\n        </tr>\n        <tr>\n            <td valign=\"top\">\n                <p>\n                    /prop/*\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Index path for all paths under the specified label. Works with the following queries\n                </p>\n                <p>\n                    SELECT * FROM collection c WHERE c.prop = \"value\"\n                </p>\n                <p>\n                    SELECT * FROM collection c WHERE c.prop.subprop &gt; 5\n                </p>\n                <p>\n                    SELECT * FROM collection c WHERE c.prop.subprop.nextprop = \"value\"\n                </p>\n                <p>\n                    SELECT * FROM collection c ORDER BY c.prop\n                </p>\n            </td>\n        </tr>\n        <tr>\n            <td valign=\"top\">\n                <p>\n                    /props/[]/?\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Index path required to serve iteration and JOIN queries against arrays of scalars like [\"a\", \"b\", \"c\"]:\n                </p>\n                <p>\n                    SELECT tag FROM tag IN collection.props WHERE tag = \"value\"\n                </p>\n                <p>\n                    SELECT tag FROM collection c JOIN tag IN c.props WHERE tag > 5\n                </p>\n            </td>\n        </tr>\n        <tr>\n            <td valign=\"top\">\n                <p>\n                    /props/[]/subprop/?\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Index path required to serve iteration and JOIN queries against arrays of objects like [{subprop: \"a\"}, {subprop: \"b\"}]:\n                </p>\n                <p>\n                    SELECT tag FROM tag IN collection.props WHERE tag.subprop = \"value\"\n                </p>\n                <p>\n                    SELECT tag FROM collection c JOIN tag IN c.props WHERE tag.subprop = \"value\"\n                </p>\n            </td>\n        </tr>        \n        <tr>\n            <td valign=\"top\">\n                <p>\n                    /prop/subprop/?\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Index path required to serve queries (with Hash or Range types respectively):\n                </p>\n                <p>\n                    SELECT * FROM collection c WHERE c.prop.subprop = \"value\"\n                </p>\n                <p>\n                    SELECT * FROM collection c WHERE c.prop.subprop &gt; 5\n                </p>\n                <p>\n                    SELECT * FROM collection c ORDER BY c.prop.subprop\n                </p>                \n            </td>\n        </tr>\n    </tbody>\n</table>\n\n>[AZURE.NOTE] While setting custom index paths, you are required to specify the default indexing rule for the entire document tree denoted by the special path \"/*\". \n\nThe following example configures a specific path with range indexing and a custom precision value of 20 bytes:\n\n    var collection = new DocumentCollection { Id = \"rangeSinglePathCollection\" };    \n    \n    collection.IndexingPolicy.IncludedPaths.Add(\n        new IncludedPath { \n            Path = \"/Title/?\", \n            Indexes = new Collection<Index> { \n                new RangeIndex(DataType.String) { Precision = 20 } } \n            });\n\n    // Default for everything else\n    collection.IndexingPolicy.IncludedPaths.Add(\n        new IncludedPath { \n            Path = \"/*\" ,\n            Indexes = new Collection<Index> {\n                new HashIndex(DataType.String) { Precision = 3 }, \n                new RangeIndex(DataType.Number) { Precision = -1 } \n            }\n        });\n        \n    collection = await client.CreateDocumentCollectionAsync(database.SelfLink, pathRange);\n\n### Index data types, kinds and precisions\n\nNow that we've taken a look at how to specify paths, let's look at the options we can use to configure the indexing policy for a path. You can specify one or more indexing definitions for every path:\n\n- Data type: **String**, **Number** or **Point** (can contain only one entry per data type per path)\n- Index kind: **Hash** (equality queries), **Range** (equality, range or Order By queries), or **Spatial** (spatial queries) \n- Precision: 1-8 or -1 (Maximum precision) for numbers, 1-100 (Maximum precision) for string\n\n#### Index kind\n\nDocumentDB supports Hash and Range index kinds for every path (that can configured for strings, numbers or both).\n\n- **Hash** supports efficient equality and JOIN queries. For most use cases, hash indexes do not need a higher precision than the default value of 3 bytes.\n- **Range** supports efficient equality queries, range queries (using >, <, >=, <=, !=), and Order By queries. Order By queries by default also require maximum index precision (-1).\n\nDocumentDB also supporst the Spatial index kind for every path, that can be specified for the Point data type. The value at the specified path must be a valid GeoJSON point like `{\"type\": \"Point\", \"coordinates\": [0.0, 10.0]}`.\n\n- **Spatial** supports efficient spatial (within and distance) queries.\n\nHere are the supported index kinds and examples of queries that they can be used to serve:\n\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"0\">\n    <tbody>\n        <tr>\n            <td valign=\"top\">\n                <p>\n                    <strong>Index kind</strong>\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    <strong>Description/use case</strong>\n                </p>\n            </td>\n        </tr>\n        <tr>\n            <td valign=\"top\">\n                <p>\n                    Hash\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Hash over /prop/? (or /*) can be used to serve the following queries efficiently:\n                      SELECT * FROM collection c WHERE c.prop = \"value\"\n                    Hash over /props/[]/? (or /* or /props/*) can be used to serve the following queries efficiently:\n                      SELECT tag FROM collection c JOIN tag IN c.props WHERE tag = 5\n                </p>\n            </td>\n        </tr>\n        <tr>\n            <td valign=\"top\">\n                <p>\n                    Range\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Range over /prop/? (or /*) can be used to serve the following queries efficiently:\n                        SELECT * FROM collection c WHERE c.prop = \"value\"\n                        SELECT * FROM collection c WHERE c.prop > 5\n                        SELECT * FROM collection c ORDER BY c.prop\n                </p>\n            </td>\n        </tr>\n        <tr>\n            <td valign=\"top\">\n                <p>\n                    Spatial\n                </p>\n            </td>\n            <td valign=\"top\">\n                <p>\n                    Range over /prop/? (or /*) can be used to serve the following queries efficiently:\n                        SELECT * FROM collection c \n                        WHERE ST_DISTANCE(c.prop, {\"type\": \"Point\", \"coordinates\": [0.0, 10.0]}) < 40\n                        SELECT * FROM collection c WHERE ST_WITHIN(c.prop, {\"type\": \"Polygon\", ... })\n                </p>\n            </td>\n        </tr>        \n    </tbody>\n</table>\n\nBy default, an error is returned for queries with range operators such as >= if there is no range index (of any precision) in order to signal that a scan might be necessary to serve the query. Range queries can be performed without a range index using the x-ms-documentdb-enable-scans header in the REST API or the EnableScanInQuery request option using the .NET SDK. If there are any other filters in the query that DocumentDB can use the index to filter against, then no error will be returned.\n\nThe same rules apply for spatial queries. By default, an error is returned for spatial queries if there is no spatial index. They can be performed as a scan using x-ms-documentdb-enable-scan/EnableScanInQuery.\n\n#### Index precision\n\nIndex precision lets you tradeoff between index storage overhead and query performance. \nFor numbers, we recommend using the default precision configuration of -1 (\"maximum\"). Since numbers are 8 bytes in JSON, this is equivalent to a configuration of 8 bytes. Picking a lower value for precision, such as 1-7, means that values within some ranges map to the same index entry. Therefore you will reduce index storage space, but query execution might have to process more documents and consequently consume more throughput i.e., request units.\n\nIndex precision configuration is more useful with string ranges. Since strings can be any arbitrary length, the choice of the index precision can impact the performance of string range queries, and impact the amount of index storage space required. String range indexes can be configured with 1-100 or -1 (\"maximum\"). If you would like to perform Order By queries against string properties, then you must specify a precision of -1 for the corresponding paths.\n\nSpatial indexes always use the default index precision for points and cannot be overriden. \n\nThe following example shows how to increase the precision for range indexes in a collection using the .NET SDK. Note that this uses the default path \"/*\".\n\n**Create a collection with a custom index precision**\n\n    var rangeDefault = new DocumentCollection { Id = \"rangeCollection\" };\n    \n    rangeDefault.IndexingPolicy.IncludedPaths.Add(\n        new IncludedPath { \n            Path = \"/*\", \n            Indexes = new Collection<Index> { \n                new RangeIndex(DataType.String) { Precision = -1 }, \n                new RangeIndex(DataType.Number) { Precision = -1 }\n            }\n        });\n\n    await client.CreateDocumentCollectionAsync(database.SelfLink, rangeDefault);   \n\n\n> [AZURE.NOTE] DocumentDB returns an error when a query uses Order By but does not have a range index against the queried path with the maximum precision. \n\nSimilarly, paths can be completely excluded from indexing. The next example shows how to exclude an entire section of the documents (a.k.a. a sub-tree) from indexing using the \"*\" wildcard.\n\n    var collection = new DocumentCollection { Id = \"excludedPathCollection\" };\n    collection.IndexingPolicy.IncludedPaths.Add(new IncludedPath { Path = \"/\" });\n    collection.IndexingPolicy.ExcludedPaths.Add(new ExcludedPath { Path = \"/nonIndexedContent/*\");\n    \n    collection = await client.CreateDocumentCollectionAsync(database.SelfLink, excluded);\n\n\n## Opting in and opting out of indexing\n\nYou can choose whether you want the collection to automatically index all documents. By default, all documents are automatically indexed, but you can choose to turn it off. When indexing is turned off, documents can be accessed only through their self-links or by queries using ID.\n\nWith automatic indexing turned off, you can still selectively add only specific documents to the index. Conversely, you can leave automatic indexing on and selectively choose to exclude only specific documents. Indexing on/off configurations are useful when you have only a subset of documents that need to be queried.\n\nFor example, the following sample shows how to include a document explicitly using the [DocumentDB .NET SDK](https://github.com/Azure/azure-documentdb-java) and the [RequestOptions.IndexingDirective](http://msdn.microsoft.com/library/microsoft.azure.documents.client.requestoptions.indexingdirective.aspx) property.\n\n    // If you want to override the default collection behavior to either\n    // exclude (or include) a Document from indexing,\n    // use the RequestOptions.IndexingDirective property.\n    client.CreateDocumentAsync(defaultCollection.SelfLink,\n        new { id = \"AndersenFamily\", isRegistered = true },\n        new RequestOptions { IndexingDirective = IndexingDirective.Include });\n\n## Modifying the indexing policy of a collection\n\nDocumentDB allows you to make changes to the indexing policy of a collection on the fly. A change in indexing policy on a DocumentDB collection can lead to a change in the shape of the index including the paths can be indexed, their precision, as well as the consistency model of the index itself. Thus a change in indexing policy, effectively requires a transformation of the old index into a new one. \n\n**Online Index Transformations**\n\n![Online Index Transformations](media/documentdb-indexing-policies/index-transformations.png)\n\nIndex transformations are made online, meaning that the documents indexed per the old policy are efficiently transformed per the new policy **without affecting the write availability or the provisioned throughput** of the collection. The consistency of read and write operations made using the REST API, SDKs or from within stored procedures and triggers is not impacted during index transformation. This means that there is no performance degradation or downtime to your apps when you make an indexing policy change.\n\nHowever, during the time that index transformation is progress, queries are eventually consistent regardless of the indexing mode configuration (Consistent or Lazy). This also applies to queries from all interfaces – REST API, SDKs, and from within stored procedures and triggers. Just like with Lazy indexing, index transformation is performed asynchronously in the background on the replicas using the spare resources available for a given replica. \n\nIndex transformations are also made **in-situ** (in place), i.e. DocumentDB does not maintain two copies of the index and swap the old index out with the new one. This means that no additional disk space is required or consumed in your collections while performing index transformations.\n\nWhen you change indexing policy, how the changes are applied to move from the old index to the new one depend primarily on the indexing mode configurations more so than the other values like included/excluded paths, index kinds and precisions. If both your old and new policies use consistent indexing, then DocumentDB performs an online index transformation. You cannot apply another indexing policy change with consistent indexing mode while the transformation is in progress.\n\nYou can however move to Lazy or None indexing mode while a transformation is in progress. \n\n- When you move to Lazy, the index policy change is made effective immediately and DocumentDB starts recreating the index asynchronously. \n- When you move to None, then the index is dropped effective immediately. Moving to None is useful when you want to cancel an in progress transformation and start fresh with a different indexing policy. \n\nIf you’re using the .NET SDK, you can kick of an indexing policy change using the new **ReplaceDocumentCollectionAsync** method and track the percentage progress of the index transformation using the **IndexTransformationProgress** response property from a **ReadDocumentCollectionAsync** call. Other SDKs and the REST API support equivalent properties and methods for making indexing policy changes.\n\nHere's a code snippet that shows how to modify a collection's indexing policy from Consistent indexing mode to Lazy.\n\n**Modify Indexing Policy from Consistent to Lazy**\n\n    // Switch to lazy indexing.\n    Console.WriteLine(\"Changing from Default to Lazy IndexingMode.\");\n\n    collection.IndexingPolicy.IndexingMode = IndexingMode.Lazy;\n\n    await client.ReplaceDocumentCollectionAsync(collection);\n\n\nYou can check the progress of an index transformation by calling ReadDocumentCollectionAsync, for example, as shown below.\n\n**Track Progress of Index Transformation**\n\n    long smallWaitTimeMilliseconds = 1000;\n    long progress = 0;\n\n    while (progress < 100)\n    {\n        ResourceResponse<DocumentCollection> collectionReadResponse = await     client.ReadDocumentCollectionAsync(collection.SelfLink);\n        progress = collectionReadResponse.IndexTransformationProgress;\n\n        await Task.Delay(TimeSpan.FromMilliseconds(smallWaitTimeMilliseconds));\n    }\n\nYou can drop the index for a collection by moving to the None indexing mode. This might be a useful operational tool if you want to cancel an in-progress transformation and start a new one immediately.\n\n**Dropping the index for a collection**\n\n    // Switch to lazy indexing.\n    Console.WriteLine(\"Dropping index by changing to to the None IndexingMode.\");\n\n    collection.IndexingPolicy.IndexingMode = IndexingMode.None;\n\n    await client.ReplaceDocumentCollectionAsync(collection);\n\nWhen would you make indexing policy changes to your DocumentDB collections? The following are the most common use cases:\n\n- Serve consistent results during normal operation, but fall back to lazy indexing during bulk data imports\n- Start using new indexing features on your current DocumentDB collections, e.g., like geospatial querying which require the Spatial index kind, or Order By/string range queries which require the string Range index kind\n- Hand select the properties to be indexed and change them over time\n- Tune indexing precision to improve query performance or reduce storage consumed\n\n>[AZURE.NOTE] To modify indexing policy using ReplaceDocumentCollectionAsync, you need version >= 1.3.0 of the .NET SDK\n\n## Performance tuning\n\nThe DocumentDB APIs provide information about performance metrics such as the index storage used, and the throughput cost (request units) for every operation. This information can be used to compare various indexing policies and for performance tuning.\n\nTo check the storage quota and usage of a collection, run a HEAD or GET request against the collection resource, and inspect the x-ms-request-quota and the x-ms-request-usage headers. In the .NET SDK, the [DocumentSizeQuota](http://msdn.microsoft.com/library/dn850325.aspx) and [DocumentSizeUsage](http://msdn.microsoft.com/library/azure/dn850324.aspx) properties in [ResourceResponse<T\\>](http://msdn.microsoft.com/library/dn799209.aspx) contain these corresponding values.\n\n     // Measure the document size usage (which includes the index size) against   \n     // different policies.        \n     ResourceResponse<DocumentCollection> collectionInfo = await client.ReadDocumentCollectionAsync(collectionSelfLink);  \n     Console.WriteLine(\"Document size quota: {0}, usage: {1}\", collectionInfo.DocumentQuota, collectionInfo.DocumentUsage);\n\n\nTo measure the overhead of indexing on each write operation (create, update, or delete), inspect the x-ms-request-charge header (or the equivalent [RequestCharge](http://msdn.microsoft.com/library/dn799099.aspx) property in [ResourceResponse<T\\>](http://msdn.microsoft.com/library/dn799209.aspx) in the .NET SDK) to measure the number of request units consumed by these operations.\n\n     // Measure the performance (request units) of writes.     \n     ResourceResponse<Document> response = await client.CreateDocumentAsync(collectionSelfLink, myDocument);              \n     Console.WriteLine(\"Insert of document consumed {0} request units\", response.RequestCharge);\n     \n     // Measure the performance (request units) of queries.    \n     IDocumentQuery<dynamic> queryable =  client.CreateDocumentQuery(collectionSelfLink, queryString).AsDocumentQuery();                                  \n     double totalRequestCharge = 0;\n     while (queryable.HasMoreResults)\n     {\n        FeedResponse<dynamic> queryResponse = await queryable.ExecuteNextAsync<dynamic>(); \n        Console.WriteLine(\"Query batch consumed {0} request units\",queryResponse.RequestCharge);\n        totalRequestCharge += queryResponse.RequestCharge;\n     }\n     \n     Console.WriteLine(\"Query consumed {0} request units in total\", totalRequestCharge);\n\n## Changes to the indexing policy specification\nA change in the schema for indexing policy was introduced on July 7, 2015 with REST API version 2015-06-03. The corresponding classes in the SDK versions have new implementations to match the schema. \n\nThe following changes were implemented in the JSON specification:\n\n- Indexing Policy supports Range indexes for strings\n- Each path can have multiple index definitions, one for each data type\n- Indexing precision supports 1-8 for numbers, 1-100 for strings, and -1 (maximum precision)\n- Paths segments do not require a double quotation to escape each path. For example, you can add a path for /title/? instead of /\"title\"/?\n- The root path representing \"all paths\" can be represented as /* (in addition to /)\n\nIf you have code that provisions collections with a custom indexing policy written with version 1.1.0 of the .NET SDK or older, you will need to change your application code to handle these changes in order to move to SDK version 1.2.0. If you do not have code that configures indexing policy, or plan to continue using an older SDK version, no changes are required.\n\nFor a practical comparison, here is one example custom indexing policy written using the REST API version 2015-06-03 as well as the previous version 2015-04-08.\n\n**Previous Indexing Policy JSON**\n\n    {\n       \"automatic\":true,\n       \"indexingMode\":\"Consistent\",\n       \"IncludedPaths\":[\n          {\n             \"IndexType\":\"Hash\",\n             \"Path\":\"/\",\n             \"NumericPrecision\":7,\n             \"StringPrecision\":3\n          }\n       ],\n       \"ExcludedPaths\":[\n          \"/\\\"nonIndexedContent\\\"/*\"\n       ]\n    }\n\n**Current Indexing Policy JSON**\n\n    {\n       \"automatic\":true,\n       \"indexingMode\":\"Consistent\",\n       \"includedPaths\":[\n          {\n             \"path\":\"/*\",\n             \"indexes\":[\n                {\n                   \"kind\":\"Hash\",\n                   \"dataType\":\"String\",\n                   \"precision\":3\n                },\n                {\n                   \"kind\":\"Hash\",\n                   \"dataType\":\"Number\",\n                   \"precision\":7\n                }\n             ]\n          }\n       ],\n       \"ExcludedPaths\":[\n          {\n             \"path\":\"/nonIndexedContent/*\"\n          }\n       ]\n    }\n\n## Next Steps\n\nFollow the links below for index policy management samples and to learn more about DocumentDB's query language.\n\n1.  [DocumentDB .NET Index Management code samples](https://github.com/Azure/azure-documentdb-net/blob/master/samples/code-samples/IndexManagement/Program.cs)\n2.  [DocumentDB REST API Collection Operations](https://msdn.microsoft.com/library/azure/dn782195.aspx)\n3.  [Query with DocumentDB SQL](documentdb-sql-query.md)\n\n \n\n\ntest\n"
}