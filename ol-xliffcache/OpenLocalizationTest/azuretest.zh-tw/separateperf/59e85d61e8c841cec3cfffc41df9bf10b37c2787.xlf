<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>DocumentDB Indexing Policies | Microsoft Azure</source>
          <target state="new">DocumentDB Indexing Policies | Microsoft Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Understand how indexing works in DocumentDB and learn how to configure and change the indexing policy.</source>
          <target state="new">Understand how indexing works in DocumentDB and learn how to configure and change the indexing policy.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>DocumentDB indexing policies</source>
          <target state="new">DocumentDB indexing policies</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>While many customers are happy to let DocumentDB automatically handle <bpt id="p1">[</bpt>all aspects of indexing<ept id="p1">](documentdb-indexing.md)</ept>, DocumentDB also supports specifying a custom <bpt id="p2">**</bpt>indexing policy<ept id="p2">**</ept> for collections during creation.</source>
          <target state="new">While many customers are happy to let DocumentDB automatically handle <bpt id="p1">[</bpt>all aspects of indexing<ept id="p1">](documentdb-indexing.md)</ept>, DocumentDB also supports specifying a custom <bpt id="p2">**</bpt>indexing policy<ept id="p2">**</ept> for collections during creation.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Indexing policies in DocumentDB are more flexible and powerful than secondary indexes offered in other database platforms, in that they let you design and customize the shape of the index without sacrificing schema flexibility.</source>
          <target state="new">Indexing policies in DocumentDB are more flexible and powerful than secondary indexes offered in other database platforms, in that they let you design and customize the shape of the index without sacrificing schema flexibility.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>By managing indexing policy, you can make fine-grained tradeoffs between index storage overhead, write and query throughput, and query consistency.</source>
          <target state="new">By managing indexing policy, you can make fine-grained tradeoffs between index storage overhead, write and query throughput, and query consistency.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>In this article, we take a close look at DocumentDB indexing policies, how you can customize indexing policy, and the associated trade-offs.</source>
          <target state="new">In this article, we take a close look at DocumentDB indexing policies, how you can customize indexing policy, and the associated trade-offs.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>After reading this article, you'll be able to answer the following questions:</source>
          <target state="new">After reading this article, you'll be able to answer the following questions:</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>How does DocumentDB support automatic indexing by default?</source>
          <target state="new">How does DocumentDB support automatic indexing by default?</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>How can I override the properties to include or exclude from indexing?</source>
          <target state="new">How can I override the properties to include or exclude from indexing?</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>How can I configure the index for eventual updates?</source>
          <target state="new">How can I configure the index for eventual updates?</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>How can I configure indexing to perform Order By or range queries?</source>
          <target state="new">How can I configure indexing to perform Order By or range queries?</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>How do I make changes to a collection’s indexing policy?</source>
          <target state="new">How do I make changes to a collection’s indexing policy?</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>How do I compare storage and performance of different indexing policies?</source>
          <target state="new">How do I compare storage and performance of different indexing policies?</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a id="CustomizingIndexingPolicy"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> Customizing the indexing policy of a collection</source>
          <target state="new"><ph id="ph1">&lt;a id="CustomizingIndexingPolicy"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> Customizing the indexing policy of a collection</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Developers can customize the trade-offs between storage, write/query performance, and query consistency, by overriding the default indexing policy on a DocumentDB collection and configuring the following aspects.</source>
          <target state="new">Developers can customize the trade-offs between storage, write/query performance, and query consistency, by overriding the default indexing policy on a DocumentDB collection and configuring the following aspects.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Including/Excluding documents and paths to/from index<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Including/Excluding documents and paths to/from index<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Developers can choose certain documents to be excluded or included in the index at the time of inserting or replacing them to the collection.</source>
          <target state="new">Developers can choose certain documents to be excluded or included in the index at the time of inserting or replacing them to the collection.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Developers can also choose to include or exclude certain JSON properties a.k.a.</source>
          <target state="new">Developers can also choose to include or exclude certain JSON properties a.k.a.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>paths (including wildcard patterns) to be indexed across documents which are included in an index.</source>
          <target state="new">paths (including wildcard patterns) to be indexed across documents which are included in an index.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Configuring Various Index Types<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Configuring Various Index Types<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For each of the included paths, developers can also specify the type of index they require over a collection based on their data and expected query workload and the numeric/string “precision” for each path.</source>
          <target state="new">For each of the included paths, developers can also specify the type of index they require over a collection based on their data and expected query workload and the numeric/string “precision” for each path.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Configuring Index Update Modes<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Configuring Index Update Modes<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>DocumentDB supports three indexing modes which can be configured via the indexing policy on a DocumentDB collection: Consistent, Lazy and None.</source>
          <target state="new">DocumentDB supports three indexing modes which can be configured via the indexing policy on a DocumentDB collection: Consistent, Lazy and None.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The following .NET code snippet shows how to set a custom indexing policy during the creation of a collection.</source>
          <target state="new">The following .NET code snippet shows how to set a custom indexing policy during the creation of a collection.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Here we set the policy with Range index for strings and numbers at the maximum precision.</source>
          <target state="new">Here we set the policy with Range index for strings and numbers at the maximum precision.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>This policy lets us execute Order By queries against strings.</source>
          <target state="new">This policy lets us execute Order By queries against strings.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> The JSON schema for indexing policy was changed with the release of REST API version 2015-06-03 to support Range indexes against strings.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> The JSON schema for indexing policy was changed with the release of REST API version 2015-06-03 to support Range indexes against strings.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>.NET SDK 1.2.0 and Java, Python, and Node.js SDKs 1.1.0 support the new policy schema.</source>
          <target state="new">.NET SDK 1.2.0 and Java, Python, and Node.js SDKs 1.1.0 support the new policy schema.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Older SDKs use the REST API version 2015-04-08 and support the older schema of Indexing Policy.</source>
          <target state="new">Older SDKs use the REST API version 2015-04-08 and support the older schema of Indexing Policy.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>By default, DocumentDB indexes all string properties within documents consistently with a Hash index, and numeric properties with a Range index.</source>
          <target state="new">By default, DocumentDB indexes all string properties within documents consistently with a Hash index, and numeric properties with a Range index.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Indexing modes</source>
          <target state="new">Indexing modes</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>DocumentDB supports three indexing modes which can be configured via the indexing policy on a DocumentDB collection – Consistent, Lazy and None.</source>
          <target state="new">DocumentDB supports three indexing modes which can be configured via the indexing policy on a DocumentDB collection – Consistent, Lazy and None.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Consistent<ept id="p1">**</ept>: If a DocumentDB collection’s policy is designated as "consistent", the queries on a given DocumentDB collection follow the same consistency level as specified for the point-reads (i.e. strong, bounded-staleness, session or eventual).</source>
          <target state="new"><bpt id="p1">**</bpt>Consistent<ept id="p1">**</ept>: If a DocumentDB collection’s policy is designated as "consistent", the queries on a given DocumentDB collection follow the same consistency level as specified for the point-reads (i.e. strong, bounded-staleness, session or eventual).</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The index is updated synchronously as part of the document update (i.e. insert, replace, update, and delete of a document in a DocumentDB collection).</source>
          <target state="new">The index is updated synchronously as part of the document update (i.e. insert, replace, update, and delete of a document in a DocumentDB collection).</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Consistent indexing supports consistent queries at the cost of possible reduction in write throughput.</source>
          <target state="new">Consistent indexing supports consistent queries at the cost of possible reduction in write throughput.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>This reduction is a function of the unique paths that need to be indexed and the “consistency level”.</source>
          <target state="new">This reduction is a function of the unique paths that need to be indexed and the “consistency level”.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Consistent indexing mode is designed for “write quickly, query immediately” workloads.</source>
          <target state="new">Consistent indexing mode is designed for “write quickly, query immediately” workloads.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Lazy<ept id="p1">**</ept>: To allow maximum document ingestion throughput, a DocumentDB collection can be configured with lazy consistency; meaning queries are eventually consistent.</source>
          <target state="new"><bpt id="p1">**</bpt>Lazy<ept id="p1">**</ept>: To allow maximum document ingestion throughput, a DocumentDB collection can be configured with lazy consistency; meaning queries are eventually consistent.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The index is updated asynchronously when a DocumentDB collection is quiescent i.e. when the collection’s throughput capacity is not fully utilized to serve user requests.</source>
          <target state="new">The index is updated asynchronously when a DocumentDB collection is quiescent i.e. when the collection’s throughput capacity is not fully utilized to serve user requests.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For "ingest now, query later" workloads requiring unhindered document ingestion, "lazy" indexing mode may be suitable.</source>
          <target state="new">For "ingest now, query later" workloads requiring unhindered document ingestion, "lazy" indexing mode may be suitable.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>None<ept id="p1">**</ept>: A collection marked with index mode of “None” has no index associated with it.</source>
          <target state="new"><bpt id="p1">**</bpt>None<ept id="p1">**</ept>: A collection marked with index mode of “None” has no index associated with it.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Configuring the indexing policy with "None" has the side effect of dropping any existing index.</source>
          <target state="new">Configuring the indexing policy with "None" has the side effect of dropping any existing index.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Configuring the indexing policy with “None” has the side effect of dropping any existing index.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Configuring the indexing policy with “None” has the side effect of dropping any existing index.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Use this if your access patterns are only require “id” and/or “self-link”.</source>
          <target state="new">Use this if your access patterns are only require “id” and/or “self-link”.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The following sample show how create a DocumentDB collection using the .NET SDK with consistent automatic indexing on all document insertions.</source>
          <target state="new">The following sample show how create a DocumentDB collection using the .NET SDK with consistent automatic indexing on all document insertions.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The following table shows the consistency for queries based on the indexing mode (Consistent and Lazy) configured for the collection and the consistency level specified for the query request.</source>
          <target state="new">The following table shows the consistency for queries based on the indexing mode (Consistent and Lazy) configured for the collection and the consistency level specified for the query request.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>This applies to queries made using any interface - REST API, SDKs or from within stored procedures and triggers.</source>
          <target state="new">This applies to queries made using any interface - REST API, SDKs or from within stored procedures and triggers.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
                    &lt;strong&gt;</ph>Consistent<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></source>
          <target state="new"><ph id="ph1">
                    &lt;strong&gt;</ph>Consistent<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
                    &lt;strong&gt;</ph>Lazy<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></source>
          <target state="new"><ph id="ph1">
                    &lt;strong&gt;</ph>Lazy<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
                    &lt;strong&gt;</ph>Strong<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></source>
          <target state="new"><ph id="ph1">
                    &lt;strong&gt;</ph>Strong<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
                    &lt;strong&gt;</ph>Bounded Staleness<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></source>
          <target state="new"><ph id="ph1">
                    &lt;strong&gt;</ph>Bounded Staleness<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
                    &lt;strong&gt;</ph>Session<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></source>
          <target state="new"><ph id="ph1">
                    &lt;strong&gt;</ph>Session<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
                    &lt;strong&gt;</ph>Eventual<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></source>
          <target state="new"><ph id="ph1">
                    &lt;strong&gt;</ph>Eventual<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>By default, an error is returned for all queries if the collection is setup with None indexing mode in order to signal that a scan might be necessary to serve the query.</source>
          <target state="new">By default, an error is returned for all queries if the collection is setup with None indexing mode in order to signal that a scan might be necessary to serve the query.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>These queries can be performed without a range index using the <ph id="ph1">`x-ms-documentdb-enable-scans`</ph> header in the REST API or the <ph id="ph2">`EnableScanInQuery`</ph> request option using the .NET SDK.</source>
          <target state="new">These queries can be performed without a range index using the <ph id="ph1">`x-ms-documentdb-enable-scans`</ph> header in the REST API or the <ph id="ph2">`EnableScanInQuery`</ph> request option using the .NET SDK.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Some queries for example, that use ORDER BY will not be allowed with None even with <ph id="ph1">`EnableScanInQuery`</ph>.</source>
          <target state="new">Some queries for example, that use ORDER BY will not be allowed with None even with <ph id="ph1">`EnableScanInQuery`</ph>.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The following table shows the consistency for queries based on the indexing mode (Consistent, Lazy, and None) when EnableScanInQuery is specified.</source>
          <target state="new">The following table shows the consistency for queries based on the indexing mode (Consistent, Lazy, and None) when EnableScanInQuery is specified.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
                    &lt;strong&gt;</ph>Consistent<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></source>
          <target state="new"><ph id="ph1">
                    &lt;strong&gt;</ph>Consistent<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
                    &lt;strong&gt;</ph>Lazy<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></source>
          <target state="new"><ph id="ph1">
                    &lt;strong&gt;</ph>Lazy<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
                    &lt;strong&gt;</ph>None<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></source>
          <target state="new"><ph id="ph1">
                    &lt;strong&gt;</ph>None<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
                    &lt;strong&gt;</ph>Strong<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></source>
          <target state="new"><ph id="ph1">
                    &lt;strong&gt;</ph>Strong<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
                    &lt;strong&gt;</ph>Bounded Staleness<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></source>
          <target state="new"><ph id="ph1">
                    &lt;strong&gt;</ph>Bounded Staleness<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
                    &lt;strong&gt;</ph>Session<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></source>
          <target state="new"><ph id="ph1">
                    &lt;strong&gt;</ph>Session<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
                    &lt;strong&gt;</ph>Eventual<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></source>
          <target state="new"><ph id="ph1">
                    &lt;strong&gt;</ph>Eventual<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The following code sample show how create a DocumentDB collection using the .NET SDK with consistent indexing on all document insertions.</source>
          <target state="new">The following code sample show how create a DocumentDB collection using the .NET SDK with consistent indexing on all document insertions.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Index paths</source>
          <target state="new">Index paths</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>DocumentDB models JSON documents and the index as trees, and allows you to tune to policies for paths within the tree.</source>
          <target state="new">DocumentDB models JSON documents and the index as trees, and allows you to tune to policies for paths within the tree.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>You can find more details in this <bpt id="p1">[</bpt>introduction to DocumentDB indexing<ept id="p1">](documentdb-indexing.md)</ept>.</source>
          <target state="new">You can find more details in this <bpt id="p1">[</bpt>introduction to DocumentDB indexing<ept id="p1">](documentdb-indexing.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Within documents, you can choose which paths must be included or excluded from indexing.</source>
          <target state="new">Within documents, you can choose which paths must be included or excluded from indexing.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>This can offer improved write performance and lower index storage for scenarios when the query patterns are known beforehand.</source>
          <target state="new">This can offer improved write performance and lower index storage for scenarios when the query patterns are known beforehand.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Index paths start with the root (/) and typically end with the ?</source>
          <target state="new">Index paths start with the root (/) and typically end with the ?</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>wildcard operator, denoting that there are multiple possible values for the prefix.</source>
          <target state="new">wildcard operator, denoting that there are multiple possible values for the prefix.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>For example, to serve SELECT * FROM Families F WHERE F.familyName = "Andersen", you must include an index path for /familyName/?</source>
          <target state="new">For example, to serve SELECT * FROM Families F WHERE F.familyName = "Andersen", you must include an index path for /familyName/?</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>in the collection’s index policy.</source>
          <target state="new">in the collection’s index policy.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Index paths can also use the * wildcard operator to specify the behavior for paths recursively under the prefix.</source>
          <target state="new">Index paths can also use the * wildcard operator to specify the behavior for paths recursively under the prefix.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>For example, /payload/* can be used to exclude everything under the payload property from indexing.</source>
          <target state="new">For example, /payload/* can be used to exclude everything under the payload property from indexing.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Here are the common patterns for specifying index paths:</source>
          <target state="new">Here are the common patterns for specifying index paths:</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
                    &lt;strong&gt;</ph>Path<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></source>
          <target state="new"><ph id="ph1">
                    &lt;strong&gt;</ph>Path<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
                    &lt;strong&gt;</ph>Description/use case<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></source>
          <target state="new"><ph id="ph1">
                    &lt;strong&gt;</ph>Description/use case<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> While setting custom index paths, you are required to specify the default indexing rule for the entire document tree denoted by the special path "/*".</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> While setting custom index paths, you are required to specify the default indexing rule for the entire document tree denoted by the special path "/*".</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The following example configures a specific path with range indexing and a custom precision value of 20 bytes:</source>
          <target state="new">The following example configures a specific path with range indexing and a custom precision value of 20 bytes:</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Index data types, kinds and precisions</source>
          <target state="new">Index data types, kinds and precisions</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Now that we've taken a look at how to specify paths, let's look at the options we can use to configure the indexing policy for a path.</source>
          <target state="new">Now that we've taken a look at how to specify paths, let's look at the options we can use to configure the indexing policy for a path.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>You can specify one or more indexing definitions for every path:</source>
          <target state="new">You can specify one or more indexing definitions for every path:</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Data type: <bpt id="p1">**</bpt>String<ept id="p1">**</ept>, <bpt id="p2">**</bpt>Number<ept id="p2">**</ept> or <bpt id="p3">**</bpt>Point<ept id="p3">**</ept> (can contain only one entry per data type per path)</source>
          <target state="new">Data type: <bpt id="p1">**</bpt>String<ept id="p1">**</ept>, <bpt id="p2">**</bpt>Number<ept id="p2">**</ept> or <bpt id="p3">**</bpt>Point<ept id="p3">**</ept> (can contain only one entry per data type per path)</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Index kind: <bpt id="p1">**</bpt>Hash<ept id="p1">**</ept> (equality queries), <bpt id="p2">**</bpt>Range<ept id="p2">**</ept> (equality, range or Order By queries), or <bpt id="p3">**</bpt>Spatial<ept id="p3">**</ept> (spatial queries)</source>
          <target state="new">Index kind: <bpt id="p1">**</bpt>Hash<ept id="p1">**</ept> (equality queries), <bpt id="p2">**</bpt>Range<ept id="p2">**</ept> (equality, range or Order By queries), or <bpt id="p3">**</bpt>Spatial<ept id="p3">**</ept> (spatial queries)</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Precision: 1-8 or -1 (Maximum precision) for numbers, 1-100 (Maximum precision) for string</source>
          <target state="new">Precision: 1-8 or -1 (Maximum precision) for numbers, 1-100 (Maximum precision) for string</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Index kind</source>
          <target state="new">Index kind</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>DocumentDB supports Hash and Range index kinds for every path (that can configured for strings, numbers or both).</source>
          <target state="new">DocumentDB supports Hash and Range index kinds for every path (that can configured for strings, numbers or both).</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Hash<ept id="p1">**</ept> supports efficient equality and JOIN queries.</source>
          <target state="new"><bpt id="p1">**</bpt>Hash<ept id="p1">**</ept> supports efficient equality and JOIN queries.</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>For most use cases, hash indexes do not need a higher precision than the default value of 3 bytes.</source>
          <target state="new">For most use cases, hash indexes do not need a higher precision than the default value of 3 bytes.</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Range<ept id="p1">**</ept> supports efficient equality queries, range queries (using &gt;, &lt;, &gt;=, &lt;=, !=), and Order By queries.</source>
          <target state="new"><bpt id="p1">**</bpt>Range<ept id="p1">**</ept> supports efficient equality queries, range queries (using &gt;, &lt;, &gt;=, &lt;=, !=), and Order By queries.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Order By queries by default also require maximum index precision (-1).</source>
          <target state="new">Order By queries by default also require maximum index precision (-1).</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>DocumentDB also supporst the Spatial index kind for every path, that can be specified for the Point data type.</source>
          <target state="new">DocumentDB also supporst the Spatial index kind for every path, that can be specified for the Point data type.</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The value at the specified path must be a valid GeoJSON point like <ph id="ph1">`{"type": "Point", "coordinates": [0.0, 10.0]}`</ph>.</source>
          <target state="new">The value at the specified path must be a valid GeoJSON point like <ph id="ph1">`{"type": "Point", "coordinates": [0.0, 10.0]}`</ph>.</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Spatial<ept id="p1">**</ept> supports efficient spatial (within and distance) queries.</source>
          <target state="new"><bpt id="p1">**</bpt>Spatial<ept id="p1">**</ept> supports efficient spatial (within and distance) queries.</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Here are the supported index kinds and examples of queries that they can be used to serve:</source>
          <target state="new">Here are the supported index kinds and examples of queries that they can be used to serve:</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
                    &lt;strong&gt;</ph>Index kind<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></source>
          <target state="new"><ph id="ph1">
                    &lt;strong&gt;</ph>Index kind<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
                    &lt;strong&gt;</ph>Description/use case<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></source>
          <target state="new"><ph id="ph1">
                    &lt;strong&gt;</ph>Description/use case<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
                </ph></target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
                    Range over /prop/? (or /*) can be used to serve the following queries efficiently:
                        SELECT * FROM collection c 
                        WHERE ST_DISTANCE(c.prop, {"type": "Point", "coordinates": [0.0, 10.0]})</ph> &lt; 40</source>
          <target state="new"><ph id="ph1">
                    Range over /prop/? (or /*) can be used to serve the following queries efficiently:
                        SELECT * FROM collection c 
                        WHERE ST_DISTANCE(c.prop, {"type": "Point", "coordinates": [0.0, 10.0]})</ph> &lt; 40</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>SELECT * FROM collection c WHERE ST_WITHIN(c.prop, {"type": "Polygon", ... })</source>
          <target state="new">SELECT * FROM collection c WHERE ST_WITHIN(c.prop, {"type": "Polygon", ... })</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>By default, an error is returned for queries with range operators such as &gt;= if there is no range index (of any precision) in order to signal that a scan might be necessary to serve the query.</source>
          <target state="new">By default, an error is returned for queries with range operators such as &gt;= if there is no range index (of any precision) in order to signal that a scan might be necessary to serve the query.</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Range queries can be performed without a range index using the x-ms-documentdb-enable-scans header in the REST API or the EnableScanInQuery request option using the .NET SDK.</source>
          <target state="new">Range queries can be performed without a range index using the x-ms-documentdb-enable-scans header in the REST API or the EnableScanInQuery request option using the .NET SDK.</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>If there are any other filters in the query that DocumentDB can use the index to filter against, then no error will be returned.</source>
          <target state="new">If there are any other filters in the query that DocumentDB can use the index to filter against, then no error will be returned.</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The same rules apply for spatial queries.</source>
          <target state="new">The same rules apply for spatial queries.</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>By default, an error is returned for spatial queries if there is no spatial index.</source>
          <target state="new">By default, an error is returned for spatial queries if there is no spatial index.</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>They can be performed as a scan using x-ms-documentdb-enable-scan/EnableScanInQuery.</source>
          <target state="new">They can be performed as a scan using x-ms-documentdb-enable-scan/EnableScanInQuery.</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Index precision</source>
          <target state="new">Index precision</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Index precision lets you tradeoff between index storage overhead and query performance.</source>
          <target state="new">Index precision lets you tradeoff between index storage overhead and query performance.</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>For numbers, we recommend using the default precision configuration of -1 ("maximum").</source>
          <target state="new">For numbers, we recommend using the default precision configuration of -1 ("maximum").</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Since numbers are 8 bytes in JSON, this is equivalent to a configuration of 8 bytes.</source>
          <target state="new">Since numbers are 8 bytes in JSON, this is equivalent to a configuration of 8 bytes.</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Picking a lower value for precision, such as 1-7, means that values within some ranges map to the same index entry.</source>
          <target state="new">Picking a lower value for precision, such as 1-7, means that values within some ranges map to the same index entry.</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Therefore you will reduce index storage space, but query execution might have to process more documents and consequently consume more throughput i.e., request units.</source>
          <target state="new">Therefore you will reduce index storage space, but query execution might have to process more documents and consequently consume more throughput i.e., request units.</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Index precision configuration is more useful with string ranges.</source>
          <target state="new">Index precision configuration is more useful with string ranges.</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Since strings can be any arbitrary length, the choice of the index precision can impact the performance of string range queries, and impact the amount of index storage space required.</source>
          <target state="new">Since strings can be any arbitrary length, the choice of the index precision can impact the performance of string range queries, and impact the amount of index storage space required.</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>String range indexes can be configured with 1-100 or -1 ("maximum").</source>
          <target state="new">String range indexes can be configured with 1-100 or -1 ("maximum").</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>If you would like to perform Order By queries against string properties, then you must specify a precision of -1 for the corresponding paths.</source>
          <target state="new">If you would like to perform Order By queries against string properties, then you must specify a precision of -1 for the corresponding paths.</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Spatial indexes always use the default index precision for points and cannot be overriden.</source>
          <target state="new">Spatial indexes always use the default index precision for points and cannot be overriden.</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The following example shows how to increase the precision for range indexes in a collection using the .NET SDK.</source>
          <target state="new">The following example shows how to increase the precision for range indexes in a collection using the .NET SDK.</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Note that this uses the default path "/*".</source>
          <target state="new">Note that this uses the default path "/*".</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Create a collection with a custom index precision</source>
          <target state="new">Create a collection with a custom index precision</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> DocumentDB returns an error when a query uses Order By but does not have a range index against the queried path with the maximum precision.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> DocumentDB returns an error when a query uses Order By but does not have a range index against the queried path with the maximum precision.</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Similarly, paths can be completely excluded from indexing.</source>
          <target state="new">Similarly, paths can be completely excluded from indexing.</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The next example shows how to exclude an entire section of the documents (a.k.a.</source>
          <target state="new">The next example shows how to exclude an entire section of the documents (a.k.a.</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>a sub-tree) from indexing using the "*" wildcard.</source>
          <target state="new">a sub-tree) from indexing using the "*" wildcard.</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Opting in and opting out of indexing</source>
          <target state="new">Opting in and opting out of indexing</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>You can choose whether you want the collection to automatically index all documents.</source>
          <target state="new">You can choose whether you want the collection to automatically index all documents.</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>By default, all documents are automatically indexed, but you can choose to turn it off.</source>
          <target state="new">By default, all documents are automatically indexed, but you can choose to turn it off.</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>When indexing is turned off, documents can be accessed only through their self-links or by queries using ID.</source>
          <target state="new">When indexing is turned off, documents can be accessed only through their self-links or by queries using ID.</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>With automatic indexing turned off, you can still selectively add only specific documents to the index.</source>
          <target state="new">With automatic indexing turned off, you can still selectively add only specific documents to the index.</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Conversely, you can leave automatic indexing on and selectively choose to exclude only specific documents.</source>
          <target state="new">Conversely, you can leave automatic indexing on and selectively choose to exclude only specific documents.</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Indexing on/off configurations are useful when you have only a subset of documents that need to be queried.</source>
          <target state="new">Indexing on/off configurations are useful when you have only a subset of documents that need to be queried.</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>For example, the following sample shows how to include a document explicitly using the <bpt id="p1">[</bpt>DocumentDB .NET SDK<ept id="p1">](https://github.com/Azure/azure-documentdb-java)</ept> and the <bpt id="p2">[</bpt>RequestOptions.IndexingDirective<ept id="p2">](http://msdn.microsoft.com/library/microsoft.azure.documents.client.requestoptions.indexingdirective.aspx)</ept> property.</source>
          <target state="new">For example, the following sample shows how to include a document explicitly using the <bpt id="p1">[</bpt>DocumentDB .NET SDK<ept id="p1">](https://github.com/Azure/azure-documentdb-java)</ept> and the <bpt id="p2">[</bpt>RequestOptions.IndexingDirective<ept id="p2">](http://msdn.microsoft.com/library/microsoft.azure.documents.client.requestoptions.indexingdirective.aspx)</ept> property.</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Modifying the indexing policy of a collection</source>
          <target state="new">Modifying the indexing policy of a collection</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>DocumentDB allows you to make changes to the indexing policy of a collection on the fly.</source>
          <target state="new">DocumentDB allows you to make changes to the indexing policy of a collection on the fly.</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>A change in indexing policy on a DocumentDB collection can lead to a change in the shape of the index including the paths can be indexed, their precision, as well as the consistency model of the index itself.</source>
          <target state="new">A change in indexing policy on a DocumentDB collection can lead to a change in the shape of the index including the paths can be indexed, their precision, as well as the consistency model of the index itself.</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Thus a change in indexing policy, effectively requires a transformation of the old index into a new one.</source>
          <target state="new">Thus a change in indexing policy, effectively requires a transformation of the old index into a new one.</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Online Index Transformations</source>
          <target state="new">Online Index Transformations</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Online Index Transformations</source>
          <target state="new">Online Index Transformations</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Index transformations are made online, meaning that the documents indexed per the old policy are efficiently transformed per the new policy <bpt id="p1">**</bpt>without affecting the write availability or the provisioned throughput<ept id="p1">**</ept> of the collection.</source>
          <target state="new">Index transformations are made online, meaning that the documents indexed per the old policy are efficiently transformed per the new policy <bpt id="p1">**</bpt>without affecting the write availability or the provisioned throughput<ept id="p1">**</ept> of the collection.</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The consistency of read and write operations made using the REST API, SDKs or from within stored procedures and triggers is not impacted during index transformation.</source>
          <target state="new">The consistency of read and write operations made using the REST API, SDKs or from within stored procedures and triggers is not impacted during index transformation.</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>This means that there is no performance degradation or downtime to your apps when you make an indexing policy change.</source>
          <target state="new">This means that there is no performance degradation or downtime to your apps when you make an indexing policy change.</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>However, during the time that index transformation is progress, queries are eventually consistent regardless of the indexing mode configuration (Consistent or Lazy).</source>
          <target state="new">However, during the time that index transformation is progress, queries are eventually consistent regardless of the indexing mode configuration (Consistent or Lazy).</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>This also applies to queries from all interfaces – REST API, SDKs, and from within stored procedures and triggers.</source>
          <target state="new">This also applies to queries from all interfaces – REST API, SDKs, and from within stored procedures and triggers.</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Just like with Lazy indexing, index transformation is performed asynchronously in the background on the replicas using the spare resources available for a given replica.</source>
          <target state="new">Just like with Lazy indexing, index transformation is performed asynchronously in the background on the replicas using the spare resources available for a given replica.</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Index transformations are also made <bpt id="p1">**</bpt>in-situ<ept id="p1">**</ept> (in place), i.e. DocumentDB does not maintain two copies of the index and swap the old index out with the new one.</source>
          <target state="new">Index transformations are also made <bpt id="p1">**</bpt>in-situ<ept id="p1">**</ept> (in place), i.e. DocumentDB does not maintain two copies of the index and swap the old index out with the new one.</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>This means that no additional disk space is required or consumed in your collections while performing index transformations.</source>
          <target state="new">This means that no additional disk space is required or consumed in your collections while performing index transformations.</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>When you change indexing policy, how the changes are applied to move from the old index to the new one depend primarily on the indexing mode configurations more so than the other values like included/excluded paths, index kinds and precisions.</source>
          <target state="new">When you change indexing policy, how the changes are applied to move from the old index to the new one depend primarily on the indexing mode configurations more so than the other values like included/excluded paths, index kinds and precisions.</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>If both your old and new policies use consistent indexing, then DocumentDB performs an online index transformation.</source>
          <target state="new">If both your old and new policies use consistent indexing, then DocumentDB performs an online index transformation.</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>You cannot apply another indexing policy change with consistent indexing mode while the transformation is in progress.</source>
          <target state="new">You cannot apply another indexing policy change with consistent indexing mode while the transformation is in progress.</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>You can however move to Lazy or None indexing mode while a transformation is in progress.</source>
          <target state="new">You can however move to Lazy or None indexing mode while a transformation is in progress.</target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>When you move to Lazy, the index policy change is made effective immediately and DocumentDB starts recreating the index asynchronously.</source>
          <target state="new">When you move to Lazy, the index policy change is made effective immediately and DocumentDB starts recreating the index asynchronously.</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>When you move to None, then the index is dropped effective immediately.</source>
          <target state="new">When you move to None, then the index is dropped effective immediately.</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Moving to None is useful when you want to cancel an in progress transformation and start fresh with a different indexing policy.</source>
          <target state="new">Moving to None is useful when you want to cancel an in progress transformation and start fresh with a different indexing policy.</target>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>If you’re using the .NET SDK, you can kick of an indexing policy change using the new <bpt id="p1">**</bpt>ReplaceDocumentCollectionAsync<ept id="p1">**</ept> method and track the percentage progress of the index transformation using the <bpt id="p2">**</bpt>IndexTransformationProgress<ept id="p2">**</ept> response property from a <bpt id="p3">**</bpt>ReadDocumentCollectionAsync<ept id="p3">**</ept> call.</source>
          <target state="new">If you’re using the .NET SDK, you can kick of an indexing policy change using the new <bpt id="p1">**</bpt>ReplaceDocumentCollectionAsync<ept id="p1">**</ept> method and track the percentage progress of the index transformation using the <bpt id="p2">**</bpt>IndexTransformationProgress<ept id="p2">**</ept> response property from a <bpt id="p3">**</bpt>ReadDocumentCollectionAsync<ept id="p3">**</ept> call.</target>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Other SDKs and the REST API support equivalent properties and methods for making indexing policy changes.</source>
          <target state="new">Other SDKs and the REST API support equivalent properties and methods for making indexing policy changes.</target>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Here's a code snippet that shows how to modify a collection's indexing policy from Consistent indexing mode to Lazy.</source>
          <target state="new">Here's a code snippet that shows how to modify a collection's indexing policy from Consistent indexing mode to Lazy.</target>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Modify Indexing Policy from Consistent to Lazy</source>
          <target state="new">Modify Indexing Policy from Consistent to Lazy</target>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>You can check the progress of an index transformation by calling ReadDocumentCollectionAsync, for example, as shown below.</source>
          <target state="new">You can check the progress of an index transformation by calling ReadDocumentCollectionAsync, for example, as shown below.</target>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Track Progress of Index Transformation</source>
          <target state="new">Track Progress of Index Transformation</target>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>You can drop the index for a collection by moving to the None indexing mode.</source>
          <target state="new">You can drop the index for a collection by moving to the None indexing mode.</target>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>This might be a useful operational tool if you want to cancel an in-progress transformation and start a new one immediately.</source>
          <target state="new">This might be a useful operational tool if you want to cancel an in-progress transformation and start a new one immediately.</target>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Dropping the index for a collection</source>
          <target state="new">Dropping the index for a collection</target>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>When would you make indexing policy changes to your DocumentDB collections?</source>
          <target state="new">When would you make indexing policy changes to your DocumentDB collections?</target>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>The following are the most common use cases:</source>
          <target state="new">The following are the most common use cases:</target>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Serve consistent results during normal operation, but fall back to lazy indexing during bulk data imports</source>
          <target state="new">Serve consistent results during normal operation, but fall back to lazy indexing during bulk data imports</target>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Start using new indexing features on your current DocumentDB collections, e.g., like geospatial querying which require the Spatial index kind, or Order By/string range queries which require the string Range index kind</source>
          <target state="new">Start using new indexing features on your current DocumentDB collections, e.g., like geospatial querying which require the Spatial index kind, or Order By/string range queries which require the string Range index kind</target>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Hand select the properties to be indexed and change them over time</source>
          <target state="new">Hand select the properties to be indexed and change them over time</target>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Tune indexing precision to improve query performance or reduce storage consumed</source>
          <target state="new">Tune indexing precision to improve query performance or reduce storage consumed</target>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> To modify indexing policy using ReplaceDocumentCollectionAsync, you need version &gt;= 1.3.0 of the .NET SDK</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> To modify indexing policy using ReplaceDocumentCollectionAsync, you need version &gt;= 1.3.0 of the .NET SDK</target>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Performance tuning</source>
          <target state="new">Performance tuning</target>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The DocumentDB APIs provide information about performance metrics such as the index storage used, and the throughput cost (request units) for every operation.</source>
          <target state="new">The DocumentDB APIs provide information about performance metrics such as the index storage used, and the throughput cost (request units) for every operation.</target>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>This information can be used to compare various indexing policies and for performance tuning.</source>
          <target state="new">This information can be used to compare various indexing policies and for performance tuning.</target>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>To check the storage quota and usage of a collection, run a HEAD or GET request against the collection resource, and inspect the x-ms-request-quota and the x-ms-request-usage headers.</source>
          <target state="new">To check the storage quota and usage of a collection, run a HEAD or GET request against the collection resource, and inspect the x-ms-request-quota and the x-ms-request-usage headers.</target>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>In the .NET SDK, the <bpt id="p1">[</bpt>DocumentSizeQuota<ept id="p1">](http://msdn.microsoft.com/library/dn850325.aspx)</ept> and <bpt id="p2">[</bpt>DocumentSizeUsage<ept id="p2">](http://msdn.microsoft.com/library/azure/dn850324.aspx)</ept> properties in <bpt id="p3">[</bpt>ResourceResponse&lt;T\&gt;<ept id="p3">](http://msdn.microsoft.com/library/dn799209.aspx)</ept> contain these corresponding values.</source>
          <target state="new">In the .NET SDK, the <bpt id="p1">[</bpt>DocumentSizeQuota<ept id="p1">](http://msdn.microsoft.com/library/dn850325.aspx)</ept> and <bpt id="p2">[</bpt>DocumentSizeUsage<ept id="p2">](http://msdn.microsoft.com/library/azure/dn850324.aspx)</ept> properties in <bpt id="p3">[</bpt>ResourceResponse&lt;T\&gt;<ept id="p3">](http://msdn.microsoft.com/library/dn799209.aspx)</ept> contain these corresponding values.</target>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>To measure the overhead of indexing on each write operation (create, update, or delete), inspect the x-ms-request-charge header (or the equivalent <bpt id="p1">[</bpt>RequestCharge<ept id="p1">](http://msdn.microsoft.com/library/dn799099.aspx)</ept> property in <bpt id="p2">[</bpt>ResourceResponse&lt;T\&gt;<ept id="p2">](http://msdn.microsoft.com/library/dn799209.aspx)</ept> in the .NET SDK) to measure the number of request units consumed by these operations.</source>
          <target state="new">To measure the overhead of indexing on each write operation (create, update, or delete), inspect the x-ms-request-charge header (or the equivalent <bpt id="p1">[</bpt>RequestCharge<ept id="p1">](http://msdn.microsoft.com/library/dn799099.aspx)</ept> property in <bpt id="p2">[</bpt>ResourceResponse&lt;T\&gt;<ept id="p2">](http://msdn.microsoft.com/library/dn799209.aspx)</ept> in the .NET SDK) to measure the number of request units consumed by these operations.</target>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Changes to the indexing policy specification</source>
          <target state="new">Changes to the indexing policy specification</target>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>A change in the schema for indexing policy was introduced on July 7, 2015 with REST API version 2015-06-03.</source>
          <target state="new">A change in the schema for indexing policy was introduced on July 7, 2015 with REST API version 2015-06-03.</target>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>The corresponding classes in the SDK versions have new implementations to match the schema.</source>
          <target state="new">The corresponding classes in the SDK versions have new implementations to match the schema.</target>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The following changes were implemented in the JSON specification:</source>
          <target state="new">The following changes were implemented in the JSON specification:</target>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Indexing Policy supports Range indexes for strings</source>
          <target state="new">Indexing Policy supports Range indexes for strings</target>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Each path can have multiple index definitions, one for each data type</source>
          <target state="new">Each path can have multiple index definitions, one for each data type</target>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Indexing precision supports 1-8 for numbers, 1-100 for strings, and -1 (maximum precision)</source>
          <target state="new">Indexing precision supports 1-8 for numbers, 1-100 for strings, and -1 (maximum precision)</target>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Paths segments do not require a double quotation to escape each path.</source>
          <target state="new">Paths segments do not require a double quotation to escape each path.</target>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>For example, you can add a path for /title/?</source>
          <target state="new">For example, you can add a path for /title/?</target>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>instead of /"title"/?</source>
          <target state="new">instead of /"title"/?</target>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>The root path representing "all paths" can be represented as /* (in addition to /)</source>
          <target state="new">The root path representing "all paths" can be represented as /* (in addition to /)</target>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>If you have code that provisions collections with a custom indexing policy written with version 1.1.0 of the .NET SDK or older, you will need to change your application code to handle these changes in order to move to SDK version 1.2.0.</source>
          <target state="new">If you have code that provisions collections with a custom indexing policy written with version 1.1.0 of the .NET SDK or older, you will need to change your application code to handle these changes in order to move to SDK version 1.2.0.</target>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>If you do not have code that configures indexing policy, or plan to continue using an older SDK version, no changes are required.</source>
          <target state="new">If you do not have code that configures indexing policy, or plan to continue using an older SDK version, no changes are required.</target>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>For a practical comparison, here is one example custom indexing policy written using the REST API version 2015-06-03 as well as the previous version 2015-04-08.</source>
          <target state="new">For a practical comparison, here is one example custom indexing policy written using the REST API version 2015-06-03 as well as the previous version 2015-04-08.</target>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Previous Indexing Policy JSON</source>
          <target state="new">Previous Indexing Policy JSON</target>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Current Indexing Policy JSON</source>
          <target state="new">Current Indexing Policy JSON</target>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="new">Next Steps</target>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Follow the links below for index policy management samples and to learn more about DocumentDB's query language.</source>
          <target state="new">Follow the links below for index policy management samples and to learn more about DocumentDB's query language.</target>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>DocumentDB .NET Index Management code samples</source>
          <target state="new">DocumentDB .NET Index Management code samples</target>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>DocumentDB REST API Collection Operations</source>
          <target state="new">DocumentDB REST API Collection Operations</target>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Query with DocumentDB SQL</source>
          <target state="new">Query with DocumentDB SQL</target>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>test</source>
          <target state="new">test</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">59e85d61e8c841cec3cfffc41df9bf10b37c2787</xliffext:olfilehash>
  </header>
</xliff>