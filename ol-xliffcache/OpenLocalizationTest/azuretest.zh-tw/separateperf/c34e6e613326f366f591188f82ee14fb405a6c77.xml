{
  "nodes": [
    {
      "content": "App Model v2.0 | Microsoft Azure",
      "pos": [
        27,
        59
      ]
    },
    {
      "content": "How to build a NodeJS Web API accepts tokens from both personal Microsoft Account and work or school accounts.",
      "pos": [
        78,
        188
      ]
    },
    {
      "content": "App Model v2.0 Preview: Secure a Web API using node.js",
      "pos": [
        512,
        566
      ]
    },
    {
      "content": "This information applies to the v2.0 app model public preview.",
      "pos": [
        583,
        645
      ]
    },
    {
      "content": "For instructions on how to integrate with the generally available Azure AD service, please refer to the <bpt id=\"p1\">[</bpt>Azure Active Directory Developer Guide<ept id=\"p1\">](active-directory-developers-guide.md)</ept>.",
      "pos": [
        647,
        830
      ]
    },
    {
      "pos": [
        832,
        1094
      ],
      "content": "With the v2.0 app model, you can protecet a Web API using <bpt id=\"p1\">[</bpt>OAuth 2.0<ept id=\"p1\">](active-directory-v2-protocols.md#oauth2-authorization-code-flow)</ept> access tokens, enabling users with both personal Microsoft account and work or school accounts to securely access your Web API."
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Passport<ept id=\"p1\">**</ept> is authentication middleware for Node.js.",
      "pos": [
        1096,
        1150
      ]
    },
    {
      "content": "Extremely flexible and modular, Passport can be unobtrusively dropped in to any Express-based or Resitify web application.",
      "pos": [
        1151,
        1273
      ]
    },
    {
      "content": "A comprehensive set of strategies support authentication using a username and password, Facebook, Twitter, and more.",
      "pos": [
        1274,
        1390
      ]
    },
    {
      "content": "We have developed a strategy for Microsoft Azure Active Directory.",
      "pos": [
        1391,
        1457
      ]
    },
    {
      "content": "We will install this module and then add the Microsoft Azure Active Directory <ph id=\"ph1\">`passport-azure-ad`</ph> plug-in.",
      "pos": [
        1458,
        1564
      ]
    },
    {
      "content": "In order to do this, you’ll need to:",
      "pos": [
        1566,
        1602
      ]
    },
    {
      "content": "Register an application with Azure AD",
      "pos": [
        1607,
        1644
      ]
    },
    {
      "content": "Set up your app to use Passport's azure-ad-passport plug-in.",
      "pos": [
        1648,
        1708
      ]
    },
    {
      "content": "Configure a client application to call the To Do List Web API",
      "pos": [
        1712,
        1773
      ]
    },
    {
      "content": "The code for this tutorial is maintained <bpt id=\"p1\">[</bpt>on GitHub<ept id=\"p1\">](https://github.com/AzureADQuickStarts/AppModelv2-WebAPI-nodejs)</ept>.",
      "pos": [
        1775,
        1892
      ]
    },
    {
      "content": "To follow along, you can <bpt id=\"p1\">[</bpt>download the app's skeleton as a .zip<ept id=\"p1\">](https://github.com/AzureADQuickStarts/AppModelv2-WebAPI-nodejs/archive/skeleton.zip)</ept> or clone the skeleton:",
      "pos": [
        1894,
        2066
      ]
    },
    {
      "content": "The completed application is provided at the end of this tutorial as well.",
      "pos": [
        2170,
        2244
      ]
    },
    {
      "content": "1. Register an App",
      "pos": [
        2250,
        2268
      ]
    },
    {
      "content": "Create a new app at <bpt id=\"p1\">[</bpt>apps.dev.microsoft.com<ept id=\"p1\">](https://apps.dev.microsoft.com)</ept>, or follow these <bpt id=\"p2\">[</bpt>detailed steps<ept id=\"p2\">](active-directory-v2-app-registration.md)</ept>.",
      "pos": [
        2269,
        2421
      ]
    },
    {
      "content": "Make sure to:",
      "pos": [
        2423,
        2436
      ]
    },
    {
      "pos": [
        2440,
        2515
      ],
      "content": "Copy down the <bpt id=\"p1\">**</bpt>Application Id<ept id=\"p1\">**</ept> assigned to your app, you'll need it soon."
    },
    {
      "pos": [
        2518,
        2559
      ],
      "content": "Add the <bpt id=\"p1\">**</bpt>Mobile<ept id=\"p1\">**</ept> platform for your app."
    },
    {
      "content": "Copy down the <bpt id=\"p1\">**</bpt>Redirect URI<ept id=\"p1\">**</ept> from the portal.",
      "pos": [
        2562,
        2609
      ]
    },
    {
      "content": "You must use the default value of <ph id=\"ph1\">`urn:ietf:wg:oauth:2.0:oob`</ph>.",
      "pos": [
        2610,
        2672
      ]
    },
    {
      "content": "2: Download node.js for your platform",
      "pos": [
        2678,
        2715
      ]
    },
    {
      "content": "To successfully use this sample, you must have a working installation of Node.js.",
      "pos": [
        2716,
        2797
      ]
    },
    {
      "pos": [
        2799,
        2859
      ],
      "content": "Install Node.js from <bpt id=\"p1\">[</bpt>http://nodejs.org<ept id=\"p1\">](http://nodejs.org)</ept>."
    },
    {
      "content": "3: Install MongoDB on to your platform",
      "pos": [
        2864,
        2902
      ]
    },
    {
      "content": "To successfully use this sample, you must have a working installation of MongoDB.",
      "pos": [
        2904,
        2985
      ]
    },
    {
      "content": "We will use MongoDB to make our REST API persistant across server instances.",
      "pos": [
        2986,
        3062
      ]
    },
    {
      "pos": [
        3064,
        3130
      ],
      "content": "Install MongoDB from <bpt id=\"p1\">[</bpt>http://mongodb.org<ept id=\"p1\">](http://www.mongodb.org)</ept>."
    },
    {
      "pos": [
        3134,
        3301
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> This walkthrough assumes that you use the default installation and server endpoints for MongoDB, which at the time of this writing is: mongodb://localhost"
    },
    {
      "content": "4: Install the Restify modules in to your Web API",
      "pos": [
        3306,
        3355
      ]
    },
    {
      "content": "We will be using Resitfy to build our REST API.",
      "pos": [
        3357,
        3404
      ]
    },
    {
      "content": "Restify is a minimal and flexible Node.js application framework derived from Express that has a robust set of features for building REST APIs on top of Connect.",
      "pos": [
        3405,
        3565
      ]
    },
    {
      "content": "Install Restify",
      "pos": [
        3571,
        3586
      ]
    },
    {
      "content": "From the command-line, change directories to the azuread directory.",
      "pos": [
        3588,
        3655
      ]
    },
    {
      "content": "If the <bpt id=\"p1\">**</bpt>azuread<ept id=\"p1\">**</ept> directory does not exist, create it.",
      "pos": [
        3656,
        3711
      ]
    },
    {
      "pos": [
        3713,
        3748
      ],
      "content": "<ph id=\"ph1\">`cd azuread`</ph> - or- <ph id=\"ph2\">`mkdir azuread;`</ph>"
    },
    {
      "content": "Type the following command:",
      "pos": [
        3750,
        3777
      ]
    },
    {
      "content": "This command installs Restify.",
      "pos": [
        3802,
        3832
      ]
    },
    {
      "content": "Did you get an error?",
      "pos": [
        3839,
        3860
      ]
    },
    {
      "content": "When using npm on some operating systems, you may receive an error of Error: EPERM, chmod '/usr/local/bin/..'",
      "pos": [
        3862,
        3971
      ]
    },
    {
      "content": "and a request to try running the account as an administrator.",
      "pos": [
        3972,
        4033
      ]
    },
    {
      "content": "If this occurs, use the sudo command to run npm at a higher privilege level.",
      "pos": [
        4034,
        4110
      ]
    },
    {
      "content": "Did you get an error regarding DTrace?",
      "pos": [
        4117,
        4155
      ]
    },
    {
      "content": "You may see something like this when installing Restify:",
      "pos": [
        4157,
        4213
      ]
    },
    {
      "content": "Restify provides a powerful mechanism to trace REST calls using DTrace.",
      "pos": [
        5111,
        5182
      ]
    },
    {
      "content": "However, many operating systems do not have DTrace available.",
      "pos": [
        5183,
        5244
      ]
    },
    {
      "content": "You can safely ignore these errors.",
      "pos": [
        5245,
        5280
      ]
    },
    {
      "content": "The output of this command should appear similar to the following:",
      "pos": [
        5283,
        5349
      ]
    },
    {
      "content": "5: Install Passport.js into your Web API",
      "pos": [
        5929,
        5969
      ]
    },
    {
      "content": "<bpt id=\"p1\">[</bpt>Passport<ept id=\"p1\">](http://passportjs.org/)</ept> is authentication middleware for Node.js.",
      "pos": [
        5971,
        6047
      ]
    },
    {
      "content": "Extremely flexible and modular, Passport can be unobtrusively dropped in to any Express-based or Resitify web application.",
      "pos": [
        6048,
        6170
      ]
    },
    {
      "content": "A comprehensive set of strategies support authentication using a username and password, Facebook, Twitter, and more.",
      "pos": [
        6171,
        6287
      ]
    },
    {
      "content": "We have developed a strategy for Azure Active Directory.",
      "pos": [
        6288,
        6344
      ]
    },
    {
      "content": "We will install this module and then add the Azure Active Directory strategy plug-in.",
      "pos": [
        6345,
        6430
      ]
    },
    {
      "content": "From the command-line, change directories to the azuread directory.",
      "pos": [
        6432,
        6499
      ]
    },
    {
      "content": "Enter the following command to install passport.js",
      "pos": [
        6501,
        6551
      ]
    },
    {
      "content": "The output of the commadn should appear similar to the following:",
      "pos": [
        6577,
        6642
      ]
    },
    {
      "content": "6: Add Passport-Azure-AD to your Web API",
      "pos": [
        6732,
        6772
      ]
    },
    {
      "content": "Next, we will add the OAuth strategy, using passport-azuread, a suite of strategies that connect Azure Active Directory with  Passport.",
      "pos": [
        6774,
        6909
      ]
    },
    {
      "content": "We will use this strategy for Bearer Tokens in this Rest API sample.",
      "pos": [
        6910,
        6978
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> Although OAuth2 provides a framework in which any known token type can be issued, only certain token types have gained wide-spread use.",
      "pos": [
        6982,
        7130
      ]
    },
    {
      "content": "For protecting endpoints, that has turned out to be Bearer Tokens.",
      "pos": [
        7131,
        7197
      ]
    },
    {
      "content": "Bearer tokens are the most widely issued type of token in OAuth2, and many implementations assume that bearer tokens are the only type of token issued.",
      "pos": [
        7198,
        7349
      ]
    },
    {
      "content": "From the command-line, change directories to the azuread directory",
      "pos": [
        7351,
        7417
      ]
    },
    {
      "content": "Type the following command to install Passport.js passport-azure-ad module:",
      "pos": [
        7419,
        7494
      ]
    },
    {
      "content": "The output of the command should appear similar to the following:",
      "pos": [
        7529,
        7594
      ]
    },
    {
      "content": "7: Add MongoDB modules to your Web API",
      "pos": [
        8350,
        8388
      ]
    },
    {
      "content": "We will be using MongoDB as our datastore For that reason, we need to install both the widely used plug-in to manage models and schemas called Mongoose, as well as the database driver for MongoDB, also called MongoDB.",
      "pos": [
        8390,
        8607
      ]
    },
    {
      "content": "8: Install additional modules",
      "pos": [
        8663,
        8692
      ]
    },
    {
      "content": "Next, we'll install the remaining required modules.",
      "pos": [
        8694,
        8745
      ]
    },
    {
      "pos": [
        8748,
        8837
      ],
      "content": "From the command-line, change directories to the <bpt id=\"p1\">**</bpt>azuread<ept id=\"p1\">**</ept> folder if not already there:"
    },
    {
      "content": "Enter the following commands to install the following modules in your node_modules directory:",
      "pos": [
        8854,
        8947
      ]
    },
    {
      "content": "9: Create a server.js with your dependencies",
      "pos": [
        9470,
        9514
      ]
    },
    {
      "content": "The server.js file will be providing the majority of our functionality for our Web API server.",
      "pos": [
        9516,
        9610
      ]
    },
    {
      "content": "We will be adding most of our code to this file.",
      "pos": [
        9611,
        9659
      ]
    },
    {
      "content": "For production purposes you would refactor the functionality in to smaller files, such as separate routes and controllers.",
      "pos": [
        9660,
        9782
      ]
    },
    {
      "content": "For the purpose of this demo we will use server.js for this functionality.",
      "pos": [
        9783,
        9857
      ]
    },
    {
      "pos": [
        9859,
        9948
      ],
      "content": "From the command-line, change directories to the <bpt id=\"p1\">**</bpt>azuread<ept id=\"p1\">**</ept> folder if not already there:"
    },
    {
      "pos": [
        9964,
        10047
      ],
      "content": "Create a <ph id=\"ph1\">`server.js`</ph> file in our favorite editor and add the following information:"
    },
    {
      "content": "Save the file.",
      "pos": [
        10418,
        10432
      ]
    },
    {
      "content": "We will return to it shortly.",
      "pos": [
        10433,
        10462
      ]
    },
    {
      "content": "10: Create a config file to store your Azure AD settings",
      "pos": [
        10467,
        10523
      ]
    },
    {
      "content": "This code file passes the configuration parameters from your Azure Active Directory Portal to Passport.js.",
      "pos": [
        10525,
        10631
      ]
    },
    {
      "content": "You created these configuration values when you added the Web API to the portal in the first part of the walkthrough.",
      "pos": [
        10632,
        10749
      ]
    },
    {
      "content": "We will explain what to put in the values of these parameters after you've copied the code.",
      "pos": [
        10750,
        10841
      ]
    },
    {
      "pos": [
        10844,
        10933
      ],
      "content": "From the command-line, change directories to the <bpt id=\"p1\">**</bpt>azuread<ept id=\"p1\">**</ept> folder if not already there:"
    },
    {
      "pos": [
        10949,
        11032
      ],
      "content": "Create a <ph id=\"ph1\">`config.js`</ph> file in our favorite editor and add the following information:"
    },
    {
      "content": "Required Values",
      "pos": [
        11494,
        11509
      ]
    },
    {
      "content": "<bpt id=\"p1\">*</bpt>IdentityMetadata<ept id=\"p1\">*</ept>: This is where passport-azure-ad will look for your configuration data for the IdP as well as the keys to validate the JWT tokens.",
      "pos": [
        11511,
        11660
      ]
    },
    {
      "content": "You probably do not want to change this if using Azure Active Directory.",
      "pos": [
        11661,
        11733
      ]
    },
    {
      "pos": [
        11735,
        11781
      ],
      "content": "<bpt id=\"p1\">*</bpt>audience<ept id=\"p1\">*</ept>: Your redirect URI from the portal."
    },
    {
      "content": "We roll our keys at frequent intervals.",
      "pos": [
        11799,
        11838
      ]
    },
    {
      "content": "Please ensure that you are always pulling from the \"openid_keys\" URL and that the app can access the internet.",
      "pos": [
        11839,
        11949
      ]
    },
    {
      "content": "11: Add configuration to your server.js file",
      "pos": [
        11955,
        11999
      ]
    },
    {
      "content": "We need to read these values from the Config file you just created across our application.",
      "pos": [
        12001,
        12091
      ]
    },
    {
      "content": "To do this, we simply add the .config file as a required resource in our application and then set the global variables to those in the config.js document",
      "pos": [
        12092,
        12245
      ]
    },
    {
      "pos": [
        12247,
        12336
      ],
      "content": "From the command-line, change directories to the <bpt id=\"p1\">**</bpt>azuread<ept id=\"p1\">**</ept> folder if not already there:"
    },
    {
      "pos": [
        12352,
        12436
      ],
      "content": "Open your <ph id=\"ph1\">`server.js`</ph> file in our favorite editor and add the following information:"
    },
    {
      "pos": [
        12490,
        12553
      ],
      "content": "Then, add a new section to <ph id=\"ph1\">`server.js`</ph> with the following code:"
    },
    {
      "content": "Step 12: Add The MongoDB Model and Schema Information using Moongoose",
      "pos": [
        13120,
        13189
      ]
    },
    {
      "content": "Now all this preparation is going to start paying off as we wind these three files together in to a REST API service.",
      "pos": [
        13191,
        13308
      ]
    },
    {
      "pos": [
        13310,
        13404
      ],
      "content": "For this walkthrough we will be using MongoDB to store our Tasks as discussed in <bpt id=\"p1\">***</bpt>Step 4<ept id=\"p1\">***</ept>."
    },
    {
      "content": "If you recall from the config.js file we created in Step 11, we called our database <bpt id=\"p1\">*</bpt>tasklist<ept id=\"p1\">*</ept>, as that was what we put at the end of our mogoose_auth_local connection URL.",
      "pos": [
        13406,
        13578
      ]
    },
    {
      "content": "You don't need to create this database beforehand in MongoDB, it will create this for us on first run of our server application (assuming it does not already exist).",
      "pos": [
        13579,
        13744
      ]
    },
    {
      "content": "Now that we've told the server what MongoDB database we'd like to use, we need to write some additional code to create the model and schema for our server's Tasks.",
      "pos": [
        13746,
        13909
      ]
    },
    {
      "content": "Discussion of the model",
      "pos": [
        13916,
        13939
      ]
    },
    {
      "content": "Our Schema model is very simple, and you expand it as required.",
      "pos": [
        13941,
        14004
      ]
    },
    {
      "content": "NAME - The name of who is assigned to the task.",
      "pos": [
        14006,
        14053
      ]
    },
    {
      "content": "A <bpt id=\"p1\">***</bpt>String<ept id=\"p1\">***</ept>",
      "pos": [
        14054,
        14068
      ]
    },
    {
      "content": "TASK - The task itself.",
      "pos": [
        14070,
        14093
      ]
    },
    {
      "content": "A <bpt id=\"p1\">***</bpt>String<ept id=\"p1\">***</ept>",
      "pos": [
        14094,
        14108
      ]
    },
    {
      "content": "DATE - The date that the task is due.",
      "pos": [
        14110,
        14147
      ]
    },
    {
      "content": "A <bpt id=\"p1\">***</bpt>DATETIME<ept id=\"p1\">***</ept>",
      "pos": [
        14148,
        14164
      ]
    },
    {
      "content": "COMPLETED - If the Task is completed or not.",
      "pos": [
        14166,
        14210
      ]
    },
    {
      "content": "A <bpt id=\"p1\">***</bpt>BOOLEAN<ept id=\"p1\">***</ept>",
      "pos": [
        14211,
        14226
      ]
    },
    {
      "content": "Creating the schema in the code",
      "pos": [
        14233,
        14264
      ]
    },
    {
      "pos": [
        14267,
        14356
      ],
      "content": "From the command-line, change directories to the <bpt id=\"p1\">**</bpt>azuread<ept id=\"p1\">**</ept> folder if not already there:"
    },
    {
      "pos": [
        14372,
        14486
      ],
      "content": "Open your <ph id=\"ph1\">`server.js`</ph> file in our favorite editor and add the following information below the configuration entry:"
    },
    {
      "content": "This will connect to the MongoDB server and hand back a Schema object to us.",
      "pos": [
        14830,
        14906
      ]
    },
    {
      "content": "Using the Schema, create our model in the code",
      "pos": [
        14913,
        14959
      ]
    },
    {
      "content": "Below the code you wrote above, add the following code:",
      "pos": [
        14961,
        15016
      ]
    },
    {
      "pos": [
        15326,
        15491
      ],
      "content": "As you can tell from the code, we create our Schema and then create a model object we will use to store our data throughout the code when we define our <bpt id=\"p1\">***</bpt>Routes<ept id=\"p1\">***</ept>."
    },
    {
      "content": "Step 13: Add our Routes for our Task REST API server",
      "pos": [
        15496,
        15548
      ]
    },
    {
      "content": "Now that we have a database model to work with, let's add the routes we will use for our REST API server.",
      "pos": [
        15550,
        15655
      ]
    },
    {
      "content": "About Routes in Restify",
      "pos": [
        15661,
        15684
      ]
    },
    {
      "content": "Routes work in Restify in the exact same way they do using the Express stack.",
      "pos": [
        15686,
        15763
      ]
    },
    {
      "content": "You define routes using the URI that you expect the client applicaitons to call.",
      "pos": [
        15764,
        15844
      ]
    },
    {
      "content": "Usually, you define your routes in a separate file.",
      "pos": [
        15845,
        15896
      ]
    },
    {
      "content": "For our purposes, we will put our routes in the server.js file.",
      "pos": [
        15897,
        15960
      ]
    },
    {
      "content": "We recommend you factor these in to their own file for production use.",
      "pos": [
        15961,
        16031
      ]
    },
    {
      "content": "A typical pattern for a Restify Route is:",
      "pos": [
        16033,
        16074
      ]
    },
    {
      "content": "This is the pattern at the most basic level.",
      "pos": [
        16392,
        16436
      ]
    },
    {
      "content": "Resitfy (and Express) provide much deeper functionaltiy such as defining application types and doing complex routing across different endpoints.",
      "pos": [
        16437,
        16581
      ]
    },
    {
      "content": "For our purposes, we will keep these routes very simply.",
      "pos": [
        16582,
        16638
      ]
    },
    {
      "content": "Add default routes to our server",
      "pos": [
        16645,
        16677
      ]
    },
    {
      "content": "We will now add the basic CRUD routes of Create, Retrieve, Update, and Delete.",
      "pos": [
        16679,
        16757
      ]
    },
    {
      "pos": [
        16759,
        16848
      ],
      "content": "From the command-line, change directories to the <bpt id=\"p1\">**</bpt>azuread<ept id=\"p1\">**</ept> folder if not already there:"
    },
    {
      "pos": [
        16864,
        16990
      ],
      "content": "Open your <ph id=\"ph1\">`server.js`</ph> file in our favorite editor and add the following information below the database entries you made above:"
    },
    {
      "content": "Add some error handling for the routes",
      "pos": [
        19304,
        19342
      ]
    },
    {
      "content": "It makes sense to add some error handling so we can communicate back to the client the problem we encountered in a way it can understand.",
      "pos": [
        19344,
        19481
      ]
    },
    {
      "content": "Add the following code underneath the code you've written above:",
      "pos": [
        19483,
        19547
      ]
    },
    {
      "content": "Step 14: Create your Server!",
      "pos": [
        20509,
        20537
      ]
    },
    {
      "content": "We have our database defined, we have our routes in place, and the last thing to do is add our server instance that will manage our calls.",
      "pos": [
        20539,
        20677
      ]
    },
    {
      "content": "Restify (and Express) have a lot of deep customization you can do for a REST API server, but again we will use the most basic setup for our purposes.",
      "pos": [
        20679,
        20828
      ]
    },
    {
      "content": "15: Adding the routes (without authentication for now)",
      "pos": [
        21694,
        21748
      ]
    },
    {
      "content": "16: Before we add OAuth support, let's run the server.",
      "pos": [
        23470,
        23524
      ]
    },
    {
      "content": "Test out your server before we add authentication",
      "pos": [
        23526,
        23575
      ]
    },
    {
      "content": "The easiest way to do this is by using curl in a command line.",
      "pos": [
        23577,
        23639
      ]
    },
    {
      "content": "Before we do that, we need a simple utility that allows us to parse output as JSON.",
      "pos": [
        23640,
        23723
      ]
    },
    {
      "content": "To do that, install the json tool as all the examples below use that.",
      "pos": [
        23724,
        23793
      ]
    },
    {
      "content": "This installs the JSON tool globally.",
      "pos": [
        23823,
        23860
      ]
    },
    {
      "content": "Now that we’ve accomplished that – let’s play with the server:",
      "pos": [
        23861,
        23923
      ]
    },
    {
      "content": "First, make sure that your monogoDB isntance is running..",
      "pos": [
        23925,
        23982
      ]
    },
    {
      "content": "Then, change to the directory and start curling..",
      "pos": [
        24000,
        24049
      ]
    },
    {
      "content": "Then, we can add a task this way:",
      "pos": [
        24422,
        24455
      ]
    },
    {
      "content": "The response should be:",
      "pos": [
        24522,
        24545
      ]
    },
    {
      "content": "And we can list tasks for Brandon this way:",
      "pos": [
        24785,
        24828
      ]
    },
    {
      "content": "If all this works out, we are ready to add OAuth to the REST API server.",
      "pos": [
        24882,
        24954
      ]
    },
    {
      "content": "You have a REST API server with MongoDB!",
      "pos": [
        24958,
        24998
      ]
    },
    {
      "content": "17: Add Authentication to our REST API Server",
      "pos": [
        25005,
        25050
      ]
    },
    {
      "content": "Now that we have a running REST API (congrats, btw!) let's get to making it useful against Azure AD.",
      "pos": [
        25052,
        25152
      ]
    },
    {
      "pos": [
        25154,
        25243
      ],
      "content": "From the command-line, change directories to the <bpt id=\"p1\">**</bpt>azuread<ept id=\"p1\">**</ept> folder if not already there:"
    },
    {
      "content": "1: Use the oidcbearerstrategy that is included with passport-azure-ad",
      "pos": [
        25263,
        25332
      ]
    },
    {
      "content": "So far we have built a typical REST TODO server without any kind of authorization.",
      "pos": [
        25334,
        25416
      ]
    },
    {
      "content": "This is where we start putting that together.",
      "pos": [
        25417,
        25462
      ]
    },
    {
      "content": "First, we need to indicate that we want to use Passport.",
      "pos": [
        25464,
        25520
      ]
    },
    {
      "content": "Put this right after your other server configuration:",
      "pos": [
        25521,
        25574
      ]
    },
    {
      "content": "When writing APIs you should always link the data to something unique from the token that the user can’t spoof.",
      "pos": [
        25758,
        25869
      ]
    },
    {
      "content": "When this server stores TODO items, it stores them based on the subscription ID of the user in the token (called through token.sub) which we put in the “owner” field.",
      "pos": [
        25870,
        26036
      ]
    },
    {
      "content": "This ensures that only that user can access his TODOs and no one else can access the TODOs entered.",
      "pos": [
        26037,
        26136
      ]
    },
    {
      "content": "There is no exposure in the API of “owner” so an external user can request other’s TODOs even if they are authenticated.",
      "pos": [
        26137,
        26257
      ]
    },
    {
      "content": "Next, let’s use the Open ID Connect Bearer strategy that comes with passport-azure-ad.",
      "pos": [
        26259,
        26345
      ]
    },
    {
      "content": "Just look at the code for now, I’ll explain it shortly.",
      "pos": [
        26346,
        26401
      ]
    },
    {
      "content": "Put this after what you pated above:",
      "pos": [
        26402,
        26438
      ]
    },
    {
      "content": "Passport uses a similar pattern for all it’s Strategies (Twitter, Facebook, etc.) that all Strategy writers adhere to.",
      "pos": [
        27491,
        27609
      ]
    },
    {
      "content": "Looking at the strategy you see we pass it a function() that has a token and a done as the parameters.",
      "pos": [
        27610,
        27712
      ]
    },
    {
      "content": "The strategy will dutifully come back to us once it does all it’s work.",
      "pos": [
        27713,
        27784
      ]
    },
    {
      "content": "Once it does we’ll want to store the user and stash the token so we won’t need to ask for it again.",
      "pos": [
        27785,
        27884
      ]
    },
    {
      "content": "The code above takes any user that happens to authenticate to our server.",
      "pos": [
        27907,
        27980
      ]
    },
    {
      "content": "This is known as auto registration.",
      "pos": [
        27981,
        28016
      ]
    },
    {
      "content": "In production servers you wouldn’t want to let anyone in without first having them go through a registration process you decide.",
      "pos": [
        28017,
        28145
      ]
    },
    {
      "content": "This is usually the pattern you see in consumer apps who allow you to register with Facebook but then ask you to fill out additional information.",
      "pos": [
        28146,
        28291
      ]
    },
    {
      "content": "If this wasn’t a command line program, we could have just extracted the email from the token object that is returned and then asked them to fill out additional information.",
      "pos": [
        28292,
        28464
      ]
    },
    {
      "content": "Since this is a test server we simply add them to the in-memory database.",
      "pos": [
        28465,
        28538
      ]
    },
    {
      "content": "2. Finally, protect some endpoints",
      "pos": [
        28544,
        28578
      ]
    },
    {
      "content": "You protect endpoints by specifying the passport.authenticate() call with the protocol you wish to use.",
      "pos": [
        28580,
        28683
      ]
    },
    {
      "content": "Let’s edit our route in our server code to do something more interesting:",
      "pos": [
        28685,
        28758
      ]
    },
    {
      "content": "18: Run your server application again and ensure it rejects you",
      "pos": [
        29804,
        29867
      ]
    },
    {
      "content": "Let's use <ph id=\"ph1\">`curl`</ph> again to see if we now have OAuth2 protection against our endpoints.",
      "pos": [
        29869,
        29954
      ]
    },
    {
      "content": "We will do this before runnning any of our client SDKs against this endpoint.",
      "pos": [
        29955,
        30032
      ]
    },
    {
      "content": "The headers returned should be enough to tell us we are down the right path.",
      "pos": [
        30033,
        30109
      ]
    },
    {
      "content": "First, make sure that your monogoDB isntance is running..",
      "pos": [
        30111,
        30168
      ]
    },
    {
      "content": "Then, change to the directory and start curling..",
      "pos": [
        30188,
        30237
      ]
    },
    {
      "content": "Try a basic POST:",
      "pos": [
        30278,
        30295
      ]
    },
    {
      "content": "A 401 is the response you are looking for here, as that indicates that the Passport layer is trying to redirect to the authorize endpoint, which is exactly what you want.",
      "pos": [
        30522,
        30692
      ]
    },
    {
      "content": "Congratulations!",
      "pos": [
        30698,
        30714
      ]
    },
    {
      "content": "You have a REST API Service using OAuth2!",
      "pos": [
        30715,
        30756
      ]
    },
    {
      "content": "You've went as far as you can with this server without using an OAuth2 compatible client.",
      "pos": [
        30758,
        30847
      ]
    },
    {
      "content": "You will need to go through an additional walkthrough.",
      "pos": [
        30848,
        30902
      ]
    },
    {
      "content": "If you were just looking for information on how to implement a REST API using Restify and OAuth2, you have more than enough code to keep developing your service and learning how to build on this example.",
      "pos": [
        30904,
        31107
      ]
    },
    {
      "content": "Next Steps",
      "pos": [
        31112,
        31122
      ]
    },
    {
      "pos": [
        31124,
        31343
      ],
      "content": "For reference, the completed sample (without your configuration values) <bpt id=\"p1\">[</bpt>is provided as a .zip here<ept id=\"p1\">](https://github.com/AzureADQuickStarts/AppModelv2-WebAPI-nodejs/archive/complete.zip)</ept>, or you can clone it from GitHub:"
    },
    {
      "content": "You can now move onto more advanced topics.",
      "pos": [
        31447,
        31490
      ]
    },
    {
      "content": "You may want to try:",
      "pos": [
        31492,
        31512
      ]
    },
    {
      "content": "Secure a Web App with the v2.0 app model in Node.js &gt;&gt;",
      "pos": [
        31515,
        31569
      ]
    },
    {
      "content": "For additional resources, check out:",
      "pos": [
        31620,
        31656
      ]
    },
    {
      "content": "The App Model v2.0 Preview &gt;&gt;",
      "pos": [
        31660,
        31689
      ]
    },
    {
      "content": "StackOverflow \"azure-active-directory\" tag &gt;&gt;",
      "pos": [
        31736,
        31781
      ]
    },
    {
      "content": "test",
      "pos": [
        31850,
        31854
      ]
    }
  ],
  "content": "<properties\n    pageTitle=\"App Model v2.0 | Microsoft Azure\"\n    description=\"How to build a NodeJS Web API accepts tokens from both personal Microsoft Account and work or school accounts.\"\n    services=\"active-directory\"\n    documentationCenter=\"nodejs\"\n    authors=\"brandwe\"\n    manager=\"mbaldwin\"\n    editor=\"\"/>\n\n<tags\n    ms.service=\"active-directory\"\n    ms.workload=\"identity\"\n    ms.tgt_pltfrm=\"na\"\n    ms.devlang=\"javascript\"\n    ms.topic=\"article\"\n    ms.date=\"08/25/2015\"\n    ms.author=\"brandwe\"/>\n\n# App Model v2.0 Preview: Secure a Web API using node.js\n\n> [AZURE.NOTE]\nThis information applies to the v2.0 app model public preview.  For instructions on how to integrate with the generally available Azure AD service, please refer to the [Azure Active Directory Developer Guide](active-directory-developers-guide.md).\n\nWith the v2.0 app model, you can protecet a Web API using [OAuth 2.0](active-directory-v2-protocols.md#oauth2-authorization-code-flow) access tokens, enabling users with both personal Microsoft account and work or school accounts to securely access your Web API.\n\n**Passport** is authentication middleware for Node.js. Extremely flexible and modular, Passport can be unobtrusively dropped in to any Express-based or Resitify web application. A comprehensive set of strategies support authentication using a username and password, Facebook, Twitter, and more. We have developed a strategy for Microsoft Azure Active Directory. We will install this module and then add the Microsoft Azure Active Directory `passport-azure-ad` plug-in.\n\nIn order to do this, you’ll need to:\n\n1. Register an application with Azure AD\n2. Set up your app to use Passport's azure-ad-passport plug-in.\n3. Configure a client application to call the To Do List Web API\n\nThe code for this tutorial is maintained [on GitHub](https://github.com/AzureADQuickStarts/AppModelv2-WebAPI-nodejs).  To follow along, you can [download the app's skeleton as a .zip](https://github.com/AzureADQuickStarts/AppModelv2-WebAPI-nodejs/archive/skeleton.zip) or clone the skeleton:\n\n```git clone --branch skeleton https://github.com/AzureADQuickStarts/AppModelv2-WebAPI-nodejs.git```\n\nThe completed application is provided at the end of this tutorial as well.\n\n\n## 1. Register an App\nCreate a new app at [apps.dev.microsoft.com](https://apps.dev.microsoft.com), or follow these [detailed steps](active-directory-v2-app-registration.md).  Make sure to:\n\n- Copy down the **Application Id** assigned to your app, you'll need it soon.\n- Add the **Mobile** platform for your app.\n- Copy down the **Redirect URI** from the portal. You must use the default value of `urn:ietf:wg:oauth:2.0:oob`.\n\n\n## 2: Download node.js for your platform\nTo successfully use this sample, you must have a working installation of Node.js.\n\nInstall Node.js from [http://nodejs.org](http://nodejs.org).\n\n## 3: Install MongoDB on to your platform\n\nTo successfully use this sample, you must have a working installation of MongoDB. We will use MongoDB to make our REST API persistant across server instances.\n\nInstall MongoDB from [http://mongodb.org](http://www.mongodb.org).\n\n> [AZURE.NOTE] This walkthrough assumes that you use the default installation and server endpoints for MongoDB, which at the time of this writing is: mongodb://localhost\n\n## 4: Install the Restify modules in to your Web API\n\nWe will be using Resitfy to build our REST API. Restify is a minimal and flexible Node.js application framework derived from Express that has a robust set of features for building REST APIs on top of Connect.\n\n### Install Restify\n\nFrom the command-line, change directories to the azuread directory. If the **azuread** directory does not exist, create it.\n\n`cd azuread` - or- `mkdir azuread;`\n\nType the following command:\n\n`npm install restify`\n\nThis command installs Restify.\n\n#### Did you get an error?\n\nWhen using npm on some operating systems, you may receive an error of Error: EPERM, chmod '/usr/local/bin/..' and a request to try running the account as an administrator. If this occurs, use the sudo command to run npm at a higher privilege level.\n\n#### Did you get an error regarding DTrace?\n\nYou may see something like this when installing Restify:\n\n```Shell\nclang: error: no such file or directory: 'HD/azuread/node_modules/restify/node_modules/dtrace-provider/libusdt'\nmake: *** [Release/DTraceProviderBindings.node] Error 1\ngyp ERR! build error\ngyp ERR! stack Error: `make` failed with exit code: 2\ngyp ERR! stack     at ChildProcess.onExit (/usr/local/lib/node_modules/npm/node_modules/node-gyp/lib/build.js:267:23)\ngyp ERR! stack     at ChildProcess.EventEmitter.emit (events.js:98:17)\ngyp ERR! stack     at Process.ChildProcess._handle.onexit (child_process.js:789:12)\ngyp ERR! System Darwin 13.1.0\ngyp ERR! command \"node\" \"/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js\" \"rebuild\"\ngyp ERR! cwd /Volumes/Development HD/azuread/node_modules/restify/node_modules/dtrace-provider\ngyp ERR! node -v v0.10.11\ngyp ERR! node-gyp -v v0.10.0\ngyp ERR! not ok\nnpm WARN optional dep failed, continuing dtrace-provider@0.2.8\n```\n\n\nRestify provides a powerful mechanism to trace REST calls using DTrace. However, many operating systems do not have DTrace available. You can safely ignore these errors.\n\n\nThe output of this command should appear similar to the following:\n\n\n    restify@2.6.1 node_modules/restify\n    ├── assert-plus@0.1.4\n    ├── once@1.3.0\n    ├── deep-equal@0.0.0\n    ├── escape-regexp-component@1.0.2\n    ├── qs@0.6.5\n    ├── tunnel-agent@0.3.0\n    ├── keep-alive-agent@0.0.1\n    ├── lru-cache@2.3.1\n    ├── node-uuid@1.4.0\n    ├── negotiator@0.3.0\n    ├── mime@1.2.11\n    ├── semver@2.2.1\n    ├── spdy@1.14.12\n    ├── backoff@2.3.0\n    ├── formidable@1.0.14\n    ├── verror@1.3.6 (extsprintf@1.0.2)\n    ├── csv@0.3.6\n    ├── http-signature@0.10.0 (assert-plus@0.1.2, asn1@0.1.11, ctype@0.5.2)\n    └── bunyan@0.22.0 (mv@0.0.5)\n\n\n## 5: Install Passport.js into your Web API\n\n[Passport](http://passportjs.org/) is authentication middleware for Node.js. Extremely flexible and modular, Passport can be unobtrusively dropped in to any Express-based or Resitify web application. A comprehensive set of strategies support authentication using a username and password, Facebook, Twitter, and more. We have developed a strategy for Azure Active Directory. We will install this module and then add the Azure Active Directory strategy plug-in.\n\nFrom the command-line, change directories to the azuread directory.\n\nEnter the following command to install passport.js\n\n`npm install passport`\n\nThe output of the commadn should appear similar to the following:\n\n    passport@0.1.17 node_modules\\passport\n    ├── pause@0.0.1\n    └── pkginfo@0.2.3\n\n## 6: Add Passport-Azure-AD to your Web API\n\nNext, we will add the OAuth strategy, using passport-azuread, a suite of strategies that connect Azure Active Directory with  Passport. We will use this strategy for Bearer Tokens in this Rest API sample.\n\n> [AZURE.NOTE] Although OAuth2 provides a framework in which any known token type can be issued, only certain token types have gained wide-spread use. For protecting endpoints, that has turned out to be Bearer Tokens. Bearer tokens are the most widely issued type of token in OAuth2, and many implementations assume that bearer tokens are the only type of token issued.\n\nFrom the command-line, change directories to the azuread directory\n\nType the following command to install Passport.js passport-azure-ad module:\n\n`npm install passport-azure-ad`\n\nThe output of the command should appear similar to the following:\n\n``\npassport-azure-ad@1.0.0 node_modules/passport-azure-ad\n├── xtend@4.0.0\n├── xmldom@0.1.19\n├── passport-http-bearer@1.0.1 (passport-strategy@1.0.0)\n├── underscore@1.8.3\n├── async@1.3.0\n├── jsonwebtoken@5.0.2\n├── xml-crypto@0.5.27 (xpath.js@1.0.6)\n├── ursa@0.8.5 (bindings@1.2.1, nan@1.8.4)\n├── jws@3.0.0 (jwa@1.0.1, base64url@1.0.4)\n├── request@2.58.0 (caseless@0.10.0, aws-sign2@0.5.0, forever-agent@0.6.1, stringstream@0.0.4, tunnel-agent@0.4.1, oauth-sign@0.8.0, isstream@0.1.2, extend@2.0.1, json-stringify-safe@5.0.1, node-uuid@1.4.3, qs@3.1.0, combined-stream@1.0.5, mime-types@2.0.14, form-data@1.0.0-rc1, http-signature@0.11.0, bl@0.9.4, tough-cookie@2.0.0, hawk@2.3.1, har-validator@1.8.0)\n└── xml2js@0.4.9 (sax@0.6.1, xmlbuilder@2.6.4)\n``\n\n## 7: Add MongoDB modules to your Web API\n\nWe will be using MongoDB as our datastore For that reason, we need to install both the widely used plug-in to manage models and schemas called Mongoose, as well as the database driver for MongoDB, also called MongoDB.\n\n\n* `npm install mongoose`\n* `npm install mongodb`\n\n## 8: Install additional modules\n\nNext, we'll install the remaining required modules.\n\n\nFrom the command-line, change directories to the **azuread** folder if not already there:\n\n`cd azuread`\n\n\nEnter the following commands to install the following modules in your node_modules directory:\n\n* `npm install crypto`\n* `npm install assert-plus`\n* `npm install posix-getopt`\n* `npm install util`\n* `npm install path`\n* `npm install connect`\n* `npm install xml-crypto`\n* `npm install xml2js`\n* `npm install xmldom`\n* `npm install async`\n* `npm install request`\n* `npm install underscore`\n* `npm install grunt-contrib-jshint@0.1.1`\n* `npm install grunt-contrib-nodeunit@0.1.2`\n* `npm install grunt-contrib-watch@0.2.0`\n* `npm install grunt@0.4.1`\n* `npm install xtend@2.0.3`\n* `npm install bunyan`\n* `npm update`\n\n\n## 9: Create a server.js with your dependencies\n\nThe server.js file will be providing the majority of our functionality for our Web API server. We will be adding most of our code to this file. For production purposes you would refactor the functionality in to smaller files, such as separate routes and controllers. For the purpose of this demo we will use server.js for this functionality.\n\nFrom the command-line, change directories to the **azuread** folder if not already there:\n\n`cd azuread`\n\nCreate a `server.js` file in our favorite editor and add the following information:\n\n```Javascript\n'use strict';\n/**\n* Module dependencies.\n*/\nvar util = require('util');\nvar assert = require('assert-plus');\nvar mongoose = require('mongoose/');\nvar bunyan = require('bunyan');\nvar restify = require('restify');\nvar config = require('./config');\nvar passport = require('passport');\nvar OIDCBearerStrategy = require('passport-azure-ad').OIDCStrategy;\n```\n\nSave the file. We will return to it shortly.\n\n## 10: Create a config file to store your Azure AD settings\n\nThis code file passes the configuration parameters from your Azure Active Directory Portal to Passport.js. You created these configuration values when you added the Web API to the portal in the first part of the walkthrough. We will explain what to put in the values of these parameters after you've copied the code.\n\n\nFrom the command-line, change directories to the **azuread** folder if not already there:\n\n`cd azuread`\n\nCreate a `config.js` file in our favorite editor and add the following information:\n\n```Javascript\n// Don't commit this file to your public repos. This config is for first-run\nexports.creds = {\nmongoose_auth_local: 'mongodb://localhost/tasklist', // Your mongo auth uri goes here\nissuer: 'https://sts.windows.net/**<your application id>**/',\naudience: '<your redirect URI>',\nidentityMetadata: 'https://login.microsoftonline.com/common/.well-known/openid-configuration' // For using Microsoft you should never need to change this.\n};\n\n```\n\n\n\n### Required Values\n\n*IdentityMetadata*: This is where passport-azure-ad will look for your configuration data for the IdP as well as the keys to validate the JWT tokens. You probably do not want to change this if using Azure Active Directory.\n\n*audience*: Your redirect URI from the portal.\n\n> [AZURE.NOTE] \nWe roll our keys at frequent intervals. Please ensure that you are always pulling from the \"openid_keys\" URL and that the app can access the internet.\n\n\n## 11: Add configuration to your server.js file\n\nWe need to read these values from the Config file you just created across our application. To do this, we simply add the .config file as a required resource in our application and then set the global variables to those in the config.js document\n\nFrom the command-line, change directories to the **azuread** folder if not already there:\n\n`cd azuread`\n\nOpen your `server.js` file in our favorite editor and add the following information:\n\n```Javascript\nvar config = require('./config');\n```\nThen, add a new section to `server.js` with the following code:\n\n```Javascript\n// We pass these options in to the ODICBearerStrategy.\nvar options = {\n// The URL of the metadata document for your app. We will put the keys for token validation from the URL found in the jwks_uri tag of the in the metadata.\nidentityMetadata: config.creds.identityMetadata,\nissuer: config.creds.issuer,\naudience: config.creds.audience\n};\n// array to hold logged in users and the current logged in user (owner)\nvar users = [];\nvar owner = null;\n// Our logger\nvar log = bunyan.createLogger({\nname: 'Microsoft Azure Active Directory Sample'\n});\n```\n\n## Step 12: Add The MongoDB Model and Schema Information using Moongoose\n\nNow all this preparation is going to start paying off as we wind these three files together in to a REST API service.\n\nFor this walkthrough we will be using MongoDB to store our Tasks as discussed in ***Step 4***.\n\nIf you recall from the config.js file we created in Step 11, we called our database *tasklist*, as that was what we put at the end of our mogoose_auth_local connection URL. You don't need to create this database beforehand in MongoDB, it will create this for us on first run of our server application (assuming it does not already exist).\n\nNow that we've told the server what MongoDB database we'd like to use, we need to write some additional code to create the model and schema for our server's Tasks.\n\n#### Discussion of the model\n\nOur Schema model is very simple, and you expand it as required.\n\nNAME - The name of who is assigned to the task. A ***String***\n\nTASK - The task itself. A ***String***\n\nDATE - The date that the task is due. A ***DATETIME***\n\nCOMPLETED - If the Task is completed or not. A ***BOOLEAN***\n\n#### Creating the schema in the code\n\n\nFrom the command-line, change directories to the **azuread** folder if not already there:\n\n`cd azuread`\n\nOpen your `server.js` file in our favorite editor and add the following information below the configuration entry:\n\n```Javascript\n// MongoDB setup\n// Setup some configuration\nvar serverPort = process.env.PORT || 8080;\nvar serverURI = (process.env.PORT) ? config.creds.mongoose_auth_mongohq : config.creds.mongoose_auth_local;\n// Connect to MongoDB\nglobal.db = mongoose.connect(serverURI);\nvar Schema = mongoose.Schema;\nlog.info('MongoDB Schema loaded');\n```\nThis will connect to the MongoDB server and hand back a Schema object to us.\n\n#### Using the Schema, create our model in the code\n\nBelow the code you wrote above, add the following code:\n\n```Javascript\n// Here we create a schema to store our tasks and users. Pretty simple schema for now.\nvar TaskSchema = new Schema({\nowner: String,\ntask: String,\ncompleted: Boolean,\ndate: Date\n});\n// Use the schema to register a model\nmongoose.model('Task', TaskSchema);\nvar Task = mongoose.model('Task');\n```\nAs you can tell from the code, we create our Schema and then create a model object we will use to store our data throughout the code when we define our ***Routes***.\n\n## Step 13: Add our Routes for our Task REST API server\n\nNow that we have a database model to work with, let's add the routes we will use for our REST API server.\n\n### About Routes in Restify\n\nRoutes work in Restify in the exact same way they do using the Express stack. You define routes using the URI that you expect the client applicaitons to call. Usually, you define your routes in a separate file. For our purposes, we will put our routes in the server.js file. We recommend you factor these in to their own file for production use.\n\nA typical pattern for a Restify Route is:\n\n```Javascript\nfunction createObject(req, res, next) {\n// do work on Object\n_object.name = req.params.object; // passed value is in req.params under object\n///...\nreturn next(); // keep the server going\n}\n....\nserver.post('/service/:add/:object', createObject); // calls createObject on routes that match this.\n```\n\n\nThis is the pattern at the most basic level. Resitfy (and Express) provide much deeper functionaltiy such as defining application types and doing complex routing across different endpoints. For our purposes, we will keep these routes very simply.\n\n#### Add default routes to our server\n\nWe will now add the basic CRUD routes of Create, Retrieve, Update, and Delete.\n\nFrom the command-line, change directories to the **azuread** folder if not already there:\n\n`cd azuread`\n\nOpen your `server.js` file in our favorite editor and add the following information below the database entries you made above:\n\n```Javascript\n/**\n*\n* APIs for our REST Task server\n*/\n// Create a task\nfunction createTask(req, res, next) {\n// Resitify currently has a bug which doesn't allow you to set default headers\n// This headers comply with CORS and allow us to mongodbServer our response to any origin\nres.header(\"Access-Control-Allow-Origin\", \"*\");\nres.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\");\n// Create a new task model, fill it up and save it to Mongodb\nvar _task = new Task();\nif (!req.params.task) {\nreq.log.warn({\nparams: p\n}, 'createTodo: missing task');\nnext(new MissingTaskError());\nreturn;\n}\n_task.owner = owner;\n_task.task = req.params.task;\n_task.date = new Date();\n_task.save(function(err) {\nif (err) {\nreq.log.warn(err, 'createTask: unable to save');\nnext(err);\n} else {\nres.send(201, _task);\n}\n});\nreturn next();\n}\n// Delete a task by name\nfunction removeTask(req, res, next) {\nTask.remove({\ntask: req.params.task,\nowner: owner\n}, function(err) {\nif (err) {\nreq.log.warn(err,\n'removeTask: unable to delete %s',\nreq.params.task);\nnext(err);\n} else {\nlog.info('Deleted task:', req.params.task);\nres.send(204);\nnext();\n}\n});\n}\n// Delete all tasks\nfunction removeAll(req, res, next) {\nTask.remove();\nres.send(204);\nreturn next();\n}\n// Get a specific task based on name\nfunction getTask(req, res, next) {\nlog.info('getTask was called for: ', owner);\nTask.find({\nowner: owner\n}, function(err, data) {\nif (err) {\nreq.log.warn(err, 'get: unable to read %s', owner);\nnext(err);\nreturn;\n}\nres.json(data);\n});\nreturn next();\n}\n/// Simple returns the list of TODOs that were loaded.\nfunction listTasks(req, res, next) {\n// Resitify currently has a bug which doesn't allow you to set default headers\n// This headers comply with CORS and allow us to mongodbServer our response to any origin\nres.header(\"Access-Control-Allow-Origin\", \"*\");\nres.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\");\nlog.info(\"listTasks was called for: \", owner);\nTask.find({\nowner: owner\n}).limit(20).sort('date').exec(function(err, data) {\nif (err)\nreturn next(err);\nif (data.length > 0) {\nlog.info(data);\n}\nif (!data.length) {\nlog.warn(err, \"There is no tasks in the database. Add one!\");\n}\nif (!owner) {\nlog.warn(err, \"You did not pass an owner when listing tasks.\");\n} else {\nres.json(data);\n}\n});\nreturn next();\n}\n```\n\n### Add some error handling for the routes\n\nIt makes sense to add some error handling so we can communicate back to the client the problem we encountered in a way it can understand.\n\nAdd the following code underneath the code you've written above:\n\n```Javascript\n///--- Errors for communicating something interesting back to the client\nfunction MissingTaskError() {\nrestify.RestError.call(this, {\nstatusCode: 409,\nrestCode: 'MissingTask',\nmessage: '\"task\" is a required parameter',\nconstructorOpt: MissingTaskError\n});\nthis.name = 'MissingTaskError';\n}\nutil.inherits(MissingTaskError, restify.RestError);\nfunction TaskExistsError(owner) {\nassert.string(owner, 'owner');\nrestify.RestError.call(this, {\nstatusCode: 409,\nrestCode: 'TaskExists',\nmessage: owner + ' already exists',\nconstructorOpt: TaskExistsError\n});\nthis.name = 'TaskExistsError';\n}\nutil.inherits(TaskExistsError, restify.RestError);\nfunction TaskNotFoundError(owner) {\nassert.string(owner, 'owner');\nrestify.RestError.call(this, {\nstatusCode: 404,\nrestCode: 'TaskNotFound',\nmessage: owner + ' was not found',\nconstructorOpt: TaskNotFoundError\n});\nthis.name = 'TaskNotFoundError';\n}\nutil.inherits(TaskNotFoundError, restify.RestError);\n```\n\n\n## Step 14: Create your Server!\n\nWe have our database defined, we have our routes in place, and the last thing to do is add our server instance that will manage our calls.\n\nRestify (and Express) have a lot of deep customization you can do for a REST API server, but again we will use the most basic setup for our purposes.\n\n```Javascript\n/**\n* Our Server\n*/\nvar server = restify.createServer({\nname: \"Microsoft Azure Active Directroy TODO Server\",\nversion: \"2.0.1\"\n});\n// Ensure we don't drop data on uploads\nserver.pre(restify.pre.pause());\n// Clean up sloppy paths like //todo//////1//\nserver.pre(restify.pre.sanitizePath());\n// Handles annoying user agents (curl)\nserver.pre(restify.pre.userAgentConnection());\n// Set a per request bunyan logger (with requestid filled in)\nserver.use(restify.requestLogger());\n// Allow 5 requests/second by IP, and burst to 10\nserver.use(restify.throttle({\nburst: 10,\nrate: 5,\nip: true,\n}));\n// Use the common stuff you probably want\nserver.use(restify.acceptParser(server.acceptable));\nserver.use(restify.dateParser());\nserver.use(restify.queryParser());\nserver.use(restify.gzipResponse());\nserver.use(restify.bodyParser({\nmapParams: true\n}));\n```\n## 15: Adding the routes (without authentication for now)\n\n```Javascript\n/// Now the real handlers. Here we just CRUD\n/**\n/*\n/* Each of these handlers are protected by our OIDCBearerStrategy by invoking 'oidc-bearer'\n/* in the pasport.authenticate() method. We set 'session: false' as REST is stateless and\n/* we don't need to maintain session state. You can experiement removing API protection\n/* by removing the passport.authenticate() method like so:\n/*\n/* server.get('/tasks', listTasks);\n/*\n**/\nserver.get('/tasks', listTasks);\nserver.get('/tasks', listTasks);\nserver.get('/tasks/:owner', getTask);\nserver.head('/tasks/:owner', getTask);\nserver.post('/tasks/:owner/:task', createTask);\nserver.post('/tasks', createTask);\nserver.del('/tasks/:owner/:task', removeTask);\nserver.del('/tasks/:owner', removeTask);\nserver.del('/tasks', removeTask);\nserver.del('/tasks', removeAll, function respond(req, res, next) {\nres.send(204);\nnext();\n});\n// Register a default '/' handler\nserver.get('/', function root(req, res, next) {\nvar routes = [\n'GET /',\n'POST /tasks/:owner/:task',\n'POST /tasks (for JSON body)',\n'GET /tasks',\n'PUT /tasks/:owner',\n'GET /tasks/:owner',\n'DELETE /tasks/:owner/:task'\n];\nres.send(200, routes);\nnext();\n});\nserver.listen(serverPort, function() {\nvar consoleMessage = '\\n Microsoft Azure Active Directory Tutorial';\nconsoleMessage += '\\n +++++++++++++++++++++++++++++++++++++++++++++++++++++';\nconsoleMessage += '\\n %s server is listening at %s';\nconsoleMessage += '\\n Open your browser to %s/tasks\\n';\nconsoleMessage += '+++++++++++++++++++++++++++++++++++++++++++++++++++++ \\n';\nconsoleMessage += '\\n !!! why not try a $curl -isS %s | json to get some ideas? \\n';\nconsoleMessage += '+++++++++++++++++++++++++++++++++++++++++++++++++++++ \\n\\n';\n});\n```\n## 16: Before we add OAuth support, let's run the server.\n\nTest out your server before we add authentication\n\nThe easiest way to do this is by using curl in a command line. Before we do that, we need a simple utility that allows us to parse output as JSON. To do that, install the json tool as all the examples below use that.\n\n`$npm install -g jsontool`\n\nThis installs the JSON tool globally. Now that we’ve accomplished that – let’s play with the server:\n\nFirst, make sure that your monogoDB isntance is running..\n\n`$sudo mongod`\n\nThen, change to the directory and start curling..\n\n`$ cd azuread`\n`$ node server.js`\n\n`$ curl -isS http://127.0.0.1:8080 | json`\n\n```Shell\nHTTP/1.1 200 OK\nConnection: close\nContent-Type: application/json\nContent-Length: 171\nDate: Tue, 14 Jul 2015 05:43:38 GMT\n[\n\"GET /\",\n\"POST /tasks/:owner/:task\",\n\"POST /tasks (for JSON body)\",\n\"GET /tasks\",\n\"PUT /tasks/:owner\",\n\"GET /tasks/:owner\",\n\"DELETE /tasks/:owner/:task\"\n]\n```\n\nThen, we can add a task this way:\n\n`$ curl -isS -X POST http://127.0.0.1:8888/tasks/brandon/Hello`\n\nThe response should be:\n\n```Shell\nHTTP/1.1 201 Created\nConnection: close\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Headers: X-Requested-With\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 5\nDate: Tue, 04 Feb 2014 01:02:26 GMT\nHello\n```\nAnd we can list tasks for Brandon this way:\n\n`$ curl -isS http://127.0.0.1:8080/tasks/brandon/`\n\nIf all this works out, we are ready to add OAuth to the REST API server.\n\n**You have a REST API server with MongoDB!**\n\n## 17: Add Authentication to our REST API Server\n\nNow that we have a running REST API (congrats, btw!) let's get to making it useful against Azure AD.\n\nFrom the command-line, change directories to the **azuread** folder if not already there:\n\n`cd azuread`\n\n### 1: Use the oidcbearerstrategy that is included with passport-azure-ad\n\nSo far we have built a typical REST TODO server without any kind of authorization. This is where we start putting that together.\n\nFirst, we need to indicate that we want to use Passport. Put this right after your other server configuration:\n\n```Javascript\n// Let's start using Passport.js\n\nserver.use(passport.initialize()); // Starts passport\nserver.use(passport.session()); // Provides session support\n```\n\n> [AZURE.TIP] \nWhen writing APIs you should always link the data to something unique from the token that the user can’t spoof. When this server stores TODO items, it stores them based on the subscription ID of the user in the token (called through token.sub) which we put in the “owner” field. This ensures that only that user can access his TODOs and no one else can access the TODOs entered. There is no exposure in the API of “owner” so an external user can request other’s TODOs even if they are authenticated.\n\nNext, let’s use the Open ID Connect Bearer strategy that comes with passport-azure-ad. Just look at the code for now, I’ll explain it shortly. Put this after what you pated above:\n\n```Javascript\n/**\n/*\n/* Calling the OIDCBearerStrategy and managing users\n/*\n/* Passport pattern provides the need to manage users and info tokens\n/* with a FindorCreate() method that must be provided by the implementor.\n/* Here we just autoregister any user and implement a FindById().\n/* You'll want to do something smarter.\n**/\nvar findById = function(id, fn) {\nfor (var i = 0, len = users.length; i < len; i++) {\nvar user = users[i];\nif (user.sub === id) {\nlog.info('Found user: ', user);\nreturn fn(null, user);\n}\n}\nreturn fn(null, null);\n};\nvar oidcStrategy = new OIDCBearerStrategy(options,\nfunction(token, done) {\nlog.info('verifying the user');\nlog.info(token, 'was the token retreived');\nfindById(token.sub, function(err, user) {\nif (err) {\nreturn done(err);\n}\nif (!user) {\n// \"Auto-registration\"\nlog.info('User was added automatically as they were new. Their sub is: ', token.sub);\nusers.push(token);\nowner = token.sub;\nreturn done(null, token);\n}\nowner = token.sub;\nreturn done(null, user, token);\n});\n}\n);\npassport.use(oidcStrategy);\n```\n\nPassport uses a similar pattern for all it’s Strategies (Twitter, Facebook, etc.) that all Strategy writers adhere to. Looking at the strategy you see we pass it a function() that has a token and a done as the parameters. The strategy will dutifully come back to us once it does all it’s work. Once it does we’ll want to store the user and stash the token so we won’t need to ask for it again.\n\n> [AZURE.IMPORTANT] \nThe code above takes any user that happens to authenticate to our server. This is known as auto registration. In production servers you wouldn’t want to let anyone in without first having them go through a registration process you decide. This is usually the pattern you see in consumer apps who allow you to register with Facebook but then ask you to fill out additional information. If this wasn’t a command line program, we could have just extracted the email from the token object that is returned and then asked them to fill out additional information. Since this is a test server we simply add them to the in-memory database.\n\n### 2. Finally, protect some endpoints\n\nYou protect endpoints by specifying the passport.authenticate() call with the protocol you wish to use.\n\nLet’s edit our route in our server code to do something more interesting:\n\n```Javascript\nserver.get('/tasks', passport.authenticate('oidc-bearer', {\nsession: false\n}), listTasks);\nserver.get('/tasks', passport.authenticate('oidc-bearer', {\nsession: false\n}), listTasks);\nserver.get('/tasks/:owner', passport.authenticate('oidc-bearer', {\nsession: false\n}), getTask);\nserver.head('/tasks/:owner', passport.authenticate('oidc-bearer', {\nsession: false\n}), getTask);\nserver.post('/tasks/:owner/:task', passport.authenticate('oidc-bearer', {\nsession: false\n}), createTask);\nserver.post('/tasks', passport.authenticate('oidc-bearer', {\nsession: false\n}), createTask);\nserver.del('/tasks/:owner/:task', passport.authenticate('oidc-bearer', {\nsession: false\n}), removeTask);\nserver.del('/tasks/:owner', passport.authenticate('oidc-bearer', {\nsession: false\n}), removeTask);\nserver.del('/tasks', passport.authenticate('oidc-bearer', {\nsession: false\n}), removeTask);\nserver.del('/tasks', passport.authenticate('oidc-bearer', {\nsession: false\n}), removeAll, function respond(req, res, next) {\nres.send(204);\nnext();\n});\n```\n\n## 18: Run your server application again and ensure it rejects you\n\nLet's use `curl` again to see if we now have OAuth2 protection against our endpoints. We will do this before runnning any of our client SDKs against this endpoint. The headers returned should be enough to tell us we are down the right path.\n\nFirst, make sure that your monogoDB isntance is running..\n\n    $sudo mongod\n\nThen, change to the directory and start curling..\n\n    $ cd azuread\n    $ node server.js\n\nTry a basic POST:\n\n`$ curl -isS -X POST http://127.0.0.1:8080/tasks/brandon/Hello`\n\n```Shell\nHTTP/1.1 401 Unauthorized\nConnection: close\nWWW-Authenticate: Bearer realm=\"Users\"\nDate: Tue, 14 Jul 2015 05:45:03 GMT\nTransfer-Encoding: chunked\n```\n\nA 401 is the response you are looking for here, as that indicates that the Passport layer is trying to redirect to the authorize endpoint, which is exactly what you want.\n\n\n## Congratulations! You have a REST API Service using OAuth2!\n\nYou've went as far as you can with this server without using an OAuth2 compatible client. You will need to go through an additional walkthrough.\n\nIf you were just looking for information on how to implement a REST API using Restify and OAuth2, you have more than enough code to keep developing your service and learning how to build on this example.\n\n## Next Steps\n\nFor reference, the completed sample (without your configuration values) [is provided as a .zip here](https://github.com/AzureADQuickStarts/AppModelv2-WebAPI-nodejs/archive/complete.zip), or you can clone it from GitHub:\n\n```git clone --branch complete https://github.com/AzureADQuickStarts/AppModelv2-WebAPI-nodejs.git```\n\nYou can now move onto more advanced topics.  You may want to try:\n\n[Secure a Web App with the v2.0 app model in Node.js >>](active-directory-v2-devquickstarts-node-web.md)\n\nFor additional resources, check out:\n- [The App Model v2.0 Preview >>](active-directory-appmodel-v2-overview.md)\n- [StackOverflow \"azure-active-directory\" tag >>](http://stackoverflow.com/questions/tagged/azure-active-directory)\n\ntest\n"
}