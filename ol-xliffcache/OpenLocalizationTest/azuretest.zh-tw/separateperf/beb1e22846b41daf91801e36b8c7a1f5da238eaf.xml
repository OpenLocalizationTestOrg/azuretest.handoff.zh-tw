{
  "nodes": [
    {
      "content": "API design guidance | Microsoft Azure",
      "pos": [
        26,
        63
      ]
    },
    {
      "content": "Guidance upon how to create a well designed API.",
      "pos": [
        81,
        129
      ]
    },
    {
      "content": "API design guidance",
      "pos": [
        423,
        442
      ]
    },
    {
      "content": "Some topics in this guidance are under discussion and may change in the future.",
      "pos": [
        495,
        574
      ]
    },
    {
      "content": "We welcome your feedback!",
      "pos": [
        575,
        600
      ]
    },
    {
      "content": "Overview",
      "pos": [
        606,
        614
      ]
    },
    {
      "content": "Many modern web-based solutions make the use of web services, hosted by web servers, to provide functionality for remote client applications.",
      "pos": [
        616,
        757
      ]
    },
    {
      "content": "The operations that a web service exposes constitute a web API.",
      "pos": [
        758,
        821
      ]
    },
    {
      "content": "A well-designed web API should aim to support:",
      "pos": [
        822,
        868
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Platform independence<ept id=\"p1\">**</ept>.",
      "pos": [
        872,
        898
      ]
    },
    {
      "content": "Client applications should be able to utilize the API that the web service provides without requiring how the data or operations that API exposes are physically implemented.",
      "pos": [
        899,
        1072
      ]
    },
    {
      "content": "This requires that the API abides by common standards that enable a client application and web service to agree on which data formats to use, and the structure of the data that is exchanged between client applications and the web service.",
      "pos": [
        1073,
        1311
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Service evolution<ept id=\"p1\">**</ept>.",
      "pos": [
        1315,
        1337
      ]
    },
    {
      "content": "The web service should be able to evolve and add (or remove) functionality independently from client applications.",
      "pos": [
        1338,
        1452
      ]
    },
    {
      "content": "Existing client applications should be able to continue to operate unmodified as the features provided by the web service change.",
      "pos": [
        1453,
        1582
      ]
    },
    {
      "content": "All functionality should also be discoverable, so that client applications can fully utilize it.",
      "pos": [
        1583,
        1679
      ]
    },
    {
      "content": "The purpose of this guidance is to describe the issues that you should consider when designing a web API.",
      "pos": [
        1681,
        1786
      ]
    },
    {
      "content": "Introduction to Representational State Transfer (REST)",
      "pos": [
        1791,
        1845
      ]
    },
    {
      "content": "In his dissertation in 2000, Roy Fielding proposed an alternative architectural approach to structuring the operations exposed by web services; REST.",
      "pos": [
        1847,
        1996
      ]
    },
    {
      "content": "REST is an architectural style for building distributed systems based on hypermedia.",
      "pos": [
        1997,
        2081
      ]
    },
    {
      "content": "A primary advantage of the REST model is that it is based on open standards and does not bind the implementation of the model or the client applications that access it to any specific implementation.",
      "pos": [
        2082,
        2281
      ]
    },
    {
      "content": "For example, a REST web service could be implemented by using the Microsoft ASP.NET Web API, and client applications could be developed by using any language and toolset that can generate HTTP requests and parse HTTP responses.",
      "pos": [
        2282,
        2509
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph>: REST is actually independent of any underlying protocol and is not necessarily tied to HTTP.",
      "pos": [
        2513,
        2619
      ]
    },
    {
      "content": "However, most common implementations of systems that are based on REST utilize HTTP as the application protocol for sending and receiving requests.",
      "pos": [
        2620,
        2767
      ]
    },
    {
      "content": "This document focusses on mapping REST principles to systems designed to operate using HTTP.",
      "pos": [
        2768,
        2860
      ]
    },
    {
      "content": "The REST model uses a navigational scheme to represent objects and services over a network (referred to as <bpt id=\"p1\">_</bpt>resources<ept id=\"p1\">_</ept>).",
      "pos": [
        2862,
        2982
      ]
    },
    {
      "content": "Many systems that implement REST typically use the HTTP protocol to transmit requests to access these resources.",
      "pos": [
        2983,
        3095
      ]
    },
    {
      "content": "In these systems, a client application submits a request in the form of a URI that identifies a resource, and an HTTP method (the most common being GET, POST, PUT, or DELETE) that indicates the operation to be performed on that resource.",
      "pos": [
        3096,
        3333
      ]
    },
    {
      "content": "The body of the HTTP request contains the data required to perform the operation.",
      "pos": [
        3335,
        3416
      ]
    },
    {
      "content": "The important point to understand is that REST defines a stateless request model.",
      "pos": [
        3417,
        3498
      ]
    },
    {
      "content": "HTTP requests should be independent and may occur in any order, so attempting to retain transient state information between requests is not feasible.",
      "pos": [
        3499,
        3648
      ]
    },
    {
      "content": "The only place where information is stored is in the resources themselves, and each request should be an atomic operation.",
      "pos": [
        3650,
        3772
      ]
    },
    {
      "content": "Effectively, a REST model implements a finite state machine where a request transitions a resource from one well-defined non-transient state to another.",
      "pos": [
        3773,
        3925
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> The stateless nature of individual requests in the REST model enables a system constructed by following these principles to be highly scalable.",
      "pos": [
        3929,
        4085
      ]
    },
    {
      "content": "There is no need to retain any affinity between a client application making a series of requests and the specific web servers handling those requests.",
      "pos": [
        4086,
        4236
      ]
    },
    {
      "content": "Another crucial point in implementing an effective REST model is to understand the relationships between the various resources to which the model provides access.",
      "pos": [
        4238,
        4400
      ]
    },
    {
      "content": "These resources are typically organized as collections and relationships.",
      "pos": [
        4401,
        4474
      ]
    },
    {
      "content": "For example, suppose that a quick analysis of an ecommerce system shows that there are two collections in which client applications are likely to be interested: orders and customers.",
      "pos": [
        4475,
        4657
      ]
    },
    {
      "content": "Each order and customer should have its own unique key for identification purposes.",
      "pos": [
        4658,
        4741
      ]
    },
    {
      "content": "The URI to access the collection of orders could be something as simple as <bpt id=\"p1\">_</bpt>/orders<ept id=\"p1\">_</ept>, and similarly the URI for retrieving all customers could be <bpt id=\"p2\">_</bpt>/customers<ept id=\"p2\">_</ept>.",
      "pos": [
        4742,
        4901
      ]
    },
    {
      "content": "Issuing an HTTP GET request to the <bpt id=\"p1\">_</bpt>/orders<ept id=\"p1\">_</ept> URI should return a list representing all orders in the collection encoded as an HTTP response:",
      "pos": [
        4902,
        5042
      ]
    },
    {
      "content": "The response shown below encodes the orders as an XML list structure.",
      "pos": [
        5108,
        5177
      ]
    },
    {
      "content": "The list contains 7 orders:",
      "pos": [
        5178,
        5205
      ]
    },
    {
      "pos": [
        5900,
        6026
      ],
      "content": "To fetch an individual order requires specifying the identifier for the order from the <bpt id=\"p1\">_</bpt>orders<ept id=\"p1\">_</ept> resource, such as <bpt id=\"p2\">_</bpt>/orders/2<ept id=\"p2\">_</ept>:"
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> For simplicity, these examples show the information in responses being returned as XML text data.",
      "pos": [
        6324,
        6434
      ]
    },
    {
      "content": "However, there is no reason why resources should not contain any other type of data supported by HTTP, such as binary or encrypted information; the content-type in the HTTP response should specify the type.",
      "pos": [
        6435,
        6641
      ]
    },
    {
      "content": "Also, a REST model may be able to return the same data in different formats, such as XML or JSON.",
      "pos": [
        6642,
        6739
      ]
    },
    {
      "content": "In this case, the web service should be able to perform content negotiation with the client making the request.",
      "pos": [
        6740,
        6851
      ]
    },
    {
      "content": "The request can include an <bpt id=\"p1\">_</bpt>Accept<ept id=\"p1\">_</ept> header which specifies the preferred format that the client would like to receive and the web service should attempt to honor this format if at all possible.",
      "pos": [
        6852,
        7045
      ]
    },
    {
      "content": "Notice that the response from a REST request makes use of the standard HTTP status codes.",
      "pos": [
        7047,
        7136
      ]
    },
    {
      "content": "For example, a request that returns valid data should include the HTTP response code 200 (OK), while a request that fails to find or delete a specified resource should return a response that includes the HTTP status code 404 (Not Found).",
      "pos": [
        7137,
        7374
      ]
    },
    {
      "content": "Design and structure of a RESTful web API",
      "pos": [
        7379,
        7420
      ]
    },
    {
      "content": "The keys to designing a successful web API are simplicity and consistency.",
      "pos": [
        7422,
        7496
      ]
    },
    {
      "content": "A Web API that exhibits these two factors makes it easier to build client applications that need to consume the API.",
      "pos": [
        7497,
        7613
      ]
    },
    {
      "content": "A RESTful web API is focused on exposing a set of connected resources, and providing the core operations that enable an application to manipulate these resources and easily navigate between them.",
      "pos": [
        7615,
        7810
      ]
    },
    {
      "content": "For this reason, the URIs that constitute a typical RESTful web API should be oriented towards the data that it exposes, and use the facilities provided by HTTP to operate on this data.",
      "pos": [
        7811,
        7996
      ]
    },
    {
      "content": "This approach requires a different mindset from that typically employed when designing a set of classes in an object-oriented API which tends to be more motivated by the behavior of objects and classes.",
      "pos": [
        7997,
        8199
      ]
    },
    {
      "content": "Additionally, a RESTful web API should be stateless and not depend on operations being invoked in a particular sequence.",
      "pos": [
        8200,
        8320
      ]
    },
    {
      "content": "The following sections summarize the points you should consider when designing a RESTful web API.",
      "pos": [
        8321,
        8418
      ]
    },
    {
      "content": "Organizing the web API around resources",
      "pos": [
        8424,
        8463
      ]
    },
    {
      "pos": [
        8467,
        8648
      ],
      "content": "<ph id=\"ph1\">[AZURE.TIP]</ph> The URIs exposed by a REST web service should be based on nouns (the data to which the web API provides access) and not verbs (what an application can do with the data)."
    },
    {
      "content": "Focus on the business entities that the web API exposes.",
      "pos": [
        8650,
        8706
      ]
    },
    {
      "content": "For example, in a web API designed to support the ecommerce system described earlier, the primary entities are customers and orders.",
      "pos": [
        8707,
        8839
      ]
    },
    {
      "content": "Processes such as the act of placing an order can be achieved by providing an HTTP POST operation that takes the order information and adds it to the list of orders for the customer.",
      "pos": [
        8840,
        9022
      ]
    },
    {
      "content": "Internally, this POST operation can perform tasks such as checking stock levels, and billing the customer.",
      "pos": [
        9023,
        9129
      ]
    },
    {
      "content": "The HTTP response can indicate whether the order was placed successfully or not.",
      "pos": [
        9130,
        9210
      ]
    },
    {
      "content": "Also note that a resource does not have to be based on a single physical data item.",
      "pos": [
        9211,
        9294
      ]
    },
    {
      "content": "As an example, an order resource might be implemented internally by using information aggregated from many rows spread across several tables in a relational database but presented to the client as a single entity.",
      "pos": [
        9295,
        9508
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.TIP]</ph> Avoid designing a REST interface that mirrors or depends on the internal structure of the data that it exposes.",
      "pos": [
        9512,
        9635
      ]
    },
    {
      "content": "REST is about more than implementing simple CRUD (Create, Retrieve, Update, Delete) operations over separate tables in a relational database.",
      "pos": [
        9636,
        9777
      ]
    },
    {
      "content": "The purpose of REST is to map business entities and the operations that an application can perform on these entities to the physical implementation of these entities, but a client should not be exposed to these physical details.",
      "pos": [
        9778,
        10006
      ]
    },
    {
      "content": "Individual business entities rarely exist in isolation (although some singleton objects may exist), but instead tend to be grouped together into collections.",
      "pos": [
        10008,
        10165
      ]
    },
    {
      "content": "In REST terms, each entity and each collection are resources.",
      "pos": [
        10166,
        10227
      ]
    },
    {
      "content": "In a RESTful web API, each collection has its own URI within the web service, and performing an HTTP GET request over a URI for a collection retrieves a list of items in that collection.",
      "pos": [
        10228,
        10414
      ]
    },
    {
      "content": "Each individual item also has its own URI, and an application can submit another HTTP GET request using that URI to retrieve the details of that item.",
      "pos": [
        10415,
        10565
      ]
    },
    {
      "content": "You should organize the URIs for collections and items in a hierarchical manner.",
      "pos": [
        10566,
        10646
      ]
    },
    {
      "content": "In the ecommerce system, the URI <bpt id=\"p1\">_</bpt>/customers<ept id=\"p1\">_</ept> denotes the customer’s collection, and <bpt id=\"p2\">_</bpt>/customers/5<ept id=\"p2\">_</ept> retrieves the details for the single customer with the ID 5 from this collection.",
      "pos": [
        10647,
        10828
      ]
    },
    {
      "content": "This approach helps to keep the web API intuitive.",
      "pos": [
        10829,
        10879
      ]
    },
    {
      "pos": [
        10883,
        11017
      ],
      "content": "<ph id=\"ph1\">[AZURE.TIP]</ph> Adopt a consistent naming convention in URIs; in general it helps to use plural nouns for URIs that reference collections."
    },
    {
      "content": "You also need to consider the relationships between different types of resources and how you might expose these associations.",
      "pos": [
        11019,
        11144
      ]
    },
    {
      "content": "For example, customers may place zero or more orders.",
      "pos": [
        11145,
        11198
      ]
    },
    {
      "content": "A natural way to represent this relationship would be through a URI such as <bpt id=\"p1\">_</bpt>/customers/5/orders<ept id=\"p1\">_</ept> to find all the orders for customer 5.",
      "pos": [
        11199,
        11335
      ]
    },
    {
      "content": "You might also consider representing the association from an order back to a specific customer through a URI such as <bpt id=\"p1\">_</bpt>/orders/99/customer<ept id=\"p1\">_</ept> to find the customer for order 99, but extending this model too far can become cumbersome to implement.",
      "pos": [
        11336,
        11578
      ]
    },
    {
      "content": "A better solution is to provide navigable links to associated resources, such as the customer, in the body of the HTTP response message returned when the order is queried.",
      "pos": [
        11579,
        11750
      ]
    },
    {
      "content": "This mechanism is described in more detail in the section Using the HATEOAS Approach to Enable Navigation To Related Resources later in this guidance.",
      "pos": [
        11751,
        11901
      ]
    },
    {
      "content": "In more complex systems there may be many more types of entity, and it can be tempting to provide URIs that enable a client application to navigate through several levels of relationships, such as <bpt id=\"p1\">_</bpt>/customers/1/orders/99/products<ept id=\"p1\">_</ept> to obtain the list of products in order 99 placed by customer 1.",
      "pos": [
        11903,
        12198
      ]
    },
    {
      "content": "However, this level of complexity can be difficult to maintain and is inflexible if the relationships between resources change in the future.",
      "pos": [
        12199,
        12340
      ]
    },
    {
      "content": "Rather, you should seek to keep URIs relatively simple.",
      "pos": [
        12341,
        12396
      ]
    },
    {
      "content": "Bear in mind that once an application has a reference to a resource, it should be possible to use this reference to find items related to that resource.",
      "pos": [
        12397,
        12549
      ]
    },
    {
      "content": "The preceding query can be replaced with the URI <bpt id=\"p1\">_</bpt>/customers/1/orders<ept id=\"p1\">_</ept> to find all the orders for customer 1, and then query the URI <bpt id=\"p2\">_</bpt>/orders/99/products<ept id=\"p2\">_</ept> to find the products in this order (assuming order 99 was placed by customer 1).",
      "pos": [
        12550,
        12785
      ]
    },
    {
      "pos": [
        12789,
        12878
      ],
      "content": "<ph id=\"ph1\">[AZURE.TIP]</ph> Avoid requiring resource URIs more complex than <bpt id=\"p1\">_</bpt>collection/item/collection<ept id=\"p1\">_</ept>."
    },
    {
      "content": "Another point to consider is that all web requests impose a load on the web server, and the greater the number of requests the bigger the load.",
      "pos": [
        12880,
        13023
      ]
    },
    {
      "content": "You should attempt to define your resources to avoid “chatty” web APIs that expose a large number of small resources.",
      "pos": [
        13024,
        13141
      ]
    },
    {
      "content": "Such an API may require a client application to submit multiple requests to find all the data that it requires.",
      "pos": [
        13142,
        13253
      ]
    },
    {
      "content": "It may be beneficial to denormalize data and combine related information together into bigger resources that can be retrieved by issuing a single request.",
      "pos": [
        13254,
        13408
      ]
    },
    {
      "content": "However, you need to balance this approach against the overhead of fetching data that might not be frequently required by the client.",
      "pos": [
        13409,
        13542
      ]
    },
    {
      "content": "Retrieving large objects can increase the latency of a request and incur additional bandwidth costs for little advantage if the additional data is not often used.",
      "pos": [
        13543,
        13705
      ]
    },
    {
      "content": "Avoid introducing dependencies between the web API to the structure, type, or location of the underlying data sources.",
      "pos": [
        13707,
        13825
      ]
    },
    {
      "content": "For example, if your data is located in a relational database, the web API does not need to expose each table as a collection of resources.",
      "pos": [
        13826,
        13965
      ]
    },
    {
      "content": "Think of the web API as an abstraction of the database, and if necessary introduce a mapping layer between the database and the web API.",
      "pos": [
        13966,
        14102
      ]
    },
    {
      "content": "In this way, if the design or implementation of the database changes (for example, you move from a relational database containing a collection of normalized tables to a denormalized NoSQL storage system such as a document database) client applications are insulated from these changes.",
      "pos": [
        14103,
        14388
      ]
    },
    {
      "pos": [
        14391,
        14617
      ],
      "content": "<ph id=\"ph1\">[AZURE.TIP]</ph> The source of the data that underpins a web API does not have to be a data store; it could be another service or line-of-business application or even a legacy application running on-premises within an organization."
    },
    {
      "content": "Finally, it might not be possible to map every operation implemented by a web API to a specific resource.",
      "pos": [
        14619,
        14724
      ]
    },
    {
      "content": "You can handle such <bpt id=\"p1\">_</bpt>non-resource<ept id=\"p1\">_</ept> scenarios through HTTP GET requests that invoke a piece of functionality and return the results as an HTTP response message.",
      "pos": [
        14725,
        14884
      ]
    },
    {
      "content": "A web API that implements simple calculator-style operations such as add and subtract could provide URIs that expose these operations as pseudo resources and utilize the query string to specify the parameters required.",
      "pos": [
        14885,
        15103
      ]
    },
    {
      "content": "For example a GET request to the URI <bpt id=\"p1\">_</bpt>/add?operand1=99&amp;operand2=1<ept id=\"p1\">_</ept> could return a response message with the body containing the value 100, and GET request to the URI <bpt id=\"p2\">_</bpt>/subtract?operand1=50&amp;operand2=20<ept id=\"p2\">_</ept> could return a response message with the body containing the value 30.",
      "pos": [
        15104,
        15376
      ]
    },
    {
      "content": "However, only use these forms of URIs sparingly.",
      "pos": [
        15377,
        15425
      ]
    },
    {
      "content": "Defining operations in terms of HTTP methods",
      "pos": [
        15431,
        15475
      ]
    },
    {
      "content": "The HTTP protocol defines a number of methods that assign semantic meaning to a request.",
      "pos": [
        15477,
        15565
      ]
    },
    {
      "content": "The common HTTP methods used by most RESTful web APIs are:",
      "pos": [
        15566,
        15624
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>GET<ept id=\"p1\">**</ept>, to retrieve a copy of the resource at the specified URI.",
      "pos": [
        15628,
        15693
      ]
    },
    {
      "content": "The body of the response message contains the details of the requested resource.",
      "pos": [
        15694,
        15774
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>POST<ept id=\"p1\">**</ept>, to create a new resource at the specified URI.",
      "pos": [
        15778,
        15834
      ]
    },
    {
      "content": "The body of the request message provides the details of the new resource.",
      "pos": [
        15835,
        15908
      ]
    },
    {
      "content": "Note that POST can also be used to trigger operations that don't actually create resources.",
      "pos": [
        15909,
        16000
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>PUT<ept id=\"p1\">**</ept>, to replace or update the resource at the specified URI.",
      "pos": [
        16004,
        16068
      ]
    },
    {
      "content": "The body of the request message specifies the resource to be modified and the values to be applied.",
      "pos": [
        16069,
        16168
      ]
    },
    {
      "pos": [
        16172,
        16228
      ],
      "content": "<bpt id=\"p1\">**</bpt>DELETE<ept id=\"p1\">**</ept>, to remove the resource at the specified URI."
    },
    {
      "pos": [
        16232,
        16671
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> The HTTP protocol also defines other less commonly-used methods, such as PATCH which is used to request selective updates to a resource, HEAD which is used to request a description of a resource, OPTIONS which enables a client information to obtain information about the communication options supported by the server, and TRACE which allows a client to request information that it can use for testing and diagnostics purposes."
    },
    {
      "content": "The effect of a specific request should depend on whether the resource to which it is applied is a collection or an individual item.",
      "pos": [
        16673,
        16805
      ]
    },
    {
      "content": "The following table summarizes the common conventions adopted by most RESTful implementations using the ecommerce example.",
      "pos": [
        16806,
        16928
      ]
    },
    {
      "content": "Note that not all of these requests might be implemented; it depends on the specific scenario.",
      "pos": [
        16929,
        17023
      ]
    },
    {
      "content": "Resource",
      "pos": [
        17029,
        17037
      ]
    },
    {
      "content": "POST",
      "pos": [
        17044,
        17048
      ]
    },
    {
      "content": "GET",
      "pos": [
        17055,
        17058
      ]
    },
    {
      "content": "PUT",
      "pos": [
        17065,
        17068
      ]
    },
    {
      "content": "DELETE",
      "pos": [
        17075,
        17081
      ]
    },
    {
      "content": "/customers",
      "pos": [
        17149,
        17159
      ]
    },
    {
      "content": "Create a new customer",
      "pos": [
        17162,
        17183
      ]
    },
    {
      "content": "Retrieve all customers",
      "pos": [
        17186,
        17208
      ]
    },
    {
      "pos": [
        17211,
        17254
      ],
      "content": "Bulk update of customers (<bpt id=\"p1\">_</bpt>if implemented<ept id=\"p1\">_</ept>)"
    },
    {
      "content": "Remove all customers",
      "pos": [
        17257,
        17277
      ]
    },
    {
      "content": "/customers/1",
      "pos": [
        17282,
        17294
      ]
    },
    {
      "content": "Error",
      "pos": [
        17297,
        17302
      ]
    },
    {
      "content": "Retrieve the details for customer 1",
      "pos": [
        17305,
        17340
      ]
    },
    {
      "content": "Update the details of customer 1 if it exists, otherwise return an error",
      "pos": [
        17343,
        17415
      ]
    },
    {
      "content": "Remove customer 1",
      "pos": [
        17418,
        17435
      ]
    },
    {
      "content": "/customers/1/orders",
      "pos": [
        17440,
        17459
      ]
    },
    {
      "content": "Create a new order for customer 1",
      "pos": [
        17462,
        17495
      ]
    },
    {
      "content": "Retrieve all orders for customer 1",
      "pos": [
        17498,
        17532
      ]
    },
    {
      "pos": [
        17535,
        17590
      ],
      "content": "Bulk update of orders for customer 1 (<bpt id=\"p1\">_</bpt>if implemented<ept id=\"p1\">_</ept>)"
    },
    {
      "pos": [
        17593,
        17643
      ],
      "content": "Remove all orders for customer 1(<bpt id=\"p1\">_</bpt>if implemented<ept id=\"p1\">_</ept>)"
    },
    {
      "content": "The purpose of GET and DELETE requests are relatively straightforward, but there is scope for confusion concerning the purpose and effects of POST and PUT requests.",
      "pos": [
        17647,
        17811
      ]
    },
    {
      "content": "A POST request should create a new resource with data provided in the body of the request.",
      "pos": [
        17813,
        17903
      ]
    },
    {
      "content": "In the REST model, you frequently apply POST requests to resources that are collections; the new resource is added to the collection.",
      "pos": [
        17904,
        18037
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> You can also define POST requests that trigger some functionality (and that don't necessarily return data), and these types of request can be applied to collections.",
      "pos": [
        18041,
        18219
      ]
    },
    {
      "content": "For example you could use a POST request to pass a timesheet to a payroll processing service and get the calculated taxes back as a response.",
      "pos": [
        18220,
        18361
      ]
    },
    {
      "content": "A PUT request is intended to modify an existing resource.",
      "pos": [
        18363,
        18420
      ]
    },
    {
      "content": "If the specified resource does not exist, the PUT request could return an error (in some cases, it might actually create the resource).",
      "pos": [
        18421,
        18556
      ]
    },
    {
      "content": "PUT requests are most frequently applied to resources that are individual items (such as a specific customer or order), although they can be applied to collections, although this is less-commonly implemented.",
      "pos": [
        18557,
        18765
      ]
    },
    {
      "content": "Note that PUT requests are idempotent whereas POST requests are not; if an application submits the same PUT request multiple times the results should always be the same (the same resource will be modified with the same values), but if an application repeats the same POST request the result will be the creation of multiple resources.",
      "pos": [
        18766,
        19100
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> Strictly speaking, an HTTP PUT request replaces an existing resource with the resource specified in the body of the request.",
      "pos": [
        19104,
        19241
      ]
    },
    {
      "content": "If the intention is to modify a selection of properties in a resource but leave other properties unchanged, then this should be implemented by using an HTTP PATCH request.",
      "pos": [
        19242,
        19413
      ]
    },
    {
      "content": "However, many RESTful implementations relax this rule and use PUT for both situations.",
      "pos": [
        19414,
        19500
      ]
    },
    {
      "content": "Processing HTTP requests",
      "pos": [
        19506,
        19530
      ]
    },
    {
      "content": "The data included by a client application in many HTTP requests, and the corresponding response messages from the web server, could be presented in a variety of formats (or media types).",
      "pos": [
        19531,
        19717
      ]
    },
    {
      "content": "For example, the data that specifies the details for a customer or order could be provided as XML, JSON, or some other encoded and compressed format.",
      "pos": [
        19718,
        19867
      ]
    },
    {
      "content": "A RESTful web API should support different media types as requested by the client application that submits a request.",
      "pos": [
        19868,
        19985
      ]
    },
    {
      "content": "When a client application sends a request that returns data in the body of a message, it can specify the media types it can handle in the Accept header of the request.",
      "pos": [
        19987,
        20154
      ]
    },
    {
      "content": "The following code illustrates an HTTP GET request that retrieves the details of customer 1 and requests the result to be returned as JSON (the client should still examine the media type of the data in the response to verify the format of the data returned):",
      "pos": [
        20155,
        20413
      ]
    },
    {
      "content": "If the web server supports this media type, it can reply with a response that includes Content-Type header that specifies the format of the data in the body of the message:",
      "pos": [
        20510,
        20682
      ]
    },
    {
      "pos": [
        20686,
        20862
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> For maximum interoperability, the media types referenced in the Accept and Content-Type headers should be recognized MIME types rather than some custom media type."
    },
    {
      "content": "If the web server does not support the requested media type, it can send the data in a different format.",
      "pos": [
        21063,
        21167
      ]
    },
    {
      "content": "IN all cases it must specify the media type (such as <bpt id=\"p1\">_</bpt>text/xml<ept id=\"p1\">_</ept>) in the Content-Type header.",
      "pos": [
        21168,
        21260
      ]
    },
    {
      "content": "It is the responsibility of the client application to parse the response message and interpret the results in the message body appropriately.",
      "pos": [
        21261,
        21402
      ]
    },
    {
      "content": "Note that in this example, the web server successfully retrieves the requested data and indicates success by passing back a status code of 200 in the response header.",
      "pos": [
        21404,
        21570
      ]
    },
    {
      "content": "If no matching data is found, it should instead return a status code of 404 (not found) and the body of the response message can contain additional information.",
      "pos": [
        21571,
        21731
      ]
    },
    {
      "content": "The format of this information is specified by the Content-Type header, as shown in the following example:",
      "pos": [
        21732,
        21838
      ]
    },
    {
      "content": "Order 222 does not exist, so the response message looks like this:",
      "pos": [
        21937,
        22003
      ]
    },
    {
      "content": "When an application sends an HTTP PUT request to update a resource, it specifies the URI of the resource and provides the data to be modified in the body of the request message.",
      "pos": [
        22179,
        22356
      ]
    },
    {
      "content": "It should also specify the format of this data by using the Content-Type header.",
      "pos": [
        22357,
        22437
      ]
    },
    {
      "content": "A common format used for text-based information is <bpt id=\"p1\">_</bpt>application/x-www-form-urlencoded<ept id=\"p1\">_</ept>, which comprises a set of name/value pairs separated by the &amp; character.",
      "pos": [
        22438,
        22597
      ]
    },
    {
      "content": "The next example shows an HTTP PUT request that modifies the information in order 1:",
      "pos": [
        22598,
        22682
      ]
    },
    {
      "content": "If the modification is successful, it should ideally respond with an HTTP 204 status code, indicating that the process has been successfully handled, but that the response body contains no further information.",
      "pos": [
        22896,
        23105
      ]
    },
    {
      "content": "The Location header in the response contains the URI of the newly updated resource:",
      "pos": [
        23106,
        23189
      ]
    },
    {
      "pos": [
        23320,
        23509
      ],
      "content": "<ph id=\"ph1\">[AZURE.TIP]</ph> If the data in an HTTP PUT request message includes date and time information, make sure that your web service accepts dates and times formatted following the ISO 8601 standard."
    },
    {
      "content": "If the resource to be updated does not exist, the web server can respond with a Not Found response as described earlier.",
      "pos": [
        23511,
        23631
      ]
    },
    {
      "content": "Alternatively, if the server actually creates the object itself it could return the status codes HTTP 200 (OK) or HTTP 201 (Created) and the response body could contain the data for the new resource.",
      "pos": [
        23632,
        23831
      ]
    },
    {
      "content": "If the Content-Type header of the request specifies a data format that the web server cannot handle, it should respond with HTTP status code 415 (Unsupported Media Type).",
      "pos": [
        23832,
        24002
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.TIP]</ph> Consider implementing bulk HTTP PUT operations that can batch updates to multiple resources in a collection.",
      "pos": [
        24006,
        24126
      ]
    },
    {
      "content": "The PUT request should specify the URI of the collection, and the request body should specify the details of the resources to be modified.",
      "pos": [
        24127,
        24265
      ]
    },
    {
      "content": "This approach can help to reduce chattiness and improve performance.",
      "pos": [
        24266,
        24334
      ]
    },
    {
      "content": "The format of an HTTP POST requests that create new resources are similar to those of PUT requests; the message body contains the details of the new resource to be added.",
      "pos": [
        24336,
        24506
      ]
    },
    {
      "content": "However, the URI typically specifies the collection to which the resource should be added.",
      "pos": [
        24507,
        24597
      ]
    },
    {
      "content": "The following example creates a new order and adds it to the orders collection:",
      "pos": [
        24598,
        24677
      ]
    },
    {
      "content": "If the request is successful, the web server should respond with a message code with HTTP status code 201 (Created).",
      "pos": [
        24891,
        25007
      ]
    },
    {
      "content": "The Location header should contain the URI of the newly created resource, and the body of the response should contain a copy of the new resource; the Content-Type header specifies the format of this data:",
      "pos": [
        25008,
        25212
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.TIP]</ph> If the data provided by a PUT or POST request is invalid, the web server should respond with a message with HTTP status code 400 (Bad Request).",
      "pos": [
        25467,
        25622
      ]
    },
    {
      "content": "The body of this message can contain additional information about the problem with the request and the formats expected, or it can contain a link to a URL that provides more details.",
      "pos": [
        25623,
        25805
      ]
    },
    {
      "content": "To remove a resource, an HTTP DELETE request simply provides the URI of the resource to be deleted.",
      "pos": [
        25807,
        25906
      ]
    },
    {
      "content": "The following example attempts to remove order 99:",
      "pos": [
        25907,
        25957
      ]
    },
    {
      "content": "If the delete operation is successful, the web server should respond with HTTP status code 204, indicating that the process has been successfully handled, but that the response body contains no further information (this is the same response returned by a successful PUT operation, but without a Location header as the resource no longer exists.) It is also possible for a DELETE request to return HTTP status code 200 (OK) or 202 (Accepted) if the deletion is performed asynchronously.",
      "pos": [
        26029,
        26514
      ]
    },
    {
      "content": "If the resource is not found, the web server should return a 404 (Not Found) message instead.",
      "pos": [
        26593,
        26686
      ]
    },
    {
      "pos": [
        26690,
        26922
      ],
      "content": "<ph id=\"ph1\">[AZURE.TIP]</ph> If all the resources in a collection need to be deleted, enable an HTTP DELETE request to be specified for the URI of the collection rather than forcing an application to remove each resource in turn from the collection."
    },
    {
      "content": "Filtering and paginating data",
      "pos": [
        26928,
        26957
      ]
    },
    {
      "content": "You should endeavour to keep the URIs simple and intuitive.",
      "pos": [
        26959,
        27018
      ]
    },
    {
      "content": "Exposing a collection of resources through a single URI assists in this respect, but it can lead to applications fetching large amounts of data when only a subset of the information is required.",
      "pos": [
        27019,
        27213
      ]
    },
    {
      "content": "Generating a large volume of traffic impacts not only the performance and scalability of the web server but also adversely affect the responsiveness of client applications requesting the data.",
      "pos": [
        27214,
        27406
      ]
    },
    {
      "content": "For example, if orders contain the price paid for the order, a client application that needs to retrieve all orders that have a cost over a specific value might need to retrieve all orders from the <bpt id=\"p1\">_</bpt>/orders<ept id=\"p1\">_</ept> URI and then filter these orders locally.",
      "pos": [
        27408,
        27657
      ]
    },
    {
      "content": "Clearly this process is highly inefficient; it wastes network bandwidth and processing power on the server hosting the web API.",
      "pos": [
        27658,
        27785
      ]
    },
    {
      "content": "One solution may be to provide a URI scheme such as <bpt id=\"p1\">_</bpt>/orders/ordervalue_greater_than_n<ept id=\"p1\">_</ept> where <bpt id=\"p2\">_</bpt>n<ept id=\"p2\">_</ept> is the order price, but for all but a limited number of prices such an approach is impractical.",
      "pos": [
        27787,
        27980
      ]
    },
    {
      "content": "Additionally, if you need to query orders based on other criteria, you can end up being faced with providing with a long list of URIs with possibly non-intuitive names.",
      "pos": [
        27981,
        28149
      ]
    },
    {
      "content": "A better strategy to filtering data is to provide the filter criteria in the query string that is passed to the web API, such as <bpt id=\"p1\">_</bpt>/orders?ordervaluethreshold=n<ept id=\"p1\">_</ept>.",
      "pos": [
        28151,
        28312
      ]
    },
    {
      "content": "In this example, the corresponding operation in the web API is responsible for parsing and handling the <ph id=\"ph1\">`ordervaluethreshold`</ph> parameter in the query string and returning the filtered results in the HTTP response.",
      "pos": [
        28313,
        28525
      ]
    },
    {
      "content": "Some simple HTTP GET requests over collection resources could potentially return a large number of items.",
      "pos": [
        28527,
        28632
      ]
    },
    {
      "content": "To combat the possibility of this occurring you should design the web API to limit the amount of data returned by any single request.",
      "pos": [
        28633,
        28766
      ]
    },
    {
      "content": "You can achieve this by supporting query strings that enable the user to specify the maximum number of items to be retrieved (which could itself be subject to an upperbound limit to help prevent Denial of Service attacks), and a starting offset into the collection.",
      "pos": [
        28767,
        29032
      ]
    },
    {
      "content": "For example, the query string in the URI <bpt id=\"p1\">_</bpt>/orders?limit=25&amp;offset=50<ept id=\"p1\">_</ept> should retrieve 25 orders starting with the 50th order found in the orders collection.",
      "pos": [
        29033,
        29189
      ]
    },
    {
      "content": "As with filtering data, the operation that implements the GET request in the web API is responsible for parsing and handling the <ph id=\"ph1\">`limit`</ph> and <ph id=\"ph2\">`offset`</ph> parameters in the query string.",
      "pos": [
        29190,
        29371
      ]
    },
    {
      "content": "To assist client applications, GET requests that return paginated data should also include some form of metadata that indicate the total number of resources available in the collection.",
      "pos": [
        29372,
        29557
      ]
    },
    {
      "content": "You might also consider other intelligent paging strategies; for more information, see <bpt id=\"p1\">[</bpt>API Design Notes: Smart Paging<ept id=\"p1\">](http://bizcoder.com/api-design-notes-smart-paging)</ept>",
      "pos": [
        29558,
        29728
      ]
    },
    {
      "content": "You can follow a similar strategy for sorting data as it is fetched; you could provide a sort parameter that takes a field name as the value, such as <bpt id=\"p1\">_</bpt>/orders?sort=ProductID<ept id=\"p1\">_</ept>.",
      "pos": [
        29730,
        29905
      ]
    },
    {
      "content": "However, note that this approach can have a deleterious effect on caching (query string parameters form part of the resource identifier used by many cache implementations as the key to cached data).",
      "pos": [
        29906,
        30104
      ]
    },
    {
      "content": "You can extend this approach to limit (project) the fields returned if a single resource item contains a large amount of data.",
      "pos": [
        30106,
        30232
      ]
    },
    {
      "content": "For example, you could use a query string parameter that accepts a comma-delimited list of fields, such as <bpt id=\"p1\">_</bpt>/orders?fields=ProductID,Quantity<ept id=\"p1\">_</ept>.",
      "pos": [
        30233,
        30376
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.TIP]</ph> Give all optional parameters in query strings meaningful defaults.",
      "pos": [
        30380,
        30458
      ]
    },
    {
      "content": "For example, set the <ph id=\"ph1\">`limit`</ph> parameter to 10 and the <ph id=\"ph2\">`offset`</ph> parameter to 0 if you implement pagination, set the sort parameter to the key of the resource if you implement ordering, and set the <ph id=\"ph3\">`fields`</ph> parameter to all fields in the resource if you support projections.",
      "pos": [
        30459,
        30730
      ]
    },
    {
      "content": "Handling large binary resources",
      "pos": [
        30736,
        30767
      ]
    },
    {
      "content": "A single resource may contain large binary fields, such as files or images.",
      "pos": [
        30769,
        30844
      ]
    },
    {
      "content": "To overcome the transmission problems caused by unreliable and intermittent connections and to improve response times, consider providing operations that enable such resources to be retrieved in chunks by the client application.",
      "pos": [
        30845,
        31073
      ]
    },
    {
      "content": "To do this, the web API should support the Accept-Ranges header for GET requests for large resources, and ideally implement HTTP HEAD requests for these resources.",
      "pos": [
        31074,
        31237
      ]
    },
    {
      "content": "The Accept-Ranges header indicates that the GET operation supports partial results, and that a client application can submit GET requests that return a subset of a resource specified as a range of bytes.",
      "pos": [
        31238,
        31441
      ]
    },
    {
      "content": "A HEAD request is similar to a GET request except that it only returns a header that describes the resource and an empty message body.",
      "pos": [
        31442,
        31576
      ]
    },
    {
      "content": "A client application can issue a HEAD request to determine whether to fetch a resource by using partial GET requests.",
      "pos": [
        31577,
        31694
      ]
    },
    {
      "content": "The following example shows a HEAD request that obtains information about a product image:",
      "pos": [
        31695,
        31785
      ]
    },
    {
      "content": "The response message contains a header that includes the size of the resource (4580 bytes), and the Accept-Ranges header that the corresponding GET operation supports partial results:",
      "pos": [
        31877,
        32060
      ]
    },
    {
      "content": "The client application can use this information to construct a series of GET operations to retrieve the image in smaller chunks.",
      "pos": [
        32166,
        32294
      ]
    },
    {
      "content": "The first request fetches the first 2500 bytes by using the Range header:",
      "pos": [
        32295,
        32368
      ]
    },
    {
      "content": "The response message indicates that this is a partial response by returning HTTP status code 206.",
      "pos": [
        32479,
        32576
      ]
    },
    {
      "content": "The Content-Length header specifies the actual number of bytes returned in the message body (not the size of the resource), and the Content-Range header indicates which part of the resource this is (bytes 0-2499 out of 4580):",
      "pos": [
        32577,
        32802
      ]
    },
    {
      "content": "A subsequent request from the client application can retrieve the remainder of the resource by using an appropriate Range header:",
      "pos": [
        32980,
        33109
      ]
    },
    {
      "content": "The corresponding result message should look like this:",
      "pos": [
        33219,
        33274
      ]
    },
    {
      "content": "Using the HATEOAS approach to enable navigation to related resources",
      "pos": [
        33432,
        33500
      ]
    },
    {
      "content": "One of the primary motivations behind REST is that it should be possible to navigate the entire set of resources without requiring prior knowledge of the URI scheme.",
      "pos": [
        33502,
        33667
      ]
    },
    {
      "content": "Each HTTP GET request should return the information necessary to find the resources related directly to the requested object through hyperlinks included in the response, and it should also be provided with information that describes the operations available on each of these resources.",
      "pos": [
        33668,
        33953
      ]
    },
    {
      "content": "This principle is known as HATEOAS, or Hypertext as the Engine of Application State.",
      "pos": [
        33954,
        34038
      ]
    },
    {
      "content": "The system is effectively a finite state machine, and the response to each request contains the information necessary to move from one state to another; no other information should be necessary.",
      "pos": [
        34039,
        34233
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> Currently there are no standards or specifications that define how to model the HATEOAS principle.",
      "pos": [
        34237,
        34348
      ]
    },
    {
      "content": "The examples shown in this section illustrate one possible solution.",
      "pos": [
        34349,
        34417
      ]
    },
    {
      "content": "As an example, to handle the relationship between customers and orders, the data returned in the response for a specific order should contain URIs in the form of a hyperlink identifying the customer that placed the order, and the operations that can be performed on that customer.",
      "pos": [
        34419,
        34699
      ]
    },
    {
      "content": "The body of the response message contains a <ph id=\"ph1\">`Links`</ph> array (highlighted in the code example) that specifies the nature of the relationship (<bpt id=\"p1\">_</bpt>Customer<ept id=\"p1\">_</ept>), the URI of the customer (<bpt id=\"p2\">_</bpt>http://adventure-works.com/customers/3<ept id=\"p2\">_</ept>), how to retrieve the details of this customer (<bpt id=\"p3\">_</bpt>GET<ept id=\"p3\">_</ept>), and the MIME types that the web server supports for retrieving this information (<bpt id=\"p4\">_</bpt>text/xml<ept id=\"p4\">_</ept> and <bpt id=\"p5\">_</bpt>application/json<ept id=\"p5\">_</ept>).",
      "pos": [
        34792,
        35182
      ]
    },
    {
      "content": "This is all the information that a client application needs to be able to fetch the details of the customer.",
      "pos": [
        35183,
        35291
      ]
    },
    {
      "content": "Additionally, the Links array also includes links for the other operations that can be performed, such as PUT (to modify the customer, together with the format that the web server expects the client to provide), and DELETE.",
      "pos": [
        35292,
        35515
      ]
    },
    {
      "content": "For completeness, the Links array should also include self-referencing information pertaining to the resource that has been retrieved.",
      "pos": [
        36145,
        36279
      ]
    },
    {
      "content": "These links have been omitted from the previous example, but are highlighted in the following code.",
      "pos": [
        36280,
        36379
      ]
    },
    {
      "content": "Notice that in these links, the relationship <bpt id=\"p1\">_</bpt>self<ept id=\"p1\">_</ept> has been used to indicate that this is a reference to the resource being returned by the operation:",
      "pos": [
        36380,
        36531
      ]
    },
    {
      "content": "For this approach to be effective, client applications must be prepared to retrieve and parse this additional information.",
      "pos": [
        37328,
        37450
      ]
    },
    {
      "content": "Versioning a RESTful web API",
      "pos": [
        37455,
        37483
      ]
    },
    {
      "content": "It is highly unlikely that in all but the simplest of situations that a web API will remain static.",
      "pos": [
        37485,
        37584
      ]
    },
    {
      "content": "As business requirements change new collections of resources may be added, the relationships between resources might change, and the structure of the data in resources might be amended.",
      "pos": [
        37585,
        37770
      ]
    },
    {
      "content": "While updating a web API to handle new or differing requirements is a relatively straightforward process, you must consider the effects that such changes will have on client applications consuming the web API.",
      "pos": [
        37771,
        37980
      ]
    },
    {
      "content": "The issue is that although the developer designing and implementing a web API has full control over that API, the developer does not have the same degree of control over client applications which may be built by third party organizations operating remotely.",
      "pos": [
        37981,
        38238
      ]
    },
    {
      "content": "The primary imperative is to enable existing client applications to continue functioning unchanged while allowing new client applications to take advantage of new features and resources.",
      "pos": [
        38239,
        38425
      ]
    },
    {
      "content": "Versioning enables a web API to indicate the features and resources that it exposes, and a client application can submit requests that are directed to a specific version of a feature or resource.",
      "pos": [
        38427,
        38622
      ]
    },
    {
      "content": "The following sections describe several different approaches, each of which has its own benefits and trade-offs.",
      "pos": [
        38623,
        38735
      ]
    },
    {
      "content": "No versioning",
      "pos": [
        38741,
        38754
      ]
    },
    {
      "content": "This is the simplest approach, and may be acceptable for some internal APIs.",
      "pos": [
        38756,
        38832
      ]
    },
    {
      "content": "Big changes could be represented as new resources or new links.",
      "pos": [
        38833,
        38896
      ]
    },
    {
      "content": "Adding content to existing resources might not present a breaking change as client applications that are not expecting to see this content will simply ignore it.",
      "pos": [
        38898,
        39059
      ]
    },
    {
      "pos": [
        39061,
        39264
      ],
      "content": "For example, a request to the URI <bpt id=\"p1\">_</bpt>http://adventure-works.com/customers/3<ept id=\"p1\">_</ept> should return the details of a single customer containing <ph id=\"ph1\">`Id`</ph>, <ph id=\"ph2\">`Name`</ph>, and <ph id=\"ph3\">`Address`</ph> fields expected by the client application:"
    },
    {
      "pos": [
        39448,
        39578
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> For the purposes of simplicity and clarity, the example responses shown in this section do not include HATEOAS links."
    },
    {
      "pos": [
        39580,
        39695
      ],
      "content": "If the <ph id=\"ph1\">`DateCreated`</ph> field is added to the schema of the customer resource, then the response would look like this:"
    },
    {
      "content": "Existing client applications might continue functioning correctly if they are capable of ignoring unrecognized fields, while new client applications can be designed to handle this new field.",
      "pos": [
        39922,
        40112
      ]
    },
    {
      "content": "However, if more radical changes to the schema of resources occur (such as removing or renaming fields) or the relationships between resources change then these may constitute breaking changes that prevent existing client applications from functioning correctly.",
      "pos": [
        40113,
        40375
      ]
    },
    {
      "content": "In these situations you should consider one of the following approaches.",
      "pos": [
        40376,
        40448
      ]
    },
    {
      "content": "URI versioning",
      "pos": [
        40454,
        40468
      ]
    },
    {
      "content": "Each time you modify the web API or change the schema of resources, you add a version number to the URI for each resource.",
      "pos": [
        40470,
        40592
      ]
    },
    {
      "content": "The previously existing URIs should continue to operate as before, returning resources that conform to their original schema.",
      "pos": [
        40593,
        40718
      ]
    },
    {
      "pos": [
        40720,
        41053
      ],
      "content": "Extending the previous example, if the <ph id=\"ph1\">`Address`</ph> field is restructured into sub-fields containing each constituent part of the address (such as <ph id=\"ph2\">`StreetAddress`</ph>, <ph id=\"ph3\">`City`</ph>, <ph id=\"ph4\">`State`</ph>, and <ph id=\"ph5\">`ZipCode`</ph>), this version of the resource could be exposed through a URI containing a version number, such as http://adventure-works.com/v2/customers/3:"
    },
    {
      "content": "This versioning mechanism is very simple but depends on the server routing the request to the appropriate endpoint.",
      "pos": [
        41327,
        41442
      ]
    },
    {
      "content": "However, it can become unwieldy as the web API matures through several iterations and the server has to support a number of different versions.",
      "pos": [
        41443,
        41586
      ]
    },
    {
      "content": "Also, from a purist’s point of view, in all cases the client applications are fetching the same data (customer 3), so the URI should not really be different depending on the version.",
      "pos": [
        41587,
        41769
      ]
    },
    {
      "content": "This scheme also complicates implementation of HATEOAS as all links will need to include the version number in their URIs.",
      "pos": [
        41770,
        41892
      ]
    },
    {
      "content": "Query string versioning",
      "pos": [
        41898,
        41921
      ]
    },
    {
      "content": "Rather than providing multiple URIs, you can specify the version of the resource by using a parameter within the query string appended to the HTTP request, such as <bpt id=\"p1\">_</bpt>http://adventure-works.com/customers/3?version=2<ept id=\"p1\">_</ept>.",
      "pos": [
        41923,
        42138
      ]
    },
    {
      "content": "The version parameter should default to a meaningful value such as 1 if it is omitted by older client applications.",
      "pos": [
        42139,
        42254
      ]
    },
    {
      "content": "This approach has the semantic advantage that the same resource is always retrieved from the same URI, but it depends on the code that handles the request to parse the query string and send back the appropriate HTTP response.",
      "pos": [
        42256,
        42481
      ]
    },
    {
      "content": "This approach also suffers from the same complications for implementing HATEOAS as the URI versioning mechanism.",
      "pos": [
        42482,
        42594
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> Some older web browsers and web proxies will not cache responses for requests that include a query string in the URL.",
      "pos": [
        42598,
        42728
      ]
    },
    {
      "content": "This can have an adverse impact on performance for web applications that use a web API and that run from within such a web browser.",
      "pos": [
        42729,
        42860
      ]
    },
    {
      "content": "Header versioning",
      "pos": [
        42866,
        42883
      ]
    },
    {
      "content": "Rather than appending the version number as a query string parameter, you could implement a custom header that indicates the version of the resource.",
      "pos": [
        42885,
        43034
      ]
    },
    {
      "content": "This approach requires that the client application adds the appropriate header to any requests, although the code handling the client request could use a default value (version 1) if the version header is omitted.",
      "pos": [
        43035,
        43248
      ]
    },
    {
      "content": "The following examples utilize a custom header named <bpt id=\"p1\">_</bpt>Custom-Header<ept id=\"p1\">_</ept>.",
      "pos": [
        43249,
        43318
      ]
    },
    {
      "content": "The value of this header indicates the version of web API.",
      "pos": [
        43319,
        43377
      ]
    },
    {
      "content": "Version 1:",
      "pos": [
        43379,
        43389
      ]
    },
    {
      "content": "Version 2:",
      "pos": [
        43673,
        43683
      ]
    },
    {
      "content": "Note that as with the previous two approaches, implementing HATEOAS requires including the appropriate custom header in any links.",
      "pos": [
        44059,
        44189
      ]
    },
    {
      "content": "Media type versioning",
      "pos": [
        44195,
        44216
      ]
    },
    {
      "content": "When a client application sends an HTTP GET request to a web server it should stipulate the format of the content that it can handle by using an Accept header, as described earlier in this guidance.",
      "pos": [
        44218,
        44416
      ]
    },
    {
      "content": "Frequently the purpose of the <bpt id=\"p1\">_</bpt>Accept<ept id=\"p1\">_</ept> header is to allow the client application to specify whether the body of the response should be XML, JSON, or some other common format that the client can parse.",
      "pos": [
        44417,
        44617
      ]
    },
    {
      "content": "However, it is possible to define custom media types that include information enabling the client application to indicate which version of a resource it is expecting.",
      "pos": [
        44618,
        44784
      ]
    },
    {
      "content": "The following example shows a request that specifies an <bpt id=\"p1\">_</bpt>Accept<ept id=\"p1\">_</ept> header with the value <bpt id=\"p2\">_</bpt>application/vnd.adventure-works.v1+json<ept id=\"p2\">_</ept>.",
      "pos": [
        44785,
        44914
      ]
    },
    {
      "content": "The <bpt id=\"p1\">_</bpt>vnd.adventure-works.v1<ept id=\"p1\">_</ept> element indicates to the web server that it should return version 1 of the resource, while the <bpt id=\"p2\">_</bpt>json<ept id=\"p2\">_</ept> element specifies that the format of the response body should be JSON:",
      "pos": [
        44915,
        45116
      ]
    },
    {
      "content": "The code handling the request is responsible for processing the <bpt id=\"p1\">_</bpt>Accept<ept id=\"p1\">_</ept> header and honoring it as far as possible (the client application may specify multiple formats in the <bpt id=\"p2\">_</bpt>Accept<ept id=\"p2\">_</ept> header, in which case the web server can choose the most appropriate format for the response body).",
      "pos": [
        45239,
        45522
      ]
    },
    {
      "content": "The web server confirms the format of the data in the response body by using the Content-Type header:",
      "pos": [
        45523,
        45624
      ]
    },
    {
      "content": "If the Accept header does not specify any known media types, the web server could generate an HTTP 406 (Not Acceptable) response message or return a message with a default media type.",
      "pos": [
        45829,
        46012
      ]
    },
    {
      "content": "This approach is arguably the purest of the versioning mechanisms and lends itself naturally to HATEOAS, which can include the MIME type of related data in resource links.",
      "pos": [
        46014,
        46185
      ]
    },
    {
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> When you select a versioning strategy, you should also consider the implications on performance, especially caching on the web server.",
      "pos": [
        46189,
        46336
      ]
    },
    {
      "content": "The URI versioning and Query String versioning schemes are cache-friendly inasmuch as the same URI/query string combination refers to the same data each time.",
      "pos": [
        46337,
        46495
      ]
    },
    {
      "content": "The Header versioning and Media Type versioning mechanisms typically require additional logic to examine the values in the custom header or the Accept header.",
      "pos": [
        46499,
        46657
      ]
    },
    {
      "content": "In a large-scale environment, many clients using different versions of a web API can result in a significant amount of duplicated data in a server-side cache.",
      "pos": [
        46658,
        46816
      ]
    },
    {
      "content": "This issue can become acute if a client application communicates with a web server through a proxy that implements caching, and that only forwards a request to the web server if it does not currently hold a copy of the requested data in its cache.",
      "pos": [
        46817,
        47064
      ]
    },
    {
      "content": "More information",
      "pos": [
        47069,
        47085
      ]
    },
    {
      "pos": [
        47089,
        47188
      ],
      "content": "The <bpt id=\"p1\">[</bpt>RESTful Cookbook<ept id=\"p1\">](http://restcookbook.com/)</ept> contains an introduction to building RESTful APIs."
    },
    {
      "pos": [
        47191,
        47349
      ],
      "content": "The Web <bpt id=\"p1\">[</bpt>API Checklist<ept id=\"p1\">](https://mathieu.fenniak.net/the-api-checklist/)</ept> contains a useful list of items to consider when designing and implementing a Web API."
    },
    {
      "content": "test",
      "pos": [
        47351,
        47355
      ]
    }
  ],
  "content": "<properties\n   pageTitle=\"API design guidance | Microsoft Azure\"\n   description=\"Guidance upon how to create a well designed API.\"\n   services=\"\"\n   documentationCenter=\"na\"\n   authors=\"dragon119\"\n   manager=\"masimms\"\n   editor=\"\"\n   tags=\"\"/>\n\n<tags\n   ms.service=\"best-practice\"\n   ms.devlang=\"rest-api\"\n   ms.topic=\"article\"\n   ms.tgt_pltfrm=\"na\"\n   ms.workload=\"na\"\n   ms.date=\"04/28/2015\"\n   ms.author=\"masashin\"/>\n\n# API design guidance\n\n![](media/best-practices-api-design/pnp-logo.png)\n\nSome topics in this guidance are under discussion and may change in the future. We welcome your feedback!\n\n\n## Overview\n\nMany modern web-based solutions make the use of web services, hosted by web servers, to provide functionality for remote client applications. The operations that a web service exposes constitute a web API. A well-designed web API should aim to support:\n\n- **Platform independence**. Client applications should be able to utilize the API that the web service provides without requiring how the data or operations that API exposes are physically implemented. This requires that the API abides by common standards that enable a client application and web service to agree on which data formats to use, and the structure of the data that is exchanged between client applications and the web service.\n\n- **Service evolution**. The web service should be able to evolve and add (or remove) functionality independently from client applications. Existing client applications should be able to continue to operate unmodified as the features provided by the web service change. All functionality should also be discoverable, so that client applications can fully utilize it.\n\nThe purpose of this guidance is to describe the issues that you should consider when designing a web API.\n\n## Introduction to Representational State Transfer (REST)\n\nIn his dissertation in 2000, Roy Fielding proposed an alternative architectural approach to structuring the operations exposed by web services; REST. REST is an architectural style for building distributed systems based on hypermedia. A primary advantage of the REST model is that it is based on open standards and does not bind the implementation of the model or the client applications that access it to any specific implementation. For example, a REST web service could be implemented by using the Microsoft ASP.NET Web API, and client applications could be developed by using any language and toolset that can generate HTTP requests and parse HTTP responses.\n\n> [AZURE.NOTE]: REST is actually independent of any underlying protocol and is not necessarily tied to HTTP. However, most common implementations of systems that are based on REST utilize HTTP as the application protocol for sending and receiving requests. This document focusses on mapping REST principles to systems designed to operate using HTTP.\n\nThe REST model uses a navigational scheme to represent objects and services over a network (referred to as _resources_). Many systems that implement REST typically use the HTTP protocol to transmit requests to access these resources. In these systems, a client application submits a request in the form of a URI that identifies a resource, and an HTTP method (the most common being GET, POST, PUT, or DELETE) that indicates the operation to be performed on that resource.  The body of the HTTP request contains the data required to perform the operation. The important point to understand is that REST defines a stateless request model. HTTP requests should be independent and may occur in any order, so attempting to retain transient state information between requests is not feasible.  The only place where information is stored is in the resources themselves, and each request should be an atomic operation. Effectively, a REST model implements a finite state machine where a request transitions a resource from one well-defined non-transient state to another.\n\n> [AZURE.NOTE] The stateless nature of individual requests in the REST model enables a system constructed by following these principles to be highly scalable. There is no need to retain any affinity between a client application making a series of requests and the specific web servers handling those requests.\n\nAnother crucial point in implementing an effective REST model is to understand the relationships between the various resources to which the model provides access. These resources are typically organized as collections and relationships. For example, suppose that a quick analysis of an ecommerce system shows that there are two collections in which client applications are likely to be interested: orders and customers. Each order and customer should have its own unique key for identification purposes. The URI to access the collection of orders could be something as simple as _/orders_, and similarly the URI for retrieving all customers could be _/customers_. Issuing an HTTP GET request to the _/orders_ URI should return a list representing all orders in the collection encoded as an HTTP response:\n\n```HTTP\nGET http://adventure-works.com/orders HTTP/1.1\n...\n```\n\nThe response shown below encodes the orders as an XML list structure. The list contains 7 orders:\n\n```HTTP\nHTTP/1.1 200 OK\n...\nDate: Fri, 22 Aug 2014 08:49:02 GMT\nContent-Length: ...\n<OrderList xmlns:i=\"...\" xmlns=\"...\"><Order><OrderID>1</OrderID><OrderValue>99.90</OrderValue><ProductID>1</ProductID><Quantity>1</Quantity></Order><Order><OrderID>2</OrderID><OrderValue>10.00</OrderValue><ProductID>4</ProductID><Quantity>2</Quantity></Order><Order><OrderID>3</OrderID><OrderValue>16.60</OrderValue><ProductID>2</ProductID><Quantity>4</Quantity></Order><Order><OrderID>4</OrderID><OrderValue>25.90</OrderValue><ProductID>3</ProductID><Quantity>1</Quantity></Order><Order><OrderID>7</OrderID><OrderValue>99.90</OrderValue><ProductID>1</ProductID><Quantity>1</Quantity></Order></OrderList>\n```\nTo fetch an individual order requires specifying the identifier for the order from the _orders_ resource, such as _/orders/2_:\n\n```HTTP\nGET http://adventure-works.com/orders/2 HTTP/1.1\n...\n```\n\n```HTTP\nHTTP/1.1 200 OK\n...\nDate: Fri, 22 Aug 2014 08:49:02 GMT\nContent-Length: ...\n<Order xmlns:i=\"...\" xmlns=\"...\">\n<OrderID>2</OrderID><OrderValue>10.00</OrderValue><ProductID>4</ProductID><Quantity>2</Quantity></Order>\n```\n\n> [AZURE.NOTE] For simplicity, these examples show the information in responses being returned as XML text data. However, there is no reason why resources should not contain any other type of data supported by HTTP, such as binary or encrypted information; the content-type in the HTTP response should specify the type. Also, a REST model may be able to return the same data in different formats, such as XML or JSON. In this case, the web service should be able to perform content negotiation with the client making the request. The request can include an _Accept_ header which specifies the preferred format that the client would like to receive and the web service should attempt to honor this format if at all possible.\n\nNotice that the response from a REST request makes use of the standard HTTP status codes. For example, a request that returns valid data should include the HTTP response code 200 (OK), while a request that fails to find or delete a specified resource should return a response that includes the HTTP status code 404 (Not Found).\n\n## Design and structure of a RESTful web API\n\nThe keys to designing a successful web API are simplicity and consistency. A Web API that exhibits these two factors makes it easier to build client applications that need to consume the API.\n\nA RESTful web API is focused on exposing a set of connected resources, and providing the core operations that enable an application to manipulate these resources and easily navigate between them. For this reason, the URIs that constitute a typical RESTful web API should be oriented towards the data that it exposes, and use the facilities provided by HTTP to operate on this data. This approach requires a different mindset from that typically employed when designing a set of classes in an object-oriented API which tends to be more motivated by the behavior of objects and classes. Additionally, a RESTful web API should be stateless and not depend on operations being invoked in a particular sequence. The following sections summarize the points you should consider when designing a RESTful web API.\n\n### Organizing the web API around resources\n\n> [AZURE.TIP] The URIs exposed by a REST web service should be based on nouns (the data to which the web API provides access) and not verbs (what an application can do with the data).\n\nFocus on the business entities that the web API exposes. For example, in a web API designed to support the ecommerce system described earlier, the primary entities are customers and orders. Processes such as the act of placing an order can be achieved by providing an HTTP POST operation that takes the order information and adds it to the list of orders for the customer. Internally, this POST operation can perform tasks such as checking stock levels, and billing the customer. The HTTP response can indicate whether the order was placed successfully or not. Also note that a resource does not have to be based on a single physical data item. As an example, an order resource might be implemented internally by using information aggregated from many rows spread across several tables in a relational database but presented to the client as a single entity.\n\n> [AZURE.TIP] Avoid designing a REST interface that mirrors or depends on the internal structure of the data that it exposes. REST is about more than implementing simple CRUD (Create, Retrieve, Update, Delete) operations over separate tables in a relational database. The purpose of REST is to map business entities and the operations that an application can perform on these entities to the physical implementation of these entities, but a client should not be exposed to these physical details.\n\nIndividual business entities rarely exist in isolation (although some singleton objects may exist), but instead tend to be grouped together into collections. In REST terms, each entity and each collection are resources. In a RESTful web API, each collection has its own URI within the web service, and performing an HTTP GET request over a URI for a collection retrieves a list of items in that collection. Each individual item also has its own URI, and an application can submit another HTTP GET request using that URI to retrieve the details of that item. You should organize the URIs for collections and items in a hierarchical manner. In the ecommerce system, the URI _/customers_ denotes the customer’s collection, and _/customers/5_ retrieves the details for the single customer with the ID 5 from this collection. This approach helps to keep the web API intuitive.\n\n> [AZURE.TIP] Adopt a consistent naming convention in URIs; in general it helps to use plural nouns for URIs that reference collections.\n\nYou also need to consider the relationships between different types of resources and how you might expose these associations. For example, customers may place zero or more orders. A natural way to represent this relationship would be through a URI such as _/customers/5/orders_ to find all the orders for customer 5. You might also consider representing the association from an order back to a specific customer through a URI such as _/orders/99/customer_ to find the customer for order 99, but extending this model too far can become cumbersome to implement. A better solution is to provide navigable links to associated resources, such as the customer, in the body of the HTTP response message returned when the order is queried. This mechanism is described in more detail in the section Using the HATEOAS Approach to Enable Navigation To Related Resources later in this guidance.\n\nIn more complex systems there may be many more types of entity, and it can be tempting to provide URIs that enable a client application to navigate through several levels of relationships, such as _/customers/1/orders/99/products_ to obtain the list of products in order 99 placed by customer 1. However, this level of complexity can be difficult to maintain and is inflexible if the relationships between resources change in the future. Rather, you should seek to keep URIs relatively simple. Bear in mind that once an application has a reference to a resource, it should be possible to use this reference to find items related to that resource. The preceding query can be replaced with the URI _/customers/1/orders_ to find all the orders for customer 1, and then query the URI _/orders/99/products_ to find the products in this order (assuming order 99 was placed by customer 1).\n\n> [AZURE.TIP] Avoid requiring resource URIs more complex than _collection/item/collection_.\n\nAnother point to consider is that all web requests impose a load on the web server, and the greater the number of requests the bigger the load. You should attempt to define your resources to avoid “chatty” web APIs that expose a large number of small resources. Such an API may require a client application to submit multiple requests to find all the data that it requires. It may be beneficial to denormalize data and combine related information together into bigger resources that can be retrieved by issuing a single request. However, you need to balance this approach against the overhead of fetching data that might not be frequently required by the client. Retrieving large objects can increase the latency of a request and incur additional bandwidth costs for little advantage if the additional data is not often used.\n\nAvoid introducing dependencies between the web API to the structure, type, or location of the underlying data sources. For example, if your data is located in a relational database, the web API does not need to expose each table as a collection of resources. Think of the web API as an abstraction of the database, and if necessary introduce a mapping layer between the database and the web API. In this way, if the design or implementation of the database changes (for example, you move from a relational database containing a collection of normalized tables to a denormalized NoSQL storage system such as a document database) client applications are insulated from these changes.\n> [AZURE.TIP] The source of the data that underpins a web API does not have to be a data store; it could be another service or line-of-business application or even a legacy application running on-premises within an organization.\n\nFinally, it might not be possible to map every operation implemented by a web API to a specific resource. You can handle such _non-resource_ scenarios through HTTP GET requests that invoke a piece of functionality and return the results as an HTTP response message. A web API that implements simple calculator-style operations such as add and subtract could provide URIs that expose these operations as pseudo resources and utilize the query string to specify the parameters required. For example a GET request to the URI _/add?operand1=99&operand2=1_ could return a response message with the body containing the value 100, and GET request to the URI _/subtract?operand1=50&operand2=20_ could return a response message with the body containing the value 30. However, only use these forms of URIs sparingly.\n\n### Defining operations in terms of HTTP methods\n\nThe HTTP protocol defines a number of methods that assign semantic meaning to a request. The common HTTP methods used by most RESTful web APIs are:\n\n- **GET**, to retrieve a copy of the resource at the specified URI. The body of the response message contains the details of the requested resource.\n\n- **POST**, to create a new resource at the specified URI. The body of the request message provides the details of the new resource. Note that POST can also be used to trigger operations that don't actually create resources.\n\n- **PUT**, to replace or update the resource at the specified URI. The body of the request message specifies the resource to be modified and the values to be applied.\n\n- **DELETE**, to remove the resource at the specified URI.\n\n> [AZURE.NOTE] The HTTP protocol also defines other less commonly-used methods, such as PATCH which is used to request selective updates to a resource, HEAD which is used to request a description of a resource, OPTIONS which enables a client information to obtain information about the communication options supported by the server, and TRACE which allows a client to request information that it can use for testing and diagnostics purposes.\n\nThe effect of a specific request should depend on whether the resource to which it is applied is a collection or an individual item. The following table summarizes the common conventions adopted by most RESTful implementations using the ecommerce example. Note that not all of these requests might be implemented; it depends on the specific scenario.\n\n| **Resource** | **POST** | **GET** | **PUT** | **DELETE** |\n|--------------|----------|---------|---------|------------|\n| /customers | Create a new customer | Retrieve all customers | Bulk update of customers (_if implemented_) | Remove all customers |\n| /customers/1 | Error | Retrieve the details for customer 1 | Update the details of customer 1 if it exists, otherwise return an error | Remove customer 1 |\n| /customers/1/orders | Create a new order for customer 1 | Retrieve all orders for customer 1 | Bulk update of orders for customer 1 (_if implemented_) | Remove all orders for customer 1(_if implemented_) |\n\nThe purpose of GET and DELETE requests are relatively straightforward, but there is scope for confusion concerning the purpose and effects of POST and PUT requests.\n\nA POST request should create a new resource with data provided in the body of the request. In the REST model, you frequently apply POST requests to resources that are collections; the new resource is added to the collection.\n\n> [AZURE.NOTE] You can also define POST requests that trigger some functionality (and that don't necessarily return data), and these types of request can be applied to collections. For example you could use a POST request to pass a timesheet to a payroll processing service and get the calculated taxes back as a response.\n\nA PUT request is intended to modify an existing resource. If the specified resource does not exist, the PUT request could return an error (in some cases, it might actually create the resource). PUT requests are most frequently applied to resources that are individual items (such as a specific customer or order), although they can be applied to collections, although this is less-commonly implemented. Note that PUT requests are idempotent whereas POST requests are not; if an application submits the same PUT request multiple times the results should always be the same (the same resource will be modified with the same values), but if an application repeats the same POST request the result will be the creation of multiple resources.\n\n> [AZURE.NOTE] Strictly speaking, an HTTP PUT request replaces an existing resource with the resource specified in the body of the request. If the intention is to modify a selection of properties in a resource but leave other properties unchanged, then this should be implemented by using an HTTP PATCH request. However, many RESTful implementations relax this rule and use PUT for both situations.\n\n### Processing HTTP requests\nThe data included by a client application in many HTTP requests, and the corresponding response messages from the web server, could be presented in a variety of formats (or media types). For example, the data that specifies the details for a customer or order could be provided as XML, JSON, or some other encoded and compressed format. A RESTful web API should support different media types as requested by the client application that submits a request.\n\nWhen a client application sends a request that returns data in the body of a message, it can specify the media types it can handle in the Accept header of the request. The following code illustrates an HTTP GET request that retrieves the details of customer 1 and requests the result to be returned as JSON (the client should still examine the media type of the data in the response to verify the format of the data returned):\n\n```HTTP\nGET http://adventure-works.com/orders/2 HTTP/1.1\n...\nAccept: application/json\n...\n```\n\nIf the web server supports this media type, it can reply with a response that includes Content-Type header that specifies the format of the data in the body of the message:\n\n> [AZURE.NOTE] For maximum interoperability, the media types referenced in the Accept and Content-Type headers should be recognized MIME types rather than some custom media type.\n\n```HTTP\nHTTP/1.1 200 OK\n...\nContent-Type: application/json; charset=utf-8\n...\nDate: Fri, 22 Aug 2014 09:18:37 GMT\nContent-Length: ...\n{\"OrderID\":2,\"ProductID\":4,\"Quantity\":2,\"OrderValue\":10.00}\n```\n\nIf the web server does not support the requested media type, it can send the data in a different format. IN all cases it must specify the media type (such as _text/xml_) in the Content-Type header. It is the responsibility of the client application to parse the response message and interpret the results in the message body appropriately.\n\nNote that in this example, the web server successfully retrieves the requested data and indicates success by passing back a status code of 200 in the response header. If no matching data is found, it should instead return a status code of 404 (not found) and the body of the response message can contain additional information. The format of this information is specified by the Content-Type header, as shown in the following example:\n\n```HTTP\nGET http://adventure-works.com/orders/222 HTTP/1.1\n...\nAccept: application/json\n...\n```\n\nOrder 222 does not exist, so the response message looks like this:\n\n```HTTP\nHTTP/1.1 404 Not Found\n...\nContent-Type: application/json; charset=utf-8\n...\nDate: Fri, 22 Aug 2014 09:18:37 GMT\nContent-Length: ...\n{\"Message\":\"No such order\"}\n```\n\nWhen an application sends an HTTP PUT request to update a resource, it specifies the URI of the resource and provides the data to be modified in the body of the request message. It should also specify the format of this data by using the Content-Type header. A common format used for text-based information is _application/x-www-form-urlencoded_, which comprises a set of name/value pairs separated by the & character. The next example shows an HTTP PUT request that modifies the information in order 1:\n\n```HTTP\nPUT http://adventure-works.com/orders/1 HTTP/1.1\n...\nContent-Type: application/x-www-form-urlencoded\n...\nDate: Fri, 22 Aug 2014 09:18:37 GMT\nContent-Length: ...\nProductID=3&Quantity=5&OrderValue=250\n```\n\nIf the modification is successful, it should ideally respond with an HTTP 204 status code, indicating that the process has been successfully handled, but that the response body contains no further information. The Location header in the response contains the URI of the newly updated resource:\n\n```HTTP\nHTTP/1.1 204 No Content\n...\nLocation: http://adventure-works.com/orders/1\n...\nDate: Fri, 22 Aug 2014 09:18:37 GMT\n```\n\n> [AZURE.TIP] If the data in an HTTP PUT request message includes date and time information, make sure that your web service accepts dates and times formatted following the ISO 8601 standard.\n\nIf the resource to be updated does not exist, the web server can respond with a Not Found response as described earlier. Alternatively, if the server actually creates the object itself it could return the status codes HTTP 200 (OK) or HTTP 201 (Created) and the response body could contain the data for the new resource. If the Content-Type header of the request specifies a data format that the web server cannot handle, it should respond with HTTP status code 415 (Unsupported Media Type).\n\n> [AZURE.TIP] Consider implementing bulk HTTP PUT operations that can batch updates to multiple resources in a collection. The PUT request should specify the URI of the collection, and the request body should specify the details of the resources to be modified. This approach can help to reduce chattiness and improve performance.\n\nThe format of an HTTP POST requests that create new resources are similar to those of PUT requests; the message body contains the details of the new resource to be added. However, the URI typically specifies the collection to which the resource should be added. The following example creates a new order and adds it to the orders collection:\n\n```HTTP\nPOST http://adventure-works.com/orders HTTP/1.1\n...\nContent-Type: application/x-www-form-urlencoded\n...\nDate: Fri, 22 Aug 2014 09:18:37 GMT\nContent-Length: ...\nProductID=5&Quantity=15&OrderValue=400\n```\n\nIf the request is successful, the web server should respond with a message code with HTTP status code 201 (Created). The Location header should contain the URI of the newly created resource, and the body of the response should contain a copy of the new resource; the Content-Type header specifies the format of this data:\n\n```HTTP\nHTTP/1.1 201 Created\n...\nContent-Type: application/json; charset=utf-8\nLocation: http://adventure-works.com/orders/99\n...\nDate: Fri, 22 Aug 2014 09:18:37 GMT\nContent-Length: ...\n{\"OrderID\":99,\"ProductID\":5,\"Quantity\":15,\"OrderValue\":400}\n```\n\n> [AZURE.TIP] If the data provided by a PUT or POST request is invalid, the web server should respond with a message with HTTP status code 400 (Bad Request). The body of this message can contain additional information about the problem with the request and the formats expected, or it can contain a link to a URL that provides more details.\n\nTo remove a resource, an HTTP DELETE request simply provides the URI of the resource to be deleted. The following example attempts to remove order 99:\n\n```HTTP\nDELETE http://adventure-works.com/orders/99 HTTP/1.1\n...\n```\n\nIf the delete operation is successful, the web server should respond with HTTP status code 204, indicating that the process has been successfully handled, but that the response body contains no further information (this is the same response returned by a successful PUT operation, but without a Location header as the resource no longer exists.) It is also possible for a DELETE request to return HTTP status code 200 (OK) or 202 (Accepted) if the deletion is performed asynchronously.\n\n```HTTP\nHTTP/1.1 204 No Content\n...\nDate: Fri, 22 Aug 2014 09:18:37 GMT\n```\n\nIf the resource is not found, the web server should return a 404 (Not Found) message instead.\n\n> [AZURE.TIP] If all the resources in a collection need to be deleted, enable an HTTP DELETE request to be specified for the URI of the collection rather than forcing an application to remove each resource in turn from the collection.\n\n### Filtering and paginating data\n\nYou should endeavour to keep the URIs simple and intuitive. Exposing a collection of resources through a single URI assists in this respect, but it can lead to applications fetching large amounts of data when only a subset of the information is required. Generating a large volume of traffic impacts not only the performance and scalability of the web server but also adversely affect the responsiveness of client applications requesting the data.\n\nFor example, if orders contain the price paid for the order, a client application that needs to retrieve all orders that have a cost over a specific value might need to retrieve all orders from the _/orders_ URI and then filter these orders locally. Clearly this process is highly inefficient; it wastes network bandwidth and processing power on the server hosting the web API.\n\nOne solution may be to provide a URI scheme such as _/orders/ordervalue_greater_than_n_ where _n_ is the order price, but for all but a limited number of prices such an approach is impractical. Additionally, if you need to query orders based on other criteria, you can end up being faced with providing with a long list of URIs with possibly non-intuitive names.\n\nA better strategy to filtering data is to provide the filter criteria in the query string that is passed to the web API, such as _/orders?ordervaluethreshold=n_. In this example, the corresponding operation in the web API is responsible for parsing and handling the `ordervaluethreshold` parameter in the query string and returning the filtered results in the HTTP response.\n\nSome simple HTTP GET requests over collection resources could potentially return a large number of items. To combat the possibility of this occurring you should design the web API to limit the amount of data returned by any single request. You can achieve this by supporting query strings that enable the user to specify the maximum number of items to be retrieved (which could itself be subject to an upperbound limit to help prevent Denial of Service attacks), and a starting offset into the collection. For example, the query string in the URI _/orders?limit=25&offset=50_ should retrieve 25 orders starting with the 50th order found in the orders collection. As with filtering data, the operation that implements the GET request in the web API is responsible for parsing and handling the `limit` and `offset` parameters in the query string. To assist client applications, GET requests that return paginated data should also include some form of metadata that indicate the total number of resources available in the collection. You might also consider other intelligent paging strategies; for more information, see [API Design Notes: Smart Paging](http://bizcoder.com/api-design-notes-smart-paging)\n\nYou can follow a similar strategy for sorting data as it is fetched; you could provide a sort parameter that takes a field name as the value, such as _/orders?sort=ProductID_. However, note that this approach can have a deleterious effect on caching (query string parameters form part of the resource identifier used by many cache implementations as the key to cached data).\n\nYou can extend this approach to limit (project) the fields returned if a single resource item contains a large amount of data. For example, you could use a query string parameter that accepts a comma-delimited list of fields, such as _/orders?fields=ProductID,Quantity_.\n\n> [AZURE.TIP] Give all optional parameters in query strings meaningful defaults. For example, set the `limit` parameter to 10 and the `offset` parameter to 0 if you implement pagination, set the sort parameter to the key of the resource if you implement ordering, and set the `fields` parameter to all fields in the resource if you support projections.\n\n### Handling large binary resources\n\nA single resource may contain large binary fields, such as files or images. To overcome the transmission problems caused by unreliable and intermittent connections and to improve response times, consider providing operations that enable such resources to be retrieved in chunks by the client application. To do this, the web API should support the Accept-Ranges header for GET requests for large resources, and ideally implement HTTP HEAD requests for these resources. The Accept-Ranges header indicates that the GET operation supports partial results, and that a client application can submit GET requests that return a subset of a resource specified as a range of bytes. A HEAD request is similar to a GET request except that it only returns a header that describes the resource and an empty message body. A client application can issue a HEAD request to determine whether to fetch a resource by using partial GET requests. The following example shows a HEAD request that obtains information about a product image:\n\n```HTTP\nHEAD http://adventure-works.com/products/10?fields=ProductImage HTTP/1.1\n...\n```\n\nThe response message contains a header that includes the size of the resource (4580 bytes), and the Accept-Ranges header that the corresponding GET operation supports partial results:\n\n```HTTP\nHTTP/1.1 200 OK\n...\nAccept-Ranges: bytes\nContent-Type: image/jpeg\nContent-Length: 4580\n...\n```\n\nThe client application can use this information to construct a series of GET operations to retrieve the image in smaller chunks. The first request fetches the first 2500 bytes by using the Range header:\n\n```HTTP\nGET http://adventure-works.com/products/10?fields=ProductImage HTTP/1.1\nRange: bytes=0-2499\n...\n```\n\nThe response message indicates that this is a partial response by returning HTTP status code 206. The Content-Length header specifies the actual number of bytes returned in the message body (not the size of the resource), and the Content-Range header indicates which part of the resource this is (bytes 0-2499 out of 4580):\n\n```HTTP\nHTTP/1.1 206 Partial Content\n...\nAccept-Ranges: bytes\nContent-Type: image/jpeg\nContent-Length: 2500\nContent-Range: bytes 0-2499/4580\n...\n_{binary data not shown}_\n```\n\nA subsequent request from the client application can retrieve the remainder of the resource by using an appropriate Range header:\n\n```HTTP\nGET http://adventure-works.com/products/10?fields=ProductImage HTTP/1.1\nRange: bytes=2500-\n...\n```\n\nThe corresponding result message should look like this:\n\n```HTTP\nHTTP/1.1 206 Partial Content\n...\nAccept-Ranges: bytes\nContent-Type: image/jpeg\nContent-Length: 2080\nContent-Range: bytes 2500-4580/4580\n...\n```\n\n## Using the HATEOAS approach to enable navigation to related resources\n\nOne of the primary motivations behind REST is that it should be possible to navigate the entire set of resources without requiring prior knowledge of the URI scheme. Each HTTP GET request should return the information necessary to find the resources related directly to the requested object through hyperlinks included in the response, and it should also be provided with information that describes the operations available on each of these resources. This principle is known as HATEOAS, or Hypertext as the Engine of Application State. The system is effectively a finite state machine, and the response to each request contains the information necessary to move from one state to another; no other information should be necessary.\n\n> [AZURE.NOTE] Currently there are no standards or specifications that define how to model the HATEOAS principle. The examples shown in this section illustrate one possible solution.\n\nAs an example, to handle the relationship between customers and orders, the data returned in the response for a specific order should contain URIs in the form of a hyperlink identifying the customer that placed the order, and the operations that can be performed on that customer.\n\n```HTTP\nGET http://adventure-works.com/orders/3 HTTP/1.1\nAccept: application/json\n...\n```\n\nThe body of the response message contains a `Links` array (highlighted in the code example) that specifies the nature of the relationship (_Customer_), the URI of the customer (_http://adventure-works.com/customers/3_), how to retrieve the details of this customer (_GET_), and the MIME types that the web server supports for retrieving this information (_text/xml_ and _application/json_). This is all the information that a client application needs to be able to fetch the details of the customer. Additionally, the Links array also includes links for the other operations that can be performed, such as PUT (to modify the customer, together with the format that the web server expects the client to provide), and DELETE.\n\n```HTTP\nHTTP/1.1 200 OK\n...\nContent-Type: application/json; charset=utf-8\n...\nContent-Length: ...\n{\"OrderID\":3,\"ProductID\":2,\"Quantity\":4,\"OrderValue\":16.60,\"Links\":[(some links omitted){\"Relationship\":\"customer\",\"HRef\":\" http://adventure-works.com/customers/3\", \"Action\":\"GET\",\"LinkedResourceMIMETypes\":[\"text/xml\",\"application/json\"]},{\"Relationship\":\"\ncustomer\",\"HRef\":\" http://adventure-works.com /customers/3\", \"Action\":\"PUT\",\"LinkedResourceMIMETypes\":[\"application/x-www-form-urlencoded\"]},{\"Relationship\":\"customer\",\"HRef\":\" http://adventure-works.com /customers/3\",\"Action\":\"DELETE\",\"LinkedResourceMIMETypes\":[]}]}\n```\n\nFor completeness, the Links array should also include self-referencing information pertaining to the resource that has been retrieved. These links have been omitted from the previous example, but are highlighted in the following code. Notice that in these links, the relationship _self_ has been used to indicate that this is a reference to the resource being returned by the operation:\n\n```HTTP\nHTTP/1.1 200 OK\n...\nContent-Type: application/json; charset=utf-8\n...\nContent-Length: ...\n{\"OrderID\":3,\"ProductID\":2,\"Quantity\":4,\"OrderValue\":16.60,\"Links\":[{\"Relationship\":\"self\",\"HRef\":\" http://adventure-works.com/orders/3\", \"Action\":\"GET\",\"LinkedResourceMIMETypes\":[\"text/xml\",\"application/json\"]},{\"Relationship\":\" self\",\"HRef\":\" http://adventure-works.com /orders/3\", \"Action\":\"PUT\",\"LinkedResourceMIMETypes\":[\"application/x-www-form-urlencoded\"]},{\"Relationship\":\"self\",\"HRef\":\" http://adventure-works.com /orders/3\", \"Action\":\"DELETE\",\"LinkedResourceMIMETypes\":[]},{\"Relationship\":\"customer\",\n\"HRef\":\" http://adventure-works.com /customers/3\", \"Action\":\"GET\",\"LinkedResourceMIMETypes\":[\"text/xml\",\"application/json\"]},{\"Relationship\":\" customer\" (customer links omitted)}]}\n```\n\nFor this approach to be effective, client applications must be prepared to retrieve and parse this additional information.\n\n## Versioning a RESTful web API\n\nIt is highly unlikely that in all but the simplest of situations that a web API will remain static. As business requirements change new collections of resources may be added, the relationships between resources might change, and the structure of the data in resources might be amended. While updating a web API to handle new or differing requirements is a relatively straightforward process, you must consider the effects that such changes will have on client applications consuming the web API. The issue is that although the developer designing and implementing a web API has full control over that API, the developer does not have the same degree of control over client applications which may be built by third party organizations operating remotely. The primary imperative is to enable existing client applications to continue functioning unchanged while allowing new client applications to take advantage of new features and resources.\n\nVersioning enables a web API to indicate the features and resources that it exposes, and a client application can submit requests that are directed to a specific version of a feature or resource. The following sections describe several different approaches, each of which has its own benefits and trade-offs.\n\n### No versioning\n\nThis is the simplest approach, and may be acceptable for some internal APIs. Big changes could be represented as new resources or new links.  Adding content to existing resources might not present a breaking change as client applications that are not expecting to see this content will simply ignore it.\n\nFor example, a request to the URI _http://adventure-works.com/customers/3_ should return the details of a single customer containing `Id`, `Name`, and `Address` fields expected by the client application:\n\n```HTTP\nHTTP/1.1 200 OK\n...\nContent-Type: application/json; charset=utf-8\n...\nContent-Length: ...\n[{\"Id\":3,\"Name\":\"Contoso LLC\",\"Address\":\"1 Microsoft Way Redmond WA 98053\"}]\n```\n\n> [AZURE.NOTE] For the purposes of simplicity and clarity, the example responses shown in this section do not include HATEOAS links.\n\nIf the `DateCreated` field is added to the schema of the customer resource, then the response would look like this:\n\n```HTTP\nHTTP/1.1 200 OK\n...\nContent-Type: application/json; charset=utf-8\n...\nContent-Length: ...\n[{\"Id\":3,\"Name\":\"Contoso LLC\",\"DateCreated\":\"2014-09-04T12:11:38.0376089Z\",\"Address\":\"1 Microsoft Way Redmond WA 98053\"}]\n```\n\nExisting client applications might continue functioning correctly if they are capable of ignoring unrecognized fields, while new client applications can be designed to handle this new field. However, if more radical changes to the schema of resources occur (such as removing or renaming fields) or the relationships between resources change then these may constitute breaking changes that prevent existing client applications from functioning correctly. In these situations you should consider one of the following approaches.\n\n### URI versioning\n\nEach time you modify the web API or change the schema of resources, you add a version number to the URI for each resource. The previously existing URIs should continue to operate as before, returning resources that conform to their original schema.\n\nExtending the previous example, if the `Address` field is restructured into sub-fields containing each constituent part of the address (such as `StreetAddress`, `City`, `State`, and `ZipCode`), this version of the resource could be exposed through a URI containing a version number, such as http://adventure-works.com/v2/customers/3:\n\n```HTTP\nHTTP/1.1 200 OK\n...\nContent-Type: application/json; charset=utf-8\n...\nContent-Length: ...\n[{\"Id\":3,\"Name\":\"Contoso LLC\",\"DateCreated\":\"2014-09-04T12:11:38.0376089Z\",\"Address\":{\"StreetAddress\":\"1 Microsoft Way\",\"City\":\"Redmond\",\"State\":\"WA\",\"ZipCode\":98053}}]\n```\n\nThis versioning mechanism is very simple but depends on the server routing the request to the appropriate endpoint. However, it can become unwieldy as the web API matures through several iterations and the server has to support a number of different versions. Also, from a purist’s point of view, in all cases the client applications are fetching the same data (customer 3), so the URI should not really be different depending on the version. This scheme also complicates implementation of HATEOAS as all links will need to include the version number in their URIs.\n\n### Query string versioning\n\nRather than providing multiple URIs, you can specify the version of the resource by using a parameter within the query string appended to the HTTP request, such as _http://adventure-works.com/customers/3?version=2_. The version parameter should default to a meaningful value such as 1 if it is omitted by older client applications.\n\nThis approach has the semantic advantage that the same resource is always retrieved from the same URI, but it depends on the code that handles the request to parse the query string and send back the appropriate HTTP response. This approach also suffers from the same complications for implementing HATEOAS as the URI versioning mechanism.\n\n> [AZURE.NOTE] Some older web browsers and web proxies will not cache responses for requests that include a query string in the URL. This can have an adverse impact on performance for web applications that use a web API and that run from within such a web browser.\n\n### Header versioning\n\nRather than appending the version number as a query string parameter, you could implement a custom header that indicates the version of the resource. This approach requires that the client application adds the appropriate header to any requests, although the code handling the client request could use a default value (version 1) if the version header is omitted. The following examples utilize a custom header named _Custom-Header_. The value of this header indicates the version of web API.\n\nVersion 1:\n\n```HTTP\nGET http://adventure-works.com/customers/3 HTTP/1.1\n...\nCustom-Header: api-version=1\n...\n```\n\n```HTTP\nHTTP/1.1 200 OK\n...\nContent-Type: application/json; charset=utf-8\n...\nContent-Length: ...\n[{\"Id\":3,\"Name\":\"Contoso LLC\",\"Address\":\"1 Microsoft Way Redmond WA 98053\"}]\n```\n\nVersion 2:\n\n```HTTP\nGET http://adventure-works.com/customers/3 HTTP/1.1\n...\nCustom-Header: api-version=2\n...\n```\n\n```HTTP\nHTTP/1.1 200 OK\n...\nContent-Type: application/json; charset=utf-8\n...\nContent-Length: ...\n[{\"Id\":3,\"Name\":\"Contoso LLC\",\"DateCreated\":\"2014-09-04T12:11:38.0376089Z\",\"Address\":{\"StreetAddress\":\"1 Microsoft Way\",\"City\":\"Redmond\",\"State\":\"WA\",\"ZipCode\":98053}}]\n```\n\nNote that as with the previous two approaches, implementing HATEOAS requires including the appropriate custom header in any links.\n\n### Media type versioning\n\nWhen a client application sends an HTTP GET request to a web server it should stipulate the format of the content that it can handle by using an Accept header, as described earlier in this guidance. Frequently the purpose of the _Accept_ header is to allow the client application to specify whether the body of the response should be XML, JSON, or some other common format that the client can parse. However, it is possible to define custom media types that include information enabling the client application to indicate which version of a resource it is expecting. The following example shows a request that specifies an _Accept_ header with the value _application/vnd.adventure-works.v1+json_. The _vnd.adventure-works.v1_ element indicates to the web server that it should return version 1 of the resource, while the _json_ element specifies that the format of the response body should be JSON:\n\n```HTTP\nGET http://adventure-works.com/customers/3 HTTP/1.1\n...\nAccept: application/vnd.adventure-works.v1+json\n...\n```\n\nThe code handling the request is responsible for processing the _Accept_ header and honoring it as far as possible (the client application may specify multiple formats in the _Accept_ header, in which case the web server can choose the most appropriate format for the response body). The web server confirms the format of the data in the response body by using the Content-Type header:\n\n```HTTP\nHTTP/1.1 200 OK\n...\nContent-Type: application/vnd.adventure-works.v1+json; charset=utf-8\n...\nContent-Length: ...\n[{\"Id\":3,\"Name\":\"Contoso LLC\",\"Address\":\"1 Microsoft Way Redmond WA 98053\"}]\n```\n\nIf the Accept header does not specify any known media types, the web server could generate an HTTP 406 (Not Acceptable) response message or return a message with a default media type.\n\nThis approach is arguably the purest of the versioning mechanisms and lends itself naturally to HATEOAS, which can include the MIME type of related data in resource links.\n\n> [AZURE.NOTE] When you select a versioning strategy, you should also consider the implications on performance, especially caching on the web server. The URI versioning and Query String versioning schemes are cache-friendly inasmuch as the same URI/query string combination refers to the same data each time.\n\n> The Header versioning and Media Type versioning mechanisms typically require additional logic to examine the values in the custom header or the Accept header. In a large-scale environment, many clients using different versions of a web API can result in a significant amount of duplicated data in a server-side cache. This issue can become acute if a client application communicates with a web server through a proxy that implements caching, and that only forwards a request to the web server if it does not currently hold a copy of the requested data in its cache.\n\n## More information\n\n- The [RESTful Cookbook](http://restcookbook.com/) contains an introduction to building RESTful APIs.\n- The Web [API Checklist](https://mathieu.fenniak.net/the-api-checklist/) contains a useful list of items to consider when designing and implementing a Web API.\n\ntest\n"
}