{
  "nodes": [
    {
      "content": "DocumentDB programming: Stored procedures, triggers, and UDFs | Microsoft Azure",
      "pos": [
        28,
        107
      ]
    },
    {
      "content": "Find out how to use Microsoft Azure DocumentDB to write stored procedures, triggers, and user defined functions (UDFs) natively in JavaScript.",
      "pos": [
        127,
        269
      ]
    },
    {
      "content": "DocumentDB server-side programming: Stored procedures, triggers, and UDFs",
      "pos": [
        588,
        661
      ]
    },
    {
      "content": "Learn how DocumentDB’s language integrated, transactional execution of JavaScript lets developers write <bpt id=\"p1\">**</bpt>stored procedures<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>triggers<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>user defined functions (UDFs)<ept id=\"p3\">**</ept> natively in JavaScript.",
      "pos": [
        663,
        864
      ]
    },
    {
      "content": "This allows you to write application logic that can be shipped and executed directly on the database storage partitions",
      "pos": [
        865,
        984
      ]
    },
    {
      "content": "We recommend getting started by watching the following video, where Andrew Liu provides a brief introduction to DocumentDB's server-side programming model.",
      "pos": [
        987,
        1142
      ]
    },
    {
      "content": "Then, return to this article, where you'll learn the answers to the following questions:",
      "pos": [
        1231,
        1319
      ]
    },
    {
      "content": "How do I write a a stored procedure, trigger, or UDF using JavaScript?",
      "pos": [
        1325,
        1395
      ]
    },
    {
      "content": "How does DocumentDB guarantee ACID?",
      "pos": [
        1398,
        1433
      ]
    },
    {
      "content": "How do transactions work in DocumentDB?",
      "pos": [
        1436,
        1475
      ]
    },
    {
      "content": "What are pre-triggers and post-triggers and how do I write one?",
      "pos": [
        1478,
        1541
      ]
    },
    {
      "content": "How do I register and execute a stored procedure, trigger, or UDF in a RESTful manner by using HTTP?",
      "pos": [
        1544,
        1644
      ]
    },
    {
      "content": "What DocumentDB SDKs are available to create and execute stored procedures, triggers, and UDFs?",
      "pos": [
        1647,
        1742
      ]
    },
    {
      "content": "Introduction",
      "pos": [
        1747,
        1759
      ]
    },
    {
      "content": "This approach of <bpt id=\"p1\">*</bpt>“JavaScript as a modern day T-SQL”<ept id=\"p1\">*</ept> frees application developers from the complexities of type system mismatches and object-relational mapping technologies.",
      "pos": [
        1761,
        1935
      ]
    },
    {
      "content": "It also has a number of intrinsic advantages that can be utilized to build rich applications:",
      "pos": [
        1936,
        2029
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Procedural Logic:<ept id=\"p1\">**</ept> JavaScript as a high level programming language, provides a rich and familiar interface to express business logic.",
      "pos": [
        2037,
        2173
      ]
    },
    {
      "content": "You can perform complex sequences of operations closer to the data.",
      "pos": [
        2174,
        2241
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Atomic Transactions:<ept id=\"p1\">**</ept> DocumentDB guarantees that database operations performed inside a single stored procedure or trigger are atomic.",
      "pos": [
        2247,
        2384
      ]
    },
    {
      "content": "This lets an application combine related operations in a single batch so that either all of them succeed or none of them succeed.",
      "pos": [
        2385,
        2514
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Performance:<ept id=\"p1\">**</ept> The fact that JSON is intrinsically mapped to the Javascript language type system and is also the basic unit of storage in DocumentDB allows for a number of optimizations like lazy materialization of JSON documents in the buffer pool and making them available on-demand to the executing code.",
      "pos": [
        2521,
        2830
      ]
    },
    {
      "content": "There are more performance benefits associated with shipping business logic to the database:",
      "pos": [
        2831,
        2923
      ]
    },
    {
      "content": "Batching – Developers can group operations like inserts and submit them in bulk.",
      "pos": [
        2932,
        3012
      ]
    },
    {
      "content": "The network traffic latency cost and the store overhead to create separate transactions are reduced significantly.",
      "pos": [
        3013,
        3127
      ]
    },
    {
      "content": "Pre-compilation – DocumentDB precompiles stored procedures, triggers and user defined functions (UDFs) to avoid JavaScript compilation cost for each invocation.",
      "pos": [
        3137,
        3297
      ]
    },
    {
      "content": "The overhead of building the byte code for the procedural logic is amortized to a minimal value.",
      "pos": [
        3298,
        3394
      ]
    },
    {
      "content": "Sequencing – Many operations need a side-effect (“trigger”) that potentially involves doing one or many secondary store operations.",
      "pos": [
        3403,
        3534
      ]
    },
    {
      "content": "Aside from atomicity, this is more performant when moved to the server.",
      "pos": [
        3535,
        3606
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>Encapsulation:<ept id=\"p1\">**</ept> Stored procedures can be used to group business logic in one place.",
      "pos": [
        3612,
        3698
      ]
    },
    {
      "content": "This has two advantages:",
      "pos": [
        3699,
        3723
      ]
    },
    {
      "content": "It adds an abstraction layer on top of the raw data, which enables data architects to evolve their applications independently from the data.",
      "pos": [
        3732,
        3872
      ]
    },
    {
      "content": "This is particularly advantageous when the data is schema-less, due to the brittle assumptions that may need to be baked into the application if they have to deal with data directly.",
      "pos": [
        3873,
        4055
      ]
    },
    {
      "content": "This abstraction lets enterprises keep their data secure by streamlining the access from the scripts.",
      "pos": [
        4066,
        4167
      ]
    },
    {
      "content": "The creation and execution of triggers, stored procedure and custom query operators is supported through the <bpt id=\"p1\">[</bpt>REST API<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn781481.aspx)</ept>, and <bpt id=\"p2\">[</bpt>client SDKs<ept id=\"p2\">](https://msdn.microsoft.com/library/azure/dn781482.aspx)</ept> in many platforms including .NET, Node.js and JavaScript.",
      "pos": [
        4171,
        4479
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>This tutorial uses the <bpt id=\"p2\">[</bpt>Node.js SDK<ept id=\"p2\">](http://dl.windowsazure.com/documentDB/nodedocs/)</ept><ept id=\"p1\">**</ept> to illustrate syntax and usage of stored procedures, triggers, and UDFs.",
      "pos": [
        4480,
        4642
      ]
    },
    {
      "content": "Stored procedures",
      "pos": [
        4650,
        4667
      ]
    },
    {
      "content": "Example: Write a simple stored procedure",
      "pos": [
        4673,
        4713
      ]
    },
    {
      "content": "Let’s start with a simple stored procedure that returns a “Hello World” response.",
      "pos": [
        4715,
        4796
      ]
    },
    {
      "content": "Stored procedures are registered per collection, and can operate on any document and attachment present in that collection.",
      "pos": [
        5044,
        5167
      ]
    },
    {
      "content": "The following snippet shows how to register the helloWorld stored procedure with a collection.",
      "pos": [
        5168,
        5262
      ]
    },
    {
      "content": "Once the stored procedure is registered, we can execute it against the collection, and read the results back at the client.",
      "pos": [
        5655,
        5778
      ]
    },
    {
      "content": "The context object provides access to all operations that can be performed on DocumentDB storage, as well as access to the request and response objects.",
      "pos": [
        6065,
        6217
      ]
    },
    {
      "content": "In this case, we used the response object to set the body of the response that was sent back to the client.",
      "pos": [
        6218,
        6325
      ]
    },
    {
      "content": "For more details, refer to the <bpt id=\"p1\">[</bpt>DocumentDB JavaScript server SDK documentation<ept id=\"p1\">](http://dl.windowsazure.com/documentDB/jsserverdocs/)</ept>.",
      "pos": [
        6326,
        6459
      ]
    },
    {
      "content": "Let us expand on this example and add more database related functionality to the stored procedure.",
      "pos": [
        6463,
        6561
      ]
    },
    {
      "content": "Stored procedures can create, update, read, query and delete documents and attachments inside the collection.",
      "pos": [
        6562,
        6671
      ]
    },
    {
      "content": "Example: Write a stored procedure to create a document",
      "pos": [
        6681,
        6735
      ]
    },
    {
      "content": "The next snippet shows how to use the context object to interact with DocumentDB resources.",
      "pos": [
        6737,
        6828
      ]
    },
    {
      "content": "This stored procedure takes as input documentToCreate, the body of a document to be created in the current collection.",
      "pos": [
        7435,
        7553
      ]
    },
    {
      "content": "All such operations are asynchronous and depend on JavaScript function callbacks.",
      "pos": [
        7554,
        7635
      ]
    },
    {
      "content": "The callback function has two parameters, one for the error object in case the operation fails, and one for the created object.",
      "pos": [
        7636,
        7763
      ]
    },
    {
      "content": "Inside the callback, users can either handle the exception or throw an error.",
      "pos": [
        7764,
        7841
      ]
    },
    {
      "content": "In case a callback is not provided and there is an error, the DocumentDB runtime throws an error.",
      "pos": [
        7842,
        7939
      ]
    },
    {
      "content": "In the example above, the callback throws an error if the operation failed.",
      "pos": [
        7944,
        8019
      ]
    },
    {
      "content": "Otherwise, it sets the id of the created document as the body of the response to the client.",
      "pos": [
        8020,
        8112
      ]
    },
    {
      "content": "Here is how this stored procedure is executed with input parameters.",
      "pos": [
        8113,
        8181
      ]
    },
    {
      "content": "Note that this stored procedure can be modified to take an array of document bodies as input and create them all in the same stored procedure execution instead of multiple network requests to create each of them individually.",
      "pos": [
        9006,
        9231
      ]
    },
    {
      "content": "This can be used to implement an efficient bulk importer for DocumentDB (discussed later in this tutorial).",
      "pos": [
        9232,
        9339
      ]
    },
    {
      "content": "The example described demonstrated how to use stored procedures.",
      "pos": [
        9344,
        9408
      ]
    },
    {
      "content": "We will cover triggers and user defined functions (UDFs) later in the tutorial.",
      "pos": [
        9409,
        9488
      ]
    },
    {
      "content": "Transactions",
      "pos": [
        9493,
        9505
      ]
    },
    {
      "content": "Transaction in a typical database can be defined as a sequence of operations performed as a single logical unit of work.",
      "pos": [
        9506,
        9626
      ]
    },
    {
      "content": "Each transaction provides <bpt id=\"p1\">**</bpt>ACID guarantees<ept id=\"p1\">**</ept>.",
      "pos": [
        9627,
        9673
      ]
    },
    {
      "content": "ACID is a well-known acronym that stands for four properties -  Atomicity, Consistency, Isolation and Durability.",
      "pos": [
        9674,
        9787
      ]
    },
    {
      "content": "Briefly, atomicity guarantees that all the work done inside a transaction is treated as a single unit where either all of it is committed or none.",
      "pos": [
        9791,
        9937
      ]
    },
    {
      "content": "Consistency makes sure that the data is always in a good internal state across transactions.",
      "pos": [
        9938,
        10030
      ]
    },
    {
      "content": "Isolation guarantees that no two transactions interfere with each other – generally, most commercial systems provide multiple isolation levels that can be used based on the application needs.",
      "pos": [
        10031,
        10222
      ]
    },
    {
      "content": "Durability ensures that any change that’s committed in the database will always be present.",
      "pos": [
        10223,
        10314
      ]
    },
    {
      "content": "In DocumentDB, JavaScript is hosted in the same memory space as the database.",
      "pos": [
        10319,
        10396
      ]
    },
    {
      "content": "Hence, requests made within stored procedures and triggers execute in the same scope of a database session.",
      "pos": [
        10397,
        10504
      ]
    },
    {
      "content": "This enables DocumentDB to guarantee ACID for all operations that are part of a single stored procedure/trigger.",
      "pos": [
        10505,
        10617
      ]
    },
    {
      "content": "Consider the following stored procedure definition:",
      "pos": [
        10618,
        10669
      ]
    },
    {
      "content": "This stored procedure uses transactions within a gaming app to trade items between two players in a single operation.",
      "pos": [
        13516,
        13633
      ]
    },
    {
      "content": "The stored procedure attempts to read two documents each corresponding to the player IDs passed in as an argument.",
      "pos": [
        13634,
        13748
      ]
    },
    {
      "content": "If both player documents are found, then the stored procedure updates the documents by swapping their items.",
      "pos": [
        13749,
        13857
      ]
    },
    {
      "content": "If any errors are encountered along the way, it throws a JavaScript exception that implicitly aborts the transaction.",
      "pos": [
        13858,
        13975
      ]
    },
    {
      "content": "Commit and rollback",
      "pos": [
        13981,
        14000
      ]
    },
    {
      "content": "Transactions are deeply and natively integrated into DocumentDB’s JavaScript programming model.",
      "pos": [
        14001,
        14096
      ]
    },
    {
      "content": "Inside a JavaScript function, all operations are automatically wrapped under a single transaction.",
      "pos": [
        14097,
        14195
      ]
    },
    {
      "content": "If the JavaScript completes without any exception, the operations to the database are committed.",
      "pos": [
        14196,
        14292
      ]
    },
    {
      "content": "In effect, the “BEGIN TRANSACTION” and “COMMIT TRANSACTION” statements in relational databases are implicit in DocumentDB.",
      "pos": [
        14293,
        14415
      ]
    },
    {
      "content": "If there is any exception that’s propagated from the script, DocumentDB’s JavaScript runtime will roll back the whole transaction.",
      "pos": [
        14420,
        14550
      ]
    },
    {
      "content": "As shown in the earlier example, throwing an exception is effectively equivalent to a “ROLLBACK TRANSACTION” in DocumentDB.",
      "pos": [
        14551,
        14674
      ]
    },
    {
      "content": "Data consistency",
      "pos": [
        14681,
        14697
      ]
    },
    {
      "content": "Stored procedures and triggers are always executed on the primary replica of the DocumentDB collection.",
      "pos": [
        14698,
        14801
      ]
    },
    {
      "content": "This ensures that reads from inside stored procedures offer strong consistency.",
      "pos": [
        14802,
        14881
      ]
    },
    {
      "content": "Queries using user defined functions can be executed on the primary or any secondary replica, but we ensure to meet the requested consistency level by choosing the appropriate replica.",
      "pos": [
        14882,
        15066
      ]
    },
    {
      "content": "Bounded execution",
      "pos": [
        15071,
        15088
      ]
    },
    {
      "content": "All DocumentDB operations must complete within the server specified request timeout duration.",
      "pos": [
        15089,
        15182
      ]
    },
    {
      "content": "This constraint also applies to JavaScript functions (stored procedures, triggers and user-defined functions).",
      "pos": [
        15183,
        15293
      ]
    },
    {
      "content": "If an operation does not complete with that time limit, the transaction is rolled back.",
      "pos": [
        15294,
        15381
      ]
    },
    {
      "content": "JavaScript functions must finish within the time limit or implement a continuation based model to batch/resume execution.",
      "pos": [
        15382,
        15503
      ]
    },
    {
      "content": "In order to simplify development of stored procedures and triggers to handle time limits, all functions under the collection object (for create, read, replace, and delete of documents and attachments) return a Boolean value that represents whether that operation will complete.",
      "pos": [
        15507,
        15784
      ]
    },
    {
      "content": "If this value is false, it is an indication that the time limit is about to expire and that the procedure must wrap up execution.",
      "pos": [
        15785,
        15914
      ]
    },
    {
      "content": "Operations queued prior to the first unaccepted store operation are guaranteed to complete if the stored procedure completes in time and does not queue any more requests.",
      "pos": [
        15916,
        16086
      ]
    },
    {
      "content": "JavaScript functions are also bounded on resource consumption.",
      "pos": [
        16090,
        16152
      ]
    },
    {
      "content": "DocumentDB reserves throughput per collection based on the provisioned size of a database account.",
      "pos": [
        16153,
        16251
      ]
    },
    {
      "content": "Throughput is expressed in terms of a normalized unit of CPU, memory and IO consumption called request units or RUs.",
      "pos": [
        16252,
        16368
      ]
    },
    {
      "content": "JavaScript functions can potentially use up a large number of RUs within a short time, and might get rate-limited if the collection’s limit is reached.",
      "pos": [
        16369,
        16520
      ]
    },
    {
      "content": "Resource intensive stored procedures might also be quarantined to ensure availability of primitive database operations.",
      "pos": [
        16521,
        16640
      ]
    },
    {
      "content": "Example: Bulk importing data",
      "pos": [
        16648,
        16676
      ]
    },
    {
      "content": "Below is an example of a stored procedure that is written to bulk-import documents into a collection.",
      "pos": [
        16677,
        16778
      ]
    },
    {
      "content": "Note how the stored procedure handles bounded execution by checking the Boolean return value from createDocument, and then uses the count of documents inserted in each invocation of the stored procedure to track and resume progress across batches.",
      "pos": [
        16779,
        17026
      ]
    },
    {
      "pos": [
        19054,
        19083
      ],
      "content": "<ph id=\"ph1\">&lt;a id=\"trigger\"&gt;</ph><ph id=\"ph2\">&lt;/a&gt;</ph> Triggers"
    },
    {
      "content": "Pre-Triggers",
      "pos": [
        19088,
        19100
      ]
    },
    {
      "content": "DocumentDB provides triggers that are executed or triggered by an operation on a document.",
      "pos": [
        19101,
        19191
      ]
    },
    {
      "content": "For example, you can specify a pre-trigger when you are creating a document – this pre-trigger will run before the document is created.",
      "pos": [
        19192,
        19327
      ]
    },
    {
      "content": "The following is an example of how pre-triggers can be used to validate the properties of a document that is being created:",
      "pos": [
        19328,
        19451
      ]
    },
    {
      "content": "And the corresponding Node.js client-side registration code for the trigger:",
      "pos": [
        20210,
        20286
      ]
    },
    {
      "content": "Pre-triggers cannot have any input parameters.",
      "pos": [
        21163,
        21209
      ]
    },
    {
      "content": "The request object can be used to manipulate the request message associated with the operation.",
      "pos": [
        21210,
        21305
      ]
    },
    {
      "content": "Here, the pre-trigger is being run with the creation of a document, and the request message body contains the document to be created in JSON format.",
      "pos": [
        21306,
        21454
      ]
    },
    {
      "content": "When triggers are registered, users can specify the operations that it can run with.",
      "pos": [
        21459,
        21543
      ]
    },
    {
      "content": "This trigger was created with TriggerOperation.Create, which means the following is not permitted.",
      "pos": [
        21544,
        21642
      ]
    },
    {
      "content": "Post-triggers",
      "pos": [
        22025,
        22038
      ]
    },
    {
      "content": "Post-triggers, like pre-triggers, are associated with an operation on a document and don’t take any input parameters.",
      "pos": [
        22039,
        22156
      ]
    },
    {
      "content": "They run <bpt id=\"p1\">**</bpt>after<ept id=\"p1\">**</ept> the operation has completed, and have access to the response message that is sent to the client.",
      "pos": [
        22157,
        22272
      ]
    },
    {
      "content": "The following example shows post-triggers in action:",
      "pos": [
        22277,
        22329
      ]
    },
    {
      "content": "The trigger can be registered as shown in the following sample.",
      "pos": [
        24188,
        24251
      ]
    },
    {
      "content": "This trigger queries for the metadata document and updates it with details about the newly created document.",
      "pos": [
        25059,
        25167
      ]
    },
    {
      "content": "One thing that is important to note is the <bpt id=\"p1\">**</bpt>transactional<ept id=\"p1\">**</ept> execution of triggers in DocumentDB.",
      "pos": [
        25171,
        25268
      ]
    },
    {
      "content": "This post-trigger runs as part of the same transaction as the creation of the original document.",
      "pos": [
        25269,
        25365
      ]
    },
    {
      "content": "Therefore, if we throw an exception from the post-trigger (say if we are unable to update the metadata document), the whole transaction will fail and be rolled back.",
      "pos": [
        25366,
        25531
      ]
    },
    {
      "content": "No document will be created, and an exception will be returned.",
      "pos": [
        25532,
        25595
      ]
    },
    {
      "content": "<ph id=\"ph1\">&lt;a id=\"udf\"&gt;</ph><ph id=\"ph2\">&lt;/a&gt;</ph>User-defined functions",
      "pos": [
        25601,
        25639
      ]
    },
    {
      "content": "User-defined functions (UDFs) are used to extend the DocumentDB SQL query language grammar and implement custom business logic.",
      "pos": [
        25640,
        25767
      ]
    },
    {
      "content": "They can only be called from inside queries.",
      "pos": [
        25768,
        25812
      ]
    },
    {
      "content": "They do not have access to the context object and are meant to be used as compute-only JavaScript.",
      "pos": [
        25813,
        25911
      ]
    },
    {
      "content": "Therefore, UDFs can be run on secondary replicas of the DocumentDB service.",
      "pos": [
        25912,
        25987
      ]
    },
    {
      "content": "The following sample creates a UDF to calculate income tax based on rates for various income brackets, and then uses it inside a query to find all people who paid more than $20,000 in taxes.",
      "pos": [
        25992,
        26182
      ]
    },
    {
      "content": "The UDF can subsequently be used in queries like in the following sample:",
      "pos": [
        26558,
        26631
      ]
    },
    {
      "content": "JavaScript language-integrated query API",
      "pos": [
        27270,
        27310
      ]
    },
    {
      "content": "In addition to issuing queries using DocumentDB’s SQL grammar, the server-side SDK allows you to perform optimized queries using a fluent JavaScript interface without any knowledge of SQL.",
      "pos": [
        27311,
        27499
      ]
    },
    {
      "content": "The JavaScript query API allows you to programmatically build queries by passing predicate functions into chainable function calls, with a syntax familiar to ECMAScript5's Array built-ins and popular JavaScript libraries like lodash.",
      "pos": [
        27500,
        27733
      ]
    },
    {
      "content": "Queries are parsed by the JavaScript runtime to be executed efficiently using DocumentDB’s indices.",
      "pos": [
        27734,
        27833
      ]
    },
    {
      "pos": [
        27837,
        28034
      ],
      "content": "[AZURE.NOTE] `__` (double-underscore) is an alias to `getContext().getCollection()`.\n<br/>\nIn other words, you can use `__` or `getContext().getCollection()` to access the JavaScript query API.",
      "leadings": [
        "",
        "> ",
        "> "
      ],
      "nodes": [
        {
          "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> <ph id=\"ph2\">`__`</ph> (double-underscore) is an alias to <ph id=\"ph3\">`getContext().getCollection()`</ph>.",
          "pos": [
            0,
            84
          ]
        },
        {
          "content": "In other words, you can use <ph id=\"ph1\">`__`</ph> or <ph id=\"ph2\">`getContext().getCollection()`</ph> to access the JavaScript query API.",
          "pos": [
            91,
            193
          ]
        }
      ]
    },
    {
      "content": "Supported functions include:",
      "pos": [
        28036,
        28064
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n&lt;b&gt;</ph>chain() ... .value([callback] [, options])<ph id=\"ph2\">&lt;/b&gt;</ph><ph id=\"ph3\">\n</ph>",
      "pos": [
        28074,
        28125
      ]
    },
    {
      "content": "Starts a chained call which must be terminated with value().",
      "pos": [
        28135,
        28195
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n&lt;b&gt;</ph>filter(predicateFunction [, options] [, callback])<ph id=\"ph2\">&lt;/b&gt;</ph><ph id=\"ph3\">\n</ph>",
      "pos": [
        28218,
        28277
      ]
    },
    {
      "content": "Filters the input using a predicate function which returns true/false in order to filter in/out input documents into the resulting set.",
      "pos": [
        28287,
        28422
      ]
    },
    {
      "content": "This behaves similar to a WHERE clause in SQL.",
      "pos": [
        28423,
        28469
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n&lt;b&gt;</ph>map(transformationFunction [, options] [, callback])<ph id=\"ph2\">&lt;/b&gt;</ph><ph id=\"ph3\">\n</ph>",
      "pos": [
        28492,
        28553
      ]
    },
    {
      "content": "Applies a projection given a transformation function which maps each input item to a JavaScript object or value.",
      "pos": [
        28563,
        28675
      ]
    },
    {
      "content": "This behaves similar to a SELECT clause in SQL.",
      "pos": [
        28676,
        28723
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n&lt;b&gt;</ph>pluck([propertyName] [, options] [, callback])<ph id=\"ph2\">&lt;/b&gt;</ph><ph id=\"ph3\">\n</ph>",
      "pos": [
        28746,
        28801
      ]
    },
    {
      "content": "This is a shortcut for a map which extracts the value of a single property from each input item.",
      "pos": [
        28811,
        28907
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n&lt;b&gt;</ph>flatten([isShallow] [, options] [, callback])<ph id=\"ph2\">&lt;/b&gt;</ph><ph id=\"ph3\">\n</ph>",
      "pos": [
        28930,
        28984
      ]
    },
    {
      "content": "Combines and flattens arrays from each input item in to a single array.",
      "pos": [
        28994,
        29065
      ]
    },
    {
      "content": "This behaves similar to SelectMany in LINQ.",
      "pos": [
        29066,
        29109
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n&lt;b&gt;</ph>sortBy([predicate] [, options] [, callback])<ph id=\"ph2\">&lt;/b&gt;</ph><ph id=\"ph3\">\n</ph>",
      "pos": [
        29132,
        29185
      ]
    },
    {
      "content": "Produce a new set of documents by sorting the documents in the input document stream in ascending order using the given predicate.",
      "pos": [
        29195,
        29325
      ]
    },
    {
      "content": "This behaves similar to a ORDER BY clause in SQL.",
      "pos": [
        29326,
        29375
      ]
    },
    {
      "content": "<ph id=\"ph1\">\n&lt;b&gt;</ph>sortByDescending([predicate] [, options] [, callback])<ph id=\"ph2\">&lt;/b&gt;</ph><ph id=\"ph3\">\n</ph>",
      "pos": [
        29398,
        29461
      ]
    },
    {
      "content": "Produce a new set of documents by sorting the documents in the input document stream in descending order using the given predicate.",
      "pos": [
        29471,
        29602
      ]
    },
    {
      "content": "This behaves similar to a ORDER BY x DESC clause in SQL.",
      "pos": [
        29603,
        29659
      ]
    },
    {
      "content": "When included inside predicate and/or selector functions, the following JavaScript constructs get automatically optimized to run directly on DocumentDB indices:",
      "pos": [
        29686,
        29846
      ]
    },
    {
      "content": "Simple operators: = + - * / % | ^ &amp;amp; == != === !=== &amp;lt; &amp;gt; &amp;lt;= &amp;gt;= || &amp;amp;&amp;amp; &amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt;!",
      "pos": [
        29850,
        29972
      ]
    },
    {
      "content": "~",
      "pos": [
        29973,
        29974
      ]
    },
    {
      "content": "Literals, including the object literal: {}",
      "pos": [
        29977,
        30019
      ]
    },
    {
      "content": "var, return",
      "pos": [
        30022,
        30033
      ]
    },
    {
      "content": "The following JavaScript constructs do not get optimized for DocumentDB indices:",
      "pos": [
        30035,
        30115
      ]
    },
    {
      "content": "Control flow (e.g. if, for, while)",
      "pos": [
        30119,
        30153
      ]
    },
    {
      "content": "Function calls",
      "pos": [
        30156,
        30170
      ]
    },
    {
      "pos": [
        30172,
        30283
      ],
      "content": "For more information, please see our <bpt id=\"p1\">[</bpt>Server-Side JSDocs<ept id=\"p1\">](http://dl.windowsazure.com/documentDB/jsserverdocs/)</ept>."
    },
    {
      "content": "Example: Write a stored procedure using the JavaScript query API",
      "pos": [
        30289,
        30353
      ]
    },
    {
      "content": "The following code sample is an example of how the JavaScript Query API can be used in the context of a stored procedure.",
      "pos": [
        30355,
        30476
      ]
    },
    {
      "content": "The stored procedure inserts a document, given by an input parameter, and updates a metadata document, using the <ph id=\"ph1\">`__.filter()`</ph> method, with minSize, maxSize, and totalSize based upon the input document's size property.",
      "pos": [
        30477,
        30695
      ]
    },
    {
      "content": "SQL to Javascript cheat sheet",
      "pos": [
        33139,
        33168
      ]
    },
    {
      "content": "The following table presents various SQL queries and the corresponding JavaScript queries.",
      "pos": [
        33169,
        33259
      ]
    },
    {
      "pos": [
        33261,
        33340
      ],
      "content": "As with SQL queries, document property keys (e.g. <ph id=\"ph1\">`doc.id`</ph>) are case-sensitive."
    },
    {
      "content": "SQL",
      "pos": [
        33525,
        33528
      ]
    },
    {
      "content": "JavaScript Query API",
      "pos": [
        33538,
        33558
      ]
    },
    {
      "content": "Details",
      "pos": [
        33568,
        33575
      ]
    },
    {
      "content": "SELECT *",
      "pos": [
        33603,
        33611
      ]
    },
    {
      "content": "FROM docs",
      "pos": [
        33612,
        33621
      ]
    },
    {
      "content": "__.map(function(doc) {",
      "pos": [
        33646,
        33668
      ]
    },
    {
      "content": "return doc;",
      "pos": [
        33673,
        33684
      ]
    },
    {
      "content": "});",
      "pos": [
        33685,
        33688
      ]
    },
    {
      "content": "Results in all documents (paginated with continuation token) as is.",
      "pos": [
        33706,
        33773
      ]
    },
    {
      "content": "SELECT docs.id, docs.message AS msg, docs.actions",
      "pos": [
        33801,
        33850
      ]
    },
    {
      "content": "FROM docs",
      "pos": [
        33852,
        33861
      ]
    },
    {
      "content": "__.map(function(doc) {",
      "pos": [
        33886,
        33908
      ]
    },
    {
      "content": "return {",
      "pos": [
        33913,
        33921
      ]
    },
    {
      "content": "id: doc.id,",
      "pos": [
        33930,
        33941
      ]
    },
    {
      "content": "msg: doc.message,",
      "pos": [
        33950,
        33967
      ]
    },
    {
      "content": "actions: doc.actions",
      "pos": [
        33976,
        33996
      ]
    },
    {
      "content": "};",
      "pos": [
        34001,
        34003
      ]
    },
    {
      "content": "});",
      "pos": [
        34004,
        34007
      ]
    },
    {
      "content": "Projects the id, message (aliased to msg), and action from all documents.",
      "pos": [
        34025,
        34098
      ]
    },
    {
      "content": "SELECT *",
      "pos": [
        34126,
        34134
      ]
    },
    {
      "content": "FROM docs",
      "pos": [
        34136,
        34145
      ]
    },
    {
      "content": "WHERE docs.id=\"X998_Y998\"",
      "pos": [
        34147,
        34172
      ]
    },
    {
      "content": "__.filter(function(doc) {",
      "pos": [
        34197,
        34222
      ]
    },
    {
      "content": "return doc.id === \"X998_Y998\";",
      "pos": [
        34227,
        34257
      ]
    },
    {
      "content": "});",
      "pos": [
        34258,
        34261
      ]
    },
    {
      "content": "Queries for documents with the predicate: id = \"X998_Y998\".",
      "pos": [
        34279,
        34338
      ]
    },
    {
      "content": "SELECT *",
      "pos": [
        34366,
        34374
      ]
    },
    {
      "content": "FROM docs",
      "pos": [
        34375,
        34384
      ]
    },
    {
      "content": "WHERE ARRAY_CONTAINS(docs.Tags, 123)",
      "pos": [
        34385,
        34421
      ]
    },
    {
      "content": "__.filter(function(x) {",
      "pos": [
        34446,
        34469
      ]
    },
    {
      "content": "return x.Tags &amp;&amp; x.Tags.indexOf(123) &gt; -1;",
      "pos": [
        34474,
        34516
      ]
    },
    {
      "content": "});",
      "pos": [
        34517,
        34520
      ]
    },
    {
      "content": "Queries for documents that have a Tags property and Tags is an array containing the value 123.",
      "pos": [
        34538,
        34632
      ]
    },
    {
      "content": "SELECT docs.id, docs.message AS msg",
      "pos": [
        34660,
        34695
      ]
    },
    {
      "content": "FROM docs",
      "pos": [
        34696,
        34705
      ]
    },
    {
      "content": "WHERE docs.id=\"X998_Y998\"",
      "pos": [
        34707,
        34732
      ]
    },
    {
      "content": "__.chain()",
      "pos": [
        34757,
        34767
      ]
    },
    {
      "content": ".filter(function(doc) {",
      "pos": [
        34772,
        34795
      ]
    },
    {
      "content": "return doc.id === \"X998_Y998\";",
      "pos": [
        34804,
        34834
      ]
    },
    {
      "content": "})",
      "pos": [
        34839,
        34841
      ]
    },
    {
      "content": ".map(function(doc) {",
      "pos": [
        34846,
        34866
      ]
    },
    {
      "content": "return {",
      "pos": [
        34875,
        34883
      ]
    },
    {
      "content": "id: doc.id,",
      "pos": [
        34896,
        34907
      ]
    },
    {
      "content": "msg: doc.message",
      "pos": [
        34920,
        34936
      ]
    },
    {
      "content": "};",
      "pos": [
        34945,
        34947
      ]
    },
    {
      "content": "})",
      "pos": [
        34952,
        34954
      ]
    },
    {
      "content": ".value();",
      "pos": [
        34959,
        34968
      ]
    },
    {
      "content": "Queries for documents with a predicate, id = \"X998_Y998\", and then projects the id and message (aliased to msg).",
      "pos": [
        34986,
        35098
      ]
    },
    {
      "content": "SELECT VALUE tag",
      "pos": [
        35126,
        35142
      ]
    },
    {
      "content": "FROM docs",
      "pos": [
        35143,
        35152
      ]
    },
    {
      "content": "JOIN tag IN docs.Tags",
      "pos": [
        35153,
        35174
      ]
    },
    {
      "content": "ORDER BY docs._ts",
      "pos": [
        35175,
        35192
      ]
    },
    {
      "content": "__.chain()",
      "pos": [
        35217,
        35227
      ]
    },
    {
      "content": ".filter(function(doc) {",
      "pos": [
        35232,
        35255
      ]
    },
    {
      "content": "return doc.Tags &amp;&amp; Array.isArray(doc.Tags);",
      "pos": [
        35264,
        35307
      ]
    },
    {
      "content": "})",
      "pos": [
        35312,
        35314
      ]
    },
    {
      "content": ".sortBy(function(doc) {",
      "pos": [
        35319,
        35342
      ]
    },
    {
      "content": "return doc._ts;",
      "pos": [
        35351,
        35366
      ]
    },
    {
      "content": "})",
      "pos": [
        35371,
        35373
      ]
    },
    {
      "content": ".pluck(\"Tags\")",
      "pos": [
        35378,
        35392
      ]
    },
    {
      "content": ".flatten()",
      "pos": [
        35397,
        35407
      ]
    },
    {
      "content": ".value()",
      "pos": [
        35412,
        35420
      ]
    },
    {
      "content": "Filters for documents which have an array property, Tags, and sorts the resulting documents by the _ts timestamp system property, and then projects + flattens the Tags array.",
      "pos": [
        35438,
        35612
      ]
    },
    {
      "content": "Runtime support",
      "pos": [
        35646,
        35661
      ]
    },
    {
      "pos": [
        35662,
        35905
      ],
      "content": "<bpt id=\"p1\">[</bpt>DocumentDB JavaScript server side SDK<ept id=\"p1\">](http://dl.windowsazure.com/documentDB/jsserverdocs/)</ept> provides support for the most of the mainstream JavaScript language features as standardized by <bpt id=\"p2\">[</bpt>ECMA-262<ept id=\"p2\">](documentdb-interactions-with-resources.md)</ept>."
    },
    {
      "content": "Security",
      "pos": [
        35911,
        35919
      ]
    },
    {
      "content": "JavaScript stored procedures and triggers are sandboxed so that the effects of one script do not leak to the other without going through the snapshot transaction isolation at the database level.",
      "pos": [
        35920,
        36114
      ]
    },
    {
      "content": "The runtime environments are pooled but cleaned of the context after each run.",
      "pos": [
        36115,
        36193
      ]
    },
    {
      "content": "Hence they are guaranteed to be safe of any unintended side effects from each other.",
      "pos": [
        36194,
        36278
      ]
    },
    {
      "content": "Pre-compilation",
      "pos": [
        36284,
        36299
      ]
    },
    {
      "content": "Stored procedures, triggers and UDFs are implicitly precompiled to the byte code format in order to avoid compilation cost at the time of each script invocation.",
      "pos": [
        36300,
        36461
      ]
    },
    {
      "content": "This ensures invocations of stored procedures are fast and have a low footprint.",
      "pos": [
        36462,
        36542
      ]
    },
    {
      "content": "Client SDK support",
      "pos": [
        36547,
        36565
      ]
    },
    {
      "content": "In addition to the <bpt id=\"p1\">[</bpt>Node.js<ept id=\"p1\">](http://dl.windowsazure.com/documentDB/nodedocs/)</ept> client, DocumentDB supports <bpt id=\"p2\">[</bpt>.NET<ept id=\"p2\">](https://msdn.microsoft.com/library/azure/dn783362.aspx)</ept>, <bpt id=\"p3\">[</bpt>Java<ept id=\"p3\">](http://dl.windowsazure.com/documentdb/javadoc/)</ept>, <bpt id=\"p4\">[</bpt>JavaScript<ept id=\"p4\">](http://dl.windowsazure.com/documentDB/jsclientdocs/)</ept>, and <bpt id=\"p5\">[</bpt>Python SDKs<ept id=\"p5\">](http://dl.windowsazure.com/documentDB/pythondocs/)</ept>.",
      "pos": [
        36566,
        36928
      ]
    },
    {
      "content": "Stored procedures, triggers and UDFs can be created and executed using any of these SDKs as well.",
      "pos": [
        36929,
        37026
      ]
    },
    {
      "content": "The following example shows how to create and execute a stored procedure using the .NET client.",
      "pos": [
        37027,
        37122
      ]
    },
    {
      "content": "Note how the .NET types are passed into the stored procedure as JSON and read back.",
      "pos": [
        37123,
        37206
      ]
    },
    {
      "pos": [
        38627,
        38798
      ],
      "content": "This sample shows how to use the <bpt id=\"p1\">[</bpt>.NET SDK<ept id=\"p1\">](https://msdn.microsoft.com/library/azure/dn783362.aspx)</ept> to create a pre-trigger and create a document with the trigger enabled."
    },
    {
      "pos": [
        39418,
        39558
      ],
      "content": "And the following example shows how to create a user defined function (UDF) and use it in a <bpt id=\"p1\">[</bpt>DocumentDB SQL query<ept id=\"p1\">](documentdb-sql-query.md)</ept>."
    },
    {
      "content": "REST API",
      "pos": [
        39979,
        39987
      ]
    },
    {
      "content": "All DocumentDB operations can be performed in a RESTful manner.",
      "pos": [
        39988,
        40051
      ]
    },
    {
      "content": "Stored procedures, triggers and user-defined functions can be registered under a collection by using HTTP POST.",
      "pos": [
        40052,
        40163
      ]
    },
    {
      "content": "The following is an example of how to register a stored procedure:",
      "pos": [
        40164,
        40230
      ]
    },
    {
      "content": "The stored procedure is registered by executing a POST request against the URI dbs/sehcAA==/colls/sehcAIE2Qy4=/sprocs with the body containing the stored procedure to create.",
      "pos": [
        41002,
        41176
      ]
    },
    {
      "content": "Triggers and UDFs can be registered similarly by issuing a POST against /triggers and /udfs respectively.",
      "pos": [
        41177,
        41282
      ]
    },
    {
      "content": "This stored procedure can then be executed by issuing a POST request against its resource link:",
      "pos": [
        41283,
        41378
      ]
    },
    {
      "content": "Here, the input to the stored procedure is passed in the request body.",
      "pos": [
        41595,
        41665
      ]
    },
    {
      "content": "Note that the input is passed as a JSON array of input parameters.",
      "pos": [
        41666,
        41732
      ]
    },
    {
      "content": "The stored procedure takes the first input as a document that is a response body.",
      "pos": [
        41733,
        41814
      ]
    },
    {
      "content": "The response we receive is as follows:",
      "pos": [
        41815,
        41853
      ]
    },
    {
      "content": "Triggers, unlike stored procedures, cannot be executed directly.",
      "pos": [
        42205,
        42269
      ]
    },
    {
      "content": "Instead they are executed as part of an operation on a document.",
      "pos": [
        42270,
        42334
      ]
    },
    {
      "content": "We can specify the triggers to run with a request using HTTP headers.",
      "pos": [
        42335,
        42404
      ]
    },
    {
      "content": "The following is request to create a document.",
      "pos": [
        42405,
        42451
      ]
    },
    {
      "content": "Here the pre-trigger to be run with the request is specified in the x-ms-documentdb-pre-trigger-include header.",
      "pos": [
        42837,
        42948
      ]
    },
    {
      "content": "Correspondingly, any post-triggers are given in the x-ms-documentdb-post-trigger-include header.",
      "pos": [
        42949,
        43045
      ]
    },
    {
      "content": "Note that both pre- and post-triggers can be specified for a given request.",
      "pos": [
        43046,
        43121
      ]
    },
    {
      "content": "Sample code",
      "pos": [
        43126,
        43137
      ]
    },
    {
      "pos": [
        43139,
        43660
      ],
      "content": "You can find more server-side code examples (including <bpt id=\"p1\">[</bpt>upsert<ept id=\"p1\">](https://github.com/Azure/azure-documentdb-js/blob/master/server-side/samples/stored-procedures/upsert.js)</ept>, <bpt id=\"p2\">[</bpt>bulk-delete<ept id=\"p2\">](https://github.com/Azure/azure-documentdb-js/blob/master/server-side/samples/stored-procedures/bulkDelete.js)</ept>, and <bpt id=\"p3\">[</bpt>update<ept id=\"p3\">](https://github.com/Azure/azure-documentdb-js/blob/master/server-side/samples/stored-procedures/update.js)</ept>) on our <bpt id=\"p4\">[</bpt>Github repository<ept id=\"p4\">](https://github.com/Azure/azure-documentdb-js/tree/master/server-side/samples)</ept>."
    },
    {
      "content": "Want to share your awesome stored procedure?",
      "pos": [
        43662,
        43706
      ]
    },
    {
      "content": "Please, send us a pull-request!",
      "pos": [
        43707,
        43738
      ]
    },
    {
      "content": "Next steps",
      "pos": [
        43744,
        43754
      ]
    },
    {
      "content": "Once you have one or more stored procedures, triggers, and user-defined functions created, you can load them and view them in the Azure Preview portal using Script Explorer.",
      "pos": [
        43756,
        43929
      ]
    },
    {
      "content": "For more information, see <bpt id=\"p1\">[</bpt>View stored procedures, triggers, and user-defined functions using the DocumentDB Script Explorer<ept id=\"p1\">](documentdb-view-scripts.md)</ept>.",
      "pos": [
        43930,
        44084
      ]
    },
    {
      "content": "You may also find the following references and resources useful in your path to learn more about DocumentDB server-side programming:",
      "pos": [
        44086,
        44218
      ]
    },
    {
      "content": "Azure DocumentDB SDKs",
      "pos": [
        44223,
        44244
      ]
    },
    {
      "content": "JSON",
      "pos": [
        44305,
        44309
      ]
    },
    {
      "content": "JavaScript ECMA-262",
      "pos": [
        44337,
        44356
      ]
    },
    {
      "content": "JavaScript – JSON type system",
      "pos": [
        44434,
        44463
      ]
    },
    {
      "content": "Secure and Portable Database Extensibility",
      "pos": [
        44500,
        44542
      ]
    },
    {
      "content": "Service Oriented Database Architecture",
      "pos": [
        44592,
        44630
      ]
    },
    {
      "content": "<bpt id=\"p1\">[</bpt>Hosting the .NET Runtime in Microsoft SQL server<ept id=\"p1\">](http://dl.acm.org/citation.cfm?id=1007669)</ept>",
      "pos": [
        44701,
        44794
      ]
    },
    {
      "content": "test",
      "pos": [
        44797,
        44801
      ]
    }
  ],
  "content": "<properties \n    pageTitle=\"DocumentDB programming: Stored procedures, triggers, and UDFs | Microsoft Azure\" \n    description=\"Find out how to use Microsoft Azure DocumentDB to write stored procedures, triggers, and user defined functions (UDFs) natively in JavaScript.\" \n    services=\"documentdb\" \n    documentationCenter=\"\" \n    authors=\"aliuy\" \n    manager=\"jhubbard\" \n    editor=\"cgronlun\"/>\n\n<tags \n    ms.service=\"documentdb\" \n    ms.workload=\"data-services\" \n    ms.tgt_pltfrm=\"na\" \n    ms.devlang=\"na\" \n    ms.topic=\"article\" \n    ms.date=\"08/18/2015\" \n    ms.author=\"andrl\"/>\n\n# DocumentDB server-side programming: Stored procedures, triggers, and UDFs\n\nLearn how DocumentDB’s language integrated, transactional execution of JavaScript lets developers write **stored procedures**, **triggers** and **user defined functions (UDFs)** natively in JavaScript. This allows you to write application logic that can be shipped and executed directly on the database storage partitions \n\nWe recommend getting started by watching the following video, where Andrew Liu provides a brief introduction to DocumentDB's server-side programming model. \n\n> [AZURE.VIDEO azure-demo-a-quick-intro-to-azure-documentdbs-server-side-javascript]\n\nThen, return to this article, where you'll learn the answers to the following questions:  \n\n- How do I write a a stored procedure, trigger, or UDF using JavaScript?\n- How does DocumentDB guarantee ACID?\n- How do transactions work in DocumentDB?\n- What are pre-triggers and post-triggers and how do I write one?\n- How do I register and execute a stored procedure, trigger, or UDF in a RESTful manner by using HTTP?\n- What DocumentDB SDKs are available to create and execute stored procedures, triggers, and UDFs?\n\n## Introduction\n\nThis approach of *“JavaScript as a modern day T-SQL”* frees application developers from the complexities of type system mismatches and object-relational mapping technologies. It also has a number of intrinsic advantages that can be utilized to build rich applications:  \n\n-   **Procedural Logic:** JavaScript as a high level programming language, provides a rich and familiar interface to express business logic. You can perform complex sequences of operations closer to the data.\n\n-   **Atomic Transactions:** DocumentDB guarantees that database operations performed inside a single stored procedure or trigger are atomic. This lets an application combine related operations in a single batch so that either all of them succeed or none of them succeed. \n\n-   **Performance:** The fact that JSON is intrinsically mapped to the Javascript language type system and is also the basic unit of storage in DocumentDB allows for a number of optimizations like lazy materialization of JSON documents in the buffer pool and making them available on-demand to the executing code. There are more performance benefits associated with shipping business logic to the database:\n    -   Batching – Developers can group operations like inserts and submit them in bulk. The network traffic latency cost and the store overhead to create separate transactions are reduced significantly. \n    -   Pre-compilation – DocumentDB precompiles stored procedures, triggers and user defined functions (UDFs) to avoid JavaScript compilation cost for each invocation. The overhead of building the byte code for the procedural logic is amortized to a minimal value.\n    -   Sequencing – Many operations need a side-effect (“trigger”) that potentially involves doing one or many secondary store operations. Aside from atomicity, this is more performant when moved to the server. \n-   **Encapsulation:** Stored procedures can be used to group business logic in one place. This has two advantages:\n    -   It adds an abstraction layer on top of the raw data, which enables data architects to evolve their applications independently from the data. This is particularly advantageous when the data is schema-less, due to the brittle assumptions that may need to be baked into the application if they have to deal with data directly.  \n    -   This abstraction lets enterprises keep their data secure by streamlining the access from the scripts.  \n\nThe creation and execution of triggers, stored procedure and custom query operators is supported through the [REST API](https://msdn.microsoft.com/library/azure/dn781481.aspx), and [client SDKs](https://msdn.microsoft.com/library/azure/dn781482.aspx) in many platforms including .NET, Node.js and JavaScript. **This tutorial uses the [Node.js SDK](http://dl.windowsazure.com/documentDB/nodedocs/)** to illustrate syntax and usage of stored procedures, triggers, and UDFs.   \n\n## Stored procedures\n\n### Example: Write a simple stored procedure \nLet’s start with a simple stored procedure that returns a “Hello World” response.\n\n    var helloWorldStoredProc = {\n        id: \"helloWorld\",\n        body: function () {\n            var context = getContext();\n            var response = context.getResponse();\n    \n            response.setBody(\"Hello, World\");\n        }\n    }\n\n\nStored procedures are registered per collection, and can operate on any document and attachment present in that collection. The following snippet shows how to register the helloWorld stored procedure with a collection. \n\n    // register the stored procedure\n    var createdStoredProcedure;\n    client.createStoredProcedureAsync(collection._self, helloWorldStoredProc)\n        .then(function (response) {\n            createdStoredProcedure = response.resource;\n            console.log(\"Successfully created stored procedure\");\n        }, function (error) {\n            console.log(\"Error\", error);\n        });\n\n\nOnce the stored procedure is registered, we can execute it against the collection, and read the results back at the client. \n\n    // execute the stored procedure\n    client.executeStoredProcedureAsync(createdStoredProcedure._self)\n        .then(function (response) {\n            console.log(response.result); // \"Hello, World\"\n        }, function (err) {\n            console.log(\"Error\", error);\n        });\n\n\nThe context object provides access to all operations that can be performed on DocumentDB storage, as well as access to the request and response objects. In this case, we used the response object to set the body of the response that was sent back to the client. For more details, refer to the [DocumentDB JavaScript server SDK documentation](http://dl.windowsazure.com/documentDB/jsserverdocs/).  \n\nLet us expand on this example and add more database related functionality to the stored procedure. Stored procedures can create, update, read, query and delete documents and attachments inside the collection.    \n\n### Example: Write a stored procedure to create a document \nThe next snippet shows how to use the context object to interact with DocumentDB resources.\n\n    var createDocumentStoredProc = {\n        id: \"createMyDocument\",\n        body: function createMyDocument(documentToCreate) {\n            var context = getContext();\n            var collection = context.getCollection();\n    \n            var accepted = collection.createDocument(collection.getSelfLink(),\n                  documentToCreate,\n                function (err, documentCreated) {\n                    if (err) throw new Error('Error' + err.message);\n                    context.getResponse().setBody(documentCreated.id)\n                });\n            if (!accepted) return;\n        }\n    }\n\n\nThis stored procedure takes as input documentToCreate, the body of a document to be created in the current collection. All such operations are asynchronous and depend on JavaScript function callbacks. The callback function has two parameters, one for the error object in case the operation fails, and one for the created object. Inside the callback, users can either handle the exception or throw an error. In case a callback is not provided and there is an error, the DocumentDB runtime throws an error.   \n\nIn the example above, the callback throws an error if the operation failed. Otherwise, it sets the id of the created document as the body of the response to the client. Here is how this stored procedure is executed with input parameters.\n\n    // register the stored procedure\n    client.createStoredProcedureAsync(collection._self, createDocumentStoredProc)\n        .then(function (response) {\n            var createdStoredProcedure = response.resource;\n    \n            // run stored procedure to create a document\n            var docToCreate = {\n                id: \"DocFromSproc\",\n                book: \"The Hitchhiker’s Guide to the Galaxy\",\n                author: \"Douglas Adams\"\n            };\n    \n            return client.executeStoredProcedureAsync(createdStoredProcedure._self,\n                  docToCreate);\n        }, function (error) {\n            console.log(\"Error\", error);\n        })\n    .then(function (response) {\n        console.log(response); // \"DocFromSproc\"\n    }, function (error) {\n        console.log(\"Error\", error);\n    });\n\n    \nNote that this stored procedure can be modified to take an array of document bodies as input and create them all in the same stored procedure execution instead of multiple network requests to create each of them individually. This can be used to implement an efficient bulk importer for DocumentDB (discussed later in this tutorial).   \n\nThe example described demonstrated how to use stored procedures. We will cover triggers and user defined functions (UDFs) later in the tutorial.\n\n## Transactions\nTransaction in a typical database can be defined as a sequence of operations performed as a single logical unit of work. Each transaction provides **ACID guarantees**. ACID is a well-known acronym that stands for four properties -  Atomicity, Consistency, Isolation and Durability.  \n\nBriefly, atomicity guarantees that all the work done inside a transaction is treated as a single unit where either all of it is committed or none. Consistency makes sure that the data is always in a good internal state across transactions. Isolation guarantees that no two transactions interfere with each other – generally, most commercial systems provide multiple isolation levels that can be used based on the application needs. Durability ensures that any change that’s committed in the database will always be present.   \n\nIn DocumentDB, JavaScript is hosted in the same memory space as the database. Hence, requests made within stored procedures and triggers execute in the same scope of a database session. This enables DocumentDB to guarantee ACID for all operations that are part of a single stored procedure/trigger. Consider the following stored procedure definition:\n\n    // JavaScript source code\n    var exchangeItemsSproc = {\n        name: \"exchangeItems\",\n        body: function (playerId1, playerId2) {\n            var context = getContext();\n            var collection = context.getCollection();\n            var response = context.getResponse();\n    \n            var player1Document, player2Document;\n    \n            // query for players\n            var filterQuery = 'SELECT * FROM Players p where p.id  = \"' + playerId1 + '\"';\n            var accept = collection.queryDocuments(collection.getSelfLink(), filterQuery, {},\n                function (err, documents, responseOptions) {\n                    if (err) throw new Error(\"Error\" + err.message);\n    \n                    if (documents.length != 1) throw \"Unable to find both names\";\n                    player1Document = documents[0];\n    \n                    var filterQuery2 = 'SELECT * FROM Players p where p.id = \"' + playerId2 + '\"';\n                    var accept2 = collection.queryDocuments(collection.getSelfLink(), filterQuery2, {},\n                        function (err2, documents2, responseOptions2) {\n                            if (err2) throw new Error(\"Error\" + err2.message);\n                            if (documents2.length != 1) throw \"Unable to find both names\";\n                            player2Document = documents2[0];\n                            swapItems(player1Document, player2Document);\n                            return;\n                        });\n                    if (!accept2) throw \"Unable to read player details, abort \";\n                });\n    \n            if (!accept) throw \"Unable to read player details, abort \";\n    \n            // swap the two players’ items\n            function swapItems(player1, player2) {\n                var player1ItemSave = player1.item;\n                player1.item = player2.item;\n                player2.item = player1ItemSave;\n    \n                var accept = collection.replaceDocument(player1._self, player1,\n                    function (err, docReplaced) {\n                        if (err) throw \"Unable to update player 1, abort \";\n    \n                        var accept2 = collection.replaceDocument(player2._self, player2,\n                            function (err2, docReplaced2) {\n                                if (err) throw \"Unable to update player 2, abort\"\n                            });\n    \n                        if (!accept2) throw \"Unable to update player 2, abort\";\n                    });\n    \n                if (!accept) throw \"Unable to update player 1, abort\";\n            }\n        }\n    }\n    \n    // register the stored procedure in Node.js client\n    client.createStoredProcedureAsync(collection._self, exchangeItemsSproc)\n        .then(function (response) {\n            var createdStoredProcedure = response.resource;\n        }\n    );\n\nThis stored procedure uses transactions within a gaming app to trade items between two players in a single operation. The stored procedure attempts to read two documents each corresponding to the player IDs passed in as an argument. If both player documents are found, then the stored procedure updates the documents by swapping their items. If any errors are encountered along the way, it throws a JavaScript exception that implicitly aborts the transaction.\n\n### Commit and rollback\nTransactions are deeply and natively integrated into DocumentDB’s JavaScript programming model. Inside a JavaScript function, all operations are automatically wrapped under a single transaction. If the JavaScript completes without any exception, the operations to the database are committed. In effect, the “BEGIN TRANSACTION” and “COMMIT TRANSACTION” statements in relational databases are implicit in DocumentDB.  \n \nIf there is any exception that’s propagated from the script, DocumentDB’s JavaScript runtime will roll back the whole transaction. As shown in the earlier example, throwing an exception is effectively equivalent to a “ROLLBACK TRANSACTION” in DocumentDB.\n \n### Data consistency\nStored procedures and triggers are always executed on the primary replica of the DocumentDB collection. This ensures that reads from inside stored procedures offer strong consistency. Queries using user defined functions can be executed on the primary or any secondary replica, but we ensure to meet the requested consistency level by choosing the appropriate replica.\n\n## Bounded execution\nAll DocumentDB operations must complete within the server specified request timeout duration. This constraint also applies to JavaScript functions (stored procedures, triggers and user-defined functions). If an operation does not complete with that time limit, the transaction is rolled back. JavaScript functions must finish within the time limit or implement a continuation based model to batch/resume execution.  \n\nIn order to simplify development of stored procedures and triggers to handle time limits, all functions under the collection object (for create, read, replace, and delete of documents and attachments) return a Boolean value that represents whether that operation will complete. If this value is false, it is an indication that the time limit is about to expire and that the procedure must wrap up execution.  Operations queued prior to the first unaccepted store operation are guaranteed to complete if the stored procedure completes in time and does not queue any more requests.  \n\nJavaScript functions are also bounded on resource consumption. DocumentDB reserves throughput per collection based on the provisioned size of a database account. Throughput is expressed in terms of a normalized unit of CPU, memory and IO consumption called request units or RUs. JavaScript functions can potentially use up a large number of RUs within a short time, and might get rate-limited if the collection’s limit is reached. Resource intensive stored procedures might also be quarantined to ensure availability of primitive database operations.  \n\n### Example: Bulk importing data\nBelow is an example of a stored procedure that is written to bulk-import documents into a collection. Note how the stored procedure handles bounded execution by checking the Boolean return value from createDocument, and then uses the count of documents inserted in each invocation of the stored procedure to track and resume progress across batches.\n\n    function bulkImport(docs) {\n        var collection = getContext().getCollection();\n        var collectionLink = collection.getSelfLink();\n    \n        // The count of imported docs, also used as current doc index.\n        var count = 0;\n    \n        // Validate input.\n        if (!docs) throw new Error(\"The array is undefined or null.\");\n    \n        var docsLength = docs.length;\n        if (docsLength == 0) {\n            getContext().getResponse().setBody(0);\n        }\n    \n        // Call the create API to create a document.\n        tryCreate(docs[count], callback);\n    \n        // Note that there are 2 exit conditions:\n        // 1) The createDocument request was not accepted. \n        //    In this case the callback will not be called, we just call setBody and we are done.\n        // 2) The callback was called docs.length times.\n        //    In this case all documents were created and we don’t need to call tryCreate anymore. Just call setBody and we are done.\n        function tryCreate(doc, callback) {\n            var isAccepted = collection.createDocument(collectionLink, doc, callback);\n    \n            // If the request was accepted, callback will be called.\n            // Otherwise report current count back to the client, \n            // which will call the script again with remaining set of docs.\n            if (!isAccepted) getContext().getResponse().setBody(count);\n        }\n    \n        // This is called when collection.createDocument is done in order to process the result.\n        function callback(err, doc, options) {\n            if (err) throw err;\n    \n            // One more document has been inserted, increment the count.\n            count++;\n    \n            if (count >= docsLength) {\n                // If we created all documents, we are done. Just set the response.\n                getContext().getResponse().setBody(count);\n            } else {\n                // Create next document.\n                tryCreate(docs[count], callback);\n            }\n        }\n    }\n\n## <a id=\"trigger\"></a> Triggers\n### Pre-Triggers\nDocumentDB provides triggers that are executed or triggered by an operation on a document. For example, you can specify a pre-trigger when you are creating a document – this pre-trigger will run before the document is created. The following is an example of how pre-triggers can be used to validate the properties of a document that is being created:\n\n    var validateDocumentContentsTrigger = {\n        name: \"validateDocumentContents\",\n        body: function validate() {\n            var context = getContext();\n            var request = context.getRequest();\n    \n            // document to be created in the current operation\n            var documentToCreate = request.getBody();\n    \n            // validate properties\n            if (!(\"timestamp\" in documentToCreate)) {\n                var ts = new Date();\n                documentToCreate[\"my timestamp\"] = ts.getTime();\n            }\n    \n            // update the document that will be created\n            request.setBody(documentToCreate);\n        },\n        triggerType: TriggerType.Pre,\n        triggerOperation: TriggerOperation.Create\n    }\n\n\nAnd the corresponding Node.js client-side registration code for the trigger:\n\n    // register pre-trigger\n    client.createTriggerAsync(collection.self, validateDocumentContentsTrigger)\n        .then(function (response) {\n            console.log(\"Created\", response.resource);\n            var docToCreate = {\n                id: \"DocWithTrigger\",\n                event: \"Error\",\n                source: \"Network outage\"\n            };\n    \n            // run trigger while creating above document \n            var options = { preTriggerInclude: \"validateDocumentContents\" };\n    \n            return client.createDocumentAsync(collection.self,\n                  docToCreate, options);\n        }, function (error) {\n            console.log(\"Error\", error);\n        })\n    .then(function (response) {\n        console.log(response.resource); // document with timestamp property added\n    }, function (error) {\n        console.log(\"Error\", error);\n    });\n\n\nPre-triggers cannot have any input parameters. The request object can be used to manipulate the request message associated with the operation. Here, the pre-trigger is being run with the creation of a document, and the request message body contains the document to be created in JSON format.   \n\nWhen triggers are registered, users can specify the operations that it can run with. This trigger was created with TriggerOperation.Create, which means the following is not permitted.\n\n    var options = { preTriggerInclude: \"validateDocumentContents\" };\n    \n    client.replaceDocumentAsync(docToReplace.self,\n                  newDocBody, options)\n    .then(function (response) {\n        console.log(response.resource);\n    }, function (error) {\n        console.log(\"Error\", error);\n    });\n    \n    // Fails, can’t use a create trigger in a replace operation\n\n### Post-triggers\nPost-triggers, like pre-triggers, are associated with an operation on a document and don’t take any input parameters. They run **after** the operation has completed, and have access to the response message that is sent to the client.   \n\nThe following example shows post-triggers in action:\n\n    var updateMetadataTrigger = {\n        name: \"updateMetadata\",\n        body: function updateMetadata() {\n            var context = getContext();\n            var collection = context.getCollection();\n            var response = context.getResponse();\n    \n            // document that was created\n            var createdDocument = response.getBody();\n    \n            // query for metadata document\n            var filterQuery = 'SELECT * FROM root r WHERE r.id = \"_metadata\"';\n            var accept = collection.queryDocuments(collection.getSelfLink(), filterQuery,\n                updateMetadataCallback);\n            if(!accept) throw \"Unable to update metadata, abort\";\n     \n            function updateMetadataCallback(err, documents, responseOptions) {\n                if(err) throw new Error(\"Error\" + err.message);\n                         if(documents.length != 1) throw 'Unable to find metadata document';\n                         \n                         var metadataDocument = documents[0];\n                         \n                         // update metadata\n                         metadataDocument.createdDocuments += 1;\n                         metadataDocument.createdNames += \" \" + createdDocument.id;\n                         var accept = collection.replaceDocument(metadataDocument._self,\n                               metadataDocument, function(err, docReplaced) {\n                                      if(err) throw \"Unable to update metadata, abort\";\n                               });\n                         if(!accept) throw \"Unable to update metadata, abort\";\n                         return;                    \n            }                                                                                           \n        },\n        triggerType: TriggerType.Post,\n        triggerOperation: TriggerOperation.All\n    }\n\n\nThe trigger can be registered as shown in the following sample.\n\n    // register post-trigger\n    client.createTriggerAsync(collection.self, updateMetadataTrigger)\n        .then(function(createdTrigger) { \n            var docToCreate = { \n                name: \"artist_profile_1023\",\n                artist: \"The Band\",\n                albums: [\"Hellujah\", \"Rotators\", \"Spinning Top\"]\n            };\n    \n            // run trigger while creating above document \n            var options = { postTriggerInclude: \"updateMetadata\" };\n        \n            return client.createDocumentAsync(collection.self,\n                  docToCreate, options);\n        }, function(error) {\n            console.log(\"Error\" , error);\n        })\n    .then(function(response) {\n        console.log(response.resource); \n    }, function(error) {\n        console.log(\"Error\" , error);\n    });\n\n\nThis trigger queries for the metadata document and updates it with details about the newly created document.  \n\nOne thing that is important to note is the **transactional** execution of triggers in DocumentDB. This post-trigger runs as part of the same transaction as the creation of the original document. Therefore, if we throw an exception from the post-trigger (say if we are unable to update the metadata document), the whole transaction will fail and be rolled back. No document will be created, and an exception will be returned.  \n\n##<a id=\"udf\"></a>User-defined functions\nUser-defined functions (UDFs) are used to extend the DocumentDB SQL query language grammar and implement custom business logic. They can only be called from inside queries. They do not have access to the context object and are meant to be used as compute-only JavaScript. Therefore, UDFs can be run on secondary replicas of the DocumentDB service.  \n \nThe following sample creates a UDF to calculate income tax based on rates for various income brackets, and then uses it inside a query to find all people who paid more than $20,000 in taxes.\n\n    var taxUdf = {\n        name: \"tax\",\n        body: function tax(income) {\n    \n            if(income == undefined) \n                throw 'no input';\n    \n            if (income < 1000) \n                return income * 0.1;\n            else if (income < 10000) \n                return income * 0.2;\n            else\n                return income * 0.4;\n        }\n    }\n\n\nThe UDF can subsequently be used in queries like in the following sample:\n\n    // register UDF\n    client.createUserDefinedFunctionAsync(collection.self, taxUdf)\n        .then(function(response) { \n            console.log(\"Created\", response.resource);\n    \n            var query = 'SELECT * FROM TaxPayers t WHERE udf.tax(t.income) > 20000'; \n            return client.queryDocuments(collection.self,\n                   query).toArrayAsync();\n        }, function(error) {\n            console.log(\"Error\" , error);\n        })\n    .then(function(response) {\n        var documents = response.feed;\n        console.log(response.resource); \n    }, function(error) {\n        console.log(\"Error\" , error);\n    });\n\n## JavaScript language-integrated query API\nIn addition to issuing queries using DocumentDB’s SQL grammar, the server-side SDK allows you to perform optimized queries using a fluent JavaScript interface without any knowledge of SQL. The JavaScript query API allows you to programmatically build queries by passing predicate functions into chainable function calls, with a syntax familiar to ECMAScript5's Array built-ins and popular JavaScript libraries like lodash. Queries are parsed by the JavaScript runtime to be executed efficiently using DocumentDB’s indices.\n\n> [AZURE.NOTE] `__` (double-underscore) is an alias to `getContext().getCollection()`.\n> <br/>\n> In other words, you can use `__` or `getContext().getCollection()` to access the JavaScript query API.\n\nSupported functions include:\n<ul>\n<li>\n<b>chain() ... .value([callback] [, options])</b>\n<ul>\n<li>\nStarts a chained call which must be terminated with value().\n</li>\n</ul>\n</li>\n<li>\n<b>filter(predicateFunction [, options] [, callback])</b>\n<ul>\n<li>\nFilters the input using a predicate function which returns true/false in order to filter in/out input documents into the resulting set. This behaves similar to a WHERE clause in SQL.\n</li>\n</ul>\n</li>\n<li>\n<b>map(transformationFunction [, options] [, callback])</b>\n<ul>\n<li>\nApplies a projection given a transformation function which maps each input item to a JavaScript object or value. This behaves similar to a SELECT clause in SQL.\n</li>\n</ul>\n</li>\n<li>\n<b>pluck([propertyName] [, options] [, callback])</b>\n<ul>\n<li>\nThis is a shortcut for a map which extracts the value of a single property from each input item.\n</li>\n</ul>\n</li>\n<li>\n<b>flatten([isShallow] [, options] [, callback])</b>\n<ul>\n<li>\nCombines and flattens arrays from each input item in to a single array. This behaves similar to SelectMany in LINQ.\n</li>\n</ul>\n</li>\n<li>\n<b>sortBy([predicate] [, options] [, callback])</b>\n<ul>\n<li>\nProduce a new set of documents by sorting the documents in the input document stream in ascending order using the given predicate. This behaves similar to a ORDER BY clause in SQL.\n</li>\n</ul>\n</li>\n<li>\n<b>sortByDescending([predicate] [, options] [, callback])</b>\n<ul>\n<li>\nProduce a new set of documents by sorting the documents in the input document stream in descending order using the given predicate. This behaves similar to a ORDER BY x DESC clause in SQL.\n</li>\n</ul>\n</li>\n</ul>\n\n\nWhen included inside predicate and/or selector functions, the following JavaScript constructs get automatically optimized to run directly on DocumentDB indices:\n\n* Simple operators: = + - * / % | ^ &amp; == != === !=== &lt; &gt; &lt;= &gt;= || &amp;&amp; &lt;&lt; &gt;&gt; &gt;&gt;&gt;! ~\n* Literals, including the object literal: {}\n* var, return\n\nThe following JavaScript constructs do not get optimized for DocumentDB indices:\n\n* Control flow (e.g. if, for, while)\n* Function calls\n\nFor more information, please see our [Server-Side JSDocs](http://dl.windowsazure.com/documentDB/jsserverdocs/).\n\n### Example: Write a stored procedure using the JavaScript query API\n\nThe following code sample is an example of how the JavaScript Query API can be used in the context of a stored procedure. The stored procedure inserts a document, given by an input parameter, and updates a metadata document, using the `__.filter()` method, with minSize, maxSize, and totalSize based upon the input document's size property.\n\n    /**\n     * Insert actual doc and update metadata doc: minSize, maxSize, totalSize based on doc.size.\n     */\n    function insertDocumentAndUpdateMetadata(doc) {\n      // HTTP error codes sent to our callback funciton by DocDB server.\n      var ErrorCode = {\n        RETRY_WITH: 449,\n      }\n\n      var isAccepted = __.createDocument(__.getSelfLink(), doc, {}, function(err, doc, options) {\n        if (err) throw err;\n\n        // Check the doc (ignore docs with invalid/zero size and metaDoc itself) and call updateMetadata.\n        if (!doc.isMetadata && doc.size > 0) {\n          // Get the meta document. We keep it in the same collection. it's the only doc that has .isMetadata = true.\n          var result = __.filter(function(x) {\n            return x.isMetadata === true\n          }, function(err, feed, options) {\n            if (err) throw err;\n\n            // We assume that metadata doc was pre-created and must exist when this script is called.\n            if (!feed || !feed.length) throw new Error(\"Failed to find the metadata document.\");\n\n            // The metadata document.\n            var metaDoc = feed[0];\n\n            // Update metaDoc.minSize:\n            // for 1st document use doc.Size, for all the rest see if it's less than last min.\n            if (metaDoc.minSize == 0) metaDoc.minSize = doc.size;\n            else metaDoc.minSize = Math.min(metaDoc.minSize, doc.size);\n\n            // Update metaDoc.maxSize.\n            metaDoc.maxSize = Math.max(metaDoc.maxSize, doc.size);\n\n            // Update metaDoc.totalSize.\n            metaDoc.totalSize += doc.size;\n\n            // Update/replace the metadata document in the store.\n            var isAccepted = __.replaceDocument(metaDoc._self, metaDoc, function(err) {\n              if (err) throw err;\n              // Note: in case concurrent updates causes conflict with ErrorCode.RETRY_WITH, we can't read the meta again \n              //       and update again because due to Snapshot isolation we will read same exact version (we are in same transaction).\n              //       We have to take care of that on the client side.\n            });\n            if (!isAccepted) throw new Error(\"replaceDocument(metaDoc) returned false.\");\n          });\n          if (!result.isAccepted) throw new Error(\"filter for metaDoc returned false.\");\n        }\n      });\n      if (!isAccepted) throw new Error(\"createDocument(actual doc) returned false.\");\n    }\n\n## SQL to Javascript cheat sheet\nThe following table presents various SQL queries and the corresponding JavaScript queries.\n\nAs with SQL queries, document property keys (e.g. `doc.id`) are case-sensitive.\n\n<br/>\n<table border=\"1\" width=\"100%\">\n<colgroup>\n<col span=\"1\" style=\"width: 40%;\">\n<col span=\"1\" style=\"width: 40%;\">\n<col span=\"1\" style=\"width: 20%;\">\n</colgroup>\n<tbody>\n<tr>\n<th>SQL</th>\n<th>JavaScript Query API</th>\n<th>Details</th>\n</tr>\n<tr>\n<td>\n<pre>\nSELECT *\nFROM docs\n</pre>\n</td>\n<td>\n<pre>\n__.map(function(doc) {\n    return doc;\n});\n</pre>\n</td>\n<td>Results in all documents (paginated with continuation token) as is.</td>\n</tr>\n<tr>\n<td>\n<pre>\nSELECT docs.id, docs.message AS msg, docs.actions \nFROM docs\n</pre>\n</td>\n<td>\n<pre>\n__.map(function(doc) {\n    return {\n        id: doc.id,\n        msg: doc.message,\n        actions: doc.actions\n    };\n});\n</pre>\n</td>\n<td>Projects the id, message (aliased to msg), and action from all documents.</td>\n</tr>\n<tr>\n<td>\n<pre>\nSELECT * \nFROM docs \nWHERE docs.id=\"X998_Y998\"\n</pre>\n</td>\n<td>\n<pre>\n__.filter(function(doc) {\n    return doc.id === \"X998_Y998\";\n});\n</pre>\n</td>\n<td>Queries for documents with the predicate: id = \"X998_Y998\".</td>\n</tr>\n<tr>\n<td>\n<pre>\nSELECT *\nFROM docs\nWHERE ARRAY_CONTAINS(docs.Tags, 123)\n</pre>\n</td>\n<td>\n<pre>\n__.filter(function(x) {\n    return x.Tags && x.Tags.indexOf(123) > -1;\n});\n</pre>\n</td>\n<td>Queries for documents that have a Tags property and Tags is an array containing the value 123.</td>\n</tr>\n<tr>\n<td>\n<pre>\nSELECT docs.id, docs.message AS msg\nFROM docs \nWHERE docs.id=\"X998_Y998\"\n</pre>\n</td>\n<td>\n<pre>\n__.chain()\n    .filter(function(doc) {\n        return doc.id === \"X998_Y998\";\n    })\n    .map(function(doc) {\n        return {\n            id: doc.id,\n            msg: doc.message\n        };\n    })\n    .value();\n</pre>\n</td>\n<td>Queries for documents with a predicate, id = \"X998_Y998\", and then projects the id and message (aliased to msg).</td>\n</tr>\n<tr>\n<td>\n<pre>\nSELECT VALUE tag\nFROM docs\nJOIN tag IN docs.Tags\nORDER BY docs._ts\n</pre>\n</td>\n<td>\n<pre>\n__.chain()\n    .filter(function(doc) {\n        return doc.Tags && Array.isArray(doc.Tags);\n    })\n    .sortBy(function(doc) {\n        return doc._ts;\n    })\n    .pluck(\"Tags\")\n    .flatten()\n    .value()\n</pre>\n</td>\n<td>Filters for documents which have an array property, Tags, and sorts the resulting documents by the _ts timestamp system property, and then projects + flattens the Tags array.</td>\n</tr>\n</tbody>\n</table>\n\n## Runtime support\n[DocumentDB JavaScript server side SDK](http://dl.windowsazure.com/documentDB/jsserverdocs/) provides support for the most of the mainstream JavaScript language features as standardized by [ECMA-262](documentdb-interactions-with-resources.md).\n\n### Security\nJavaScript stored procedures and triggers are sandboxed so that the effects of one script do not leak to the other without going through the snapshot transaction isolation at the database level. The runtime environments are pooled but cleaned of the context after each run. Hence they are guaranteed to be safe of any unintended side effects from each other.\n\n### Pre-compilation\nStored procedures, triggers and UDFs are implicitly precompiled to the byte code format in order to avoid compilation cost at the time of each script invocation. This ensures invocations of stored procedures are fast and have a low footprint.\n\n## Client SDK support\nIn addition to the [Node.js](http://dl.windowsazure.com/documentDB/nodedocs/) client, DocumentDB supports [.NET](https://msdn.microsoft.com/library/azure/dn783362.aspx), [Java](http://dl.windowsazure.com/documentdb/javadoc/), [JavaScript](http://dl.windowsazure.com/documentDB/jsclientdocs/), and [Python SDKs](http://dl.windowsazure.com/documentDB/pythondocs/). Stored procedures, triggers and UDFs can be created and executed using any of these SDKs as well. The following example shows how to create and execute a stored procedure using the .NET client. Note how the .NET types are passed into the stored procedure as JSON and read back.\n\n    var markAntiquesSproc = new StoredProcedure\n    {\n        Id = \"ValidateDocumentAge\",\n        Body = @\"\n                function(docToCreate, antiqueYear) {\n                    var collection = getContext().getCollection();    \n                    var response = getContext().getResponse();    \n    \n                    if(docToCreate.Year != undefined && docToCreate.Year < antiqueYear){\n                        docToCreate.antique = true;\n                    }\n    \n                    collection.createDocument(collection.getSelfLink(), docToCreate, {}, \n                        function(err, docCreated, options) { \n                            if(err) throw new Error('Error while creating document: ' + err.message);                              \n                            if(options.maxCollectionSizeInMb == 0) throw 'max collection size not found'; \n                            response.setBody(docCreated);\n                    });\n            }\"\n    };\n    \n    // register stored procedure\n    StoredProcedure createdStoredProcedure = await client.CreateStoredProcedureAsync(collection.SelfLink, markAntiquesSproc);\n    dynamic document = new Document() { Id = \"Borges_112\" };\n    document.Title = \"Aleph\";\n    document.Year = 1949;\n    \n    // execute stored procedure\n    Document createdDocument = await client.ExecuteStoredProcedureAsync<Document>(createdStoredProcedure.SelfLink, document, 1920);\n\n\nThis sample shows how to use the [.NET SDK](https://msdn.microsoft.com/library/azure/dn783362.aspx) to create a pre-trigger and create a document with the trigger enabled. \n\n    Trigger preTrigger = new Trigger()\n    {\n        Id = \"CapitalizeName\",\n        Body = @\"function() {\n            var item = getContext().getRequest().getBody();\n            item.id = item.id.toUpperCase();\n            getContext().getRequest().setBody(item);\n        }\",\n        TriggerOperation = TriggerOperation.Create,\n        TriggerType = TriggerType.Pre\n    };\n    \n    Document createdItem = await client.CreateDocumentAsync(collection.SelfLink, new Document { Id = \"documentdb\" },\n        new RequestOptions\n        {\n            PreTriggerInclude = new List<string> { \"CapitalizeName\" },\n        });\n\n\nAnd the following example shows how to create a user defined function (UDF) and use it in a [DocumentDB SQL query](documentdb-sql-query.md).\n\n    UserDefinedFunction function = new UserDefinedFunction()\n    {\n        Id = \"LOWER\",\n        Body = @\"function(input) \n        {\n            return input.toLowerCase();\n        }\"\n    };\n    \n    foreach (Book book in client.CreateDocumentQuery(collection.SelfLink,\n        \"SELECT * FROM Books b WHERE udf.LOWER(b.Title) = 'war and peace'\"))\n    {\n        Console.WriteLine(\"Read {0} from query\", book);\n    }\n\n## REST API\nAll DocumentDB operations can be performed in a RESTful manner. Stored procedures, triggers and user-defined functions can be registered under a collection by using HTTP POST. The following is an example of how to register a stored procedure:\n\n    POST https://<url>/sprocs/ HTTP/1.1\n    authorization: <<auth>>\n    x-ms-date: Thu, 07 Aug 2014 03:43:10 GMT\n    \n    \n    var x = {\n      \"name\": \"createAndAddProperty\",\n      \"body\": function (docToCreate, addedPropertyName, addedPropertyValue) {\n                var collectionManager = getContext().getCollection();\n                collectionManager.createDocument(\n                    collectionManager.getSelfLink(),\n                    docToCreate,\n                    function(err, docCreated) {\n                      if(err) throw new Error('Error:  ' + err.message);\n                      docCreated[addedPropertyName] = addedPropertyValue;\n                      getContext().getResponse().setBody(docCreated);\n                    });\n            }\n    }\n\n\nThe stored procedure is registered by executing a POST request against the URI dbs/sehcAA==/colls/sehcAIE2Qy4=/sprocs with the body containing the stored procedure to create. Triggers and UDFs can be registered similarly by issuing a POST against /triggers and /udfs respectively.\nThis stored procedure can then be executed by issuing a POST request against its resource link:\n\n    POST https://<url>/sprocs/<sproc> HTTP/1.1\n    authorization: <<auth>>\n    x-ms-date: Thu, 07 Aug 2014 03:43:20 GMT\n    \n    \n    [ { \"name\": \"TestDocument\", \"book\": \"Autumn of the Patriarch\"}, \"Price\", 200 ]\n\n\nHere, the input to the stored procedure is passed in the request body. Note that the input is passed as a JSON array of input parameters. The stored procedure takes the first input as a document that is a response body. The response we receive is as follows:\n\n    HTTP/1.1 200 OK\n     \n    { \n      name: 'TestDocument',\n      book: ‘Autumn of the Patriarch’,\n      id: ‘V7tQANV3rAkDAAAAAAAAAA==‘,\n      ts: 1407830727,\n      self: ‘dbs/V7tQAA==/colls/V7tQANV3rAk=/docs/V7tQANV3rAkDAAAAAAAAAA==/’,\n      etag: ‘6c006596-0000-0000-0000-53e9cac70000’,\n      attachments: ‘attachments/’,\n      Price: 200\n    }\n\n\nTriggers, unlike stored procedures, cannot be executed directly. Instead they are executed as part of an operation on a document. We can specify the triggers to run with a request using HTTP headers. The following is request to create a document.\n\n    POST https://<url>/docs/ HTTP/1.1\n    authorization: <<auth>>\n    x-ms-date: Thu, 07 Aug 2014 03:43:10 GMT\n    x-ms-documentdb-pre-trigger-include: validateDocumentContents \n    x-ms-documentdb-post-trigger-include: bookCreationPostTrigger\n    \n    \n    {\n       \"name\": \"newDocument\",\n       “title”: “The Wizard of Oz”,\n       “author”: “Frank Baum”,\n       “pages”: 92\n    }\n\n\nHere the pre-trigger to be run with the request is specified in the x-ms-documentdb-pre-trigger-include header. Correspondingly, any post-triggers are given in the x-ms-documentdb-post-trigger-include header. Note that both pre- and post-triggers can be specified for a given request.\n\n## Sample code\n\nYou can find more server-side code examples (including [upsert](https://github.com/Azure/azure-documentdb-js/blob/master/server-side/samples/stored-procedures/upsert.js), [bulk-delete](https://github.com/Azure/azure-documentdb-js/blob/master/server-side/samples/stored-procedures/bulkDelete.js), and [update](https://github.com/Azure/azure-documentdb-js/blob/master/server-side/samples/stored-procedures/update.js)) on our [Github repository](https://github.com/Azure/azure-documentdb-js/tree/master/server-side/samples).\n\nWant to share your awesome stored procedure? Please, send us a pull-request! \n\n## Next steps\n\nOnce you have one or more stored procedures, triggers, and user-defined functions created, you can load them and view them in the Azure Preview portal using Script Explorer. For more information, see [View stored procedures, triggers, and user-defined functions using the DocumentDB Script Explorer](documentdb-view-scripts.md).\n\nYou may also find the following references and resources useful in your path to learn more about DocumentDB server-side programming:\n\n- [Azure DocumentDB SDKs](https://msdn.microsoft.com/library/azure/dn781482.aspx)\n- [JSON](http://www.json.org/) \n- [JavaScript ECMA-262](http://www.ecma-international.org/publications/standards/Ecma-262.htm)\n-   [JavaScript – JSON type system](http://www.json.org/js.html) \n-   [Secure and Portable Database Extensibility](http://dl.acm.org/citation.cfm?id=276339) \n-   [Service Oriented Database Architecture](http://dl.acm.org/citation.cfm?id=1066267&coll=Portal&dl=GUIDE) \n-   [Hosting the .NET Runtime in Microsoft SQL server](http://dl.acm.org/citation.cfm?id=1007669)  \ntest\n"
}