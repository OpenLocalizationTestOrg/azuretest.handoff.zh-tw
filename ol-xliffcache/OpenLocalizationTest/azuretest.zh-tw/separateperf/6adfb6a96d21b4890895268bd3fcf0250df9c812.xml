{
  "nodes": [
    {
      "content": "Code sample: Retry logic from Enterprise Library, in C# for connecting to SQL Database | Microsoft Azure",
      "pos": [
        28,
        132
      ]
    },
    {
      "content": "Enterprise Library is designed to ease the task of including retry logic to your client programs that access cloud services.",
      "pos": [
        151,
        275
      ]
    },
    {
      "content": "Code sample: Retry logic from Enterprise Library, in C&amp;#x23; for connecting to SQL Database",
      "pos": [
        599,
        690
      ]
    },
    {
      "content": "This topic presents a complete code sample that demonstrates the Enterprise Library (EntLib).",
      "pos": [
        693,
        786
      ]
    },
    {
      "content": "EntLib eases the programmer's task of including retry logic in their client that interact with the SQL Database cloud service of Microsoft Azure.",
      "pos": [
        788,
        933
      ]
    },
    {
      "content": "Enterprise Library 6 (EntLib60) is the latest version.",
      "pos": [
        936,
        990
      ]
    },
    {
      "content": "The following links are recommended for in-depth information about EntLib:",
      "pos": [
        993,
        1067
      ]
    },
    {
      "content": "<bpt id=\"p1\">[</bpt>Enterprise Library 6 â€“ April 2013<ept id=\"p1\">](http://msdn.microsoft.com/library/dn169621.aspx)</ept>",
      "pos": [
        1072,
        1156
      ]
    },
    {
      "content": "Provides numerous links to further information.",
      "pos": [
        1161,
        1208
      ]
    },
    {
      "content": "Free ebook in .PDF format from Microsoft:",
      "pos": [
        1212,
        1253
      ]
    },
    {
      "content": "<bpt id=\"p1\">[</bpt>Developer's Guide to Microsoft Enterprise Library, 2nd Edition<ept id=\"p1\">](http://www.microsoft.com/download/details.aspx?id=41145)</ept>.",
      "pos": [
        1258,
        1380
      ]
    },
    {
      "content": "Prerequisites",
      "pos": [
        1386,
        1399
      ]
    },
    {
      "content": "EntLib is not included when you install Visual Studio and Microsoft .NET Framework.",
      "pos": [
        1402,
        1485
      ]
    },
    {
      "content": "You must perform a separate download action.",
      "pos": [
        1486,
        1530
      ]
    },
    {
      "content": "The <bpt id=\"p1\">**</bpt>NuGet<ept id=\"p1\">**</ept> system through Visual Studio makes the download easy.",
      "pos": [
        1533,
        1600
      ]
    },
    {
      "content": "The download results in a directory named packages\\ under the same directory where your Visual Studio solution .sln file is stored.",
      "pos": [
        1601,
        1732
      ]
    },
    {
      "content": "The EntLib assembly .dll files are installed in a subdirectory.",
      "pos": [
        1735,
        1798
      ]
    },
    {
      "content": "The two assembly files are named as follows:",
      "pos": [
        1799,
        1843
      ]
    },
    {
      "content": "C&amp;#x23; code files explained",
      "pos": [
        1994,
        2022
      ]
    },
    {
      "content": "The C# code sample consists of three .cs files whose content is pasted into the sections that follow.",
      "pos": [
        2025,
        2126
      ]
    },
    {
      "content": "Their file names are:",
      "pos": [
        2127,
        2148
      ]
    },
    {
      "pos": [
        2294,
        2334
      ],
      "content": "Shorter <ph id=\"ph1\">`Program.cs`</ph> without <ph id=\"ph2\">`try/catch`</ph>"
    },
    {
      "content": "Another .cs file provided is a much shorter version of <ph id=\"ph1\">`Program.cs`</ph>.",
      "pos": [
        2337,
        2405
      ]
    },
    {
      "content": "All the <ph id=\"ph1\">`try/catch`</ph> code has been removed.",
      "pos": [
        2406,
        2448
      ]
    },
    {
      "content": "This makes it easier for the eye to see the EntLib calls.",
      "pos": [
        2449,
        2506
      ]
    },
    {
      "content": "Test .cs file",
      "pos": [
        2514,
        2527
      ]
    },
    {
      "content": "Testing your retry logic is tricky because there is no obvious way to cause a genuine transient fault error.",
      "pos": [
        2530,
        2638
      ]
    },
    {
      "content": "One test solution is to use temporary code to:",
      "pos": [
        2639,
        2685
      ]
    },
    {
      "content": "Cause a pretend transient fault.",
      "pos": [
        2691,
        2723
      ]
    },
    {
      "content": "Fix the cause of the transient fault.",
      "pos": [
        2727,
        2764
      ]
    },
    {
      "content": "Retry the connection or query, expecting success.",
      "pos": [
        2768,
        2817
      ]
    },
    {
      "content": "To help you test, another .cs file is provided that you can use as a temporary substitute:",
      "pos": [
        2820,
        2910
      ]
    },
    {
      "pos": [
        2958,
        3039
      ],
      "content": "Temporary replacement for <ph id=\"ph1\">`Custom_SqlDatabaseTransientErrorDetectionStrategy.cs`</ph>."
    },
    {
      "pos": [
        3042,
        3174
      ],
      "content": "The code locations at which to make changes for this testing are tagged with a comment that contains the string <ph id=\"ph1\">`TEST.PASSWORD_FIX`</ph>."
    },
    {
      "content": "Compile and run the code sample",
      "pos": [
        3180,
        3211
      ]
    },
    {
      "content": "You can compile the sample with the following steps:",
      "pos": [
        3214,
        3266
      ]
    },
    {
      "content": "In Visual Studio, create a new project from the C# Console Application template.",
      "pos": [
        3272,
        3352
      ]
    },
    {
      "content": "Right-click your project, and then add the .cs files for which source code is provided in this topic.",
      "pos": [
        3357,
        3458
      ]
    },
    {
      "content": "In a <ph id=\"ph1\">`cmd.exe`</ph> command window, run the program as shown next.",
      "pos": [
        3463,
        3524
      ]
    },
    {
      "content": "Actual output from a run is also shown:",
      "pos": [
        3525,
        3564
      ]
    },
    {
      "content": "The C# source code for the .cs files are in the following sections.",
      "pos": [
        3923,
        3990
      ]
    },
    {
      "content": "Program.cs file",
      "pos": [
        3996,
        4011
      ]
    },
    {
      "content": "The following code file, Program.cs, is long because it contains <ph id=\"ph1\">`try/catch`</ph> blocks that execute only if an error occurs.",
      "pos": [
        4014,
        4135
      ]
    },
    {
      "content": "Near the end of the present topic is a much shorter version of <ph id=\"ph1\">`Program.cs`</ph> with all the <ph id=\"ph2\">`try/catch`</ph> lines removed.",
      "pos": [
        4136,
        4251
      ]
    },
    {
      "content": "The <ph id=\"ph1\">`Main`</ph> method is in <ph id=\"ph2\">`Program.cs`</ph>.",
      "pos": [
        4254,
        4291
      ]
    },
    {
      "content": "The call stack runs as follows:",
      "pos": [
        4292,
        4323
      ]
    },
    {
      "pos": [
        4329,
        4360
      ],
      "content": "<ph id=\"ph1\">`Main`</ph> calls <ph id=\"ph2\">`ConnectAndQuery`</ph>."
    },
    {
      "pos": [
        4365,
        4408
      ],
      "content": "<ph id=\"ph1\">`ConnectAndQuery`</ph> calls <ph id=\"ph2\">`InitializeFields`</ph>."
    },
    {
      "pos": [
        4413,
        4459
      ],
      "content": "<ph id=\"ph1\">`ConnectAndQuery`</ph> calls <ph id=\"ph2\">`EstablishConnection`</ph>."
    },
    {
      "pos": [
        4464,
        4512
      ],
      "content": "<ph id=\"ph1\">`EstablishConnection`</ph> calls <ph id=\"ph2\">`IssueQueryCommand`</ph>."
    },
    {
      "content": "&amp;nbsp;",
      "pos": [
        4515,
        4521
      ]
    },
    {
      "content": "&amp;nbsp;",
      "pos": [
        18168,
        18174
      ]
    },
    {
      "pos": [
        18180,
        18239
      ],
      "content": "<ph id=\"ph1\">`Custom_SqlDatabaseTransientErrorDetectionStrategy.cs`</ph> file"
    },
    {
      "content": "EntLib60 has a class named <ph id=\"ph1\">`ReliableSqlConnection`</ph>.",
      "pos": [
        18242,
        18293
      ]
    },
    {
      "content": "You can control how the connection instance decides whether an exception is a transient error by assigning to it a class that implements <ph id=\"ph1\">`ITransientErrorDetectionStrategy`</ph>.",
      "pos": [
        18294,
        18466
      ]
    },
    {
      "content": "EntLib60 offers the class <ph id=\"ph1\">`SqlDatabaseTransientErrorDetectionStrategy`</ph>.",
      "pos": [
        18468,
        18539
      ]
    },
    {
      "content": "But in this topic we chose to implement and use our own custom class <ph id=\"ph1\">`Custom_SqlDatabaseTransientErrorDetectionStrategy`</ph>.",
      "pos": [
        18540,
        18661
      ]
    },
    {
      "content": "Our custom class has a whitelist of values to compare against <ph id=\"ph1\">`SqlException.Number`</ph>.",
      "pos": [
        18662,
        18746
      ]
    },
    {
      "content": "&amp;nbsp;",
      "pos": [
        20863,
        20869
      ]
    },
    {
      "pos": [
        20875,
        20942
      ],
      "content": "<ph id=\"ph1\">`ForcePersistent_SqlCommandTransientErrorDetectionStrategy.cs`</ph> file"
    },
    {
      "content": "This custom class that implements <ph id=\"ph1\">`ITransientErrorDetectionStrategy`</ph> enforces our choice to never consider let EntLib60 consider any query command error to be merely transient.",
      "pos": [
        20945,
        21121
      ]
    },
    {
      "content": "Instead, the overall program is designed to assess the <ph id=\"ph1\">`SqlException.Number`</ph> in its own custom logic.",
      "pos": [
        21122,
        21223
      ]
    },
    {
      "content": "With the class in this section, we made the design choice to have our program discard and recreate a new connection before retrying any failed query command, transient or not.",
      "pos": [
        21226,
        21401
      ]
    },
    {
      "content": "&amp;nbsp;",
      "pos": [
        22285,
        22291
      ]
    },
    {
      "content": "Test your retry logic",
      "pos": [
        22297,
        22318
      ]
    },
    {
      "content": "It is tricky to test your EntLib60 program.",
      "pos": [
        22321,
        22364
      ]
    },
    {
      "content": "It is difficult to cause a genuinely transient error, and to controls its timings.",
      "pos": [
        22365,
        22447
      ]
    },
    {
      "content": "This demo code includes a simple technique you can use to mimic a transient error.",
      "pos": [
        22448,
        22530
      ]
    },
    {
      "content": "The technique is to use our custom detector <ph id=\"ph1\">`Test2_TransientErrorDetectionStrategy`</ph> class in place of the <ph id=\"ph2\">`Custom_SqlTransientErrorDetectionStrategy`</ph> class.",
      "pos": [
        22534,
        22690
      ]
    },
    {
      "content": "This way you can force the <ph id=\"ph1\">`ReliableSqlConnection`</ph> of EntLib60 to assess <bpt id=\"p1\">*</bpt>all<ept id=\"p1\">*</ept> <ph id=\"ph2\">`SqlException`</ph> occurrences as being transient.",
      "pos": [
        22691,
        22816
      ]
    },
    {
      "content": "The trick is to have the program self-fix the problem before the first retry.",
      "pos": [
        22817,
        22894
      ]
    },
    {
      "content": "Misspelled password trick",
      "pos": [
        22901,
        22926
      ]
    },
    {
      "content": "An easy approach is to start with a misspelled value for the connection password.",
      "pos": [
        22929,
        23010
      ]
    },
    {
      "content": "When this causes an <ph id=\"ph1\">`SqlException`</ph>, with <ph id=\"ph2\">`sqlExc.Number==18456`</ph>, the program must fix the password.",
      "pos": [
        23011,
        23110
      ]
    },
    {
      "content": "On the retry the program succeeds.",
      "pos": [
        23111,
        23145
      ]
    },
    {
      "content": "To implement this test in our demo program, search the source code for all occurrences of <ph id=\"ph1\">`TEST.PASSWORD_FIX`</ph>.",
      "pos": [
        23148,
        23258
      ]
    },
    {
      "content": "After you find all occurrences of <ph id=\"ph1\">`TEST.PASSWORD_FIX`</ph> and make the changes that are explained in comments at each location, you will have made the following changes:",
      "pos": [
        23259,
        23424
      ]
    },
    {
      "pos": [
        23429,
        23528
      ],
      "content": "In the live code in the <ph id=\"ph1\">`InitializeFields`</ph> method, change the password value to an incorrect value."
    },
    {
      "content": "In <ph id=\"ph1\">`//`</ph> commented code, in the <ph id=\"ph2\">`EstablishConnection`</ph> method, there is an entire <ph id=\"ph3\">`catch`</ph> block...",
      "pos": [
        23532,
        23628
      ]
    },
    {
      "content": "that is commented out.",
      "pos": [
        23676,
        23698
      ]
    },
    {
      "content": "Uncomment the whole block.",
      "pos": [
        23699,
        23725
      ]
    },
    {
      "pos": [
        23729,
        23803
      ],
      "content": "In the newly uncommented <ph id=\"ph1\">`catch`</ph> block, assign the correct password value."
    },
    {
      "content": "Where the class <ph id=\"ph1\">`Custom_TransientErrorDetectionStrategy`</ph> is referenced in the code, replace the reference with <ph id=\"ph2\">`Test2_TransientErrorDetectionStrategy`</ph>.",
      "pos": [
        23807,
        23958
      ]
    },
    {
      "content": "You can keep the variable name the same.",
      "pos": [
        23959,
        23999
      ]
    },
    {
      "pos": [
        24006,
        24053
      ],
      "content": "<ph id=\"ph1\">`Test2_TransientErrorDetectionStrategy.cs`</ph> file"
    },
    {
      "content": "&amp;nbsp;",
      "pos": [
        25057,
        25063
      ]
    },
    {
      "pos": [
        25069,
        25110
      ],
      "content": "Shorter <ph id=\"ph1\">`Program.cs`</ph>, without <ph id=\"ph2\">`try/catch`</ph>"
    },
    {
      "content": "The shorter code in this section does compile, and if run it would usually work.",
      "pos": [
        25113,
        25193
      ]
    },
    {
      "content": "But the shorter code is not meant to be run in production.",
      "pos": [
        25194,
        25252
      ]
    },
    {
      "content": "The only purpose of this shorter <ph id=\"ph1\">`Program.cs`</ph> sample is to make it easier to see the same EntLib calls that are in the real <ph id=\"ph2\">`Program.cs`</ph>.",
      "pos": [
        25255,
        25392
      ]
    },
    {
      "content": "The removal of all the <ph id=\"ph1\">`try/catch`</ph> blocks makes the EntLib calls easier to see.",
      "pos": [
        25393,
        25472
      ]
    },
    {
      "content": "Related links",
      "pos": [
        30690,
        30703
      ]
    },
    {
      "content": "Microsoft.Practices.EnterpriseLibrary.TransientFaultHandling Namespace",
      "pos": [
        30709,
        30779
      ]
    },
    {
      "content": "Enterprise Library 6 Class Library",
      "pos": [
        30886,
        30920
      ]
    },
    {
      "content": "Code sample: Retry logic in C# for connecting to SQL Database with ADO.NET",
      "pos": [
        30975,
        31049
      ]
    },
    {
      "content": "Client quick-start code samples to SQL Database",
      "pos": [
        31101,
        31148
      ]
    }
  ],
  "content": "<properties \n    pageTitle=\"Code sample: Retry logic from Enterprise Library, in C# for connecting to SQL Database | Microsoft Azure\"\n    description=\"Enterprise Library is designed to ease the task of including retry logic to your client programs that access cloud services.\"\n    services=\"sql-database\"\n    documentationCenter=\"\"\n    authors=\"MightyPen\"\n    manager=\"jeffreyg\"\n    editor=\"\" />\n\n\n<tags \n    ms.service=\"sql-database\" \n    ms.workload=\"data-management\" \n    ms.tgt_pltfrm=\"na\" \n    ms.devlang=\"dotnet\" \n    ms.topic=\"article\" \n    ms.date=\"08/04/2015\" \n    ms.author=\"genemi\"/>\n\n\n# Code sample: Retry logic from Enterprise Library, in C&#x23; for connecting to SQL Database\n\n\nThis topic presents a complete code sample that demonstrates the Enterprise Library (EntLib).  EntLib eases the programmer's task of including retry logic in their client that interact with the SQL Database cloud service of Microsoft Azure.\n\n\nEnterprise Library 6 (EntLib60) is the latest version.\n\n\nThe following links are recommended for in-depth information about EntLib:\n\n\n- [Enterprise Library 6 â€“ April 2013](http://msdn.microsoft.com/library/dn169621.aspx)<br/>Provides numerous links to further information.\n\n- Free ebook in .PDF format from Microsoft:<br/>[Developer's Guide to Microsoft Enterprise Library, 2nd Edition](http://www.microsoft.com/download/details.aspx?id=41145).\n\n\n## Prerequisites\n\n\nEntLib is not included when you install Visual Studio and Microsoft .NET Framework. You must perform a separate download action.\n\n\nThe **NuGet** system through Visual Studio makes the download easy. The download results in a directory named packages\\ under the same directory where your Visual Studio solution .sln file is stored.\n\n\nThe EntLib assembly .dll files are installed in a subdirectory. The two assembly files are named as follows:\n\n\n- `Microsoft.Practices.EnterpriseLibrary.TransientFaultHandling.dll`\n- `Microsoft.Practices.EnterpriseLibrary.TransientFaultHandling.Data.dll`\n\n\n## C&#x23; code files explained\n\n\nThe C# code sample consists of three .cs files whose content is pasted into the sections that follow. Their file names are:\n\n\n- `Program.cs`\n- `Custom_SqlDatabaseTransientErrorDetectionStrategy.cs`\n- `ForcePersistent_SqlCommandTransientErrorDetectionStrategy.cs`\n\n\n### Shorter `Program.cs` without `try/catch`\n\n\nAnother .cs file provided is a much shorter version of `Program.cs`. All the `try/catch` code has been removed. This makes it easier for the eye to see the EntLib calls.\n\n\n\n### Test .cs file\n\n\nTesting your retry logic is tricky because there is no obvious way to cause a genuine transient fault error. One test solution is to use temporary code to:\n\n\n1. Cause a pretend transient fault.\n2. Fix the cause of the transient fault.\n3. Retry the connection or query, expecting success.\n\n\nTo help you test, another .cs file is provided that you can use as a temporary substitute:\n\n\n- `Test2_TransientErrorDetectionStrategy`\n - Temporary replacement for `Custom_SqlDatabaseTransientErrorDetectionStrategy.cs`.\n\n\nThe code locations at which to make changes for this testing are tagged with a comment that contains the string `TEST.PASSWORD_FIX`.\n\n\n## Compile and run the code sample\n\n\nYou can compile the sample with the following steps:\n\n\n1. In Visual Studio, create a new project from the C# Console Application template.\n\n2. Right-click your project, and then add the .cs files for which source code is provided in this topic.\n\n3. In a `cmd.exe` command window, run the program as shown next. Actual output from a run is also shown:\n\n\n        [C:\\MyVS\\ConsoleApplication1\\ConsoleApplication1\\bin\\Debug\\]\n        >> ConsoleApplication1.exe\n        \n        database_firewall_rules_table   245575913\n        filestream_tombstone_2073058421 2073058421\n        filetable_updates_2105058535    2105058535\n        \n        [C:\\MyVS\\ConsoleApplication1\\ConsoleApplication1\\bin\\Debug\\]\n        >>\n\n\nThe C# source code for the .cs files are in the following sections.\n\n\n## Program.cs file\n\n\nThe following code file, Program.cs, is long because it contains `try/catch` blocks that execute only if an error occurs. Near the end of the present topic is a much shorter version of `Program.cs` with all the `try/catch` lines removed.\n\n\nThe `Main` method is in `Program.cs`. The call stack runs as follows:\n\n\n1. `Main` calls `ConnectAndQuery`.\n\n2. `ConnectAndQuery` calls `InitializeFields`.\n\n3. `ConnectAndQuery` calls `EstablishConnection`.\n\n4. `EstablishConnection` calls `IssueQueryCommand`.\n\n\n&nbsp;\n\n\n    using     System;  // C#\n    using X = System.Text;\n    using D = System.Data;\n    using C = System.Data.SqlClient;\n    using E = Microsoft.Practices.EnterpriseLibrary.TransientFaultHandling;\n    \n    namespace ConsoleApplication1 \n    {\n        /// <summary>\n        /// Demo sample C# program that uses Microsoft's Enterprise Library 6 to robustly\n        /// connect to and interact with Azure SQL Database.\n        /// .\n        /// The sample chooses a strategy of discarding the Sql Connection whenever\n        /// a Sql Command fails, even for a transient reason. The 'for' loop\n        /// manages this choice. We are neither recommending nor disrecommending\n        /// this particular choice, just demonstrating flexibility.\n        /// .\n        /// For an optional test mechanism manually built into this program, find all:\n        /// 'TEST.PASSWORD_FIX' (related to connection).\n        /// </summary>\n        class Program\n        {\n            // const fields, so that SqlException objects thrown from Sql Commands\n            // are tested for transience by our custom logic.\n            private const string M_progressCreatingConnection = \"CreatingConnection\";\n            private const string M_progressIssuingCommand     = \"IssuingCommand\";\n    \n            // Fields, shared among methods.\n            private string progressLocation;\n            private E.ReliableSqlConnection rsConnection;\n            private E.RetryPolicy connectionRetryPolicy;\n            private E.RetryPolicy commandRetryPolicy;\n            private C.SqlConnectionStringBuilder scsBuilder;\n            private Action EstablishConnection_action;\n            private Action IssueQueryCommand_action;\n            private string sqlSelectCode;\n            private ForcePersistent_SqlCommandTransientErrorDetectionStrategy\n                forcePersistent_SqlCommandTransientErrorDetectionStrategy;\n    \n            // Also consider E.FixedInterval or E.Incremental.\n            private E.ExponentialBackoff exponentialBackoffStrategy;\n    \n            // TEST.PASSWORD_FIX.  Replace with Test2_TransientErrorDetectionStrategy.\n            private Custom_SqlDatabaseTransientErrorDetectionStrategy\n                custom_SqlDatabaseTransientErrorDetectionStrategy;\n    \n    \n            static void Main(string[] args)\n            {\n                new Program().ConnectAndQuery();\n            }\n    \n    \n            /// <summary>\n            /// Called from Main.\n            /// Calls a method to establish a connection, which calls\n            /// another method to issue a query through the connection. \n            /// </summary>\n            void ConnectAndQuery()\n            {\n                int maxCountTriesConnectAndQuery = 3;  // Adjustable.\n    \n                this.InitializeFields();\n    \n                //-------------------------------------------------------\n                // Preparations are complete.\n                // Next is a call .ExecuteAction to invoke the method EstablishConnection.\n                // Method EstablishConnection then calls another .ExecuteAction to\n                //     invoke the method IssueQueryCommand.\n                // Then control is returned to this method.\n    \n                for (int cc = 1; cc <= maxCountTriesConnectAndQuery; cc++)\n                {\n                    if (cc >= 2) { Console.WriteLine(\"-- Another iteration of outer loop, cc=={0}. --\", cc); }\n    \n                    try\n                    {\n                        // [A.1] Connect, which proceeds to issue a query command.\n                        this.connectionRetryPolicy.ExecuteAction(this.EstablishConnection_action);\n    \n                        break; // [A.2] All has gone well, so let the program end.\n                    }\n                    catch (C.SqlException sqlExc)\n                    {\n                        bool isTransientErrorNumber = false;\n    \n                        // [A.3] Call our collection of transient error numbers.\n                        isTransientErrorNumber =\n                            Custom_SqlDatabaseTransientErrorDetectionStrategy // TEST.PASSWORD_FIX.\n                            .IsTransientStatic(sqlExc);\n    \n                        if (isTransientErrorNumber == false)\n                        {\n                            Console.WriteLine();\n                            Console.WriteLine(\"Persistent error suffered, SqlException.Number = {0}.\"\n                                + \"  Will terminate.\", sqlExc.Number);\n                            Console.WriteLine(sqlExc.ToString());\n    \n                            // [A.4] Either the connection attempt or the query command attempt\n                            //     suffered a persistent SqlException.\n                            // Break the query command loop, let the hopeless program end.\n                            break;\n                        }\n    \n                        if (this.progressLocation == M_progressCreatingConnection)\n                        {\n                            // [A.5] The EntLib retry mechanisms already gave the Sql Connection\n                            //     enough retries, so this block will not give connection any more tries.\n                            // This block gives retries to certain Sql Command only.\n                            break;\n                        }\n    \n                        // [A.6] The SqlException identified a transient error from an attempt\n                        //     to issue a query command.\n                        // So let this method reloop and try again. However, we recommend that the new\n                        // query attempt should start at the beginning and establish a new connection.\n                        Console.WriteLine();\n                        Console.WriteLine(\"Transient error encountered.  SqlException.Number = {0}.\"\n                            + \"  Program might retry by itself.\", sqlExc.Number);\n                        Console.WriteLine(\"{0} = Attempts so far. Might retry.\", cc);\n                        Console.WriteLine(sqlExc.Message);\n                    }\n                    catch (Exception exc)\n                    {\n                        Console.WriteLine();\n                        Console.WriteLine(\"Unexpected exception type caught.  Will terminate.\");\n                        throw exc; // [A.7] The program must end, so re-throw the unrecognized exception.\n                    }\n    \n    \n                    // [A.8] Throw an exception if transient SqlExceptions caused us\n                    // to exceed our self-imposed maximum of retries.\n                    if (cc > maxCountTriesConnectAndQuery)\n                    {\n                        Console.WriteLine();\n                        string mesg = String.Format(\n                            \"Transient errors suffered in too many retries ({0}). Will terminate.\",\n                            cc - 1);\n                        Console.WriteLine(mesg);\n    \n                        // [A.9] To end the program, throw a new exception of a different type.\n                        ApplicationException appExc = new ApplicationException(mesg);\n                        throw appExc;\n                    }\n                } // for cc\n                return;\n            } // method ConnectAndQuery\n    \n    \n            void EstablishConnection()\n            {\n                try\n                {\n                    // [C.1]\n                    using ( this.rsConnection = new E.ReliableSqlConnection(\n                        this.scsBuilder.ToString(),\n                        this.connectionRetryPolicy,\n                        this.commandRetryPolicy )\n                        )\n                    {\n                        this.progressLocation = M_progressCreatingConnection;\n                        this.rsConnection.Open(); // [C.2] Open the newly constructed reliable connection.\n    \n                        // [C.3] Prepare delegate, then issue a query command.\n                        this.commandRetryPolicy.ExecuteAction(this.IssueQueryCommand_action);\n                    }\n                }\n                // TEST.PASSWORD_FIX.\n                    // Step_1: In InitializeFields(), set password to a wrong value.\n                    // Step_2: Uncomment the following 'catch' of sqlExc.\n                //catch (C.SqlException sqlExc)  // For TESTING only.  Usually comment out this one CATCH.\n                //{\n                //    if (sqlExc.Number == 18456)  // Could mean wrong password, could not connect.\n                //    {\n                //        this.scsBuilder[\"Password\"] = \"MyCorrectPassword\";\n                //        Console.WriteLine(\"Testing.  Password now fixed in catch.\");\n                //    }\n                //    throw sqlExc;\n                //}\n                catch (Exception exc)\n                {\n                    throw exc;  // [C.4] Let caller assess any exception, SqlException or any kind.\n                }\n                return;\n            } // method EstablishConnection\n    \n    \n            void IssueQueryCommand()\n            {\n                D.IDataReader dReader = null;\n                D.IDbCommand dbCommand = null;\n    \n                X.StringBuilder sBuilder = new X.StringBuilder(256);\n    \n                try\n                {\n                    // [D.1] Use the connection to create a query command.\n                    using (dbCommand = this.rsConnection.CreateCommand())\n                    {\n                        dbCommand.CommandText = this.sqlSelectCode;\n    \n                        // [D.2] Issue the query command through the connection.\n                        this.progressLocation = M_progressIssuingCommand;\n                        using (dReader = this.rsConnection.ExecuteCommand<D.IDataReader>(dbCommand))\n                        {\n                            Console.WriteLine();\n                            // [D.3] Loop through all returned rows, writing the data to the console.\n                            while (dReader.Read())\n                            {\n                                sBuilder.Length = 0;\n                                sBuilder.Append(dReader.GetString(0));\n                                sBuilder.Append(\"\\t\");\n                                sBuilder.Append(dReader.GetString(1));\n    \n                                Console.WriteLine(sBuilder.ToString());\n                            }\n                        }\n                    }\n                }\n                catch (Exception exc)\n                {\n                    throw exc; // [D.4] Let caller assess any exception.\n                }\n                return;\n            } // method IssueQueryCommand\n    \n    \n            void InitializeFields()\n            {\n                // [B.1] Prepare the connection string to Azure SQL Database.\n                this.scsBuilder = new C.SqlConnectionStringBuilder();\n                // Change these values to your values.\n                this.scsBuilder[\"Server\"] = \"tcp:myazuresqldbserver.database.windows.net,1433\";\n                this.scsBuilder[\"User ID\"] = \"MyLogin\";  // @yourservername suffix sometimes.\n                this.scsBuilder[\"Password\"] = \"MyCorrectPassword\";  // TEST.PASSWORD_FIX.\n                this.scsBuilder[\"Database\"] = \"MyDatabase\";\n                // Leave these values as they are.\n                this.scsBuilder[\"Trusted_Connection\"] = false;\n                this.scsBuilder[\"Integrated Security\"] = false;\n                this.scsBuilder[\"Encrypt\"] = true;\n                this.scsBuilder[\"Connection Timeout\"] = 30; // Default is 15 seconds, too brief over Internet!\n    \n                // [B.2] Prepare the Transact-SQL select statement.\n                this.sqlSelectCode =\n                    @\"SELECT TOP 3 name, CAST(object_id as nvarchar(32)) as [object_id]\n                      FROM sys.objects\n                      WHERE type='IT'\n                      ORDER BY name;\";\n    \n                // [B.3] Begin steps to create a retry policy for connecting.\n                this.exponentialBackoffStrategy = new E.ExponentialBackoff(\n                    \"exponentialBackoffStrategy\",\n                    2,                               // Maximum number of times to retry.\n                    TimeSpan.FromMilliseconds(2000), // Minimum interval between retries.\n                    TimeSpan.FromMilliseconds(8000), // Maximum interval between retries.\n                    TimeSpan.FromMilliseconds(2000)  // Factor for random differences in interval between retries.\n                    );\n    \n                this.forcePersistent_SqlCommandTransientErrorDetectionStrategy =\n                    new ForcePersistent_SqlCommandTransientErrorDetectionStrategy();\n    \n                this.custom_SqlDatabaseTransientErrorDetectionStrategy =\n                    new Custom_SqlDatabaseTransientErrorDetectionStrategy();// TEST.PASSWORD_FIX.\n    \n                this.connectionRetryPolicy = new E.RetryPolicy(\n                    this.custom_SqlDatabaseTransientErrorDetectionStrategy,\n                    this.exponentialBackoffStrategy);\n                this.commandRetryPolicy = new E.RetryPolicy(\n                    this.forcePersistent_SqlCommandTransientErrorDetectionStrategy,\n                    this.exponentialBackoffStrategy);\n    \n                this.EstablishConnection_action = delegate() { this.EstablishConnection(); };\n                this.IssueQueryCommand_action   = delegate() { this.IssueQueryCommand(); };\n    \n                return;\n            } // method InitializeFields\n        } // class Program\n    }\n\n\n&nbsp;\n\n\n## `Custom_SqlDatabaseTransientErrorDetectionStrategy.cs` file\n\n\nEntLib60 has a class named `ReliableSqlConnection`. You can control how the connection instance decides whether an exception is a transient error by assigning to it a class that implements `ITransientErrorDetectionStrategy`.\n\nEntLib60 offers the class `SqlDatabaseTransientErrorDetectionStrategy`. But in this topic we chose to implement and use our own custom class `Custom_SqlDatabaseTransientErrorDetectionStrategy`. Our custom class has a whitelist of values to compare against `SqlException.Number`.\n\n\n    using     System;\n    using G = System.Collections.Generic;\n    using C = System.Data.SqlClient;\n    using E = Microsoft.Practices.EnterpriseLibrary.TransientFaultHandling;\n    \n    namespace ConsoleApplication1\n    {\n        /// <summary>\n        /// A custom alternative to class SqlDatabaeTransientErrorDetectionStrategy.\n        /// </summary>\n        public class Custom_SqlDatabaseTransientErrorDetectionStrategy\n            : E.ITransientErrorDetectionStrategy\n        {\n            static private G.List<int> M_listTransientErrorNumbers;\n    \n    \n            /// <summary>\n            /// This method is required by ITransientErrorDetectionStrategy.\n            /// </summary>\n            public bool IsTransient(Exception exc)\n            {\n                return IsTransientStatic(exc);\n            }\n    \n    \n            /// <summary>\n            /// For general use beyond formal Enterprise Library classes.\n            /// </summary>\n            static public bool IsTransientStatic(Exception exc)\n            {\n                bool returnBool = false;  // Assume is a persistent error.\n                C.SqlException sqlExc;\n    \n                if (exc is C.SqlException)\n                {\n                    sqlExc = exc as C.SqlException;\n                    if (M_listTransientErrorNumbers.Contains(sqlExc.Number) == true)\n                    {\n                        returnBool = true;  // Error is transient, not persistent.\n                    }\n                }\n                return returnBool;\n            }\n    \n    \n            /// <summary>\n            /// Lists the SqlException.Number values that are considered\n            /// to indicate transient errors.\n            /// </summary>\n            static Custom_SqlDatabaseTransientErrorDetectionStrategy()\n            {\n                int[] arrayOfTransientErrorNumbers =\n                    {4060, 10928, 10929, 40197, 40501, 40613};\n    \n                M_listTransientErrorNumbers = new G.List<int>(arrayOfTransientErrorNumbers);\n            }\n        } // class Custom_SqlDatabaseTransientErrorDetectionStrategy\n    }\n\n\n&nbsp;\n\n\n## `ForcePersistent_SqlCommandTransientErrorDetectionStrategy.cs` file\n\n\nThis custom class that implements `ITransientErrorDetectionStrategy` enforces our choice to never consider let EntLib60 consider any query command error to be merely transient. Instead, the overall program is designed to assess the `SqlException.Number` in its own custom logic.\n\n\nWith the class in this section, we made the design choice to have our program discard and recreate a new connection before retrying any failed query command, transient or not.\n\n\n    using     System;\n    using E = Microsoft.Practices.EnterpriseLibrary.TransientFaultHandling;\n    \n    \n    namespace ConsoleApplication1\n    {\n        /// <summary>\n        /// Is a substitute for class E.SqlCommandTransientErrorDetectionStrategy.\n        /// Choosing to always discard the Sql Connection whenever the command fails,\n        /// regardless of whether command failure was transient.\n        /// Program try/catch and for-loop logic prefers to discard then re-construct\n        /// a new Sql Connection.\n        /// </summary>\n        public class ForcePersistent_SqlCommandTransientErrorDetectionStrategy\n            : E.ITransientErrorDetectionStrategy\n        {\n            public bool IsTransient(Exception exc)\n            {\n                return false;  // Force a failure, even if is transient.  No retry of sql command.\n            }\n        }\n    }\n\n\n&nbsp;\n\n\n## Test your retry logic\n\n\nIt is tricky to test your EntLib60 program. It is difficult to cause a genuinely transient error, and to controls its timings. This demo code includes a simple technique you can use to mimic a transient error. \n\n\nThe technique is to use our custom detector `Test2_TransientErrorDetectionStrategy` class in place of the `Custom_SqlTransientErrorDetectionStrategy` class. This way you can force the `ReliableSqlConnection` of EntLib60 to assess *all* `SqlException` occurrences as being transient. The trick is to have the program self-fix the problem before the first retry.\n\n\n### Misspelled password trick\n\n\nAn easy approach is to start with a misspelled value for the connection password. When this causes an `SqlException`, with `sqlExc.Number==18456`, the program must fix the password. On the retry the program succeeds.\n\n\nTo implement this test in our demo program, search the source code for all occurrences of `TEST.PASSWORD_FIX`. After you find all occurrences of `TEST.PASSWORD_FIX` and make the changes that are explained in comments at each location, you will have made the following changes:\n\n\n- In the live code in the `InitializeFields` method, change the password value to an incorrect value.\n\n- In `//` commented code, in the `EstablishConnection` method, there is an entire `catch` block...<br/>`//catch (SDSqlC.SqlException sqlExc)`<br/>that is commented out. Uncomment the whole block.\n\n- In the newly uncommented `catch` block, assign the correct password value.\n\n- Where the class `Custom_TransientErrorDetectionStrategy` is referenced in the code, replace the reference with `Test2_TransientErrorDetectionStrategy`. You can keep the variable name the same.\n\n\n### `Test2_TransientErrorDetectionStrategy.cs` file\n\n\n    using     System;\n    using E = Microsoft.Practices.EnterpriseLibrary.TransientFaultHandling;\n    \n    namespace ConsoleApplication1\n    {\n        /// <summary>\n        /// For testing, is a substitute for class E.SqlDatabaseTransientErrorDetectionStrategy.\n        /// Change the true/false assignment to returnValue for different tests.\n        /// </summary>\n        public class Test2_TransientErrorDetectionStrategy\n            : E.ITransientErrorDetectionStrategy\n        {\n            public bool IsTransient(Exception exc)\n            {\n                bool returnValue = Test2_TransientErrorDetectionStrategy.IsTransientStatic(exc);\n                Console.WriteLine(\"Inside Test2_TransientErrorDetectionStrategy .IsTransientStatic,\"\n                    + \" returning {0}.\", returnValue);\n                return returnValue;\n            }\n            static public bool IsTransientStatic(Exception exc)\n            {\n                return true;  //false;\n            }\n        }\n    }\n\n\n&nbsp;\n\n\n## Shorter `Program.cs`, without `try/catch`\n\n\nThe shorter code in this section does compile, and if run it would usually work. But the shorter code is not meant to be run in production.\n\n\nThe only purpose of this shorter `Program.cs` sample is to make it easier to see the same EntLib calls that are in the real `Program.cs`. The removal of all the `try/catch` blocks makes the EntLib calls easier to see.\n\n\n    using     System;  // C#\n    using X = System.Text;\n    using D = System.Data;\n    using C = System.Data.SqlClient;\n    using E = Microsoft.Practices.EnterpriseLibrary.TransientFaultHandling;\n    \n    namespace ConsoleApplication1_Shorter_No_TryCatch\n    {\n        class Program\n        {\n            private E.ReliableSqlConnection rsConnection;\n            private E.RetryPolicy connectionRetryPolicy;\n            private E.RetryPolicy commandRetryPolicy;\n            private E.ExponentialBackoff exponentialBackoffStrategy;\n            private C.SqlConnectionStringBuilder scsBuilder;\n            private Action EstablishConnection_action;\n            private Action IssueQueryCommand_action;\n            private string sqlSelectCode;\n            private Custom_SqlDatabaseTransientErrorDetectionStrategy\n                custom_SqlDatabaseTransientErrorDetectionStrategy;\n            private ForcePersistent_SqlCommandTransientErrorDetectionStrategy\n                forcePersistent_SqlCommandTransientErrorDetectionStrategy;\n    \n            static void Main(string[] args)\n            {\n                new Program().ConnectAndQuery();\n            }\n    \n            void ConnectAndQuery()\n            {\n                this.InitializeFields();\n                this.connectionRetryPolicy.ExecuteAction(this.EstablishConnection_action);\n            } // method ConnectAndQuery\n    \n            void EstablishConnection()\n            {\n                using ( this.rsConnection = new E.ReliableSqlConnection(\n                    this.scsBuilder.ToString(),\n                    this.connectionRetryPolicy,\n                    this.commandRetryPolicy )\n                        )\n                {\n                    this.rsConnection.Open();\n                    this.commandRetryPolicy.ExecuteAction(this.IssueQueryCommand_action);\n                }\n            } // method EstablishConnection\n    \n    \n            void IssueQueryCommand()\n            {\n                D.IDataReader dReader = null;\n                D.IDbCommand dbCommand = null;\n                X.StringBuilder sBuilder = new X.StringBuilder(256);\n    \n                using (dbCommand = this.rsConnection.CreateCommand())\n                {\n                    dbCommand.CommandText = this.sqlSelectCode;\n                    using (dReader = this.rsConnection.ExecuteCommand<D.IDataReader>(dbCommand))\n                    {\n                        while (dReader.Read())\n                        {\n                            sBuilder.Length = 0;\n                            sBuilder.Append(dReader.GetString(0));\n                            sBuilder.Append(\"\\t\");\n                            sBuilder.Append(dReader.GetString(1));\n                            Console.WriteLine(sBuilder.ToString());\n                        }\n                    }\n                }\n            } // method IssueQueryCommand\n    \n            void InitializeFields()\n            {\n                this.scsBuilder = new C.SqlConnectionStringBuilder();\n                // Change these values to your values.\n                this.scsBuilder[\"Server\"] = \"tcp:myazuresqldbserver.database.windows.net,1433\";\n                this.scsBuilder[\"User ID\"] = \"MyLogin\";\n                this.scsBuilder[\"Password\"] = \"MyPassword\";  // TEST.PASSWORD_FIX.\n                this.scsBuilder[\"Database\"] = \"MyDatabase\";\n                // Leave these values as they are.\n                this.scsBuilder[\"Trusted_Connection\"] = false;\n                this.scsBuilder[\"Integrated Security\"] = false;\n                this.scsBuilder[\"Encrypt\"] = true;\n                this.scsBuilder[\"Connection Timeout\"] = 30;\n    \n                this.sqlSelectCode =\n                    @\"SELECT TOP 3 name, CAST(object_id as nvarchar(32)) as [object_id]\n                      FROM sys.objects\n                      WHERE type='IT'\n                      ORDER BY name;\";\n    \n                this.exponentialBackoffStrategy = new E.ExponentialBackoff(\n                    \"exponentialBackoffStrategy\",\n                    2,\n                    TimeSpan.FromMilliseconds(2000),\n                    TimeSpan.FromMilliseconds(8000),\n                    TimeSpan.FromMilliseconds(2000)\n                    );\n    \n                this.forcePersistent_SqlCommandTransientErrorDetectionStrategy =\n                    new ForcePersistent_SqlCommandTransientErrorDetectionStrategy();\n                this.custom_SqlDatabaseTransientErrorDetectionStrategy =\n                    new Custom_SqlDatabaseTransientErrorDetectionStrategy();\n    \n                this.connectionRetryPolicy = new E.RetryPolicy(\n                    this.custom_SqlDatabaseTransientErrorDetectionStrategy,\n                    this.exponentialBackoffStrategy);\n                this.commandRetryPolicy = new E.RetryPolicy(\n                    this.forcePersistent_SqlCommandTransientErrorDetectionStrategy,\n                    this.exponentialBackoffStrategy);\n    \n                this.EstablishConnection_action = delegate() { this.EstablishConnection(); };\n                this.IssueQueryCommand_action   = delegate() { this.IssueQueryCommand(); };\n            } // method InitializeFields\n        } // class Program\n    }\n\n\n## Related links\n\n\n- [Microsoft.Practices.EnterpriseLibrary.TransientFaultHandling Namespace](http://msdn.microsoft.com/library/microsoft.practices.enterpriselibrary.transientfaulthandling.aspx)\n\n- [Enterprise Library 6 Class Library](http://msdn.microsoft.com/library/dn170426.aspx)\n\n- [Code sample: Retry logic in C# for connecting to SQL Database with ADO.NET](sql-database-develop-csharp-retry-windows.md)\n\n- [Client quick-start code samples to SQL Database](sql-database-develop-quick-start-client-code-samples.md)\n\n"
}