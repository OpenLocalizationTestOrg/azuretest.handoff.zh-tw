<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>API design guidance | Microsoft Azure</source>
          <target state="new">API design guidance | Microsoft Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Guidance upon how to create a well designed API.</source>
          <target state="new">Guidance upon how to create a well designed API.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>API design guidance</source>
          <target state="new">API design guidance</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Some topics in this guidance are under discussion and may change in the future.</source>
          <target state="new">Some topics in this guidance are under discussion and may change in the future.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>We welcome your feedback!</source>
          <target state="new">We welcome your feedback!</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="new">Overview</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Many modern web-based solutions make the use of web services, hosted by web servers, to provide functionality for remote client applications.</source>
          <target state="new">Many modern web-based solutions make the use of web services, hosted by web servers, to provide functionality for remote client applications.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The operations that a web service exposes constitute a web API.</source>
          <target state="new">The operations that a web service exposes constitute a web API.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A well-designed web API should aim to support:</source>
          <target state="new">A well-designed web API should aim to support:</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Platform independence<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Platform independence<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Client applications should be able to utilize the API that the web service provides without requiring how the data or operations that API exposes are physically implemented.</source>
          <target state="new">Client applications should be able to utilize the API that the web service provides without requiring how the data or operations that API exposes are physically implemented.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This requires that the API abides by common standards that enable a client application and web service to agree on which data formats to use, and the structure of the data that is exchanged between client applications and the web service.</source>
          <target state="new">This requires that the API abides by common standards that enable a client application and web service to agree on which data formats to use, and the structure of the data that is exchanged between client applications and the web service.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Service evolution<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Service evolution<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The web service should be able to evolve and add (or remove) functionality independently from client applications.</source>
          <target state="new">The web service should be able to evolve and add (or remove) functionality independently from client applications.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Existing client applications should be able to continue to operate unmodified as the features provided by the web service change.</source>
          <target state="new">Existing client applications should be able to continue to operate unmodified as the features provided by the web service change.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>All functionality should also be discoverable, so that client applications can fully utilize it.</source>
          <target state="new">All functionality should also be discoverable, so that client applications can fully utilize it.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The purpose of this guidance is to describe the issues that you should consider when designing a web API.</source>
          <target state="new">The purpose of this guidance is to describe the issues that you should consider when designing a web API.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Introduction to Representational State Transfer (REST)</source>
          <target state="new">Introduction to Representational State Transfer (REST)</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>In his dissertation in 2000, Roy Fielding proposed an alternative architectural approach to structuring the operations exposed by web services; REST.</source>
          <target state="new">In his dissertation in 2000, Roy Fielding proposed an alternative architectural approach to structuring the operations exposed by web services; REST.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>REST is an architectural style for building distributed systems based on hypermedia.</source>
          <target state="new">REST is an architectural style for building distributed systems based on hypermedia.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>A primary advantage of the REST model is that it is based on open standards and does not bind the implementation of the model or the client applications that access it to any specific implementation.</source>
          <target state="new">A primary advantage of the REST model is that it is based on open standards and does not bind the implementation of the model or the client applications that access it to any specific implementation.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For example, a REST web service could be implemented by using the Microsoft ASP.NET Web API, and client applications could be developed by using any language and toolset that can generate HTTP requests and parse HTTP responses.</source>
          <target state="new">For example, a REST web service could be implemented by using the Microsoft ASP.NET Web API, and client applications could be developed by using any language and toolset that can generate HTTP requests and parse HTTP responses.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>: REST is actually independent of any underlying protocol and is not necessarily tied to HTTP.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>: REST is actually independent of any underlying protocol and is not necessarily tied to HTTP.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>However, most common implementations of systems that are based on REST utilize HTTP as the application protocol for sending and receiving requests.</source>
          <target state="new">However, most common implementations of systems that are based on REST utilize HTTP as the application protocol for sending and receiving requests.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This document focusses on mapping REST principles to systems designed to operate using HTTP.</source>
          <target state="new">This document focusses on mapping REST principles to systems designed to operate using HTTP.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The REST model uses a navigational scheme to represent objects and services over a network (referred to as <bpt id="p1">_</bpt>resources<ept id="p1">_</ept>).</source>
          <target state="new">The REST model uses a navigational scheme to represent objects and services over a network (referred to as <bpt id="p1">_</bpt>resources<ept id="p1">_</ept>).</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Many systems that implement REST typically use the HTTP protocol to transmit requests to access these resources.</source>
          <target state="new">Many systems that implement REST typically use the HTTP protocol to transmit requests to access these resources.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>In these systems, a client application submits a request in the form of a URI that identifies a resource, and an HTTP method (the most common being GET, POST, PUT, or DELETE) that indicates the operation to be performed on that resource.</source>
          <target state="new">In these systems, a client application submits a request in the form of a URI that identifies a resource, and an HTTP method (the most common being GET, POST, PUT, or DELETE) that indicates the operation to be performed on that resource.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The body of the HTTP request contains the data required to perform the operation.</source>
          <target state="new">The body of the HTTP request contains the data required to perform the operation.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The important point to understand is that REST defines a stateless request model.</source>
          <target state="new">The important point to understand is that REST defines a stateless request model.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>HTTP requests should be independent and may occur in any order, so attempting to retain transient state information between requests is not feasible.</source>
          <target state="new">HTTP requests should be independent and may occur in any order, so attempting to retain transient state information between requests is not feasible.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The only place where information is stored is in the resources themselves, and each request should be an atomic operation.</source>
          <target state="new">The only place where information is stored is in the resources themselves, and each request should be an atomic operation.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Effectively, a REST model implements a finite state machine where a request transitions a resource from one well-defined non-transient state to another.</source>
          <target state="new">Effectively, a REST model implements a finite state machine where a request transitions a resource from one well-defined non-transient state to another.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> The stateless nature of individual requests in the REST model enables a system constructed by following these principles to be highly scalable.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> The stateless nature of individual requests in the REST model enables a system constructed by following these principles to be highly scalable.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>There is no need to retain any affinity between a client application making a series of requests and the specific web servers handling those requests.</source>
          <target state="new">There is no need to retain any affinity between a client application making a series of requests and the specific web servers handling those requests.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Another crucial point in implementing an effective REST model is to understand the relationships between the various resources to which the model provides access.</source>
          <target state="new">Another crucial point in implementing an effective REST model is to understand the relationships between the various resources to which the model provides access.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>These resources are typically organized as collections and relationships.</source>
          <target state="new">These resources are typically organized as collections and relationships.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>For example, suppose that a quick analysis of an ecommerce system shows that there are two collections in which client applications are likely to be interested: orders and customers.</source>
          <target state="new">For example, suppose that a quick analysis of an ecommerce system shows that there are two collections in which client applications are likely to be interested: orders and customers.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Each order and customer should have its own unique key for identification purposes.</source>
          <target state="new">Each order and customer should have its own unique key for identification purposes.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The URI to access the collection of orders could be something as simple as <bpt id="p1">_</bpt>/orders<ept id="p1">_</ept>, and similarly the URI for retrieving all customers could be <bpt id="p2">_</bpt>/customers<ept id="p2">_</ept>.</source>
          <target state="new">The URI to access the collection of orders could be something as simple as <bpt id="p1">_</bpt>/orders<ept id="p1">_</ept>, and similarly the URI for retrieving all customers could be <bpt id="p2">_</bpt>/customers<ept id="p2">_</ept>.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Issuing an HTTP GET request to the <bpt id="p1">_</bpt>/orders<ept id="p1">_</ept> URI should return a list representing all orders in the collection encoded as an HTTP response:</source>
          <target state="new">Issuing an HTTP GET request to the <bpt id="p1">_</bpt>/orders<ept id="p1">_</ept> URI should return a list representing all orders in the collection encoded as an HTTP response:</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The response shown below encodes the orders as an XML list structure.</source>
          <target state="new">The response shown below encodes the orders as an XML list structure.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The list contains 7 orders:</source>
          <target state="new">The list contains 7 orders:</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>To fetch an individual order requires specifying the identifier for the order from the <bpt id="p1">_</bpt>orders<ept id="p1">_</ept> resource, such as <bpt id="p2">_</bpt>/orders/2<ept id="p2">_</ept>:</source>
          <target state="new">To fetch an individual order requires specifying the identifier for the order from the <bpt id="p1">_</bpt>orders<ept id="p1">_</ept> resource, such as <bpt id="p2">_</bpt>/orders/2<ept id="p2">_</ept>:</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> For simplicity, these examples show the information in responses being returned as XML text data.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> For simplicity, these examples show the information in responses being returned as XML text data.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>However, there is no reason why resources should not contain any other type of data supported by HTTP, such as binary or encrypted information; the content-type in the HTTP response should specify the type.</source>
          <target state="new">However, there is no reason why resources should not contain any other type of data supported by HTTP, such as binary or encrypted information; the content-type in the HTTP response should specify the type.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Also, a REST model may be able to return the same data in different formats, such as XML or JSON.</source>
          <target state="new">Also, a REST model may be able to return the same data in different formats, such as XML or JSON.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>In this case, the web service should be able to perform content negotiation with the client making the request.</source>
          <target state="new">In this case, the web service should be able to perform content negotiation with the client making the request.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The request can include an <bpt id="p1">_</bpt>Accept<ept id="p1">_</ept> header which specifies the preferred format that the client would like to receive and the web service should attempt to honor this format if at all possible.</source>
          <target state="new">The request can include an <bpt id="p1">_</bpt>Accept<ept id="p1">_</ept> header which specifies the preferred format that the client would like to receive and the web service should attempt to honor this format if at all possible.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Notice that the response from a REST request makes use of the standard HTTP status codes.</source>
          <target state="new">Notice that the response from a REST request makes use of the standard HTTP status codes.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For example, a request that returns valid data should include the HTTP response code 200 (OK), while a request that fails to find or delete a specified resource should return a response that includes the HTTP status code 404 (Not Found).</source>
          <target state="new">For example, a request that returns valid data should include the HTTP response code 200 (OK), while a request that fails to find or delete a specified resource should return a response that includes the HTTP status code 404 (Not Found).</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Design and structure of a RESTful web API</source>
          <target state="new">Design and structure of a RESTful web API</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The keys to designing a successful web API are simplicity and consistency.</source>
          <target state="new">The keys to designing a successful web API are simplicity and consistency.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>A Web API that exhibits these two factors makes it easier to build client applications that need to consume the API.</source>
          <target state="new">A Web API that exhibits these two factors makes it easier to build client applications that need to consume the API.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>A RESTful web API is focused on exposing a set of connected resources, and providing the core operations that enable an application to manipulate these resources and easily navigate between them.</source>
          <target state="new">A RESTful web API is focused on exposing a set of connected resources, and providing the core operations that enable an application to manipulate these resources and easily navigate between them.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>For this reason, the URIs that constitute a typical RESTful web API should be oriented towards the data that it exposes, and use the facilities provided by HTTP to operate on this data.</source>
          <target state="new">For this reason, the URIs that constitute a typical RESTful web API should be oriented towards the data that it exposes, and use the facilities provided by HTTP to operate on this data.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>This approach requires a different mindset from that typically employed when designing a set of classes in an object-oriented API which tends to be more motivated by the behavior of objects and classes.</source>
          <target state="new">This approach requires a different mindset from that typically employed when designing a set of classes in an object-oriented API which tends to be more motivated by the behavior of objects and classes.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Additionally, a RESTful web API should be stateless and not depend on operations being invoked in a particular sequence.</source>
          <target state="new">Additionally, a RESTful web API should be stateless and not depend on operations being invoked in a particular sequence.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The following sections summarize the points you should consider when designing a RESTful web API.</source>
          <target state="new">The following sections summarize the points you should consider when designing a RESTful web API.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Organizing the web API around resources</source>
          <target state="new">Organizing the web API around resources</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.TIP]</ph> The URIs exposed by a REST web service should be based on nouns (the data to which the web API provides access) and not verbs (what an application can do with the data).</source>
          <target state="new"><ph id="ph1">[AZURE.TIP]</ph> The URIs exposed by a REST web service should be based on nouns (the data to which the web API provides access) and not verbs (what an application can do with the data).</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Focus on the business entities that the web API exposes.</source>
          <target state="new">Focus on the business entities that the web API exposes.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>For example, in a web API designed to support the ecommerce system described earlier, the primary entities are customers and orders.</source>
          <target state="new">For example, in a web API designed to support the ecommerce system described earlier, the primary entities are customers and orders.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Processes such as the act of placing an order can be achieved by providing an HTTP POST operation that takes the order information and adds it to the list of orders for the customer.</source>
          <target state="new">Processes such as the act of placing an order can be achieved by providing an HTTP POST operation that takes the order information and adds it to the list of orders for the customer.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Internally, this POST operation can perform tasks such as checking stock levels, and billing the customer.</source>
          <target state="new">Internally, this POST operation can perform tasks such as checking stock levels, and billing the customer.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The HTTP response can indicate whether the order was placed successfully or not.</source>
          <target state="new">The HTTP response can indicate whether the order was placed successfully or not.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Also note that a resource does not have to be based on a single physical data item.</source>
          <target state="new">Also note that a resource does not have to be based on a single physical data item.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>As an example, an order resource might be implemented internally by using information aggregated from many rows spread across several tables in a relational database but presented to the client as a single entity.</source>
          <target state="new">As an example, an order resource might be implemented internally by using information aggregated from many rows spread across several tables in a relational database but presented to the client as a single entity.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.TIP]</ph> Avoid designing a REST interface that mirrors or depends on the internal structure of the data that it exposes.</source>
          <target state="new"><ph id="ph1">[AZURE.TIP]</ph> Avoid designing a REST interface that mirrors or depends on the internal structure of the data that it exposes.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>REST is about more than implementing simple CRUD (Create, Retrieve, Update, Delete) operations over separate tables in a relational database.</source>
          <target state="new">REST is about more than implementing simple CRUD (Create, Retrieve, Update, Delete) operations over separate tables in a relational database.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The purpose of REST is to map business entities and the operations that an application can perform on these entities to the physical implementation of these entities, but a client should not be exposed to these physical details.</source>
          <target state="new">The purpose of REST is to map business entities and the operations that an application can perform on these entities to the physical implementation of these entities, but a client should not be exposed to these physical details.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Individual business entities rarely exist in isolation (although some singleton objects may exist), but instead tend to be grouped together into collections.</source>
          <target state="new">Individual business entities rarely exist in isolation (although some singleton objects may exist), but instead tend to be grouped together into collections.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>In REST terms, each entity and each collection are resources.</source>
          <target state="new">In REST terms, each entity and each collection are resources.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>In a RESTful web API, each collection has its own URI within the web service, and performing an HTTP GET request over a URI for a collection retrieves a list of items in that collection.</source>
          <target state="new">In a RESTful web API, each collection has its own URI within the web service, and performing an HTTP GET request over a URI for a collection retrieves a list of items in that collection.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Each individual item also has its own URI, and an application can submit another HTTP GET request using that URI to retrieve the details of that item.</source>
          <target state="new">Each individual item also has its own URI, and an application can submit another HTTP GET request using that URI to retrieve the details of that item.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>You should organize the URIs for collections and items in a hierarchical manner.</source>
          <target state="new">You should organize the URIs for collections and items in a hierarchical manner.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>In the ecommerce system, the URI <bpt id="p1">_</bpt>/customers<ept id="p1">_</ept> denotes the customer’s collection, and <bpt id="p2">_</bpt>/customers/5<ept id="p2">_</ept> retrieves the details for the single customer with the ID 5 from this collection.</source>
          <target state="new">In the ecommerce system, the URI <bpt id="p1">_</bpt>/customers<ept id="p1">_</ept> denotes the customer’s collection, and <bpt id="p2">_</bpt>/customers/5<ept id="p2">_</ept> retrieves the details for the single customer with the ID 5 from this collection.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>This approach helps to keep the web API intuitive.</source>
          <target state="new">This approach helps to keep the web API intuitive.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.TIP]</ph> Adopt a consistent naming convention in URIs; in general it helps to use plural nouns for URIs that reference collections.</source>
          <target state="new"><ph id="ph1">[AZURE.TIP]</ph> Adopt a consistent naming convention in URIs; in general it helps to use plural nouns for URIs that reference collections.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>You also need to consider the relationships between different types of resources and how you might expose these associations.</source>
          <target state="new">You also need to consider the relationships between different types of resources and how you might expose these associations.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>For example, customers may place zero or more orders.</source>
          <target state="new">For example, customers may place zero or more orders.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>A natural way to represent this relationship would be through a URI such as <bpt id="p1">_</bpt>/customers/5/orders<ept id="p1">_</ept> to find all the orders for customer 5.</source>
          <target state="new">A natural way to represent this relationship would be through a URI such as <bpt id="p1">_</bpt>/customers/5/orders<ept id="p1">_</ept> to find all the orders for customer 5.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>You might also consider representing the association from an order back to a specific customer through a URI such as <bpt id="p1">_</bpt>/orders/99/customer<ept id="p1">_</ept> to find the customer for order 99, but extending this model too far can become cumbersome to implement.</source>
          <target state="new">You might also consider representing the association from an order back to a specific customer through a URI such as <bpt id="p1">_</bpt>/orders/99/customer<ept id="p1">_</ept> to find the customer for order 99, but extending this model too far can become cumbersome to implement.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>A better solution is to provide navigable links to associated resources, such as the customer, in the body of the HTTP response message returned when the order is queried.</source>
          <target state="new">A better solution is to provide navigable links to associated resources, such as the customer, in the body of the HTTP response message returned when the order is queried.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>This mechanism is described in more detail in the section Using the HATEOAS Approach to Enable Navigation To Related Resources later in this guidance.</source>
          <target state="new">This mechanism is described in more detail in the section Using the HATEOAS Approach to Enable Navigation To Related Resources later in this guidance.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>In more complex systems there may be many more types of entity, and it can be tempting to provide URIs that enable a client application to navigate through several levels of relationships, such as <bpt id="p1">_</bpt>/customers/1/orders/99/products<ept id="p1">_</ept> to obtain the list of products in order 99 placed by customer 1.</source>
          <target state="new">In more complex systems there may be many more types of entity, and it can be tempting to provide URIs that enable a client application to navigate through several levels of relationships, such as <bpt id="p1">_</bpt>/customers/1/orders/99/products<ept id="p1">_</ept> to obtain the list of products in order 99 placed by customer 1.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>However, this level of complexity can be difficult to maintain and is inflexible if the relationships between resources change in the future.</source>
          <target state="new">However, this level of complexity can be difficult to maintain and is inflexible if the relationships between resources change in the future.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Rather, you should seek to keep URIs relatively simple.</source>
          <target state="new">Rather, you should seek to keep URIs relatively simple.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Bear in mind that once an application has a reference to a resource, it should be possible to use this reference to find items related to that resource.</source>
          <target state="new">Bear in mind that once an application has a reference to a resource, it should be possible to use this reference to find items related to that resource.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The preceding query can be replaced with the URI <bpt id="p1">_</bpt>/customers/1/orders<ept id="p1">_</ept> to find all the orders for customer 1, and then query the URI <bpt id="p2">_</bpt>/orders/99/products<ept id="p2">_</ept> to find the products in this order (assuming order 99 was placed by customer 1).</source>
          <target state="new">The preceding query can be replaced with the URI <bpt id="p1">_</bpt>/customers/1/orders<ept id="p1">_</ept> to find all the orders for customer 1, and then query the URI <bpt id="p2">_</bpt>/orders/99/products<ept id="p2">_</ept> to find the products in this order (assuming order 99 was placed by customer 1).</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.TIP]</ph> Avoid requiring resource URIs more complex than <bpt id="p1">_</bpt>collection/item/collection<ept id="p1">_</ept>.</source>
          <target state="new"><ph id="ph1">[AZURE.TIP]</ph> Avoid requiring resource URIs more complex than <bpt id="p1">_</bpt>collection/item/collection<ept id="p1">_</ept>.</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Another point to consider is that all web requests impose a load on the web server, and the greater the number of requests the bigger the load.</source>
          <target state="new">Another point to consider is that all web requests impose a load on the web server, and the greater the number of requests the bigger the load.</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>You should attempt to define your resources to avoid “chatty” web APIs that expose a large number of small resources.</source>
          <target state="new">You should attempt to define your resources to avoid “chatty” web APIs that expose a large number of small resources.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Such an API may require a client application to submit multiple requests to find all the data that it requires.</source>
          <target state="new">Such an API may require a client application to submit multiple requests to find all the data that it requires.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>It may be beneficial to denormalize data and combine related information together into bigger resources that can be retrieved by issuing a single request.</source>
          <target state="new">It may be beneficial to denormalize data and combine related information together into bigger resources that can be retrieved by issuing a single request.</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>However, you need to balance this approach against the overhead of fetching data that might not be frequently required by the client.</source>
          <target state="new">However, you need to balance this approach against the overhead of fetching data that might not be frequently required by the client.</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Retrieving large objects can increase the latency of a request and incur additional bandwidth costs for little advantage if the additional data is not often used.</source>
          <target state="new">Retrieving large objects can increase the latency of a request and incur additional bandwidth costs for little advantage if the additional data is not often used.</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Avoid introducing dependencies between the web API to the structure, type, or location of the underlying data sources.</source>
          <target state="new">Avoid introducing dependencies between the web API to the structure, type, or location of the underlying data sources.</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>For example, if your data is located in a relational database, the web API does not need to expose each table as a collection of resources.</source>
          <target state="new">For example, if your data is located in a relational database, the web API does not need to expose each table as a collection of resources.</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Think of the web API as an abstraction of the database, and if necessary introduce a mapping layer between the database and the web API.</source>
          <target state="new">Think of the web API as an abstraction of the database, and if necessary introduce a mapping layer between the database and the web API.</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>In this way, if the design or implementation of the database changes (for example, you move from a relational database containing a collection of normalized tables to a denormalized NoSQL storage system such as a document database) client applications are insulated from these changes.</source>
          <target state="new">In this way, if the design or implementation of the database changes (for example, you move from a relational database containing a collection of normalized tables to a denormalized NoSQL storage system such as a document database) client applications are insulated from these changes.</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.TIP]</ph> The source of the data that underpins a web API does not have to be a data store; it could be another service or line-of-business application or even a legacy application running on-premises within an organization.</source>
          <target state="new"><ph id="ph1">[AZURE.TIP]</ph> The source of the data that underpins a web API does not have to be a data store; it could be another service or line-of-business application or even a legacy application running on-premises within an organization.</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Finally, it might not be possible to map every operation implemented by a web API to a specific resource.</source>
          <target state="new">Finally, it might not be possible to map every operation implemented by a web API to a specific resource.</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>You can handle such <bpt id="p1">_</bpt>non-resource<ept id="p1">_</ept> scenarios through HTTP GET requests that invoke a piece of functionality and return the results as an HTTP response message.</source>
          <target state="new">You can handle such <bpt id="p1">_</bpt>non-resource<ept id="p1">_</ept> scenarios through HTTP GET requests that invoke a piece of functionality and return the results as an HTTP response message.</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>A web API that implements simple calculator-style operations such as add and subtract could provide URIs that expose these operations as pseudo resources and utilize the query string to specify the parameters required.</source>
          <target state="new">A web API that implements simple calculator-style operations such as add and subtract could provide URIs that expose these operations as pseudo resources and utilize the query string to specify the parameters required.</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>For example a GET request to the URI <bpt id="p1">_</bpt>/add?operand1=99&amp;operand2=1<ept id="p1">_</ept> could return a response message with the body containing the value 100, and GET request to the URI <bpt id="p2">_</bpt>/subtract?operand1=50&amp;operand2=20<ept id="p2">_</ept> could return a response message with the body containing the value 30.</source>
          <target state="new">For example a GET request to the URI <bpt id="p1">_</bpt>/add?operand1=99&amp;operand2=1<ept id="p1">_</ept> could return a response message with the body containing the value 100, and GET request to the URI <bpt id="p2">_</bpt>/subtract?operand1=50&amp;operand2=20<ept id="p2">_</ept> could return a response message with the body containing the value 30.</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>However, only use these forms of URIs sparingly.</source>
          <target state="new">However, only use these forms of URIs sparingly.</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Defining operations in terms of HTTP methods</source>
          <target state="new">Defining operations in terms of HTTP methods</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The HTTP protocol defines a number of methods that assign semantic meaning to a request.</source>
          <target state="new">The HTTP protocol defines a number of methods that assign semantic meaning to a request.</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The common HTTP methods used by most RESTful web APIs are:</source>
          <target state="new">The common HTTP methods used by most RESTful web APIs are:</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>GET<ept id="p1">**</ept>, to retrieve a copy of the resource at the specified URI.</source>
          <target state="new"><bpt id="p1">**</bpt>GET<ept id="p1">**</ept>, to retrieve a copy of the resource at the specified URI.</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The body of the response message contains the details of the requested resource.</source>
          <target state="new">The body of the response message contains the details of the requested resource.</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>POST<ept id="p1">**</ept>, to create a new resource at the specified URI.</source>
          <target state="new"><bpt id="p1">**</bpt>POST<ept id="p1">**</ept>, to create a new resource at the specified URI.</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The body of the request message provides the details of the new resource.</source>
          <target state="new">The body of the request message provides the details of the new resource.</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Note that POST can also be used to trigger operations that don't actually create resources.</source>
          <target state="new">Note that POST can also be used to trigger operations that don't actually create resources.</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>PUT<ept id="p1">**</ept>, to replace or update the resource at the specified URI.</source>
          <target state="new"><bpt id="p1">**</bpt>PUT<ept id="p1">**</ept>, to replace or update the resource at the specified URI.</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The body of the request message specifies the resource to be modified and the values to be applied.</source>
          <target state="new">The body of the request message specifies the resource to be modified and the values to be applied.</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>DELETE<ept id="p1">**</ept>, to remove the resource at the specified URI.</source>
          <target state="new"><bpt id="p1">**</bpt>DELETE<ept id="p1">**</ept>, to remove the resource at the specified URI.</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> The HTTP protocol also defines other less commonly-used methods, such as PATCH which is used to request selective updates to a resource, HEAD which is used to request a description of a resource, OPTIONS which enables a client information to obtain information about the communication options supported by the server, and TRACE which allows a client to request information that it can use for testing and diagnostics purposes.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> The HTTP protocol also defines other less commonly-used methods, such as PATCH which is used to request selective updates to a resource, HEAD which is used to request a description of a resource, OPTIONS which enables a client information to obtain information about the communication options supported by the server, and TRACE which allows a client to request information that it can use for testing and diagnostics purposes.</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The effect of a specific request should depend on whether the resource to which it is applied is a collection or an individual item.</source>
          <target state="new">The effect of a specific request should depend on whether the resource to which it is applied is a collection or an individual item.</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The following table summarizes the common conventions adopted by most RESTful implementations using the ecommerce example.</source>
          <target state="new">The following table summarizes the common conventions adopted by most RESTful implementations using the ecommerce example.</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Note that not all of these requests might be implemented; it depends on the specific scenario.</source>
          <target state="new">Note that not all of these requests might be implemented; it depends on the specific scenario.</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Resource</source>
          <target state="new">Resource</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>POST</source>
          <target state="new">POST</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>GET</source>
          <target state="new">GET</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>PUT</source>
          <target state="new">PUT</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>DELETE</source>
          <target state="new">DELETE</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>/customers</source>
          <target state="new">/customers</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Create a new customer</source>
          <target state="new">Create a new customer</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Retrieve all customers</source>
          <target state="new">Retrieve all customers</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Bulk update of customers (<bpt id="p1">_</bpt>if implemented<ept id="p1">_</ept>)</source>
          <target state="new">Bulk update of customers (<bpt id="p1">_</bpt>if implemented<ept id="p1">_</ept>)</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Remove all customers</source>
          <target state="new">Remove all customers</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>/customers/1</source>
          <target state="new">/customers/1</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Error</source>
          <target state="new">Error</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Retrieve the details for customer 1</source>
          <target state="new">Retrieve the details for customer 1</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Update the details of customer 1 if it exists, otherwise return an error</source>
          <target state="new">Update the details of customer 1 if it exists, otherwise return an error</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Remove customer 1</source>
          <target state="new">Remove customer 1</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>/customers/1/orders</source>
          <target state="new">/customers/1/orders</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Create a new order for customer 1</source>
          <target state="new">Create a new order for customer 1</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Retrieve all orders for customer 1</source>
          <target state="new">Retrieve all orders for customer 1</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Bulk update of orders for customer 1 (<bpt id="p1">_</bpt>if implemented<ept id="p1">_</ept>)</source>
          <target state="new">Bulk update of orders for customer 1 (<bpt id="p1">_</bpt>if implemented<ept id="p1">_</ept>)</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Remove all orders for customer 1(<bpt id="p1">_</bpt>if implemented<ept id="p1">_</ept>)</source>
          <target state="new">Remove all orders for customer 1(<bpt id="p1">_</bpt>if implemented<ept id="p1">_</ept>)</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The purpose of GET and DELETE requests are relatively straightforward, but there is scope for confusion concerning the purpose and effects of POST and PUT requests.</source>
          <target state="new">The purpose of GET and DELETE requests are relatively straightforward, but there is scope for confusion concerning the purpose and effects of POST and PUT requests.</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>A POST request should create a new resource with data provided in the body of the request.</source>
          <target state="new">A POST request should create a new resource with data provided in the body of the request.</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>In the REST model, you frequently apply POST requests to resources that are collections; the new resource is added to the collection.</source>
          <target state="new">In the REST model, you frequently apply POST requests to resources that are collections; the new resource is added to the collection.</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> You can also define POST requests that trigger some functionality (and that don't necessarily return data), and these types of request can be applied to collections.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> You can also define POST requests that trigger some functionality (and that don't necessarily return data), and these types of request can be applied to collections.</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>For example you could use a POST request to pass a timesheet to a payroll processing service and get the calculated taxes back as a response.</source>
          <target state="new">For example you could use a POST request to pass a timesheet to a payroll processing service and get the calculated taxes back as a response.</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>A PUT request is intended to modify an existing resource.</source>
          <target state="new">A PUT request is intended to modify an existing resource.</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>If the specified resource does not exist, the PUT request could return an error (in some cases, it might actually create the resource).</source>
          <target state="new">If the specified resource does not exist, the PUT request could return an error (in some cases, it might actually create the resource).</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>PUT requests are most frequently applied to resources that are individual items (such as a specific customer or order), although they can be applied to collections, although this is less-commonly implemented.</source>
          <target state="new">PUT requests are most frequently applied to resources that are individual items (such as a specific customer or order), although they can be applied to collections, although this is less-commonly implemented.</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Note that PUT requests are idempotent whereas POST requests are not; if an application submits the same PUT request multiple times the results should always be the same (the same resource will be modified with the same values), but if an application repeats the same POST request the result will be the creation of multiple resources.</source>
          <target state="new">Note that PUT requests are idempotent whereas POST requests are not; if an application submits the same PUT request multiple times the results should always be the same (the same resource will be modified with the same values), but if an application repeats the same POST request the result will be the creation of multiple resources.</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Strictly speaking, an HTTP PUT request replaces an existing resource with the resource specified in the body of the request.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Strictly speaking, an HTTP PUT request replaces an existing resource with the resource specified in the body of the request.</target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>If the intention is to modify a selection of properties in a resource but leave other properties unchanged, then this should be implemented by using an HTTP PATCH request.</source>
          <target state="new">If the intention is to modify a selection of properties in a resource but leave other properties unchanged, then this should be implemented by using an HTTP PATCH request.</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>However, many RESTful implementations relax this rule and use PUT for both situations.</source>
          <target state="new">However, many RESTful implementations relax this rule and use PUT for both situations.</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Processing HTTP requests</source>
          <target state="new">Processing HTTP requests</target>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The data included by a client application in many HTTP requests, and the corresponding response messages from the web server, could be presented in a variety of formats (or media types).</source>
          <target state="new">The data included by a client application in many HTTP requests, and the corresponding response messages from the web server, could be presented in a variety of formats (or media types).</target>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>For example, the data that specifies the details for a customer or order could be provided as XML, JSON, or some other encoded and compressed format.</source>
          <target state="new">For example, the data that specifies the details for a customer or order could be provided as XML, JSON, or some other encoded and compressed format.</target>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>A RESTful web API should support different media types as requested by the client application that submits a request.</source>
          <target state="new">A RESTful web API should support different media types as requested by the client application that submits a request.</target>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>When a client application sends a request that returns data in the body of a message, it can specify the media types it can handle in the Accept header of the request.</source>
          <target state="new">When a client application sends a request that returns data in the body of a message, it can specify the media types it can handle in the Accept header of the request.</target>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>The following code illustrates an HTTP GET request that retrieves the details of customer 1 and requests the result to be returned as JSON (the client should still examine the media type of the data in the response to verify the format of the data returned):</source>
          <target state="new">The following code illustrates an HTTP GET request that retrieves the details of customer 1 and requests the result to be returned as JSON (the client should still examine the media type of the data in the response to verify the format of the data returned):</target>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>If the web server supports this media type, it can reply with a response that includes Content-Type header that specifies the format of the data in the body of the message:</source>
          <target state="new">If the web server supports this media type, it can reply with a response that includes Content-Type header that specifies the format of the data in the body of the message:</target>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> For maximum interoperability, the media types referenced in the Accept and Content-Type headers should be recognized MIME types rather than some custom media type.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> For maximum interoperability, the media types referenced in the Accept and Content-Type headers should be recognized MIME types rather than some custom media type.</target>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>If the web server does not support the requested media type, it can send the data in a different format.</source>
          <target state="new">If the web server does not support the requested media type, it can send the data in a different format.</target>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>IN all cases it must specify the media type (such as <bpt id="p1">_</bpt>text/xml<ept id="p1">_</ept>) in the Content-Type header.</source>
          <target state="new">IN all cases it must specify the media type (such as <bpt id="p1">_</bpt>text/xml<ept id="p1">_</ept>) in the Content-Type header.</target>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the client application to parse the response message and interpret the results in the message body appropriately.</source>
          <target state="new">It is the responsibility of the client application to parse the response message and interpret the results in the message body appropriately.</target>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Note that in this example, the web server successfully retrieves the requested data and indicates success by passing back a status code of 200 in the response header.</source>
          <target state="new">Note that in this example, the web server successfully retrieves the requested data and indicates success by passing back a status code of 200 in the response header.</target>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>If no matching data is found, it should instead return a status code of 404 (not found) and the body of the response message can contain additional information.</source>
          <target state="new">If no matching data is found, it should instead return a status code of 404 (not found) and the body of the response message can contain additional information.</target>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The format of this information is specified by the Content-Type header, as shown in the following example:</source>
          <target state="new">The format of this information is specified by the Content-Type header, as shown in the following example:</target>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Order 222 does not exist, so the response message looks like this:</source>
          <target state="new">Order 222 does not exist, so the response message looks like this:</target>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>When an application sends an HTTP PUT request to update a resource, it specifies the URI of the resource and provides the data to be modified in the body of the request message.</source>
          <target state="new">When an application sends an HTTP PUT request to update a resource, it specifies the URI of the resource and provides the data to be modified in the body of the request message.</target>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>It should also specify the format of this data by using the Content-Type header.</source>
          <target state="new">It should also specify the format of this data by using the Content-Type header.</target>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>A common format used for text-based information is <bpt id="p1">_</bpt>application/x-www-form-urlencoded<ept id="p1">_</ept>, which comprises a set of name/value pairs separated by the &amp; character.</source>
          <target state="new">A common format used for text-based information is <bpt id="p1">_</bpt>application/x-www-form-urlencoded<ept id="p1">_</ept>, which comprises a set of name/value pairs separated by the &amp; character.</target>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The next example shows an HTTP PUT request that modifies the information in order 1:</source>
          <target state="new">The next example shows an HTTP PUT request that modifies the information in order 1:</target>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>If the modification is successful, it should ideally respond with an HTTP 204 status code, indicating that the process has been successfully handled, but that the response body contains no further information.</source>
          <target state="new">If the modification is successful, it should ideally respond with an HTTP 204 status code, indicating that the process has been successfully handled, but that the response body contains no further information.</target>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>The Location header in the response contains the URI of the newly updated resource:</source>
          <target state="new">The Location header in the response contains the URI of the newly updated resource:</target>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.TIP]</ph> If the data in an HTTP PUT request message includes date and time information, make sure that your web service accepts dates and times formatted following the ISO 8601 standard.</source>
          <target state="new"><ph id="ph1">[AZURE.TIP]</ph> If the data in an HTTP PUT request message includes date and time information, make sure that your web service accepts dates and times formatted following the ISO 8601 standard.</target>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>If the resource to be updated does not exist, the web server can respond with a Not Found response as described earlier.</source>
          <target state="new">If the resource to be updated does not exist, the web server can respond with a Not Found response as described earlier.</target>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Alternatively, if the server actually creates the object itself it could return the status codes HTTP 200 (OK) or HTTP 201 (Created) and the response body could contain the data for the new resource.</source>
          <target state="new">Alternatively, if the server actually creates the object itself it could return the status codes HTTP 200 (OK) or HTTP 201 (Created) and the response body could contain the data for the new resource.</target>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>If the Content-Type header of the request specifies a data format that the web server cannot handle, it should respond with HTTP status code 415 (Unsupported Media Type).</source>
          <target state="new">If the Content-Type header of the request specifies a data format that the web server cannot handle, it should respond with HTTP status code 415 (Unsupported Media Type).</target>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.TIP]</ph> Consider implementing bulk HTTP PUT operations that can batch updates to multiple resources in a collection.</source>
          <target state="new"><ph id="ph1">[AZURE.TIP]</ph> Consider implementing bulk HTTP PUT operations that can batch updates to multiple resources in a collection.</target>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The PUT request should specify the URI of the collection, and the request body should specify the details of the resources to be modified.</source>
          <target state="new">The PUT request should specify the URI of the collection, and the request body should specify the details of the resources to be modified.</target>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>This approach can help to reduce chattiness and improve performance.</source>
          <target state="new">This approach can help to reduce chattiness and improve performance.</target>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The format of an HTTP POST requests that create new resources are similar to those of PUT requests; the message body contains the details of the new resource to be added.</source>
          <target state="new">The format of an HTTP POST requests that create new resources are similar to those of PUT requests; the message body contains the details of the new resource to be added.</target>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>However, the URI typically specifies the collection to which the resource should be added.</source>
          <target state="new">However, the URI typically specifies the collection to which the resource should be added.</target>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>The following example creates a new order and adds it to the orders collection:</source>
          <target state="new">The following example creates a new order and adds it to the orders collection:</target>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>If the request is successful, the web server should respond with a message code with HTTP status code 201 (Created).</source>
          <target state="new">If the request is successful, the web server should respond with a message code with HTTP status code 201 (Created).</target>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The Location header should contain the URI of the newly created resource, and the body of the response should contain a copy of the new resource; the Content-Type header specifies the format of this data:</source>
          <target state="new">The Location header should contain the URI of the newly created resource, and the body of the response should contain a copy of the new resource; the Content-Type header specifies the format of this data:</target>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.TIP]</ph> If the data provided by a PUT or POST request is invalid, the web server should respond with a message with HTTP status code 400 (Bad Request).</source>
          <target state="new"><ph id="ph1">[AZURE.TIP]</ph> If the data provided by a PUT or POST request is invalid, the web server should respond with a message with HTTP status code 400 (Bad Request).</target>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>The body of this message can contain additional information about the problem with the request and the formats expected, or it can contain a link to a URL that provides more details.</source>
          <target state="new">The body of this message can contain additional information about the problem with the request and the formats expected, or it can contain a link to a URL that provides more details.</target>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>To remove a resource, an HTTP DELETE request simply provides the URI of the resource to be deleted.</source>
          <target state="new">To remove a resource, an HTTP DELETE request simply provides the URI of the resource to be deleted.</target>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>The following example attempts to remove order 99:</source>
          <target state="new">The following example attempts to remove order 99:</target>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>If the delete operation is successful, the web server should respond with HTTP status code 204, indicating that the process has been successfully handled, but that the response body contains no further information (this is the same response returned by a successful PUT operation, but without a Location header as the resource no longer exists.) It is also possible for a DELETE request to return HTTP status code 200 (OK) or 202 (Accepted) if the deletion is performed asynchronously.</source>
          <target state="new">If the delete operation is successful, the web server should respond with HTTP status code 204, indicating that the process has been successfully handled, but that the response body contains no further information (this is the same response returned by a successful PUT operation, but without a Location header as the resource no longer exists.) It is also possible for a DELETE request to return HTTP status code 200 (OK) or 202 (Accepted) if the deletion is performed asynchronously.</target>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>If the resource is not found, the web server should return a 404 (Not Found) message instead.</source>
          <target state="new">If the resource is not found, the web server should return a 404 (Not Found) message instead.</target>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.TIP]</ph> If all the resources in a collection need to be deleted, enable an HTTP DELETE request to be specified for the URI of the collection rather than forcing an application to remove each resource in turn from the collection.</source>
          <target state="new"><ph id="ph1">[AZURE.TIP]</ph> If all the resources in a collection need to be deleted, enable an HTTP DELETE request to be specified for the URI of the collection rather than forcing an application to remove each resource in turn from the collection.</target>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Filtering and paginating data</source>
          <target state="new">Filtering and paginating data</target>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>You should endeavour to keep the URIs simple and intuitive.</source>
          <target state="new">You should endeavour to keep the URIs simple and intuitive.</target>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Exposing a collection of resources through a single URI assists in this respect, but it can lead to applications fetching large amounts of data when only a subset of the information is required.</source>
          <target state="new">Exposing a collection of resources through a single URI assists in this respect, but it can lead to applications fetching large amounts of data when only a subset of the information is required.</target>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Generating a large volume of traffic impacts not only the performance and scalability of the web server but also adversely affect the responsiveness of client applications requesting the data.</source>
          <target state="new">Generating a large volume of traffic impacts not only the performance and scalability of the web server but also adversely affect the responsiveness of client applications requesting the data.</target>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>For example, if orders contain the price paid for the order, a client application that needs to retrieve all orders that have a cost over a specific value might need to retrieve all orders from the <bpt id="p1">_</bpt>/orders<ept id="p1">_</ept> URI and then filter these orders locally.</source>
          <target state="new">For example, if orders contain the price paid for the order, a client application that needs to retrieve all orders that have a cost over a specific value might need to retrieve all orders from the <bpt id="p1">_</bpt>/orders<ept id="p1">_</ept> URI and then filter these orders locally.</target>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Clearly this process is highly inefficient; it wastes network bandwidth and processing power on the server hosting the web API.</source>
          <target state="new">Clearly this process is highly inefficient; it wastes network bandwidth and processing power on the server hosting the web API.</target>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>One solution may be to provide a URI scheme such as <bpt id="p1">_</bpt>/orders/ordervalue_greater_than_n<ept id="p1">_</ept> where <bpt id="p2">_</bpt>n<ept id="p2">_</ept> is the order price, but for all but a limited number of prices such an approach is impractical.</source>
          <target state="new">One solution may be to provide a URI scheme such as <bpt id="p1">_</bpt>/orders/ordervalue_greater_than_n<ept id="p1">_</ept> where <bpt id="p2">_</bpt>n<ept id="p2">_</ept> is the order price, but for all but a limited number of prices such an approach is impractical.</target>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Additionally, if you need to query orders based on other criteria, you can end up being faced with providing with a long list of URIs with possibly non-intuitive names.</source>
          <target state="new">Additionally, if you need to query orders based on other criteria, you can end up being faced with providing with a long list of URIs with possibly non-intuitive names.</target>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>A better strategy to filtering data is to provide the filter criteria in the query string that is passed to the web API, such as <bpt id="p1">_</bpt>/orders?ordervaluethreshold=n<ept id="p1">_</ept>.</source>
          <target state="new">A better strategy to filtering data is to provide the filter criteria in the query string that is passed to the web API, such as <bpt id="p1">_</bpt>/orders?ordervaluethreshold=n<ept id="p1">_</ept>.</target>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>In this example, the corresponding operation in the web API is responsible for parsing and handling the <ph id="ph1">`ordervaluethreshold`</ph> parameter in the query string and returning the filtered results in the HTTP response.</source>
          <target state="new">In this example, the corresponding operation in the web API is responsible for parsing and handling the <ph id="ph1">`ordervaluethreshold`</ph> parameter in the query string and returning the filtered results in the HTTP response.</target>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Some simple HTTP GET requests over collection resources could potentially return a large number of items.</source>
          <target state="new">Some simple HTTP GET requests over collection resources could potentially return a large number of items.</target>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>To combat the possibility of this occurring you should design the web API to limit the amount of data returned by any single request.</source>
          <target state="new">To combat the possibility of this occurring you should design the web API to limit the amount of data returned by any single request.</target>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>You can achieve this by supporting query strings that enable the user to specify the maximum number of items to be retrieved (which could itself be subject to an upperbound limit to help prevent Denial of Service attacks), and a starting offset into the collection.</source>
          <target state="new">You can achieve this by supporting query strings that enable the user to specify the maximum number of items to be retrieved (which could itself be subject to an upperbound limit to help prevent Denial of Service attacks), and a starting offset into the collection.</target>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>For example, the query string in the URI <bpt id="p1">_</bpt>/orders?limit=25&amp;offset=50<ept id="p1">_</ept> should retrieve 25 orders starting with the 50th order found in the orders collection.</source>
          <target state="new">For example, the query string in the URI <bpt id="p1">_</bpt>/orders?limit=25&amp;offset=50<ept id="p1">_</ept> should retrieve 25 orders starting with the 50th order found in the orders collection.</target>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>As with filtering data, the operation that implements the GET request in the web API is responsible for parsing and handling the <ph id="ph1">`limit`</ph> and <ph id="ph2">`offset`</ph> parameters in the query string.</source>
          <target state="new">As with filtering data, the operation that implements the GET request in the web API is responsible for parsing and handling the <ph id="ph1">`limit`</ph> and <ph id="ph2">`offset`</ph> parameters in the query string.</target>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>To assist client applications, GET requests that return paginated data should also include some form of metadata that indicate the total number of resources available in the collection.</source>
          <target state="new">To assist client applications, GET requests that return paginated data should also include some form of metadata that indicate the total number of resources available in the collection.</target>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>You might also consider other intelligent paging strategies; for more information, see <bpt id="p1">[</bpt>API Design Notes: Smart Paging<ept id="p1">](http://bizcoder.com/api-design-notes-smart-paging)</ept></source>
          <target state="new">You might also consider other intelligent paging strategies; for more information, see <bpt id="p1">[</bpt>API Design Notes: Smart Paging<ept id="p1">](http://bizcoder.com/api-design-notes-smart-paging)</ept></target>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>You can follow a similar strategy for sorting data as it is fetched; you could provide a sort parameter that takes a field name as the value, such as <bpt id="p1">_</bpt>/orders?sort=ProductID<ept id="p1">_</ept>.</source>
          <target state="new">You can follow a similar strategy for sorting data as it is fetched; you could provide a sort parameter that takes a field name as the value, such as <bpt id="p1">_</bpt>/orders?sort=ProductID<ept id="p1">_</ept>.</target>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>However, note that this approach can have a deleterious effect on caching (query string parameters form part of the resource identifier used by many cache implementations as the key to cached data).</source>
          <target state="new">However, note that this approach can have a deleterious effect on caching (query string parameters form part of the resource identifier used by many cache implementations as the key to cached data).</target>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>You can extend this approach to limit (project) the fields returned if a single resource item contains a large amount of data.</source>
          <target state="new">You can extend this approach to limit (project) the fields returned if a single resource item contains a large amount of data.</target>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>For example, you could use a query string parameter that accepts a comma-delimited list of fields, such as <bpt id="p1">_</bpt>/orders?fields=ProductID,Quantity<ept id="p1">_</ept>.</source>
          <target state="new">For example, you could use a query string parameter that accepts a comma-delimited list of fields, such as <bpt id="p1">_</bpt>/orders?fields=ProductID,Quantity<ept id="p1">_</ept>.</target>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.TIP]</ph> Give all optional parameters in query strings meaningful defaults.</source>
          <target state="new"><ph id="ph1">[AZURE.TIP]</ph> Give all optional parameters in query strings meaningful defaults.</target>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>For example, set the <ph id="ph1">`limit`</ph> parameter to 10 and the <ph id="ph2">`offset`</ph> parameter to 0 if you implement pagination, set the sort parameter to the key of the resource if you implement ordering, and set the <ph id="ph3">`fields`</ph> parameter to all fields in the resource if you support projections.</source>
          <target state="new">For example, set the <ph id="ph1">`limit`</ph> parameter to 10 and the <ph id="ph2">`offset`</ph> parameter to 0 if you implement pagination, set the sort parameter to the key of the resource if you implement ordering, and set the <ph id="ph3">`fields`</ph> parameter to all fields in the resource if you support projections.</target>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Handling large binary resources</source>
          <target state="new">Handling large binary resources</target>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>A single resource may contain large binary fields, such as files or images.</source>
          <target state="new">A single resource may contain large binary fields, such as files or images.</target>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>To overcome the transmission problems caused by unreliable and intermittent connections and to improve response times, consider providing operations that enable such resources to be retrieved in chunks by the client application.</source>
          <target state="new">To overcome the transmission problems caused by unreliable and intermittent connections and to improve response times, consider providing operations that enable such resources to be retrieved in chunks by the client application.</target>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>To do this, the web API should support the Accept-Ranges header for GET requests for large resources, and ideally implement HTTP HEAD requests for these resources.</source>
          <target state="new">To do this, the web API should support the Accept-Ranges header for GET requests for large resources, and ideally implement HTTP HEAD requests for these resources.</target>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>The Accept-Ranges header indicates that the GET operation supports partial results, and that a client application can submit GET requests that return a subset of a resource specified as a range of bytes.</source>
          <target state="new">The Accept-Ranges header indicates that the GET operation supports partial results, and that a client application can submit GET requests that return a subset of a resource specified as a range of bytes.</target>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>A HEAD request is similar to a GET request except that it only returns a header that describes the resource and an empty message body.</source>
          <target state="new">A HEAD request is similar to a GET request except that it only returns a header that describes the resource and an empty message body.</target>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>A client application can issue a HEAD request to determine whether to fetch a resource by using partial GET requests.</source>
          <target state="new">A client application can issue a HEAD request to determine whether to fetch a resource by using partial GET requests.</target>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The following example shows a HEAD request that obtains information about a product image:</source>
          <target state="new">The following example shows a HEAD request that obtains information about a product image:</target>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The response message contains a header that includes the size of the resource (4580 bytes), and the Accept-Ranges header that the corresponding GET operation supports partial results:</source>
          <target state="new">The response message contains a header that includes the size of the resource (4580 bytes), and the Accept-Ranges header that the corresponding GET operation supports partial results:</target>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The client application can use this information to construct a series of GET operations to retrieve the image in smaller chunks.</source>
          <target state="new">The client application can use this information to construct a series of GET operations to retrieve the image in smaller chunks.</target>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The first request fetches the first 2500 bytes by using the Range header:</source>
          <target state="new">The first request fetches the first 2500 bytes by using the Range header:</target>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>The response message indicates that this is a partial response by returning HTTP status code 206.</source>
          <target state="new">The response message indicates that this is a partial response by returning HTTP status code 206.</target>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>The Content-Length header specifies the actual number of bytes returned in the message body (not the size of the resource), and the Content-Range header indicates which part of the resource this is (bytes 0-2499 out of 4580):</source>
          <target state="new">The Content-Length header specifies the actual number of bytes returned in the message body (not the size of the resource), and the Content-Range header indicates which part of the resource this is (bytes 0-2499 out of 4580):</target>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>A subsequent request from the client application can retrieve the remainder of the resource by using an appropriate Range header:</source>
          <target state="new">A subsequent request from the client application can retrieve the remainder of the resource by using an appropriate Range header:</target>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The corresponding result message should look like this:</source>
          <target state="new">The corresponding result message should look like this:</target>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Using the HATEOAS approach to enable navigation to related resources</source>
          <target state="new">Using the HATEOAS approach to enable navigation to related resources</target>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>One of the primary motivations behind REST is that it should be possible to navigate the entire set of resources without requiring prior knowledge of the URI scheme.</source>
          <target state="new">One of the primary motivations behind REST is that it should be possible to navigate the entire set of resources without requiring prior knowledge of the URI scheme.</target>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Each HTTP GET request should return the information necessary to find the resources related directly to the requested object through hyperlinks included in the response, and it should also be provided with information that describes the operations available on each of these resources.</source>
          <target state="new">Each HTTP GET request should return the information necessary to find the resources related directly to the requested object through hyperlinks included in the response, and it should also be provided with information that describes the operations available on each of these resources.</target>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>This principle is known as HATEOAS, or Hypertext as the Engine of Application State.</source>
          <target state="new">This principle is known as HATEOAS, or Hypertext as the Engine of Application State.</target>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>The system is effectively a finite state machine, and the response to each request contains the information necessary to move from one state to another; no other information should be necessary.</source>
          <target state="new">The system is effectively a finite state machine, and the response to each request contains the information necessary to move from one state to another; no other information should be necessary.</target>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Currently there are no standards or specifications that define how to model the HATEOAS principle.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Currently there are no standards or specifications that define how to model the HATEOAS principle.</target>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The examples shown in this section illustrate one possible solution.</source>
          <target state="new">The examples shown in this section illustrate one possible solution.</target>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>As an example, to handle the relationship between customers and orders, the data returned in the response for a specific order should contain URIs in the form of a hyperlink identifying the customer that placed the order, and the operations that can be performed on that customer.</source>
          <target state="new">As an example, to handle the relationship between customers and orders, the data returned in the response for a specific order should contain URIs in the form of a hyperlink identifying the customer that placed the order, and the operations that can be performed on that customer.</target>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>The body of the response message contains a <ph id="ph1">`Links`</ph> array (highlighted in the code example) that specifies the nature of the relationship (<bpt id="p1">_</bpt>Customer<ept id="p1">_</ept>), the URI of the customer (<bpt id="p2">_</bpt>http://adventure-works.com/customers/3<ept id="p2">_</ept>), how to retrieve the details of this customer (<bpt id="p3">_</bpt>GET<ept id="p3">_</ept>), and the MIME types that the web server supports for retrieving this information (<bpt id="p4">_</bpt>text/xml<ept id="p4">_</ept> and <bpt id="p5">_</bpt>application/json<ept id="p5">_</ept>).</source>
          <target state="new">The body of the response message contains a <ph id="ph1">`Links`</ph> array (highlighted in the code example) that specifies the nature of the relationship (<bpt id="p1">_</bpt>Customer<ept id="p1">_</ept>), the URI of the customer (<bpt id="p2">_</bpt>http://adventure-works.com/customers/3<ept id="p2">_</ept>), how to retrieve the details of this customer (<bpt id="p3">_</bpt>GET<ept id="p3">_</ept>), and the MIME types that the web server supports for retrieving this information (<bpt id="p4">_</bpt>text/xml<ept id="p4">_</ept> and <bpt id="p5">_</bpt>application/json<ept id="p5">_</ept>).</target>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>This is all the information that a client application needs to be able to fetch the details of the customer.</source>
          <target state="new">This is all the information that a client application needs to be able to fetch the details of the customer.</target>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Additionally, the Links array also includes links for the other operations that can be performed, such as PUT (to modify the customer, together with the format that the web server expects the client to provide), and DELETE.</source>
          <target state="new">Additionally, the Links array also includes links for the other operations that can be performed, such as PUT (to modify the customer, together with the format that the web server expects the client to provide), and DELETE.</target>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>For completeness, the Links array should also include self-referencing information pertaining to the resource that has been retrieved.</source>
          <target state="new">For completeness, the Links array should also include self-referencing information pertaining to the resource that has been retrieved.</target>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>These links have been omitted from the previous example, but are highlighted in the following code.</source>
          <target state="new">These links have been omitted from the previous example, but are highlighted in the following code.</target>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Notice that in these links, the relationship <bpt id="p1">_</bpt>self<ept id="p1">_</ept> has been used to indicate that this is a reference to the resource being returned by the operation:</source>
          <target state="new">Notice that in these links, the relationship <bpt id="p1">_</bpt>self<ept id="p1">_</ept> has been used to indicate that this is a reference to the resource being returned by the operation:</target>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>For this approach to be effective, client applications must be prepared to retrieve and parse this additional information.</source>
          <target state="new">For this approach to be effective, client applications must be prepared to retrieve and parse this additional information.</target>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Versioning a RESTful web API</source>
          <target state="new">Versioning a RESTful web API</target>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>It is highly unlikely that in all but the simplest of situations that a web API will remain static.</source>
          <target state="new">It is highly unlikely that in all but the simplest of situations that a web API will remain static.</target>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>As business requirements change new collections of resources may be added, the relationships between resources might change, and the structure of the data in resources might be amended.</source>
          <target state="new">As business requirements change new collections of resources may be added, the relationships between resources might change, and the structure of the data in resources might be amended.</target>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>While updating a web API to handle new or differing requirements is a relatively straightforward process, you must consider the effects that such changes will have on client applications consuming the web API.</source>
          <target state="new">While updating a web API to handle new or differing requirements is a relatively straightforward process, you must consider the effects that such changes will have on client applications consuming the web API.</target>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>The issue is that although the developer designing and implementing a web API has full control over that API, the developer does not have the same degree of control over client applications which may be built by third party organizations operating remotely.</source>
          <target state="new">The issue is that although the developer designing and implementing a web API has full control over that API, the developer does not have the same degree of control over client applications which may be built by third party organizations operating remotely.</target>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>The primary imperative is to enable existing client applications to continue functioning unchanged while allowing new client applications to take advantage of new features and resources.</source>
          <target state="new">The primary imperative is to enable existing client applications to continue functioning unchanged while allowing new client applications to take advantage of new features and resources.</target>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Versioning enables a web API to indicate the features and resources that it exposes, and a client application can submit requests that are directed to a specific version of a feature or resource.</source>
          <target state="new">Versioning enables a web API to indicate the features and resources that it exposes, and a client application can submit requests that are directed to a specific version of a feature or resource.</target>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>The following sections describe several different approaches, each of which has its own benefits and trade-offs.</source>
          <target state="new">The following sections describe several different approaches, each of which has its own benefits and trade-offs.</target>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>No versioning</source>
          <target state="new">No versioning</target>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>This is the simplest approach, and may be acceptable for some internal APIs.</source>
          <target state="new">This is the simplest approach, and may be acceptable for some internal APIs.</target>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>Big changes could be represented as new resources or new links.</source>
          <target state="new">Big changes could be represented as new resources or new links.</target>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Adding content to existing resources might not present a breaking change as client applications that are not expecting to see this content will simply ignore it.</source>
          <target state="new">Adding content to existing resources might not present a breaking change as client applications that are not expecting to see this content will simply ignore it.</target>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>For example, a request to the URI <bpt id="p1">_</bpt>http://adventure-works.com/customers/3<ept id="p1">_</ept> should return the details of a single customer containing <ph id="ph1">`Id`</ph>, <ph id="ph2">`Name`</ph>, and <ph id="ph3">`Address`</ph> fields expected by the client application:</source>
          <target state="new">For example, a request to the URI <bpt id="p1">_</bpt>http://adventure-works.com/customers/3<ept id="p1">_</ept> should return the details of a single customer containing <ph id="ph1">`Id`</ph>, <ph id="ph2">`Name`</ph>, and <ph id="ph3">`Address`</ph> fields expected by the client application:</target>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> For the purposes of simplicity and clarity, the example responses shown in this section do not include HATEOAS links.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> For the purposes of simplicity and clarity, the example responses shown in this section do not include HATEOAS links.</target>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`DateCreated`</ph> field is added to the schema of the customer resource, then the response would look like this:</source>
          <target state="new">If the <ph id="ph1">`DateCreated`</ph> field is added to the schema of the customer resource, then the response would look like this:</target>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Existing client applications might continue functioning correctly if they are capable of ignoring unrecognized fields, while new client applications can be designed to handle this new field.</source>
          <target state="new">Existing client applications might continue functioning correctly if they are capable of ignoring unrecognized fields, while new client applications can be designed to handle this new field.</target>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>However, if more radical changes to the schema of resources occur (such as removing or renaming fields) or the relationships between resources change then these may constitute breaking changes that prevent existing client applications from functioning correctly.</source>
          <target state="new">However, if more radical changes to the schema of resources occur (such as removing or renaming fields) or the relationships between resources change then these may constitute breaking changes that prevent existing client applications from functioning correctly.</target>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>In these situations you should consider one of the following approaches.</source>
          <target state="new">In these situations you should consider one of the following approaches.</target>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>URI versioning</source>
          <target state="new">URI versioning</target>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Each time you modify the web API or change the schema of resources, you add a version number to the URI for each resource.</source>
          <target state="new">Each time you modify the web API or change the schema of resources, you add a version number to the URI for each resource.</target>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>The previously existing URIs should continue to operate as before, returning resources that conform to their original schema.</source>
          <target state="new">The previously existing URIs should continue to operate as before, returning resources that conform to their original schema.</target>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Extending the previous example, if the <ph id="ph1">`Address`</ph> field is restructured into sub-fields containing each constituent part of the address (such as <ph id="ph2">`StreetAddress`</ph>, <ph id="ph3">`City`</ph>, <ph id="ph4">`State`</ph>, and <ph id="ph5">`ZipCode`</ph>), this version of the resource could be exposed through a URI containing a version number, such as http://adventure-works.com/v2/customers/3:</source>
          <target state="new">Extending the previous example, if the <ph id="ph1">`Address`</ph> field is restructured into sub-fields containing each constituent part of the address (such as <ph id="ph2">`StreetAddress`</ph>, <ph id="ph3">`City`</ph>, <ph id="ph4">`State`</ph>, and <ph id="ph5">`ZipCode`</ph>), this version of the resource could be exposed through a URI containing a version number, such as http://adventure-works.com/v2/customers/3:</target>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>This versioning mechanism is very simple but depends on the server routing the request to the appropriate endpoint.</source>
          <target state="new">This versioning mechanism is very simple but depends on the server routing the request to the appropriate endpoint.</target>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>However, it can become unwieldy as the web API matures through several iterations and the server has to support a number of different versions.</source>
          <target state="new">However, it can become unwieldy as the web API matures through several iterations and the server has to support a number of different versions.</target>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>Also, from a purist’s point of view, in all cases the client applications are fetching the same data (customer 3), so the URI should not really be different depending on the version.</source>
          <target state="new">Also, from a purist’s point of view, in all cases the client applications are fetching the same data (customer 3), so the URI should not really be different depending on the version.</target>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>This scheme also complicates implementation of HATEOAS as all links will need to include the version number in their URIs.</source>
          <target state="new">This scheme also complicates implementation of HATEOAS as all links will need to include the version number in their URIs.</target>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>Query string versioning</source>
          <target state="new">Query string versioning</target>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Rather than providing multiple URIs, you can specify the version of the resource by using a parameter within the query string appended to the HTTP request, such as <bpt id="p1">_</bpt>http://adventure-works.com/customers/3?version=2<ept id="p1">_</ept>.</source>
          <target state="new">Rather than providing multiple URIs, you can specify the version of the resource by using a parameter within the query string appended to the HTTP request, such as <bpt id="p1">_</bpt>http://adventure-works.com/customers/3?version=2<ept id="p1">_</ept>.</target>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>The version parameter should default to a meaningful value such as 1 if it is omitted by older client applications.</source>
          <target state="new">The version parameter should default to a meaningful value such as 1 if it is omitted by older client applications.</target>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>This approach has the semantic advantage that the same resource is always retrieved from the same URI, but it depends on the code that handles the request to parse the query string and send back the appropriate HTTP response.</source>
          <target state="new">This approach has the semantic advantage that the same resource is always retrieved from the same URI, but it depends on the code that handles the request to parse the query string and send back the appropriate HTTP response.</target>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>This approach also suffers from the same complications for implementing HATEOAS as the URI versioning mechanism.</source>
          <target state="new">This approach also suffers from the same complications for implementing HATEOAS as the URI versioning mechanism.</target>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Some older web browsers and web proxies will not cache responses for requests that include a query string in the URL.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Some older web browsers and web proxies will not cache responses for requests that include a query string in the URL.</target>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>This can have an adverse impact on performance for web applications that use a web API and that run from within such a web browser.</source>
          <target state="new">This can have an adverse impact on performance for web applications that use a web API and that run from within such a web browser.</target>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>Header versioning</source>
          <target state="new">Header versioning</target>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>Rather than appending the version number as a query string parameter, you could implement a custom header that indicates the version of the resource.</source>
          <target state="new">Rather than appending the version number as a query string parameter, you could implement a custom header that indicates the version of the resource.</target>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>This approach requires that the client application adds the appropriate header to any requests, although the code handling the client request could use a default value (version 1) if the version header is omitted.</source>
          <target state="new">This approach requires that the client application adds the appropriate header to any requests, although the code handling the client request could use a default value (version 1) if the version header is omitted.</target>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>The following examples utilize a custom header named <bpt id="p1">_</bpt>Custom-Header<ept id="p1">_</ept>.</source>
          <target state="new">The following examples utilize a custom header named <bpt id="p1">_</bpt>Custom-Header<ept id="p1">_</ept>.</target>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>The value of this header indicates the version of web API.</source>
          <target state="new">The value of this header indicates the version of web API.</target>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>Version 1:</source>
          <target state="new">Version 1:</target>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Version 2:</source>
          <target state="new">Version 2:</target>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>Note that as with the previous two approaches, implementing HATEOAS requires including the appropriate custom header in any links.</source>
          <target state="new">Note that as with the previous two approaches, implementing HATEOAS requires including the appropriate custom header in any links.</target>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>Media type versioning</source>
          <target state="new">Media type versioning</target>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>When a client application sends an HTTP GET request to a web server it should stipulate the format of the content that it can handle by using an Accept header, as described earlier in this guidance.</source>
          <target state="new">When a client application sends an HTTP GET request to a web server it should stipulate the format of the content that it can handle by using an Accept header, as described earlier in this guidance.</target>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>Frequently the purpose of the <bpt id="p1">_</bpt>Accept<ept id="p1">_</ept> header is to allow the client application to specify whether the body of the response should be XML, JSON, or some other common format that the client can parse.</source>
          <target state="new">Frequently the purpose of the <bpt id="p1">_</bpt>Accept<ept id="p1">_</ept> header is to allow the client application to specify whether the body of the response should be XML, JSON, or some other common format that the client can parse.</target>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>However, it is possible to define custom media types that include information enabling the client application to indicate which version of a resource it is expecting.</source>
          <target state="new">However, it is possible to define custom media types that include information enabling the client application to indicate which version of a resource it is expecting.</target>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>The following example shows a request that specifies an <bpt id="p1">_</bpt>Accept<ept id="p1">_</ept> header with the value <bpt id="p2">_</bpt>application/vnd.adventure-works.v1+json<ept id="p2">_</ept>.</source>
          <target state="new">The following example shows a request that specifies an <bpt id="p1">_</bpt>Accept<ept id="p1">_</ept> header with the value <bpt id="p2">_</bpt>application/vnd.adventure-works.v1+json<ept id="p2">_</ept>.</target>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">_</bpt>vnd.adventure-works.v1<ept id="p1">_</ept> element indicates to the web server that it should return version 1 of the resource, while the <bpt id="p2">_</bpt>json<ept id="p2">_</ept> element specifies that the format of the response body should be JSON:</source>
          <target state="new">The <bpt id="p1">_</bpt>vnd.adventure-works.v1<ept id="p1">_</ept> element indicates to the web server that it should return version 1 of the resource, while the <bpt id="p2">_</bpt>json<ept id="p2">_</ept> element specifies that the format of the response body should be JSON:</target>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>The code handling the request is responsible for processing the <bpt id="p1">_</bpt>Accept<ept id="p1">_</ept> header and honoring it as far as possible (the client application may specify multiple formats in the <bpt id="p2">_</bpt>Accept<ept id="p2">_</ept> header, in which case the web server can choose the most appropriate format for the response body).</source>
          <target state="new">The code handling the request is responsible for processing the <bpt id="p1">_</bpt>Accept<ept id="p1">_</ept> header and honoring it as far as possible (the client application may specify multiple formats in the <bpt id="p2">_</bpt>Accept<ept id="p2">_</ept> header, in which case the web server can choose the most appropriate format for the response body).</target>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>The web server confirms the format of the data in the response body by using the Content-Type header:</source>
          <target state="new">The web server confirms the format of the data in the response body by using the Content-Type header:</target>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>If the Accept header does not specify any known media types, the web server could generate an HTTP 406 (Not Acceptable) response message or return a message with a default media type.</source>
          <target state="new">If the Accept header does not specify any known media types, the web server could generate an HTTP 406 (Not Acceptable) response message or return a message with a default media type.</target>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>This approach is arguably the purest of the versioning mechanisms and lends itself naturally to HATEOAS, which can include the MIME type of related data in resource links.</source>
          <target state="new">This approach is arguably the purest of the versioning mechanisms and lends itself naturally to HATEOAS, which can include the MIME type of related data in resource links.</target>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> When you select a versioning strategy, you should also consider the implications on performance, especially caching on the web server.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> When you select a versioning strategy, you should also consider the implications on performance, especially caching on the web server.</target>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>The URI versioning and Query String versioning schemes are cache-friendly inasmuch as the same URI/query string combination refers to the same data each time.</source>
          <target state="new">The URI versioning and Query String versioning schemes are cache-friendly inasmuch as the same URI/query string combination refers to the same data each time.</target>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>The Header versioning and Media Type versioning mechanisms typically require additional logic to examine the values in the custom header or the Accept header.</source>
          <target state="new">The Header versioning and Media Type versioning mechanisms typically require additional logic to examine the values in the custom header or the Accept header.</target>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>In a large-scale environment, many clients using different versions of a web API can result in a significant amount of duplicated data in a server-side cache.</source>
          <target state="new">In a large-scale environment, many clients using different versions of a web API can result in a significant amount of duplicated data in a server-side cache.</target>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>This issue can become acute if a client application communicates with a web server through a proxy that implements caching, and that only forwards a request to the web server if it does not currently hold a copy of the requested data in its cache.</source>
          <target state="new">This issue can become acute if a client application communicates with a web server through a proxy that implements caching, and that only forwards a request to the web server if it does not currently hold a copy of the requested data in its cache.</target>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>More information</source>
          <target state="new">More information</target>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RESTful Cookbook<ept id="p1">](http://restcookbook.com/)</ept> contains an introduction to building RESTful APIs.</source>
          <target state="new">The <bpt id="p1">[</bpt>RESTful Cookbook<ept id="p1">](http://restcookbook.com/)</ept> contains an introduction to building RESTful APIs.</target>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>The Web <bpt id="p1">[</bpt>API Checklist<ept id="p1">](https://mathieu.fenniak.net/the-api-checklist/)</ept> contains a useful list of items to consider when designing and implementing a Web API.</source>
          <target state="new">The Web <bpt id="p1">[</bpt>API Checklist<ept id="p1">](https://mathieu.fenniak.net/the-api-checklist/)</ept> contains a useful list of items to consider when designing and implementing a Web API.</target>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>test</source>
          <target state="new">test</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">beb1e22846b41daf91801e36b8c7a1f5da238eaf</xliffext:olfilehash>
  </header>
</xliff>