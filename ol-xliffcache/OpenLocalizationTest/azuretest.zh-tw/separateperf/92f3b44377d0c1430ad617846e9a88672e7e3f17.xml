{
  "nodes": [
    {
      "content": "Azure AD NodeJS Getting Started | Microsoft Azure",
      "pos": [
        27,
        76
      ]
    },
    {
      "content": "How to build a Node.js Web API that integrates with Azure AD for authentication.",
      "pos": [
        95,
        175
      ]
    },
    {
      "content": "Getting Started With WEB-API for Node",
      "pos": [
        499,
        536
      ]
    },
    {
      "content": "This walkthrough will give you  a quick and easy way to set up a REST API Service that is integrated with  Azure Active Directory for API protection using the OAuth2 protocol.",
      "pos": [
        628,
        803
      ]
    },
    {
      "content": "The sample server included in the download are designed to run on any platform but target OSX and Linux.",
      "pos": [
        804,
        908
      ]
    },
    {
      "content": "By the end of this walk-through, you should be able to build a running REST API server with the following features:",
      "pos": [
        910,
        1025
      ]
    },
    {
      "content": "A node.js server running an REST API interface with JSON using MongoDB as persistant storage",
      "pos": [
        1029,
        1121
      ]
    },
    {
      "content": "REST APIs leveraging OAuth2 API protection with Bearer tokens using Azure Active Directory",
      "pos": [
        1124,
        1214
      ]
    },
    {
      "content": "We've released all of the source code for this running example in GitHub under an Apache 2.0 license, so feel free to clone (or even better, fork!) and provide feedback and pull requests.",
      "pos": [
        1217,
        1404
      ]
    },
    {
      "content": "About Node.js Modules",
      "pos": [
        1409,
        1430
      ]
    },
    {
      "content": "We will be using Node.js modules in this walkthrough.",
      "pos": [
        1432,
        1485
      ]
    },
    {
      "content": "Modules are loadable JavaScript packages that provide specific functionality for your application.",
      "pos": [
        1486,
        1584
      ]
    },
    {
      "content": "You usually install modules by using the Node.js NPM command-line tool in the NPM installation directory, but some modules, such as the HTTP module, are included the core Node.js package.",
      "pos": [
        1585,
        1772
      ]
    },
    {
      "content": "Installed modules are saved in the node_modules directory at the root of your Node.js installation directory.",
      "pos": [
        1773,
        1882
      ]
    },
    {
      "content": "Each module in the node_modules directory maintains its own node_modules directory that contains any modules that it depends on, and each required module has a node_modules directory.",
      "pos": [
        1883,
        2066
      ]
    },
    {
      "content": "This recursive directory structure represents the dependency chain.",
      "pos": [
        2067,
        2134
      ]
    },
    {
      "content": "This dependency chain structure results in a larger application footprint, but it guarantees that all dependencies are met and that the version of the modules used in development will also be used in production.",
      "pos": [
        2136,
        2347
      ]
    },
    {
      "content": "This makes the production app behavior more predictable and prevents versioning problems that might affect users.",
      "pos": [
        2348,
        2461
      ]
    },
    {
      "content": "Step 1: Register a Azure AD Tenant",
      "pos": [
        2466,
        2500
      ]
    },
    {
      "content": "To use this sample you will need a Azure Active Directory Tenant.",
      "pos": [
        2502,
        2567
      ]
    },
    {
      "content": "If you're not sure what a tenant is or how you would get one, see  <bpt id=\"p1\">[</bpt>How to get an Azure AD tenant<ept id=\"p1\">](active-directory-howto-tenant.md)</ept>.",
      "pos": [
        2568,
        2701
      ]
    },
    {
      "content": "Step 2: Add A Web API to your tenant",
      "pos": [
        2706,
        2742
      ]
    },
    {
      "content": "After you get your Azure Active Directory tenant, add this sample app to your tenant so you can use it to protect the API.",
      "pos": [
        2744,
        2866
      ]
    },
    {
      "content": "To enable your app to authenticate users, you'll first need to register a new application in your tenant.",
      "pos": [
        2868,
        2973
      ]
    },
    {
      "content": "Sign into the Azure Management Portal.",
      "pos": [
        2977,
        3015
      ]
    },
    {
      "pos": [
        3018,
        3070
      ],
      "content": "In the left hand nav, click on <bpt id=\"p1\">**</bpt>Active Directory<ept id=\"p1\">**</ept>."
    },
    {
      "content": "Select the tenant where you wish to register the application.",
      "pos": [
        3073,
        3134
      ]
    },
    {
      "pos": [
        3137,
        3204
      ],
      "content": "Click the <bpt id=\"p1\">**</bpt>Applications<ept id=\"p1\">**</ept> tab, and click add in the bottom drawer."
    },
    {
      "pos": [
        3207,
        3277
      ],
      "content": "Follow the prompts and create a new <bpt id=\"p1\">**</bpt>Web Application and/or WebAPI<ept id=\"p1\">**</ept>."
    },
    {
      "pos": [
        3284,
        3359
      ],
      "content": "The <bpt id=\"p1\">**</bpt>name<ept id=\"p1\">**</ept> of the application will describe your application to end-users"
    },
    {
      "content": "The <bpt id=\"p1\">**</bpt>Sign-On URL<ept id=\"p1\">**</ept> is the base URL of your app.",
      "pos": [
        3368,
        3416
      ]
    },
    {
      "content": "The skeleton’s default is <ph id=\"ph1\">`https://localhost:8888`</ph>.",
      "pos": [
        3418,
        3469
      ]
    },
    {
      "content": "The <bpt id=\"p1\">**</bpt>App ID URI<ept id=\"p1\">**</ept> is a unique identifier for your application.",
      "pos": [
        3476,
        3539
      ]
    },
    {
      "content": "The convention is to use <ph id=\"ph1\">`https://&lt;tenant-domain&gt;/&lt;app-name&gt;`</ph>, e.g. <ph id=\"ph2\">`https://contoso.onmicrosoft.com/my-first-aad-app`</ph>",
      "pos": [
        3541,
        3659
      ]
    },
    {
      "content": "Once you’ve completed registration, AAD will assign your app a unique client identifier.",
      "pos": [
        3662,
        3750
      ]
    },
    {
      "content": "You’ll need this value in the next sections, so copy it from the Configure tab.",
      "pos": [
        3752,
        3831
      ]
    },
    {
      "content": "Step 3: Download node.js for your platform",
      "pos": [
        3836,
        3878
      ]
    },
    {
      "content": "To successfully use this sample, you must have a working installation of Node.js.",
      "pos": [
        3879,
        3960
      ]
    },
    {
      "pos": [
        3962,
        4022
      ],
      "content": "Install Node.js from <bpt id=\"p1\">[</bpt>http://nodejs.org<ept id=\"p1\">](http://nodejs.org)</ept>."
    },
    {
      "content": "Step 4: Install MongoDB on to your platform",
      "pos": [
        4027,
        4070
      ]
    },
    {
      "content": "To successfully use this sample, you must have a working installation of MongoDB.",
      "pos": [
        4072,
        4153
      ]
    },
    {
      "content": "We will use MongoDB to make our REST API persistant across server instances.",
      "pos": [
        4154,
        4230
      ]
    },
    {
      "pos": [
        4232,
        4298
      ],
      "content": "Install MongoDB from <bpt id=\"p1\">[</bpt>http://mongodb.org<ept id=\"p1\">](http://www.mongodb.org)</ept>."
    },
    {
      "pos": [
        4300,
        4464
      ],
      "content": "<bpt id=\"p1\">**</bpt>NOTE:<ept id=\"p1\">**</ept> This walkthrough assumes that you use the default installation and server endpoints for MongoDB, which at the time of this writing is: mongodb://localhost"
    },
    {
      "content": "Step 5: Install the Restify modules in to your Web API",
      "pos": [
        4470,
        4524
      ]
    },
    {
      "content": "We will be using Resitfy to build our REST API.",
      "pos": [
        4526,
        4573
      ]
    },
    {
      "content": "Restify is a minimal and flexible Node.js application framework derived from Express that has a robust set of features for building REST APIs on top of Connect.",
      "pos": [
        4574,
        4734
      ]
    },
    {
      "content": "Install Restify",
      "pos": [
        4740,
        4755
      ]
    },
    {
      "content": "From the command-line, change directories to the azuread directory.",
      "pos": [
        4757,
        4824
      ]
    },
    {
      "content": "If the <bpt id=\"p1\">**</bpt>azuread<ept id=\"p1\">**</ept> directory does not exist, create it.",
      "pos": [
        4825,
        4880
      ]
    },
    {
      "content": "Type the following command:",
      "pos": [
        4928,
        4955
      ]
    },
    {
      "content": "This command installs Restify.",
      "pos": [
        4980,
        5010
      ]
    },
    {
      "content": "DID YOU GET AN ERROR?",
      "pos": [
        5017,
        5038
      ]
    },
    {
      "content": "When using npm on some operating systems, you may receive an error of Error: EPERM, chmod '/usr/local/bin/..'",
      "pos": [
        5040,
        5149
      ]
    },
    {
      "content": "and a request to try running the account as an administrator.",
      "pos": [
        5150,
        5211
      ]
    },
    {
      "content": "If this occurs, use the sudo command to run npm at a higher privilege level.",
      "pos": [
        5212,
        5288
      ]
    },
    {
      "content": "DID YOU GET AN ERROR REGARDING DTRACE?",
      "pos": [
        5295,
        5333
      ]
    },
    {
      "content": "You may see something like this when installing Restify:",
      "pos": [
        5335,
        5391
      ]
    },
    {
      "content": "Restify provides a powerful mechanism to trace REST calls using DTrace.",
      "pos": [
        6289,
        6360
      ]
    },
    {
      "content": "However, many operating systems do not have DTrace available.",
      "pos": [
        6361,
        6422
      ]
    },
    {
      "content": "You can safely ignore these errors.",
      "pos": [
        6423,
        6458
      ]
    },
    {
      "content": "The output of this command should appear similar to the following:",
      "pos": [
        6461,
        6527
      ]
    },
    {
      "content": "Step 6: Install Passport.js in to your Web API",
      "pos": [
        7107,
        7153
      ]
    },
    {
      "content": "<bpt id=\"p1\">[</bpt>Passport<ept id=\"p1\">](http://passportjs.org/)</ept> is authentication middleware for Node.js.",
      "pos": [
        7155,
        7231
      ]
    },
    {
      "content": "Extremely flexible and modular, Passport can be unobtrusively dropped in to any Express-based or Resitify web application.",
      "pos": [
        7232,
        7354
      ]
    },
    {
      "content": "A comprehensive set of strategies support authentication using a username and password, Facebook, Twitter, and more.",
      "pos": [
        7355,
        7471
      ]
    },
    {
      "content": "We have developed a strategy for Azure Active Directory.",
      "pos": [
        7472,
        7528
      ]
    },
    {
      "content": "We will install this module and then add the Azure Active Directory strategy plug-in.",
      "pos": [
        7529,
        7614
      ]
    },
    {
      "content": "From the command-line, change directories to the azuread directory.",
      "pos": [
        7616,
        7683
      ]
    },
    {
      "content": "Enter the following command to install passport.js",
      "pos": [
        7685,
        7735
      ]
    },
    {
      "content": "The output of the commadn should appear similar to the following:",
      "pos": [
        7761,
        7826
      ]
    },
    {
      "content": "Step 7: Add Passport.js Bearer Token Support to your Web API",
      "pos": [
        7916,
        7976
      ]
    },
    {
      "content": "Next, we will add the Bearer strategy, using passport-bearer-http, a Bearner handler for <bpt id=\"p1\">[</bpt>Passport<ept id=\"p1\">](http://passportjs.org/)</ept>.",
      "pos": [
        7978,
        8102
      ]
    },
    {
      "content": "We will also add JWT token handler support by using node-jwt.",
      "pos": [
        8103,
        8164
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>NOTE:<ept id=\"p1\">**</ept> Although OAuth2 provides a framework in which any known token type can be issued, only certain token types have gained wide-spread use.",
      "pos": [
        8166,
        8311
      ]
    },
    {
      "content": "For protecting endpoints, that has turned out to be Bearer Tokens.",
      "pos": [
        8312,
        8378
      ]
    },
    {
      "content": "Bearer tokens are the most widely issued type of token in OAuth2, and many implementations assume that bearer tokens are the only type of token issued.",
      "pos": [
        8379,
        8530
      ]
    },
    {
      "pos": [
        8532,
        8603
      ],
      "content": "From the command-line, change directories to the <bpt id=\"p1\">**</bpt>azuread<ept id=\"p1\">**</ept> directory."
    },
    {
      "content": "Type the following command to install Passport.js modules:",
      "pos": [
        8605,
        8663
      ]
    },
    {
      "content": "The output of the commamd should appear similar to the following:",
      "pos": [
        8759,
        8824
      ]
    },
    {
      "content": "Step 8: Add MongoDB modules to your Web API",
      "pos": [
        8996,
        9039
      ]
    },
    {
      "content": "We will be using MongoDB as our datastore For that reason, we need to install both the widely used plug-in to manage models and schemas called Mongoose, as well as the database driver for MongoDB, also called MongoDB.",
      "pos": [
        9041,
        9258
      ]
    },
    {
      "content": "Step 9:  Install additional modules",
      "pos": [
        9314,
        9349
      ]
    },
    {
      "content": "Next, we'll install the remaining required modules.",
      "pos": [
        9351,
        9402
      ]
    },
    {
      "pos": [
        9405,
        9494
      ],
      "content": "From the command-line, change directories to the <bpt id=\"p1\">**</bpt>azuread<ept id=\"p1\">**</ept> folder if not already there:"
    },
    {
      "content": "Enter the following commands to install the following modules in your node_modules directory:",
      "pos": [
        9511,
        9604
      ]
    },
    {
      "content": "Step 10: Create a server.js with your dependencies",
      "pos": [
        10127,
        10177
      ]
    },
    {
      "content": "The server.js file will be providing the majority of our functionality for our Web API server.",
      "pos": [
        10179,
        10273
      ]
    },
    {
      "content": "We will be adding most of our code to this file.",
      "pos": [
        10274,
        10322
      ]
    },
    {
      "content": "For production purposes you would refactor the functionality in to smaller files, such as separate routes and controllers.",
      "pos": [
        10323,
        10445
      ]
    },
    {
      "content": "For the purpose of this demo we will use server.js for this functionality.",
      "pos": [
        10446,
        10520
      ]
    },
    {
      "pos": [
        10522,
        10611
      ],
      "content": "From the command-line, change directories to the <bpt id=\"p1\">**</bpt>azuread<ept id=\"p1\">**</ept> folder if not already there:"
    },
    {
      "pos": [
        10627,
        10710
      ],
      "content": "Create a <ph id=\"ph1\">`server.js`</ph> file in our favorite editor and add the following information:"
    },
    {
      "content": "Save the file.",
      "pos": [
        11083,
        11097
      ]
    },
    {
      "content": "We will return to it shortly.",
      "pos": [
        11098,
        11127
      ]
    },
    {
      "content": "Step 11: Create a config file to store your Azure AD settings",
      "pos": [
        11132,
        11193
      ]
    },
    {
      "content": "This code file passes the configuration parameters from your Azure Active Directory Portal to Passport.js.",
      "pos": [
        11195,
        11301
      ]
    },
    {
      "content": "You created these configuration values when you added the Web API to the portal in the first part of the walkthrough.",
      "pos": [
        11302,
        11419
      ]
    },
    {
      "content": "We will explain what to put in the values of these parameters after you've copied the code.",
      "pos": [
        11420,
        11511
      ]
    },
    {
      "pos": [
        11514,
        11603
      ],
      "content": "From the command-line, change directories to the <bpt id=\"p1\">**</bpt>azuread<ept id=\"p1\">**</ept> folder if not already there:"
    },
    {
      "pos": [
        11619,
        11702
      ],
      "content": "Create a <ph id=\"ph1\">`config.js`</ph> file in our favorite editor and add the following information:"
    },
    {
      "pos": [
        12244,
        12309
      ],
      "content": "<bpt id=\"p1\">**</bpt>NOTE:<ept id=\"p1\">**</ept> You will most likely never need to change these values."
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>NOTE:<ept id=\"p1\">**</ept> We roll our keys at frequent intervals.",
      "pos": [
        12311,
        12360
      ]
    },
    {
      "content": "Please ensure that you are always pulling from the \"openid_keys\" URL and that the app can access the internet.",
      "pos": [
        12361,
        12471
      ]
    },
    {
      "content": "Step 12: Add configuration to your server.js file",
      "pos": [
        12477,
        12526
      ]
    },
    {
      "content": "We need to read these values from the Config file you just created across our application.",
      "pos": [
        12528,
        12618
      ]
    },
    {
      "content": "To do this, we simply add the .config file as a required resource in our application and then set the global variables to those in the config.js document",
      "pos": [
        12619,
        12772
      ]
    },
    {
      "pos": [
        12774,
        12863
      ],
      "content": "From the command-line, change directories to the <bpt id=\"p1\">**</bpt>azuread<ept id=\"p1\">**</ept> folder if not already there:"
    },
    {
      "pos": [
        12879,
        12963
      ],
      "content": "Open your <ph id=\"ph1\">`server.js`</ph> file in our favorite editor and add the following information:"
    },
    {
      "pos": [
        13017,
        13080
      ],
      "content": "Then, add a new section to <ph id=\"ph1\">`server.js`</ph> with the following code:"
    },
    {
      "content": "Step 13: Create a metadata.js helper file to aid in parsing metadata/tokens",
      "pos": [
        13328,
        13403
      ]
    },
    {
      "content": "Since the goal is to keep only application logic in the server.js file, it makes sense to put some helper methods in a separate file.",
      "pos": [
        13405,
        13538
      ]
    },
    {
      "content": "These methods simply help us parse the OpenID Connect metadata and do not relate to the core scenario.",
      "pos": [
        13539,
        13641
      ]
    },
    {
      "content": "It's better to stuff them away.",
      "pos": [
        13642,
        13673
      ]
    },
    {
      "content": "We will be adding more to this file as we go through the Walkthrough.",
      "pos": [
        13674,
        13743
      ]
    },
    {
      "content": "<bpt id=\"p1\">***</bpt>NOTE:<ept id=\"p1\">***</ept> You'll notice that this metadata.js file parses XML for SAML and WS-Fed as well as JSON for OpenID Connect.",
      "pos": [
        13745,
        13864
      ]
    },
    {
      "content": "That is by design as you'll use this file in our other samples as well.",
      "pos": [
        13865,
        13936
      ]
    },
    {
      "content": "You can safely ignore it now.",
      "pos": [
        13937,
        13966
      ]
    },
    {
      "pos": [
        13968,
        14057
      ],
      "content": "From the command-line, change directories to the <bpt id=\"p1\">**</bpt>azuread<ept id=\"p1\">**</ept> folder if not already there:"
    },
    {
      "pos": [
        14073,
        14158
      ],
      "content": "Create a <ph id=\"ph1\">`metadata.js`</ph> file in our favorite editor and add the following information:"
    },
    {
      "content": "As you can see from the code, it simply takes the openid URL you passed in <ph id=\"ph1\">`config.js`</ph> and then parses it for information which we will use in the <ph id=\"ph2\">`server.js`</ph> file.",
      "pos": [
        20052,
        20216
      ]
    },
    {
      "content": "You are more than welcome to investigate this code and expand it if needed.",
      "pos": [
        20217,
        20292
      ]
    },
    {
      "content": "Load the metadata.js file in your server.js",
      "pos": [
        20298,
        20341
      ]
    },
    {
      "content": "We need to tell our server where to get the methods you jus wrote.",
      "pos": [
        20343,
        20409
      ]
    },
    {
      "pos": [
        20411,
        20500
      ],
      "content": "From the command-line, change directories to the <bpt id=\"p1\">**</bpt>azuread<ept id=\"p1\">**</ept> folder if not already there:"
    },
    {
      "pos": [
        20516,
        20600
      ],
      "content": "Open your <ph id=\"ph1\">`server.js`</ph> file in our favorite editor and add the following information:"
    },
    {
      "pos": [
        20657,
        20796
      ],
      "content": "Next, add to the end of the <ph id=\"ph1\">`Configuration`</ph> section this call to send the metadata document in our <ph id=\"ph2\">`config.js`</ph> to the parser we just wrote:"
    },
    {
      "content": "Step 14: Add The MongoDB Model and Schema Information using Moongoose",
      "pos": [
        20887,
        20956
      ]
    },
    {
      "content": "Now all this preparation is going to start paying off as we wind these three files together in to a REST API service.",
      "pos": [
        20958,
        21075
      ]
    },
    {
      "pos": [
        21077,
        21171
      ],
      "content": "For this walkthrough we will be using MongoDB to store our Tasks as discussed in <bpt id=\"p1\">***</bpt>Step 4<ept id=\"p1\">***</ept>."
    },
    {
      "content": "If you recall from the <ph id=\"ph1\">`config.js`</ph> file we created in <bpt id=\"p1\">***</bpt>Step 11<ept id=\"p1\">***</ept> we called our database <ph id=\"ph2\">`tasklist`</ph> as that was what we put at the end of our mogoose_auth_local connection URL.",
      "pos": [
        21173,
        21351
      ]
    },
    {
      "content": "You don't need to create this database beforehand in MongoDB, it will create this for us on first run of our server application (assuming it does not already exist).",
      "pos": [
        21352,
        21517
      ]
    },
    {
      "content": "Now that we've told the server what MongoDB database we'd like to use, we need to write some additional code to create the model and schema for our server's Tasks.",
      "pos": [
        21519,
        21682
      ]
    },
    {
      "content": "Discussion of the model",
      "pos": [
        21689,
        21712
      ]
    },
    {
      "content": "Our Schema model is very simple, and you expand it as required.",
      "pos": [
        21714,
        21777
      ]
    },
    {
      "content": "NAME - The name of who is assigned to the task.",
      "pos": [
        21779,
        21826
      ]
    },
    {
      "content": "A <bpt id=\"p1\">***</bpt>String<ept id=\"p1\">***</ept>",
      "pos": [
        21827,
        21841
      ]
    },
    {
      "content": "TASK - The task itself.",
      "pos": [
        21843,
        21866
      ]
    },
    {
      "content": "A <bpt id=\"p1\">***</bpt>String<ept id=\"p1\">***</ept>",
      "pos": [
        21867,
        21881
      ]
    },
    {
      "content": "DATE - The date that the task is due.",
      "pos": [
        21883,
        21920
      ]
    },
    {
      "content": "A <bpt id=\"p1\">***</bpt>DATETIME<ept id=\"p1\">***</ept>",
      "pos": [
        21921,
        21937
      ]
    },
    {
      "content": "COMPLETED - If the Task is completed or not.",
      "pos": [
        21939,
        21983
      ]
    },
    {
      "content": "A <bpt id=\"p1\">***</bpt>BOOLEAN<ept id=\"p1\">***</ept>",
      "pos": [
        21984,
        21999
      ]
    },
    {
      "content": "Creating the schema in the code",
      "pos": [
        22006,
        22037
      ]
    },
    {
      "pos": [
        22040,
        22129
      ],
      "content": "From the command-line, change directories to the <bpt id=\"p1\">**</bpt>azuread<ept id=\"p1\">**</ept> folder if not already there:"
    },
    {
      "pos": [
        22145,
        22259
      ],
      "content": "Open your <ph id=\"ph1\">`server.js`</ph> file in our favorite editor and add the following information below the configuration entry:"
    },
    {
      "content": "This will connect to the MongoDB server and hand back a Schema object to us.",
      "pos": [
        22383,
        22459
      ]
    },
    {
      "content": "Using the Schema, create our model in the code",
      "pos": [
        22466,
        22512
      ]
    },
    {
      "content": "Below the code you wrote above, add the following code:",
      "pos": [
        22514,
        22569
      ]
    },
    {
      "pos": [
        22886,
        23051
      ],
      "content": "As you can tell from the code, we create our Schema and then create a model object we will use to store our data throughout the code when we define our <bpt id=\"p1\">***</bpt>Routes<ept id=\"p1\">***</ept>."
    },
    {
      "content": "Step 15: Add our Routes for our Task REST API server",
      "pos": [
        23056,
        23108
      ]
    },
    {
      "content": "Now that we have a database model to work with, let's add the routes we will use for our REST API server.",
      "pos": [
        23110,
        23215
      ]
    },
    {
      "content": "About Routes in Restify",
      "pos": [
        23221,
        23244
      ]
    },
    {
      "content": "Routes work in Restify in the exact same way they do using the Express stack.",
      "pos": [
        23246,
        23323
      ]
    },
    {
      "content": "You define routes using the URI that you expect the client applicaitons to call.",
      "pos": [
        23324,
        23404
      ]
    },
    {
      "content": "Usually, you define your routes in a separate file.",
      "pos": [
        23405,
        23456
      ]
    },
    {
      "content": "For our purposes, we will put our routes in the server.js file.",
      "pos": [
        23457,
        23520
      ]
    },
    {
      "content": "We recommend you factor these in to their own file for production use.",
      "pos": [
        23521,
        23591
      ]
    },
    {
      "content": "A typical pattern for a Restify Route is:",
      "pos": [
        23593,
        23634
      ]
    },
    {
      "content": "This is the pattern at the most basic level.",
      "pos": [
        23961,
        24005
      ]
    },
    {
      "content": "Resitfy (and Express) provide much deeper functionaltiy such as defining application types and doing complex routing across different endpoints.",
      "pos": [
        24006,
        24150
      ]
    },
    {
      "content": "For our purposes, we will keep these routes very simply.",
      "pos": [
        24151,
        24207
      ]
    },
    {
      "content": "Add default routes to our server",
      "pos": [
        24214,
        24246
      ]
    },
    {
      "content": "We will now add the basic CRUD routes of Create, Retrieve, Update, and Delete.",
      "pos": [
        24248,
        24326
      ]
    },
    {
      "pos": [
        24328,
        24417
      ],
      "content": "From the command-line, change directories to the <bpt id=\"p1\">**</bpt>azuread<ept id=\"p1\">**</ept> folder if not already there:"
    },
    {
      "pos": [
        24433,
        24559
      ],
      "content": "Open your <ph id=\"ph1\">`server.js`</ph> file in our favorite editor and add the following information below the database entries you made above:"
    },
    {
      "content": "Add some error handling for the routes",
      "pos": [
        27446,
        27484
      ]
    },
    {
      "content": "It makes sense to add some error handling so we can communicate back to the client the problem we encountered in a way it can understand.",
      "pos": [
        27486,
        27623
      ]
    },
    {
      "content": "Add the following code underneath the code you've written above:",
      "pos": [
        27625,
        27689
      ]
    },
    {
      "content": "Step 16: Create your Server!",
      "pos": [
        28934,
        28962
      ]
    },
    {
      "content": "We have our database defined, we have our routes in place, and the last thing to do is add our server instance that will manage our calls.",
      "pos": [
        28964,
        29102
      ]
    },
    {
      "content": "Restify (and Express) have a lot of deep customization you can do for a REST API server, but again we will use the most basic setup for our purposes.",
      "pos": [
        29104,
        29253
      ]
    },
    {
      "content": "Step 17: Before we add OAuth support, let's run the server.",
      "pos": [
        33211,
        33270
      ]
    },
    {
      "content": "It's a good idea to make sure we have no mistakes before we continue on to the OAuth part of the Walkthrough.",
      "pos": [
        33272,
        33381
      ]
    },
    {
      "content": "The easiest way to do this is by using <ph id=\"ph1\">`curl`</ph> in a command line.",
      "pos": [
        33383,
        33447
      ]
    },
    {
      "content": "Before we do that, we need a simple utility that allows us to parse output as JSON.",
      "pos": [
        33448,
        33531
      ]
    },
    {
      "content": "To do that, install the <bpt id=\"p1\">[</bpt>json<ept id=\"p1\">](https://github.com/trentm/json)</ept> tool as all the examples below use that.",
      "pos": [
        33532,
        33635
      ]
    },
    {
      "content": "This installs the JSON tool globally.",
      "pos": [
        33667,
        33704
      ]
    },
    {
      "content": "Now that we've accomplished that - let's play with the server:",
      "pos": [
        33705,
        33767
      ]
    },
    {
      "content": "First, make sure that your monogoDB isntance is running..",
      "pos": [
        33769,
        33826
      ]
    },
    {
      "content": "Then, change to the directory and start curling..",
      "pos": [
        33846,
        33895
      ]
    },
    {
      "content": "Then, we can add a task this way:",
      "pos": [
        34334,
        34367
      ]
    },
    {
      "content": "The response should be:",
      "pos": [
        34436,
        34459
      ]
    },
    {
      "content": "And we can list tasks for Brandon this way:",
      "pos": [
        34720,
        34763
      ]
    },
    {
      "content": "If all this works out, we are ready to add OAuth to the REST API server.",
      "pos": [
        34819,
        34891
      ]
    },
    {
      "content": "Step 18: Add Passport.js code to our REST API Server",
      "pos": [
        34896,
        34948
      ]
    },
    {
      "content": "Now that we have a running REST API (congrats, btw!) let's get to making it useful against Azure AD.",
      "pos": [
        34950,
        35050
      ]
    },
    {
      "pos": [
        35052,
        35141
      ],
      "content": "From the command-line, change directories to the <bpt id=\"p1\">**</bpt>azuread<ept id=\"p1\">**</ept> folder if not already there:"
    },
    {
      "content": "Step 1: Add our Passport modules",
      "pos": [
        35161,
        35193
      ]
    },
    {
      "content": "Open your <ph id=\"ph1\">`server.js`</ph> file in our favorite editor and add the following information below where you previously stated the modules to load.",
      "pos": [
        35195,
        35333
      ]
    },
    {
      "content": "This is towards the top of the file and should be right after the <ph id=\"ph1\">`var aadutils = require('./aadutils');`</ph> import.",
      "pos": [
        35334,
        35447
      ]
    },
    {
      "content": "2. Tell our server we are using authentication",
      "pos": [
        35627,
        35673
      ]
    },
    {
      "pos": [
        35675,
        35857
      ],
      "content": "Open your <ph id=\"ph1\">`server.js`</ph> file in our favorite editor and add the following information <bpt id=\"p1\">**</bpt>below the server.get()<ept id=\"p1\">**</ept> where you defined your Routes but above the <bpt id=\"p2\">**</bpt>server.listen()<ept id=\"p2\">**</ept> method."
    },
    {
      "pos": [
        35860,
        35980
      ],
      "content": "We need to tell Restify to begin using its <ph id=\"ph1\">`authorizationParser()`</ph> and look at the contents of the Authorization header."
    },
    {
      "content": "3. Add the Passport OAuth2 module to our code",
      "pos": [
        36059,
        36104
      ]
    },
    {
      "content": "Here we use the specific OAuth2 parameters we added to the config.js file.",
      "pos": [
        36106,
        36180
      ]
    },
    {
      "content": "If our <ph id=\"ph1\">`aadutils.js`</ph> file did its job parsing our Federation Metadata document, all these values should be populated for us even if they are blank in the config.js file.",
      "pos": [
        36181,
        36350
      ]
    },
    {
      "content": "Step 4: Add Routes for OAuth authentication",
      "pos": [
        36910,
        36953
      ]
    },
    {
      "content": "Step 5: Add a IsAuthenticated() Helper Method to the Routes",
      "pos": [
        37649,
        37708
      ]
    },
    {
      "content": "Step 6: Add a caching mechnaism for the cookies",
      "pos": [
        38183,
        38230
      ]
    },
    {
      "content": "Step 7: Finally, protect some endpoints",
      "pos": [
        38749,
        38788
      ]
    },
    {
      "content": "You protect endpoints by specifying the passport.authenticate() call with the protocol you wish to use.",
      "pos": [
        38790,
        38893
      ]
    },
    {
      "content": "Let's edit our route in our server code to do something more interesting:",
      "pos": [
        38895,
        38968
      ]
    },
    {
      "content": "Step 19: Run your server application again and ensure it rejects you",
      "pos": [
        39081,
        39149
      ]
    },
    {
      "content": "Let's use <ph id=\"ph1\">`curl`</ph> again to see if we now have OAuth2 protection against our endpoints.",
      "pos": [
        39151,
        39236
      ]
    },
    {
      "content": "We will do this before runnning any of our client SDKs against this endpoint.",
      "pos": [
        39237,
        39314
      ]
    },
    {
      "content": "The headers returned should be enough to tell us we are down the right path.",
      "pos": [
        39315,
        39391
      ]
    },
    {
      "content": "First, make sure that your monogoDB isntance is running..",
      "pos": [
        39393,
        39450
      ]
    },
    {
      "content": "Then, change to the directory and start curling..",
      "pos": [
        39470,
        39519
      ]
    },
    {
      "content": "Try a basic GET:",
      "pos": [
        39560,
        39576
      ]
    },
    {
      "content": "A 302 is the response you are looking for here, as that indicates that the Passport layer is trying to redirect to the authorize endpoint, which is exactly what you want.",
      "pos": [
        39885,
        40055
      ]
    },
    {
      "content": "Congratulations!",
      "pos": [
        40060,
        40076
      ]
    },
    {
      "content": "You have a REST API Service using OAuth2!",
      "pos": [
        40077,
        40118
      ]
    },
    {
      "content": "You've went as far as you can with this server without using an OAuth2 compatible client.",
      "pos": [
        40120,
        40209
      ]
    },
    {
      "content": "You will need to go through an additional walkthrough.",
      "pos": [
        40210,
        40264
      ]
    },
    {
      "content": "If you were just looking for information on how to implement a REST API using Restify and OAuth2, you have more than enough code to keep developing your service and learning how to build on this example.",
      "pos": [
        40266,
        40469
      ]
    },
    {
      "content": "If you are interested in the next steps in your ADAL journey, here are some supported ADAL clients we recommend for you to keep working:",
      "pos": [
        40471,
        40607
      ]
    },
    {
      "content": "Simply clone down to your developer machine and configure as stated in the Walkthrough.",
      "pos": [
        40609,
        40696
      ]
    },
    {
      "content": "ADAL for iOS",
      "pos": [
        40699,
        40711
      ]
    },
    {
      "content": "ADAL for Android",
      "pos": [
        40784,
        40800
      ]
    },
    {
      "content": "ADAL for .Net",
      "pos": [
        40877,
        40890
      ]
    },
    {
      "content": "test",
      "pos": [
        41100,
        41104
      ]
    }
  ],
  "content": "<properties\n    pageTitle=\"Azure AD NodeJS Getting Started | Microsoft Azure\"\n    description=\"How to build a Node.js Web API that integrates with Azure AD for authentication.\"\n    services=\"active-directory\"\n    documentationCenter=\"nodejs\"\n    authors=\"brandwe\"\n    manager=\"mbaldwin\"\n    editor=\"\"/>\n\n<tags\n    ms.service=\"active-directory\"\n    ms.workload=\"identity\"\n    ms.tgt_pltfrm=\"na\"\n    ms.devlang=\"javascript\"\n    ms.topic=\"article\"\n    ms.date=\"07/17/2015\"\n    ms.author=\"brandwe\"/>\n\n# Getting Started With WEB-API for Node\n\n[AZURE.INCLUDE [active-directory-devguide](../../includes/active-directory-devguide.md)]\n\nThis walkthrough will give you  a quick and easy way to set up a REST API Service that is integrated with  Azure Active Directory for API protection using the OAuth2 protocol. The sample server included in the download are designed to run on any platform but target OSX and Linux.\n\nBy the end of this walk-through, you should be able to build a running REST API server with the following features:\n\n* A node.js server running an REST API interface with JSON using MongoDB as persistant storage\n* REST APIs leveraging OAuth2 API protection with Bearer tokens using Azure Active Directory\n\n\nWe've released all of the source code for this running example in GitHub under an Apache 2.0 license, so feel free to clone (or even better, fork!) and provide feedback and pull requests.\n\n## About Node.js Modules\n\nWe will be using Node.js modules in this walkthrough. Modules are loadable JavaScript packages that provide specific functionality for your application. You usually install modules by using the Node.js NPM command-line tool in the NPM installation directory, but some modules, such as the HTTP module, are included the core Node.js package.\nInstalled modules are saved in the node_modules directory at the root of your Node.js installation directory. Each module in the node_modules directory maintains its own node_modules directory that contains any modules that it depends on, and each required module has a node_modules directory. This recursive directory structure represents the dependency chain.\n\nThis dependency chain structure results in a larger application footprint, but it guarantees that all dependencies are met and that the version of the modules used in development will also be used in production. This makes the production app behavior more predictable and prevents versioning problems that might affect users.\n\n## Step 1: Register a Azure AD Tenant\n\nTo use this sample you will need a Azure Active Directory Tenant. If you're not sure what a tenant is or how you would get one, see  [How to get an Azure AD tenant](active-directory-howto-tenant.md).\n\n## Step 2: Add A Web API to your tenant\n\nAfter you get your Azure Active Directory tenant, add this sample app to your tenant so you can use it to protect the API.\n\nTo enable your app to authenticate users, you'll first need to register a new application in your tenant.\n\n- Sign into the Azure Management Portal.\n- In the left hand nav, click on **Active Directory**.\n- Select the tenant where you wish to register the application.\n- Click the **Applications** tab, and click add in the bottom drawer.\n- Follow the prompts and create a new **Web Application and/or WebAPI**.\n    - The **name** of the application will describe your application to end-users\n    -   The **Sign-On URL** is the base URL of your app.  The skeleton’s default is `https://localhost:8888`.\n    - The **App ID URI** is a unique identifier for your application.  The convention is to use `https://<tenant-domain>/<app-name>`, e.g. `https://contoso.onmicrosoft.com/my-first-aad-app`\n- Once you’ve completed registration, AAD will assign your app a unique client identifier.  You’ll need this value in the next sections, so copy it from the Configure tab.\n\n## Step 3: Download node.js for your platform\nTo successfully use this sample, you must have a working installation of Node.js.\n\nInstall Node.js from [http://nodejs.org](http://nodejs.org).\n\n## Step 4: Install MongoDB on to your platform\n\nTo successfully use this sample, you must have a working installation of MongoDB. We will use MongoDB to make our REST API persistant across server instances.\n\nInstall MongoDB from [http://mongodb.org](http://www.mongodb.org).\n\n**NOTE:** This walkthrough assumes that you use the default installation and server endpoints for MongoDB, which at the time of this writing is: mongodb://localhost\n\n\n## Step 5: Install the Restify modules in to your Web API\n\nWe will be using Resitfy to build our REST API. Restify is a minimal and flexible Node.js application framework derived from Express that has a robust set of features for building REST APIs on top of Connect.\n\n### Install Restify\n\nFrom the command-line, change directories to the azuread directory. If the **azuread** directory does not exist, create it.\n\n`cd azuread - or- mkdir azuread; cd azuread`\n\nType the following command:\n\n`npm install restify`\n\nThis command installs Restify.\n\n#### DID YOU GET AN ERROR?\n\nWhen using npm on some operating systems, you may receive an error of Error: EPERM, chmod '/usr/local/bin/..' and a request to try running the account as an administrator. If this occurs, use the sudo command to run npm at a higher privilege level.\n\n#### DID YOU GET AN ERROR REGARDING DTRACE?\n\nYou may see something like this when installing Restify:\n\n```Shell\nclang: error: no such file or directory: 'HD/azuread/node_modules/restify/node_modules/dtrace-provider/libusdt'\nmake: *** [Release/DTraceProviderBindings.node] Error 1\ngyp ERR! build error\ngyp ERR! stack Error: `make` failed with exit code: 2\ngyp ERR! stack     at ChildProcess.onExit (/usr/local/lib/node_modules/npm/node_modules/node-gyp/lib/build.js:267:23)\ngyp ERR! stack     at ChildProcess.EventEmitter.emit (events.js:98:17)\ngyp ERR! stack     at Process.ChildProcess._handle.onexit (child_process.js:789:12)\ngyp ERR! System Darwin 13.1.0\ngyp ERR! command \"node\" \"/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js\" \"rebuild\"\ngyp ERR! cwd /Volumes/Development HD/azuread/node_modules/restify/node_modules/dtrace-provider\ngyp ERR! node -v v0.10.11\ngyp ERR! node-gyp -v v0.10.0\ngyp ERR! not ok\nnpm WARN optional dep failed, continuing dtrace-provider@0.2.8\n```\n\n\nRestify provides a powerful mechanism to trace REST calls using DTrace. However, many operating systems do not have DTrace available. You can safely ignore these errors.\n\n\nThe output of this command should appear similar to the following:\n\n\n    restify@2.6.1 node_modules/restify\n    ├── assert-plus@0.1.4\n    ├── once@1.3.0\n    ├── deep-equal@0.0.0\n    ├── escape-regexp-component@1.0.2\n    ├── qs@0.6.5\n    ├── tunnel-agent@0.3.0\n    ├── keep-alive-agent@0.0.1\n    ├── lru-cache@2.3.1\n    ├── node-uuid@1.4.0\n    ├── negotiator@0.3.0\n    ├── mime@1.2.11\n    ├── semver@2.2.1\n    ├── spdy@1.14.12\n    ├── backoff@2.3.0\n    ├── formidable@1.0.14\n    ├── verror@1.3.6 (extsprintf@1.0.2)\n    ├── csv@0.3.6\n    ├── http-signature@0.10.0 (assert-plus@0.1.2, asn1@0.1.11, ctype@0.5.2)\n    └── bunyan@0.22.0 (mv@0.0.5)\n\n\n## Step 6: Install Passport.js in to your Web API\n\n[Passport](http://passportjs.org/) is authentication middleware for Node.js. Extremely flexible and modular, Passport can be unobtrusively dropped in to any Express-based or Resitify web application. A comprehensive set of strategies support authentication using a username and password, Facebook, Twitter, and more. We have developed a strategy for Azure Active Directory. We will install this module and then add the Azure Active Directory strategy plug-in.\n\nFrom the command-line, change directories to the azuread directory.\n\nEnter the following command to install passport.js\n\n`npm install passport`\n\nThe output of the commadn should appear similar to the following:\n\n    passport@0.1.17 node_modules\\passport\n    ├── pause@0.0.1\n    └── pkginfo@0.2.3\n\n## Step 7: Add Passport.js Bearer Token Support to your Web API\n\nNext, we will add the Bearer strategy, using passport-bearer-http, a Bearner handler for [Passport](http://passportjs.org/). We will also add JWT token handler support by using node-jwt.\n\n**NOTE:** Although OAuth2 provides a framework in which any known token type can be issued, only certain token types have gained wide-spread use. For protecting endpoints, that has turned out to be Bearer Tokens. Bearer tokens are the most widely issued type of token in OAuth2, and many implementations assume that bearer tokens are the only type of token issued.\n\nFrom the command-line, change directories to the **azuread** directory.\n\nType the following command to install Passport.js modules:\n\n- `npm install passport-oauth`\n- `npm install passport-http-bearer`\n- `npm install node-jwt`\n\nThe output of the commamd should appear similar to the following:\n\n    ms-passport-wsfed-saml2@0.3.8 node_modules\\passport-oauth  \n    ├── xtend@2.0.3\n    ├── xml-crypto@0.0.9\n    ├── xmldom@0.1.13\n    └── xml2js@0.1.14 (sax@0.5.2)\n\n\n## Step 8: Add MongoDB modules to your Web API\n\nWe will be using MongoDB as our datastore For that reason, we need to install both the widely used plug-in to manage models and schemas called Mongoose, as well as the database driver for MongoDB, also called MongoDB.\n\n\n* `npm install mongoose`\n* `npm install mongodb`\n\n## Step 9:  Install additional modules\n\nNext, we'll install the remaining required modules.\n\n\nFrom the command-line, change directories to the **azuread** folder if not already there:\n\n`cd azuread`\n\n\nEnter the following commands to install the following modules in your node_modules directory:\n\n* `npm install crypto`\n* `npm install assert-plus`\n* `npm install posix-getopt`\n* `npm install util`\n* `npm install path`\n* `npm install connect`\n* `npm install xml-crypto`\n* `npm install xml2js`\n* `npm install xmldom`\n* `npm install async`\n* `npm install request`\n* `npm install underscore`\n* `npm install grunt-contrib-jshint@0.1.1`\n* `npm install grunt-contrib-nodeunit@0.1.2`\n* `npm install grunt-contrib-watch@0.2.0`\n* `npm install grunt@0.4.1`\n* `npm install xtend@2.0.3`\n* `npm install bunyan`\n* `npm update`\n\n\n## Step 10: Create a server.js with your dependencies\n\nThe server.js file will be providing the majority of our functionality for our Web API server. We will be adding most of our code to this file. For production purposes you would refactor the functionality in to smaller files, such as separate routes and controllers. For the purpose of this demo we will use server.js for this functionality.\n\nFrom the command-line, change directories to the **azuread** folder if not already there:\n\n`cd azuread`\n\nCreate a `server.js` file in our favorite editor and add the following information:\n\n```Javascript\n    'use strict';\n\n    /**\n    * Module dependencies.\n    */\n\n    var fs = require('fs');\n    var path = require('path');\n    var util = require('util');\n    var assert = require('assert-plus');\n    var bunyan = require('bunyan');\n    var getopt = require('posix-getopt');\n    var mongoose = require('mongoose/');\n    var restify = require('restify');\n```\n\nSave the file. We will return to it shortly.\n\n## Step 11: Create a config file to store your Azure AD settings\n\nThis code file passes the configuration parameters from your Azure Active Directory Portal to Passport.js. You created these configuration values when you added the Web API to the portal in the first part of the walkthrough. We will explain what to put in the values of these parameters after you've copied the code.\n\n\nFrom the command-line, change directories to the **azuread** folder if not already there:\n\n`cd azuread`\n\nCreate a `config.js` file in our favorite editor and add the following information:\n\n```Javascript\n// Don't commit this file to your public repos\n    exports.creds = {\n    mongoose_auth_local: 'mongodb://localhost/tasklist', // Your mongo auth uri goes here\n    openid_configuration: 'https://login.microsoftonline.com/common/.well-known/openid-configuration', // For using Microsoft you should never need to change this.\n    openid_keys: 'https://login.microsoftonline.com/common/discovery/keys', // For using Microsoft you should never need to change this. If absent will attempt to get from openid_configuration\n}\n\n```\n\n\n\n**NOTE:** You will most likely never need to change these values.\n\n**NOTE:** We roll our keys at frequent intervals. Please ensure that you are always pulling from the \"openid_keys\" URL and that the app can access the internet.\n\n\n## Step 12: Add configuration to your server.js file\n\nWe need to read these values from the Config file you just created across our application. To do this, we simply add the .config file as a required resource in our application and then set the global variables to those in the config.js document\n\nFrom the command-line, change directories to the **azuread** folder if not already there:\n\n`cd azuread`\n\nOpen your `server.js` file in our favorite editor and add the following information:\n\n```Javascript\nvar config = require('./config');\n```\nThen, add a new section to `server.js` with the following code:\n\n```Javascript\n/**\n* Setup some configuration\n*/\nvar mongoose = require('mongoose/');\nvar serverPort = process.env.PORT || 8888;\nvar serverURI = ( process.env.PORT ) ? config.creds.mongoose_auth_mongohq : config.creds.mongoose_auth_local;\n\n```\n## Step 13: Create a metadata.js helper file to aid in parsing metadata/tokens\n\nSince the goal is to keep only application logic in the server.js file, it makes sense to put some helper methods in a separate file. These methods simply help us parse the OpenID Connect metadata and do not relate to the core scenario. It's better to stuff them away. We will be adding more to this file as we go through the Walkthrough.\n\n***NOTE:*** You'll notice that this metadata.js file parses XML for SAML and WS-Fed as well as JSON for OpenID Connect. That is by design as you'll use this file in our other samples as well. You can safely ignore it now.\n\nFrom the command-line, change directories to the **azuread** folder if not already there:\n\n`cd azuread`\n\nCreate a `metadata.js` file in our favorite editor and add the following information:\n\n```Javascript\n\n'use strict';\n\nvar xml2js = require('xml2js');\nvar request = require('request');\nvar aadutils = require('./aadutils');\nvar async = require('async');\n\n// Logging\n\nvar bunyan = require('bunyan');\nvar log = bunyan.createLogger({name: 'Microsoft OpenID Connect Passport Strategy'});\n\nvar Metadata = function (url, authtype) {\n\n\n  if(!url) {\n    throw new Error(\"Metadata: url is a required argument\");\n  }\n  if(!authtype) {\n    throw new Error('OIDCBearerStrategy requires an authentication type specified to metadata parser. Valid types are saml, wsfed, or odic\"');\n  }\n\n  this.url = url;\n  this.metadata = null;\n  this.authtype = authtype;\n  log.info(authtype, 'Metadata requested for authentication type');\n};\n\nObject.defineProperty(Metadata, 'url', {\n  get: function () {\n    return this.url;\n  }\n});\n\nObject.defineProperty(Metadata, 'saml', {\n  get: function () {\n    return this.saml;\n  }\n});\n\nObject.defineProperty(Metadata, 'wsfed', {\n  get: function () {\n    return this.wsfed;\n  }\n});\n\nObject.defineProperty(Metadata, 'oidc', {\n  get: function () {\n    return this.oidc;\n  }\n});\n\n\nObject.defineProperty(Metadata, 'metadata', {\n  get: function () {\n    return this.metadata;\n  }\n});\n\nMetadata.prototype.updateSamlMetadata = function(doc, next) {\n  log.info('Request to update the SAML Metadata');\n  try {\n\n    this.saml = {};\n\n    var entity = aadutils.getElement(doc, 'EntityDescriptor');\n    var idp = aadutils.getElement(entity, 'IDPSSODescriptor');\n    var signOn = aadutils.getElement(idp[0], 'SingleSignOnService');\n    var signOff = aadutils.getElement(idp[0], 'SingleLogoutService');\n    var keyDescriptor = aadutils.getElement(idp[0], 'KeyDescriptor');\n    this.saml.loginEndpoint = signOn[0].$.Location;\n    this.saml.logoutEndpoint = signOff[0].$.Location;\n\n    // copy the x509 certs from the metadata\n    this.saml.certs = [];\n    for (var j=0;j<keyDescriptor.length;j++) {\n      this.saml.certs.push(keyDescriptor[j].KeyInfo[0].X509Data[0].X509Certificate[0]);\n    }\n    next(null);\n  } catch (e) {\n    next(new Error('Invalid SAMLP Federation Metadata ' + e.message));\n  }\n};\n\nMetadata.prototype.updateOidcMetadata = function(doc, next) {\n  log.info('Request to update the Open ID Connect Metadata');\n  try {\n    this.oidc = {};\n\n    var issuer = doc['issuer'];\n    var keyDescriptor = aadutils.getElement(idp[0], 'keys');\n\n    // copy the x509 certs from the metadata\n    this.oidc.certs = [];\n    for (var j=0;j<keyDescriptor.length;j++) {\n      this.oidc.certs.push(keyDescriptor[j].KeyInfo[0].X509Data[0].X509Certificate[0]);\n    }\n    next(null);\n  } catch (e) {\n    next(new Error('Invalid Open ID Connect Federation Metadata ' + e.message));\n  }\n};\n\n\nMetadata.prototype.updateWsfedMetadata = function(doc, next) {\n  log.info('Request to update the WS Federation Metadata');\n  try {\n    this.wsfed = {};\n    var entity = aadutils.getElement(doc, 'EntityDescriptor');\n    var roles = aadutils.getElement(entity, 'RoleDescriptor');\n    for(var i = 0; i < roles.length; i++) {\n      var role = roles[i];\n      if(role['fed:SecurityTokenServiceEndpoint']) {\n        var endpoint = role['fed:SecurityTokenServiceEndpoint'];\n        var endPointReference = aadutils.getFirstElement(endpoint[0],'EndpointReference');\n        this.wsfed.loginEndpoint = aadutils.getFirstElement(endPointReference,'Address');\n\n        var keyDescriptor = aadutils.getElement(role, 'KeyDescriptor');\n        // copy the x509 certs from the metadata\n        this.wsfed.certs = [];\n        for (var j=0;j<keyDescriptor.length;j++) {\n          this.wsfed.certs.push(keyDescriptor[j].KeyInfo[0].X509Data[0].X509Certificate[0]);\n        }\n        break;\n      }\n    }\n\n    return next(null);\n  } catch (e) {\n    next(new Error('Invalid WSFED Federation Metadata ' + e.message));\n  }\n};\n\nMetadata.prototype.fetch = function(callback) {\n  var self = this;\n  log.info(\"Fetching metadata from the provided metadata URL: \" + self.url);\n  async.waterfall([\n    // fetch the Federation metadata for the AAD tenant\n    function(next){\n      request(self.url, function (err, response, body) {\n        if(err) {\n          next(err);\n        } else if(response.statusCode !== 200) {\n          next(new Error(\"Error:\" + response.statusCode +  \" Cannot get AAD Federation metadata from \" + self.url));\n        } else {\n          log.info(body, \"retreived\");\n          next(null, body);\n        }\n      });\n    },\n    function(body, next){\n      // parse the AAD Federation metadata xml\n\n      if(self.authtype == \"saml\" || self.authtype == \"wsfed\") {\n      log.info(body, \"Parsing XML retreived from the endpoint\");\n      var parser = new xml2js.Parser({explicitRoot:true});\n      // Note: xml responses from Azure AAD have a leading \\ufeff which breaks xml2js parser!\n      parser.parseString(body.replace(\"\\ufeff\", \"\"), function (err, data) {\n        self.metatdata = data;\n        next(err);\n\n      });\n    } else if(self.authtype == \"oidc\") {\n      log.info(body, \"Parsing JSON retreived from the endpoint\");\n      JSON.parse(body, function (err, data) {\n        self.metatdata = data;\n        next(err);\n      });\n\n    } else {\n\n       next(new Error(\"Error: No Authentication type specified to metadata parser. Valid types are saml, wsfed, or odic\"));\n    }\n\n    },\n\n    function(next){\n      if(self.authtype = \"saml\") {\n      // update the SAML SSO endpoints and certs from the metadata\n      self.updateSamlMetadata(self.metatdata, next);\n    }},\n    function(next){\n      if(self.authtype = \"wsfed\") {\n      // update the SAML SSO endpoints and certs from the metadata\n      self.updateWsfedMetadata(self.metatdata, next);\n    }},\n    function(next){\n      if(self.authtype = \"oidc\") {\n      self.updateOidcMetadata(self.metadata, next);\n    }},\n  ], function (err) {\n    // return err or success (err === null) to callback\n    callback(err);\n  });\n};\n\nexports.Metadata = Metadata;\n```\nAs you can see from the code, it simply takes the openid URL you passed in `config.js` and then parses it for information which we will use in the `server.js` file. You are more than welcome to investigate this code and expand it if needed.\n\n### Load the metadata.js file in your server.js\n\nWe need to tell our server where to get the methods you jus wrote.\n\nFrom the command-line, change directories to the **azuread** folder if not already there:\n\n`cd azuread`\n\nOpen your `server.js` file in our favorite editor and add the following information:\n\n```Javascript\nvar metadata = require('./metadata);\n```\nNext, add to the end of the `Configuration` section this call to send the metadata document in our `config.js` to the parser we just wrote:\n\n```Javascript\nthis.aadutils = new var Metadata = require('./metadata').Metadata;\n```\n\n## Step 14: Add The MongoDB Model and Schema Information using Moongoose\n\nNow all this preparation is going to start paying off as we wind these three files together in to a REST API service.\n\nFor this walkthrough we will be using MongoDB to store our Tasks as discussed in ***Step 4***.\n\nIf you recall from the `config.js` file we created in ***Step 11*** we called our database `tasklist` as that was what we put at the end of our mogoose_auth_local connection URL. You don't need to create this database beforehand in MongoDB, it will create this for us on first run of our server application (assuming it does not already exist).\n\nNow that we've told the server what MongoDB database we'd like to use, we need to write some additional code to create the model and schema for our server's Tasks.\n\n#### Discussion of the model\n\nOur Schema model is very simple, and you expand it as required.\n\nNAME - The name of who is assigned to the task. A ***String***\n\nTASK - The task itself. A ***String***\n\nDATE - The date that the task is due. A ***DATETIME***\n\nCOMPLETED - If the Task is completed or not. A ***BOOLEAN***\n\n#### Creating the schema in the code\n\n\nFrom the command-line, change directories to the **azuread** folder if not already there:\n\n`cd azuread`\n\nOpen your `server.js` file in our favorite editor and add the following information below the configuration entry:\n\n```Javascript\n/**\n*\n* Connect to MongoDB\n*/\n\nglobal.db = mongoose.connect(serverURI);\nvar Schema = mongoose.Schema;  \n```\nThis will connect to the MongoDB server and hand back a Schema object to us.\n\n#### Using the Schema, create our model in the code\n\nBelow the code you wrote above, add the following code:\n\n```Javascript\n/**\n/ Here we create a schema to store our tasks. Pretty simple schema for now.\n*/\n\nvar TaskSchema = new Schema({\n  owner: String,\n  task: String,\n  completed: Boolean,\n  date: Date\n});\n\n// Use the schema to register a model\n\nmongoose.model('Task', TaskSchema);\nvar Task = mongoose.model('Task');\n```\nAs you can tell from the code, we create our Schema and then create a model object we will use to store our data throughout the code when we define our ***Routes***.\n\n## Step 15: Add our Routes for our Task REST API server\n\nNow that we have a database model to work with, let's add the routes we will use for our REST API server.\n\n### About Routes in Restify\n\nRoutes work in Restify in the exact same way they do using the Express stack. You define routes using the URI that you expect the client applicaitons to call. Usually, you define your routes in a separate file. For our purposes, we will put our routes in the server.js file. We recommend you factor these in to their own file for production use.\n\nA typical pattern for a Restify Route is:\n\n```Javascript\nfunction createObject(req, res, next) {\n\n// do work on Object\n\n _object.name = req.params.object; // passed value is in req.params under object\n\n ///...\n\nreturn next(); // keep the server going\n}\n\n....\n\nserver.post('/service/:add/:object', createObject); // calls createObject on routes that match this.\n\n```\n\n\nThis is the pattern at the most basic level. Resitfy (and Express) provide much deeper functionaltiy such as defining application types and doing complex routing across different endpoints. For our purposes, we will keep these routes very simply.\n\n#### Add default routes to our server\n\nWe will now add the basic CRUD routes of Create, Retrieve, Update, and Delete.\n\nFrom the command-line, change directories to the **azuread** folder if not already there:\n\n`cd azuread`\n\nOpen your `server.js` file in our favorite editor and add the following information below the database entries you made above:\n\n```Javascript\n\n/**\n *\n * APIs\n */\n\nfunction createTask(req, res, next) {\n\n    // Resitify currently has a bug which doesn't allow you to set default headers\n    // This headers comply with CORS and allow us to mongodbServer our response to any origin\n\n  res.header(\"Access-Control-Allow-Origin\", \"*\");\n  res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\");\n\n    // Create a new task model, fill it up and save it to Mongodb\n  var _task = new Task();\n\n        if (!req.params.task) {\n                req.log.warn('createTask: missing task');\n                next(new MissingTaskError());\n                return;\n        }\n\n\n  _task.owner = req.params.owner;\n   _task.task = req.params.task;\n   _task.date = new Date();\n\n  _task.save(function (err) {\n    if (err) {\n        req.log.warn(err, 'createTask: unable to save');\n        next(err);\n    } else {\n    res.send(201, _task);\n\n            }\n  });\n\n  return next();\n\n}\n\n\n/**\n * Deletes a Task by name\n */\nfunction removeTask(req, res, next) {\n\n        Task.remove( { task:req.params.task }, function (err) {\n                if (err) {\n                        req.log.warn(err,\n                                     'removeTask: unable to delete %s',\n                                     req.params.task);\n                        next(err);\n                } else {\n                        res.send(204);\n                        next();\n                }\n        });\n}\n\n/**\n * Deletes all Tasks. A wipe\n */\nfunction removeAll(req, res, next) {\n        Task.remove();\n        res.send(204);\n        return next();\n}    });\n}\n\n\n/**\n *\n *\n *\n */\nfunction getTask(req, res, next) {\n\n\n        Task.find(req.params.name, function (err, data) {\n                if (err) {\n                        req.log.warn(err, 'get: unable to read %s', req.params.name);\n                        next(err);\n                        return;\n                }\n\n                res.json(data);\n        });\n\n        return next();\n}\n\n\n/**\n * Simple returns the list of TODOs that were loaded.\n *\n */\n\nfunction listTasks(req, res, next) {\n  // Resitify currently has a bug which doesn't allow you to set default headers\n  // This headers comply with CORS and allow us to mongodbServer our response to any origin\n\n  res.header(\"Access-Control-Allow-Origin\", \"*\");\n  res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\");\n\n  console.log(\"server getTasks\");\n\n  Task.find().limit(20).sort('date').exec(function (err,data) {\n\n    if (err)\n      return next(err);\n\n    if (data.length > 0) {\n            console.log(data);\n        }\n\n    if (!data.length) {\n            console.log('there was a problem');\n            console.log(err);\n            console.log(\"There is no tasks in the database. Did you initalize the database as stated in the README?\");\n        }\n\n    else {\n\n        res.json(data);\n\n        }\n  });\n\n  return next();\n}\n```\n\n### Add some error handling for the routes\n\nIt makes sense to add some error handling so we can communicate back to the client the problem we encountered in a way it can understand.\n\nAdd the following code underneath the code you've written above:\n\n```Javascript\n///--- Errors for communicating something interesting back to the client\n\nfunction MissingTaskError() {\n        restify.RestError.call(this, {\n                statusCode: 409,\n                restCode: 'MissingTask',\n                message: '\"task\" is a required parameter',\n                constructorOpt: MissingTaskError\n        });\n\n        this.name = 'MissingTaskError';\n}\nutil.inherits(MissingTaskError, restify.RestError);\n\n\nfunction TaskExistsError(name) {\n        assert.string(name, 'name');\n\n        restify.RestError.call(this, {\n                statusCode: 409,\n                restCode: 'TaskExists',\n                message: name + ' already exists',\n                constructorOpt: TaskExistsError\n        });\n\n        this.name = 'TaskExistsError';\n}\nutil.inherits(TaskExistsError, restify.RestError);\n\n\nfunction TaskNotFoundError(name) {\n        assert.string(name, 'name');\n\n        restify.RestError.call(this, {\n                statusCode: 404,\n                restCode: 'TaskNotFound',\n                message: name + ' was not found',\n                constructorOpt: TaskNotFoundError\n        });\n\n        this.name = 'TaskNotFoundError';\n}\n\nutil.inherits(TaskNotFoundError, restify.RestError);\n```\n\n\n## Step 16: Create your Server!\n\nWe have our database defined, we have our routes in place, and the last thing to do is add our server instance that will manage our calls.\n\nRestify (and Express) have a lot of deep customization you can do for a REST API server, but again we will use the most basic setup for our purposes.\n\n```Javascript\n/**\n * Our Server\n */\n\n\nvar server = restify.createServer({\n        name: \"Azure Active Directroy TODO Server\",\n    version: \"1.0.0\",\n    formatters: {\n        'application/json': function(req, res, body){\n            if(req.params.callback){\n                var callbackFunctionName = req.params.callback.replace(/[^A-Za-z0-9_\\.]/g, '');\n                return callbackFunctionName + \"(\" + JSON.stringify(body) + \");\";\n            } else {\n                return JSON.stringify(body);\n            }\n        },\n        'text/html': function(req, res, body){\n            if (body instanceof Error)\n                        return body.stack;\n\n                      if (Buffer.isBuffer(body))\n                        return body.toString('base64');\n\n                return util.inspect(body);\n        },\n        'application/x-www-form-urlencoded': function(req, res, body){\n            if (body instanceof Error) {\n                    res.statusCode = body.statusCode || 500;\n                    body = body.message;\n            } else if (typeof (body) === 'object') {\n                body = body.task || JSON.stringify(body);\n            } else {\n                body = body.toString();\n            }\n\n        res.setHeader('Content-Length', Buffer.byteLength(body));\n        return (body);\n        }\n    }\n});\n\n        // Ensure we don't drop data on uploads\n        server.pre(restify.pre.pause());\n\n        // Clean up sloppy paths like //todo//////1//\n        server.pre(restify.pre.sanitizePath());\n\n        // Handles annoying user agents (curl)\n        server.pre(restify.pre.userAgentConnection());\n\n        // Set a per request bunyan logger (with requestid filled in)\n        server.use(restify.requestLogger());\n\n        // Allow 5 requests/second by IP, and burst to 10\n        server.use(restify.throttle({\n                burst: 10,\n                rate: 5,\n                ip: true,\n        }));\n\n        // Use the common stuff you probably want\n        server.use(restify.acceptParser(server.acceptable));\n        server.use(restify.dateParser());\n        server.use(restify.queryParser());\n        server.use(restify.gzipResponse());\n\n        // This lets us push JSON to the REST API endpoint as well. Maps x: y as /name:value\n\n        server.use(restify.bodyParser({ mapParams: false }));\n\n        /// Now the real handlers. Here we just CRUD\n\n        server.get('/tasks', listTasks);\n        server.head('/tasks', listTasks);\n        server.get('/tasks/:name', getTask);\n        server.head('/tasks/:name', getTask);\n        server.post('/tasks/:name/:task', createTask);\n        server.del('/tasks/:name/:task', removeTask);\n        server.del('/tasks/:name', removeTask);\n        server.del('/tasks', removeAll, function respond(req, res, next) { res.send(204); next(); });\n\n\n        // Register a default '/' handler\n\n        server.get('/', function root(req, res, next) {\n                var routes = [\n                        'GET     /',\n                        'POST    /tasks/:name/:task',\n                        'GET     /tasks',\n                        'PUT     /tasks/:name',\n                        'GET     /tasks/:name',\n                        'DELETE  /tasks/:name/:task'\n                ];\n                res.send(200, routes);\n                next();\n        });\n\n  server.listen(serverPort, function() {\n\n  var consoleMessage = '\\n Azure Active Directory Tutorial'\n  consoleMessage += '\\n +++++++++++++++++++++++++++++++++++++++++++++++++++++'\n  consoleMessage += '\\n %s server is listening at %s';\n  consoleMessage += '\\n Open your browser to %s/tasks\\n';\n  consoleMessage += '+++++++++++++++++++++++++++++++++++++++++++++++++++++ \\n'\n  consoleMessage += '\\n !!! why not try a $curl -isS %s | json to get some ideas? \\n'\n  consoleMessage += '+++++++++++++++++++++++++++++++++++++++++++++++++++++ \\n\\n'  \n\n  console.log(consoleMessage, server.name, server.url, server.url, server.url);\n\n});\n```\n\n## Step 17: Before we add OAuth support, let's run the server.\n\nIt's a good idea to make sure we have no mistakes before we continue on to the OAuth part of the Walkthrough.\n\nThe easiest way to do this is by using `curl` in a command line. Before we do that, we need a simple utility that allows us to parse output as JSON. To do that, install the [json](https://github.com/trentm/json) tool as all the examples below use that.\n\n    $npm install -g jsontool\n\nThis installs the JSON tool globally. Now that we've accomplished that - let's play with the server:\n\nFirst, make sure that your monogoDB isntance is running..\n\n    $sudo mongod\n\nThen, change to the directory and start curling..\n\n    $ cd azuread\n    $ node server.js\n\n    $ curl -isS http://127.0.0.1:8888 | json\n    HTTP/1.1 200 OK\n    Connection: close\n    Content-Type: application/x-www-form-urlencoded\n    Content-Length: 145\n    Date: Wed, 29 Jan 2014 03:41:24 GMT\n\n    [\n    \"GET     /\",\n    \"POST    /tasks/:owner/:task\",\n    \"GET     /tasks\",\n    \"DELETE  /tasks\",\n    \"PUT     /tasks/:owner\",\n    \"GET     /tasks/:owner\",\n    \"DELETE  /tasks/:task\"\n    ]\n\nThen, we can add a task this way:\n\n    $ curl -isS -X POST http://127.0.0.1:8888/tasks/brandon/Hello\n\nThe response should be:\n\n    HTTP/1.1 201 Created\n    Connection: close\n    Access-Control-Allow-Origin: *\n    Access-Control-Allow-Headers: X-Requested-With\n    Content-Type: application/x-www-form-urlencoded\n    Content-Length: 5\n    Date: Tue, 04 Feb 2014 01:02:26 GMT\n\n    Hello\n\nAnd we can list tasks for Brandon this way:\n\n    $ curl -isS http://127.0.0.1:8888/tasks/brandon/\n\nIf all this works out, we are ready to add OAuth to the REST API server.\n\n## Step 18: Add Passport.js code to our REST API Server\n\nNow that we have a running REST API (congrats, btw!) let's get to making it useful against Azure AD.\n\nFrom the command-line, change directories to the **azuread** folder if not already there:\n\n`cd azuread`\n\n### Step 1: Add our Passport modules\n\nOpen your `server.js` file in our favorite editor and add the following information below where you previously stated the modules to load. This is towards the top of the file and should be right after the `var aadutils = require('./aadutils');` import.\n\n```Javascript\n/*\n*\n* Load our old friend Passport for OAuth2 flows\n*/\n\nvar passport = require('passport')\n  , OAuth2Strategy = require('passport-oauth').OAuth2Strategy;\n```\n\n### 2. Tell our server we are using authentication\n\nOpen your `server.js` file in our favorite editor and add the following information **below the server.get()** where you defined your Routes but above the **server.listen()** method.\n\n\nWe need to tell Restify to begin using its `authorizationParser()` and look at the contents of the Authorization header.\n\n```Javascript\n        server.use(restify.authorizationParser());\n\n\n```\n\n\n### 3. Add the Passport OAuth2 module to our code\n\nHere we use the specific OAuth2 parameters we added to the config.js file. If our `aadutils.js` file did its job parsing our Federation Metadata document, all these values should be populated for us even if they are blank in the config.js file.\n\n```Javascript\n// Now our own handlers for authentication/authorization\n// Here we only use Oauth2 from Passport.js\n\npassport.use('provider', new OAuth2Strategy({\n    authorizationURL: authEndpoint,\n    tokenURL: tokenEndpoint,\n    clientID: clientID,\n    clientSecret: clientSecret,\n    callbackURL: callbackURL\n  },\n  function(accessToken, refreshToken, profile, done) {\n    User.findOrCreate({ UserId: profile.id }, function(err, user) {\n      done(err, user);\n    });\n  }\n));\n\n// Let's start using Passport.js\n\nserver.use(passport.initialize());\n\n```\n### Step 4: Add Routes for OAuth authentication\n\n```Javascript\n// Redirect the user to the OAuth 2.0 provider for authentication.  When\n// complete, the provider will redirect the user back to the application at\n//     /auth/provider/callback\n\nserver.get('/auth/provider', passport.authenticate('provider'));\n\n// The OAuth 2.0 provider has redirected the user back to the application.\n// Finish the authentication process by attempting to obtain an access\n// token.  If authorization was granted, the user will be logged in.\n// Otherwise, authentication has failed.\n\nserver.get('/auth/provider/callback',\n  passport.authenticate('provider', { successRedirect: '/',\n                                      failureRedirect: '/login' }));\n```\n\n### Step 5: Add a IsAuthenticated() Helper Method to the Routes\n\n```Javascript\n// Simple route middleware to ensure user is authenticated.\n//   Use this route middleware on any resource that needs to be protected.  If\n//   the request is authenticated (typically via a persistent login session),\n//   the request will proceed.  Otherwise, the user will be redirected to the\n//   login page.\n\nvar ensureAuthenticated = function(req, res, next) {\n  if (req.isAuthenticated()) {\n    return next();\n  }\n  res.redirect('/login');\n};\n\n```\n\n### Step 6: Add a caching mechnaism for the cookies\n\n```Javascript\n// Passport session setup.\n//   To support persistent login sessions, Passport needs to be able to\n//   serialize users into and deserialize users out of the session.  Typically,\n//   this will be as simple as storing the user ID when serializing, and finding\n//   the user by ID when deserializing.\npassport.serializeUser(function(user, done) {\n  done(null, user.email);\n});\n\npassport.deserializeUser(function(id, done) {\n  findByEmail(id, function (err, user) {\n    done(err, user);\n  });\n});\n```\n### Step 7: Finally, protect some endpoints\n\nYou protect endpoints by specifying the passport.authenticate() call with the protocol you wish to use.\n\nLet's edit our route in our server code to do something more interesting:\n\n```Javascript\nserver.get('/tasks', passport.authenticate('provider', { session: false }), listTasks);\n```\n\n\n## Step 19: Run your server application again and ensure it rejects you\n\nLet's use `curl` again to see if we now have OAuth2 protection against our endpoints. We will do this before runnning any of our client SDKs against this endpoint. The headers returned should be enough to tell us we are down the right path.\n\nFirst, make sure that your monogoDB isntance is running..\n\n    $sudo mongod\n\nThen, change to the directory and start curling..\n\n    $ cd azuread\n    $ node server.js\n\nTry a basic GET:\n\n    $ curl -isS http://127.0.0.1:8888/tasks/\n    HTTP/1.1 302 Moved Temporarily\n    Connection: close\n    Location: https://login.windows.net/468a75f4-f9a7-4dc4-a527-4f4522734790/oauth2/authorize?response_type=code&redirect_uri=&client_id=123\n    Content-Length: 0\n    Date: Tue, 04 Feb 2014 02:15:14 GMT\n\n\nA 302 is the response you are looking for here, as that indicates that the Passport layer is trying to redirect to the authorize endpoint, which is exactly what you want.\n\n## Congratulations! You have a REST API Service using OAuth2!\n\nYou've went as far as you can with this server without using an OAuth2 compatible client. You will need to go through an additional walkthrough.\n\nIf you were just looking for information on how to implement a REST API using Restify and OAuth2, you have more than enough code to keep developing your service and learning how to build on this example.\n\nIf you are interested in the next steps in your ADAL journey, here are some supported ADAL clients we recommend for you to keep working:\n\nSimply clone down to your developer machine and configure as stated in the Walkthrough.\n\n[ADAL for iOS](https://github.com/MSOpenTech/azure-activedirectory-library-for-ios)\n\n[ADAL for Android](https://github.com/MSOpenTech/azure-activedirectory-library-for-android)\n\n[ADAL for .Net](http://msdn.microsoft.com/library/windowsazure/jj573266.aspx)\n\n[AZURE.INCLUDE [active-directory-devquickstarts-additional-resources](../../includes/active-directory-devquickstarts-additional-resources.md)]\n \ntest\n"
}