<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Reliable Collections</source>
          <target state="new">Reliable Collections</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Reliable Collections enable you to write highly available, scalable, and low latency cloud applications.</source>
          <target state="new">Reliable Collections enable you to write highly available, scalable, and low latency cloud applications.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Reliable Collections</source>
          <target state="new">Reliable Collections</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Reliable Collections enable you to write highly available, scalable, and low latency</source>
          <target state="new">Reliable Collections enable you to write highly available, scalable, and low latency</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>cloud applications as though you are writing single machine applications.</source>
          <target state="new">cloud applications as though you are writing single machine applications.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The classes in the <ph id="ph1">`Microsoft.ServiceFabric.Data.Collections`</ph> namespace provide a set of out-of-the-box</source>
          <target state="new">The classes in the <ph id="ph1">`Microsoft.ServiceFabric.Data.Collections`</ph> namespace provide a set of out-of-the-box</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>collections that automatically make your state highly available.</source>
          <target state="new">collections that automatically make your state highly available.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Developers need only to program to the Reliable Collection APIs and let Reliable Collections</source>
          <target state="new">Developers need only to program to the Reliable Collection APIs and let Reliable Collections</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>manage the replicated and local state.</source>
          <target state="new">manage the replicated and local state.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The key difference between Reliable Collections and other high-availability technologies</source>
          <target state="new">The key difference between Reliable Collections and other high-availability technologies</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>(such as Redis, Azure Table service, and Azure Queue service) is that the state is</source>
          <target state="new">(such as Redis, Azure Table service, and Azure Queue service) is that the state is</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>kept locally in the service instance while also being made highly available.</source>
          <target state="new">kept locally in the service instance while also being made highly available.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This means that:</source>
          <target state="new">This means that:</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>All reads are local, which results in low latency and high throughput reads.</source>
          <target state="new">All reads are local, which results in low latency and high throughput reads.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>All writes incur the minimum number of network IOs, which results in low latency and high throughput writes.</source>
          <target state="new">All writes incur the minimum number of network IOs, which results in low latency and high throughput writes.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Image of Evolution of Collections.</source>
          <target state="new">Image of Evolution of Collections.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Reliable Collections can be thought of as the natural evolution of the <ph id="ph1">`System.Collections`</ph></source>
          <target state="new">Reliable Collections can be thought of as the natural evolution of the <ph id="ph1">`System.Collections`</ph></target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>classes: a new set of collections that are designed for the cloud and multi-machine</source>
          <target state="new">classes: a new set of collections that are designed for the cloud and multi-machine</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>applications without increasing complexity for the developer.</source>
          <target state="new">applications without increasing complexity for the developer.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>As such, they are:</source>
          <target state="new">As such, they are:</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Replicated: State changes are replicated for high availability.</source>
          <target state="new">Replicated: State changes are replicated for high availability.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Persisted: Data is persisted to disk for durability against large-scale outages (for example, a datacenter power outage).</source>
          <target state="new">Persisted: Data is persisted to disk for durability against large-scale outages (for example, a datacenter power outage).</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Asynchronous: APIs are asynchronous to ensure threads are not blocked when incurring IO.</source>
          <target state="new">Asynchronous: APIs are asynchronous to ensure threads are not blocked when incurring IO.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Transactional: APIs utilize the abstraction of transactions to allow you to manage multiple Reliable Collections within a service easily.</source>
          <target state="new">Transactional: APIs utilize the abstraction of transactions to allow you to manage multiple Reliable Collections within a service easily.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Reliable Collections provide strong consistency guarantees out of the box in order</source>
          <target state="new">Reliable Collections provide strong consistency guarantees out of the box in order</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>to make reasoning about application state easier.</source>
          <target state="new">to make reasoning about application state easier.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Strong consistency is achieved by ensuring transaction commits only complete after the entire transaction</source>
          <target state="new">Strong consistency is achieved by ensuring transaction commits only complete after the entire transaction</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>has been applied on a quorum of replicas including the primary.</source>
          <target state="new">has been applied on a quorum of replicas including the primary.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>To achieve weaker consistency, application can acknowledge back to the client / requester</source>
          <target state="new">To achieve weaker consistency, application can acknowledge back to the client / requester</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>before the asynchronous commit returns.</source>
          <target state="new">before the asynchronous commit returns.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The Reliable Collections APIs are an evolution of concurrent collections APIs</source>
          <target state="new">The Reliable Collections APIs are an evolution of concurrent collections APIs</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>(found in the <ph id="ph1">`System.Collections.Concurrent`</ph> namespace):</source>
          <target state="new">(found in the <ph id="ph1">`System.Collections.Concurrent`</ph> namespace):</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Asynchronous: Returns a Task since, unlike Reliable Collections, the operations are replicated and persisted.</source>
          <target state="new">Asynchronous: Returns a Task since, unlike Reliable Collections, the operations are replicated and persisted.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>No out parameters: Uses <ph id="ph1">`ConditionalResult&lt;T&gt;`</ph> to return a bool and a value instead of out parameters.</source>
          <target state="new">No out parameters: Uses <ph id="ph1">`ConditionalResult&lt;T&gt;`</ph> to return a bool and a value instead of out parameters.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ConditionalResult&lt;T&gt;`</ph> is like <ph id="ph2">`Nullable&lt;T&gt;`</ph> but does not require T to be a struct.</source>
          <target state="new"><ph id="ph1">`ConditionalResult&lt;T&gt;`</ph> is like <ph id="ph2">`Nullable&lt;T&gt;`</ph> but does not require T to be a struct.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Transactions: Uses a transaction object to enable the user to group actions on multiple Reliable Collections in a transaction.</source>
          <target state="new">Transactions: Uses a transaction object to enable the user to group actions on multiple Reliable Collections in a transaction.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Today, <ph id="ph1">`Microsoft.ServiceFabric.Data.Collections`</ph> contains two collections:</source>
          <target state="new">Today, <ph id="ph1">`Microsoft.ServiceFabric.Data.Collections`</ph> contains two collections:</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Reliable Dictionary<ept id="p1">](https://msdn.microsoft.com/library/azure/dn971511.aspx)</ept>: Represents a replicated, transactional, and asynchronous collection of key/value pairs.</source>
          <target state="new"><bpt id="p1">[</bpt>Reliable Dictionary<ept id="p1">](https://msdn.microsoft.com/library/azure/dn971511.aspx)</ept>: Represents a replicated, transactional, and asynchronous collection of key/value pairs.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Similar to <ph id="ph1">`ConcurrentDictionary`</ph>, both the key and the value can be of any type.</source>
          <target state="new">Similar to <ph id="ph1">`ConcurrentDictionary`</ph>, both the key and the value can be of any type.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Reliable Queue<ept id="p1">](https://msdn.microsoft.com/library/azure/dn971527.aspx)</ept>: Represents a replicated, transactional, and asynchronous strict first-in first-out (FIFO) queue.</source>
          <target state="new"><bpt id="p1">[</bpt>Reliable Queue<ept id="p1">](https://msdn.microsoft.com/library/azure/dn971527.aspx)</ept>: Represents a replicated, transactional, and asynchronous strict first-in first-out (FIFO) queue.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Similar to <ph id="ph1">`ConcurrentQueue`</ph>, the value can be of any type.</source>
          <target state="new">Similar to <ph id="ph1">`ConcurrentQueue`</ph>, the value can be of any type.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Isolation Levels</source>
          <target state="new">Isolation Levels</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Isolation level is a measure of the degree isolation is achieved.</source>
          <target state="new">Isolation level is a measure of the degree isolation is achieved.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Isolation means that a transaction behaves as it would in a system that only allows</source>
          <target state="new">Isolation means that a transaction behaves as it would in a system that only allows</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>one transaction to be in-flight at any given point of time.</source>
          <target state="new">one transaction to be in-flight at any given point of time.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Reliable Collections automatically choose the isolation level to use for a given</source>
          <target state="new">Reliable Collections automatically choose the isolation level to use for a given</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>read operation depending on the operation and the role of the replica.</source>
          <target state="new">read operation depending on the operation and the role of the replica.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>There are two isolation levels that are supported in Reliable Collections:</source>
          <target state="new">There are two isolation levels that are supported in Reliable Collections:</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Repeatable Read<ept id="p1">**</ept>: "Specifies that statements cannot read data that has been modified but not yet committed by other transactions and that no other transactions can modify data that has been read by the current transaction until the current transaction completes.</source>
          <target state="new"><bpt id="p1">**</bpt>Repeatable Read<ept id="p1">**</ept>: "Specifies that statements cannot read data that has been modified but not yet committed by other transactions and that no other transactions can modify data that has been read by the current transaction until the current transaction completes.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>(https://msdn.microsoft.com/en-us/library/ms173763.aspx)"</source>
          <target state="new">(https://msdn.microsoft.com/en-us/library/ms173763.aspx)"</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Snapshot<ept id="p1">**</ept>: "Specifies that data read by any statement in a transaction will be the transactionally consistent version of the data that existed at the start of the transaction.</source>
          <target state="new"><bpt id="p1">**</bpt>Snapshot<ept id="p1">**</ept>: "Specifies that data read by any statement in a transaction will be the transactionally consistent version of the data that existed at the start of the transaction.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The transaction can only recognize data modifications that were committed before the start of the transaction.</source>
          <target state="new">The transaction can only recognize data modifications that were committed before the start of the transaction.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Data modifications made by other transactions after the start of the current transaction are not visible to statements executing in the current transaction.</source>
          <target state="new">Data modifications made by other transactions after the start of the current transaction are not visible to statements executing in the current transaction.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The effect is as if the statements in a transaction get a snapshot of the committed data as it existed at the start of the transaction.</source>
          <target state="new">The effect is as if the statements in a transaction get a snapshot of the committed data as it existed at the start of the transaction.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>(https://msdn.microsoft.com/en-us/library/ms173763.aspx)"</source>
          <target state="new">(https://msdn.microsoft.com/en-us/library/ms173763.aspx)"</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Both the Reliable Dictionary and the Reliable Queue support Read Your Writes.</source>
          <target state="new">Both the Reliable Dictionary and the Reliable Queue support Read Your Writes.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In other words, any write within a transaction will be visible to a following read</source>
          <target state="new">In other words, any write within a transaction will be visible to a following read</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>that belongs to the same transaction.</source>
          <target state="new">that belongs to the same transaction.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Reliable Dictionary</source>
          <target state="new">Reliable Dictionary</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Operation \ Role</source>
          <target state="new">Operation \ Role</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Primary</source>
          <target state="new">Primary</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Secondary</source>
          <target state="new">Secondary</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Single Entity Read</source>
          <target state="new">Single Entity Read</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Repeatable Read</source>
          <target state="new">Repeatable Read</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Snapshot</source>
          <target state="new">Snapshot</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Enumeration \ Count</source>
          <target state="new">Enumeration \ Count</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Snapshot</source>
          <target state="new">Snapshot</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Snapshot</source>
          <target state="new">Snapshot</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Reliable Queue</source>
          <target state="new">Reliable Queue</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Operation \ Role</source>
          <target state="new">Operation \ Role</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Primary</source>
          <target state="new">Primary</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Secondary</source>
          <target state="new">Secondary</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Single Entity Read</source>
          <target state="new">Single Entity Read</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Snapshot</source>
          <target state="new">Snapshot</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Snapshot</source>
          <target state="new">Snapshot</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Enumeration \ Count</source>
          <target state="new">Enumeration \ Count</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Snapshot</source>
          <target state="new">Snapshot</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Snapshot</source>
          <target state="new">Snapshot</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Persistence Model</source>
          <target state="new">Persistence Model</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Reliable State Manager and Reliable Collections follow a persistence model that is called Log and Checkpoint.</source>
          <target state="new">Reliable State Manager and Reliable Collections follow a persistence model that is called Log and Checkpoint.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>This is a model where each state change is logged on disk and only applied in memory.</source>
          <target state="new">This is a model where each state change is logged on disk and only applied in memory.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The complete state itself is only persisted occasionally (aka.</source>
          <target state="new">The complete state itself is only persisted occasionally (aka.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Checkpoint).</source>
          <target state="new">Checkpoint).</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The benefit it provides is:</source>
          <target state="new">The benefit it provides is:</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Deltas are turned into sequential append-only writes on disk for improved performance.</source>
          <target state="new">Deltas are turned into sequential append-only writes on disk for improved performance.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>To better understand the log and checkpoint model, let’s first look at the infinite disk scenario.</source>
          <target state="new">To better understand the log and checkpoint model, let’s first look at the infinite disk scenario.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Reliable State Manager logs every operation before it is replicated.</source>
          <target state="new">Reliable State Manager logs every operation before it is replicated.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>This allows the Reliable Collection to only apply the operation in memory.</source>
          <target state="new">This allows the Reliable Collection to only apply the operation in memory.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Since logs are persisted, even when the replica fails and needs to be restarted, the Reliable State Manager</source>
          <target state="new">Since logs are persisted, even when the replica fails and needs to be restarted, the Reliable State Manager</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>has enough information in its logs to replay all the operations the replica has lost.</source>
          <target state="new">has enough information in its logs to replay all the operations the replica has lost.</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>As disk is infinite, log records never need to be removed and the Reliable Collection only needs to manage the in-memory state.</source>
          <target state="new">As disk is infinite, log records never need to be removed and the Reliable Collection only needs to manage the in-memory state.</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Now let’s look at the finite disk scenario.</source>
          <target state="new">Now let’s look at the finite disk scenario.</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>At one point the Reliable State Manager will run out of disk space.</source>
          <target state="new">At one point the Reliable State Manager will run out of disk space.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Before that happens the Reliable State Manager needs to truncate its log to make room for the newer records.</source>
          <target state="new">Before that happens the Reliable State Manager needs to truncate its log to make room for the newer records.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>It will request the Reliable Collections to checkpoint their in-memory state.</source>
          <target state="new">It will request the Reliable Collections to checkpoint their in-memory state.</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>It is the Reliable Collection's responsibility to persist its state up to that point.</source>
          <target state="new">It is the Reliable Collection's responsibility to persist its state up to that point.</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Once the Reliable Collections complete their checkpoints, the Reliable State Manager can truncate the log to free up disk space.</source>
          <target state="new">Once the Reliable Collections complete their checkpoints, the Reliable State Manager can truncate the log to free up disk space.</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>This way, when the replica needs to be restarted, Reliable Collections will recover their</source>
          <target state="new">This way, when the replica needs to be restarted, Reliable Collections will recover their</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>checkpointed state, and the Reliable State Manager will recover and play back all the state changes that occurred</source>
          <target state="new">checkpointed state, and the Reliable State Manager will recover and play back all the state changes that occurred</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>since the checkpoint.</source>
          <target state="new">since the checkpoint.</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Locking</source>
          <target state="new">Locking</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>In Reliable Collections, all transactions are two-phased: a transaction does not release</source>
          <target state="new">In Reliable Collections, all transactions are two-phased: a transaction does not release</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>the locks it has acquired until the transaction terminates with either an abort or commit.</source>
          <target state="new">the locks it has acquired until the transaction terminates with either an abort or commit.</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Reliable Collections always take Exclusive locks.</source>
          <target state="new">Reliable Collections always take Exclusive locks.</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>For reads, the locking is dependent on couple of factors.</source>
          <target state="new">For reads, the locking is dependent on couple of factors.</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Any read operation done using Shapshot Isolation is lock free.</source>
          <target state="new">Any read operation done using Shapshot Isolation is lock free.</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Any Repeatable read operation by default takes Shared locks.</source>
          <target state="new">Any Repeatable read operation by default takes Shared locks.</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>However, for any read operation that supports Repeatable Read, user can ask for an</source>
          <target state="new">However, for any read operation that supports Repeatable Read, user can ask for an</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Update lock instead of the Shared lock.</source>
          <target state="new">Update lock instead of the Shared lock.</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Update lock is an asymmetric lock used to prevent a common form of deadlock that</source>
          <target state="new">Update lock is an asymmetric lock used to prevent a common form of deadlock that</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>occurs when multiple transactions lock resources for potential update at a later time.</source>
          <target state="new">occurs when multiple transactions lock resources for potential update at a later time.</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The lock compatibility matrix can be found below:</source>
          <target state="new">The lock compatibility matrix can be found below:</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Request \ Granted</source>
          <target state="new">Request \ Granted</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="new">None</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Shared</source>
          <target state="new">Shared</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="new">Update</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Exclusive</source>
          <target state="new">Exclusive</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Shared</source>
          <target state="new">Shared</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>No Conflict</source>
          <target state="new">No Conflict</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>No Conflict</source>
          <target state="new">No Conflict</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Conflict</source>
          <target state="new">Conflict</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Conflict</source>
          <target state="new">Conflict</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="new">Update</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>No Conflict</source>
          <target state="new">No Conflict</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>No Conflict</source>
          <target state="new">No Conflict</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Conflict</source>
          <target state="new">Conflict</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Conflict</source>
          <target state="new">Conflict</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Exclusive</source>
          <target state="new">Exclusive</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>No Conflict</source>
          <target state="new">No Conflict</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Conflict</source>
          <target state="new">Conflict</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Conflict</source>
          <target state="new">Conflict</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Conflict</source>
          <target state="new">Conflict</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Note that timeout argument in the Reliable Collections APIs are used as a deadlock detection.</source>
          <target state="new">Note that timeout argument in the Reliable Collections APIs are used as a deadlock detection.</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>For example, two transactions (T1 and T2) are trying to read and update K1.</source>
          <target state="new">For example, two transactions (T1 and T2) are trying to read and update K1.</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>It is possible for them to deadlock, because they both end up having the Shared lock.</source>
          <target state="new">It is possible for them to deadlock, because they both end up having the Shared lock.</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>In this case, one or both of the operations will timeout.</source>
          <target state="new">In this case, one or both of the operations will timeout.</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Note that the above deadlock scenario is a great example of how Update lock can prevent deadlocks.</source>
          <target state="new">Note that the above deadlock scenario is a great example of how Update lock can prevent deadlocks.</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Recommendations</source>
          <target state="new">Recommendations</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>DO NOT<ept id="p1">**</ept> modify an object of custom type returned by read operations (e.g <ph id="ph1">`TryPeekAsync`</ph> or <ph id="ph2">`TryGetAsync`</ph>).</source>
          <target state="new"><bpt id="p1">**</bpt>DO NOT<ept id="p1">**</ept> modify an object of custom type returned by read operations (e.g <ph id="ph1">`TryPeekAsync`</ph> or <ph id="ph2">`TryGetAsync`</ph>).</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Reliable Collections, just like Concurrent Collections, return a reference to the objects and not a copy.</source>
          <target state="new">Reliable Collections, just like Concurrent Collections, return a reference to the objects and not a copy.</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>DO<ept id="p1">**</ept> deep copy returned object of custom type before modifying it.</source>
          <target state="new"><bpt id="p1">**</bpt>DO<ept id="p1">**</ept> deep copy returned object of custom type before modifying it.</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Since, structs and built-in types are pass-by-value, you do not need to do a deep copy on them.</source>
          <target state="new">Since, structs and built-in types are pass-by-value, you do not need to do a deep copy on them.</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>DO NOT<ept id="p1">**</ept> use <ph id="ph1">`TimeSpan.MaxValue`</ph> for timeouts.</source>
          <target state="new"><bpt id="p1">**</bpt>DO NOT<ept id="p1">**</ept> use <ph id="ph1">`TimeSpan.MaxValue`</ph> for timeouts.</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Timeouts should be used to detect deadlocks.</source>
          <target state="new">Timeouts should be used to detect deadlocks.</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>DO NOT<ept id="p1">**</ept> create a transaction within another transaction’s <ph id="ph1">`using`</ph> statement because it can cause deadlocks.</source>
          <target state="new"><bpt id="p1">**</bpt>DO NOT<ept id="p1">**</ept> create a transaction within another transaction’s <ph id="ph1">`using`</ph> statement because it can cause deadlocks.</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Here are some things to keep in mind:</source>
          <target state="new">Here are some things to keep in mind:</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The default timeout is 4 seconds for all the Reliable Collection APIs.</source>
          <target state="new">The default timeout is 4 seconds for all the Reliable Collection APIs.</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Most users should not override this.</source>
          <target state="new">Most users should not override this.</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The default cancellation token is <ph id="ph1">`CancellationToken.None`</ph> in all Reliable Collections APIs.</source>
          <target state="new">The default cancellation token is <ph id="ph1">`CancellationToken.None`</ph> in all Reliable Collections APIs.</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Enumerations are snapshot consistent within a collection.</source>
          <target state="new">Enumerations are snapshot consistent within a collection.</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>However, enumerations of multiple collections are not consistent across collections.</source>
          <target state="new">However, enumerations of multiple collections are not consistent across collections.</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>To achieve high availability for the Reliable Collections, each service should have at least a target and minimum replica set size of 3.</source>
          <target state="new">To achieve high availability for the Reliable Collections, each service should have at least a target and minimum replica set size of 3.</target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="new">Next Steps</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Reliable Services Quick Start</source>
          <target state="new">Reliable Services Quick Start</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Getting Started with Service Fabric Web API services</source>
          <target state="new">Getting Started with Service Fabric Web API services</target>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Advanced usage of the Reliable Services programming model</source>
          <target state="new">Advanced usage of the Reliable Services programming model</target>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Developer reference for Reliable Collections</source>
          <target state="new">Developer reference for Reliable Collections</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">16da82de845941284f45b6e6979a93de1445c941</xliffext:olfilehash>
  </header>
</xliff>