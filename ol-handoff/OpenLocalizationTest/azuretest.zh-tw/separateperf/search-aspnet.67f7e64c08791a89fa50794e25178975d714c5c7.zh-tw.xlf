<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Connect Azure Search with ASP.NET Web Apps | Microsoft Azure</source>
          <target state="new">Connect Azure Search with ASP.NET Web Apps | Microsoft Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Hook up an ASP.NET Web app with Azure Search.</source>
          <target state="new">Hook up an ASP.NET Web app with Azure Search.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Learn how to connect, query, and render results using the .Net library or REST API.</source>
          <target state="new">Learn how to connect, query, and render results using the .Net library or REST API.</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>How to integrate Azure Search with ASP.NET Web Apps</source>
          <target state="new">How to integrate Azure Search with ASP.NET Web Apps</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>ASP.NET is the predominant web application framework in custom solutions that integrate with Azure Search.</source>
          <target state="new">ASP.NET is the predominant web application framework in custom solutions that integrate with Azure Search.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>In this article, you’ll learn how to connect your ASP.NET web app to Azure Search, ramp up on design patterns for common operations, and review a few coding practices that could help your development experience go more smoothly.</source>
          <target state="new">In this article, you’ll learn how to connect your ASP.NET web app to Azure Search, ramp up on design patterns for common operations, and review a few coding practices that could help your development experience go more smoothly.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Organize your code</source>
          <target state="new">Organize your code</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Splitting your workloads up into standalone projects within the same Visual Studio solution gives you more flexibility in how you design, maintain, and run each program.</source>
          <target state="new">Splitting your workloads up into standalone projects within the same Visual Studio solution gives you more flexibility in how you design, maintain, and run each program.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>We recommend three:</source>
          <target state="new">We recommend three:</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Index creation code</source>
          <target state="new">Index creation code</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Data ingestion code</source>
          <target state="new">Data ingestion code</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>User interaction code</source>
          <target state="new">User interaction code</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>In Azure Search, indexing operations and document operations – such as adding or updating documents, or executing queries – are fully independent of each other.</source>
          <target state="new">In Azure Search, indexing operations and document operations – such as adding or updating documents, or executing queries – are fully independent of each other.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>This means you can decouple index management from your ASP.NET user interaction code that formulates search requests and renders the results.</source>
          <target state="new">This means you can decouple index management from your ASP.NET user interaction code that formulates search requests and renders the results.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>In most of our code samples, the index is both created and loaded in one project (referred to as DataIndexer, CatalogIndexer, or DataCatalog in various samples), while the code that handles search requests and responses is placed in an ASP.NET MVC application project.</source>
          <target state="new">In most of our code samples, the index is both created and loaded in one project (referred to as DataIndexer, CatalogIndexer, or DataCatalog in various samples), while the code that handles search requests and responses is placed in an ASP.NET MVC application project.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>In code samples, its practical to bundle index creation and document upload in one project, but production code would probably isolate these operations.</source>
          <target state="new">In code samples, its practical to bundle index creation and document upload in one project, but production code would probably isolate these operations.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Once an index is created, it’s rarely changed (and if it does change, it needs to be rebuilt), whereas documents are likely to be refreshed on a recurring basis.</source>
          <target state="new">Once an index is created, it’s rarely changed (and if it does change, it needs to be rebuilt), whereas documents are likely to be refreshed on a recurring basis.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Separating the workloads provides other advantages in the form of different levels of permissions for Azure Search (full admin rights versus query-only rights), use of different programming languages, more specific dependencies per program, plus the ability to revise programs independently or create multiple front-end applications that all operate on the index built and maintained by a central indexing application.</source>
          <target state="new">Separating the workloads provides other advantages in the form of different levels of permissions for Azure Search (full admin rights versus query-only rights), use of different programming languages, more specific dependencies per program, plus the ability to revise programs independently or create multiple front-end applications that all operate on the index built and maintained by a central indexing application.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Samples and demos using ASP.NET and Azure Search</source>
          <target state="new">Samples and demos using ASP.NET and Azure Search</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Several code samples already exist that show how Search integrates with ASP.NET.</source>
          <target state="new">Several code samples already exist that show how Search integrates with ASP.NET.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>You can go straight to code or a demo app by visiting any of these links:</source>
          <target state="new">You can go straight to code or a demo app by visiting any of these links:</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>New York City (NYC) jobs demo site</source>
          <target state="new">New York City (NYC) jobs demo site</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Try App Service + Azure Search</source>
          <target state="new">Try App Service + Azure Search</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Complete list of videos, tutorials, demos, and code samples</source>
          <target state="new">Complete list of videos, tutorials, demos, and code samples</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Connect to the service</source>
          <target state="new">Connect to the service</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>To establish a connection to the service and issue requests, your Web application only needs three things:</source>
          <target state="new">To establish a connection to the service and issue requests, your Web application only needs three things:</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>A URL to the Azure Search service you’ve provisioned, formatted as https://&lt;service-name&gt;.search.windows.net</source>
          <target state="new">A URL to the Azure Search service you’ve provisioned, formatted as https://&lt;service-name&gt;.search.windows.net</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>An API key (GUID) that authenticates the connection to Azure Search</source>
          <target state="new">An API key (GUID) that authenticates the connection to Azure Search</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>An HTTPClient or SearchServiceClient to formulate the connection request</source>
          <target state="new">An HTTPClient or SearchServiceClient to formulate the connection request</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>URLs and API Keys</source>
          <target state="new">URLs and API Keys</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>You can find the URL and API key in the <bpt id="p1">[</bpt>portal<ept id="p1">](search-create-service-portal.md)</ept> or retrieve them programmatically using the <bpt id="p2">[</bpt>Management REST API<ept id="p2">](https://msdn.microsoft.com/library/dn832684.aspx)</ept>.</source>
          <target state="new">You can find the URL and API key in the <bpt id="p1">[</bpt>portal<ept id="p1">](search-create-service-portal.md)</ept> or retrieve them programmatically using the <bpt id="p2">[</bpt>Management REST API<ept id="p2">](https://msdn.microsoft.com/library/dn832684.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Typically, both URL and key are placed in the web.config file of your user interaction program:</source>
          <target state="new">Typically, both URL and key are placed in the web.config file of your user interaction program:</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The Search service name can be the short name you specified during provisioning as long as you append the domain (search.windows.net) on the connection, or you could specify the fully qualified name (&lt;service-name&gt;.search.windows.net) in web.config, without the HTTPS prefix.</source>
          <target state="new">The Search service name can be the short name you specified during provisioning as long as you append the domain (search.windows.net) on the connection, or you could specify the fully qualified name (&lt;service-name&gt;.search.windows.net) in web.config, without the HTTPS prefix.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The API key is an authentication token generated during service provisioning (admin keys only) or generated by hand if you are creating query keys in the portal.</source>
          <target state="new">The API key is an authentication token generated during service provisioning (admin keys only) or generated by hand if you are creating query keys in the portal.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The type of key determines which search operations are available to your application:</source>
          <target state="new">The type of key determines which search operations are available to your application:</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>admin keys (read-write permissions, 2 per service)</source>
          <target state="new">admin keys (read-write permissions, 2 per service)</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>query keys (read-only, up to 50 per service)</source>
          <target state="new">query keys (read-only, up to 50 per service)</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>All API keys are GUIDs.</source>
          <target state="new">All API keys are GUIDs.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Visually, there is no distinction between admin and query keys.</source>
          <target state="new">Visually, there is no distinction between admin and query keys.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>You would need to check the portal or use the Management REST API to determine the type of key.</source>
          <target state="new">You would need to check the portal or use the Management REST API to determine the type of key.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.TIP]</ph> A query key delivers a read-only experience to the client.</source>
          <target state="new"><ph id="ph1">[AZURE.TIP]</ph> A query key delivers a read-only experience to the client.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>See the <bpt id="p1">[</bpt>TryAppService + Azure Search<ept id="p1">](search-tryappservice.md)</ept> to test-drive the Azure Search operations that are available in a read-only service.</source>
          <target state="new">See the <bpt id="p1">[</bpt>TryAppService + Azure Search<ept id="p1">](search-tryappservice.md)</ept> to test-drive the Azure Search operations that are available in a read-only service.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Note that in TryAppService, the Web app code is fully modifiable – you can change any of the C# code in the ASP.NET project to modify web page layout, search query construction, or search results—it’s just the Azure Search service index and document load operations that are read-only, per the inclusion of a query api-key on the service connection.</source>
          <target state="new">Note that in TryAppService, the Web app code is fully modifiable – you can change any of the C# code in the ASP.NET project to modify web page layout, search query construction, or search results—it’s just the Azure Search service index and document load operations that are read-only, per the inclusion of a query api-key on the service connection.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Client Connection</source>
          <target state="new">Client Connection</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The next two code snippets set up a connection to the Search service using the URL and API key.</source>
          <target state="new">The next two code snippets set up a connection to the Search service using the URL and API key.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Recall that the service name and API keys are specified in web.config file.</source>
          <target state="new">Recall that the service name and API keys are specified in web.config file.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For REST calls, admin keys must be passed in the request header, while query keys could be passed in the header or directly in the URL.</source>
          <target state="new">For REST calls, admin keys must be passed in the request header, while query keys could be passed in the header or directly in the URL.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>HttpClient<ept id="p1">](https://msdn.microsoft.com/library/system.net.http.httpclient.aspx)</ept> with REST API calls</source>
          <target state="new"><bpt id="p1">[</bpt>HttpClient<ept id="p1">](https://msdn.microsoft.com/library/system.net.http.httpclient.aspx)</ept> with REST API calls</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>SearchServiceClient<ept id="p1">](https://msdn.microsoft.com/library/azure/microsoft.azure.search.searchserviceclient.aspx)</ept> with .NET</source>
          <target state="new"><bpt id="p1">[</bpt>SearchServiceClient<ept id="p1">](https://msdn.microsoft.com/library/azure/microsoft.azure.search.searchserviceclient.aspx)</ept> with .NET</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Design patterns</source>
          <target state="new">Design patterns</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>A Web app that integrates with Azure Search will need to formulate queries and render the results.</source>
          <target state="new">A Web app that integrates with Azure Search will need to formulate queries and render the results.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>This section provides guidance on how to structure code for tasks executed in a program that contains user interaction code.</source>
          <target state="new">This section provides guidance on how to structure code for tasks executed in a program that contains user interaction code.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Schema definition, index generation, and data ingestion are purposely excluded.</source>
          <target state="new">Schema definition, index generation, and data ingestion are purposely excluded.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For guidance on how to code those operations, see the walkthroughs and samples listed in <bpt id="p1">[</bpt>Videos, samples, and tutorials in Azure Search<ept id="p1">](search-video-demo-tutorial-list.md)</ept>.</source>
          <target state="new">For guidance on how to code those operations, see the walkthroughs and samples listed in <bpt id="p1">[</bpt>Videos, samples, and tutorials in Azure Search<ept id="p1">](search-video-demo-tutorial-list.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Query formulation</source>
          <target state="new">Query formulation</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>A full-text search over your index is executed on fields marked as <bpt id="p1">**</bpt>isSearchable<ept id="p1">**</ept> in the schema that defines the index.</source>
          <target state="new">A full-text search over your index is executed on fields marked as <bpt id="p1">**</bpt>isSearchable<ept id="p1">**</ept> in the schema that defines the index.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Given a search term input (represented below by string "q"), the search engine looks for a match inside all searchable fields, and returns results from fields marked as <bpt id="p1">**</bpt>isRetrievable<ept id="p1">**</ept>.</source>
          <target state="new">Given a search term input (represented below by string "q"), the search engine looks for a match inside all searchable fields, and returns results from fields marked as <bpt id="p1">**</bpt>isRetrievable<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> While most fields are likely to be searchable, an index could contain fields used only in filter expressions, in which case you would mark them as non-searchable to exclude them from full-text search and non-retrievable to exclude them from the search results.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> While most fields are likely to be searchable, an index could contain fields used only in filter expressions, in which case you would mark them as non-searchable to exclude them from full-text search and non-retrievable to exclude them from the search results.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>A search query wraps the input term provided by the user into a Search request that specifies the target index, plus parameters used to filter or refine the request.</source>
          <target state="new">A search query wraps the input term provided by the user into a Search request that specifies the target index, plus parameters used to filter or refine the request.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Operators embedded within the search string, such as +, - or |, are handled automatically, which means there are no coding requirements for parsing a search term.</source>
          <target state="new">Operators embedded within the search string, such as +, - or |, are handled automatically, which means there are no coding requirements for parsing a search term.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Any parsing is done by the search engine, as an internal operation.</source>
          <target state="new">Any parsing is done by the search engine, as an internal operation.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>You can assume that the string you pass in will be parsed and analyzed by the engine.</source>
          <target state="new">You can assume that the string you pass in will be parsed and analyzed by the engine.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>A search query comes in two flavors: <bpt id="p1">**</bpt>Search<ept id="p1">**</ept> or <bpt id="p2">**</bpt>Suggestions<ept id="p2">**</ept>.</source>
          <target state="new">A search query comes in two flavors: <bpt id="p1">**</bpt>Search<ept id="p1">**</ept> or <bpt id="p2">**</bpt>Suggestions<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>You would define separate methods for each type of query.</source>
          <target state="new">You would define separate methods for each type of query.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Search<ept id="p1">**</ept> is full-text search over fields in your index.</source>
          <target state="new"><bpt id="p1">**</bpt>Search<ept id="p1">**</ept> is full-text search over fields in your index.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Suggestions<ept id="p1">**</ept> is the type-ahead or auto-complete query feature in Azure Search that builds a list of potential search terms based on the first three characters of user input.</source>
          <target state="new"><bpt id="p1">**</bpt>Suggestions<ept id="p1">**</ept> is the type-ahead or auto-complete query feature in Azure Search that builds a list of potential search terms based on the first three characters of user input.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>In most cases, you would constrain <bpt id="p1">**</bpt>Suggestions<ept id="p1">**</ept> to just those fields that contain relatively unique or distinctive values (like a product or publication name), as opposed to a fields that contain undifferentiated data.</source>
          <target state="new">In most cases, you would constrain <bpt id="p1">**</bpt>Suggestions<ept id="p1">**</ept> to just those fields that contain relatively unique or distinctive values (like a product or publication name), as opposed to a fields that contain undifferentiated data.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The following code snippet captures a search term input in a program that uses the REST API.</source>
          <target state="new">The following code snippet captures a search term input in a program that uses the REST API.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The input term is represented by string q, and the remaining parameters are used to pass in filter values from a faceted navigation structure on the same search page.</source>
          <target state="new">The input term is represented by string q, and the remaining parameters are used to pass in filter values from a faceted navigation structure on the same search page.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Both the input term and filter parameters are used in the Search method.</source>
          <target state="new">Both the input term and filter parameters are used in the Search method.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Search<ept id="p1">**</ept> method that accepts this query is defined as follows.</source>
          <target state="new">The <bpt id="p1">**</bpt>Search<ept id="p1">**</ept> method that accepts this query is defined as follows.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Notice that it defines the parameters on the query string, plus the faceted navigation structure (supported through filters that do the heavy lifting on narrowing search results), and sort order.</source>
          <target state="new">Notice that it defines the parameters on the query string, plus the faceted navigation structure (supported through filters that do the heavy lifting on narrowing search results), and sort order.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>A .NET method that constructs a search string could be placed in an MVC view or in a controller.</source>
          <target state="new">A .NET method that constructs a search string could be placed in an MVC view or in a controller.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>This function passes the string to the Home controller.</source>
          <target state="new">This function passes the string to the Home controller.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>It also defines a data structure for the results.</source>
          <target state="new">It also defines a data structure for the results.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>A .NET method for invoking <bpt id="p1">**</bpt>Search<ept id="p1">**</ept> might look like this, contained in the main C# program that provides the connection and search operation:</source>
          <target state="new">A .NET method for invoking <bpt id="p1">**</bpt>Search<ept id="p1">**</ept> might look like this, contained in the main C# program that provides the connection and search operation:</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Handling search results</source>
          <target state="new">Handling search results</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Search results are returned as a rowset composed of fields that are marked in the index schema as isRetrievable.</source>
          <target state="new">Search results are returned as a rowset composed of fields that are marked in the index schema as isRetrievable.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>One of the simpler ways to render a result set is by using the ViewBag system object in MVC.</source>
          <target state="new">One of the simpler ways to render a result set is by using the ViewBag system object in MVC.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The following code snippet is from Index.cshtml in the <bpt id="p1">[</bpt>AdventureWorksDemo project on CodePlex<ept id="p1">](https://azuresearchadventureworksdemo.codeplex.com/)</ept>.</source>
          <target state="new">The following code snippet is from Index.cshtml in the <bpt id="p1">[</bpt>AdventureWorksDemo project on CodePlex<ept id="p1">](https://azuresearchadventureworksdemo.codeplex.com/)</ept>.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Faceted navigation</source>
          <target state="new">Faceted navigation</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>In the same Index.cshmtl file, you can find the HTML used to build a faceted navigation structure that provides classifications for self-directed filtering, progressively narrowing search results by color, price or category.</source>
          <target state="new">In the same Index.cshmtl file, you can find the HTML used to build a faceted navigation structure that provides classifications for self-directed filtering, progressively narrowing search results by color, price or category.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Hit highlighting</source>
          <target state="new">Hit highlighting</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Applying a style to the instance of the search term in a search result is called hit highlighting.</source>
          <target state="new">Applying a style to the instance of the search term in a search result is called hit highlighting.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>In Azure Search, hit highlights are specified in the query, via the highlight search parameter, to which you give a comma-delimited list of fields to scan for matching terms.</source>
          <target state="new">In Azure Search, hit highlights are specified in the query, via the highlight search parameter, to which you give a comma-delimited list of fields to scan for matching terms.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The actual style you apply is up to you.</source>
          <target state="new">The actual style you apply is up to you.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The following three code snippets are from the <bpt id="p1">[</bpt>TryAppService + Azure Search tutorial<ept id="p1">](search-tryappservice.md)</ept>.</source>
          <target state="new">The following three code snippets are from the <bpt id="p1">[</bpt>TryAppService + Azure Search tutorial<ept id="p1">](search-tryappservice.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>First, specify hit highlights as a search parameter and list the fields to check for matching terms.</source>
          <target state="new">First, specify hit highlights as a search parameter and list the fields to check for matching terms.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Specify the HTML style to use on hit highlight.</source>
          <target state="new">Specify the HTML style to use on hit highlight.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Next, iterate through the search results to find the string that needs to be highlighted.</source>
          <target state="new">Next, iterate through the search results to find the string that needs to be highlighted.</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>private HtmlString RenderHitHighlightedString(SearchResult item, string fieldName)</source>
          <target state="new">private HtmlString RenderHitHighlightedString(SearchResult item, string fieldName)</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Last, provide the layout of the search results, specifying the result set that was evaluated in the previous snippet.</source>
          <target state="new">Last, provide the layout of the search results, specifying the result set that was evaluated in the previous snippet.</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Common coding practices</source>
          <target state="new">Common coding practices</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>New to MVC, .NET programming, or REST APIs?</source>
          <target state="new">New to MVC, .NET programming, or REST APIs?</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>These sections offer a few coding practices to help you get up to speed.</source>
          <target state="new">These sections offer a few coding practices to help you get up to speed.</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>MVC template</source>
          <target state="new">MVC template</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The following table summarizes how MVC template components are used in applications that include Azure Search.</source>
          <target state="new">The following table summarizes how MVC template components are used in applications that include Azure Search.</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>If you’re using MVC 4 or MVC 5, code that integrates Azure Search will generally be added to these modules</source>
          <target state="new">If you’re using MVC 4 or MVC 5, code that integrates Azure Search will generally be added to these modules</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>File</source>
          <target state="new">File</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="new">Description</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Web.config</source>
          <target state="new">Web.config</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Provide the service URL and api-key.</source>
          <target state="new">Provide the service URL and api-key.</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Add a reference to System.Configuration in your main program module to read the values.</source>
          <target state="new">Add a reference to System.Configuration in your main program module to read the values.</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Program.cs</source>
          <target state="new">Program.cs</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>In the main program, set up an HttpClient or SearchServiceClient to establish a connection to the service.</source>
          <target state="new">In the main program, set up an HttpClient or SearchServiceClient to establish a connection to the service.</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Add the Search method to this program.</source>
          <target state="new">Add the Search method to this program.</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>DataModel</source>
          <target state="new">DataModel</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Not used.</source>
          <target state="new">Not used.</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Assuming that index creation and data load operations are in different programs, no data model is required for Azure Search in your web application.</source>
          <target state="new">Assuming that index creation and data load operations are in different programs, no data model is required for Azure Search in your web application.</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Views</source>
          <target state="new">Views</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>A view contains the HTML for the application web page, from search box input to dynamic HTML for handling search results.</source>
          <target state="new">A view contains the HTML for the application web page, from search box input to dynamic HTML for handling search results.</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Controllers</source>
          <target state="new">Controllers</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Query construction and error handling is typically found in the HomeContoller.cs.</source>
          <target state="new">Query construction and error handling is typically found in the HomeContoller.cs.</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>At a minimum, the controller should include a search method that retrieves results from Azure Search and forwards the result set to the view.</source>
          <target state="new">At a minimum, the controller should include a search method that retrieves results from Azure Search and forwards the result set to the view.</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Optionally, if you are using suggestions for auto-complete queries, you would include a method that returns suggested queries, depending on whether your index contains a matching value to the search term input provided by the user.</source>
          <target state="new">Optionally, if you are using suggestions for auto-complete queries, you would include a method that returns suggested queries, depending on whether your index contains a matching value to the search term input provided by the user.</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>When to use the .NET client library vs. REST API</source>
          <target state="new">When to use the .NET client library vs. REST API</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>For ASP.NET applications, the .NET client library is considered a better choice because it sets up the HTTP connection and handles JSON serialization and deserialization for you, which simplifies your code.</source>
          <target state="new">For ASP.NET applications, the .NET client library is considered a better choice because it sets up the HTTP connection and handles JSON serialization and deserialization for you, which simplifies your code.</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>In some cases, your choice of API might be dictated by feature parity between the two approaches.</source>
          <target state="new">In some cases, your choice of API might be dictated by feature parity between the two approaches.</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Generally, the <bpt id="p1">[</bpt>.NET client library<ept id="p1">](https://msdn.microsoft.com/library/azure/dn951165.aspx)</ept> and <bpt id="p2">[</bpt>Service REST API<ept id="p2">](https://msdn.microsoft.com/library/azure/dn798935.aspx)</ept> are interchangeable so long as the operations you require are implemented in both.</source>
          <target state="new">Generally, the <bpt id="p1">[</bpt>.NET client library<ept id="p1">](https://msdn.microsoft.com/library/azure/dn951165.aspx)</ept> and <bpt id="p2">[</bpt>Service REST API<ept id="p2">](https://msdn.microsoft.com/library/azure/dn798935.aspx)</ept> are interchangeable so long as the operations you require are implemented in both.</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>However, sometimes new features show up first in the REST API as part of a preview release, and only added to the .NET library months later.</source>
          <target state="new">However, sometimes new features show up first in the REST API as part of a preview release, and only added to the .NET library months later.</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>For example, indexers, which are used to automate data load operations from specific data source types, appeared in preview REST API first before showing up in the client library a few months later.</source>
          <target state="new">For example, indexers, which are used to automate data load operations from specific data source types, appeared in preview REST API first before showing up in the client library a few months later.</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Any restrictions on feature implementation are noted in feature documentation.</source>
          <target state="new">Any restrictions on feature implementation are noted in feature documentation.</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Include AzureSearchHelper.cs for JSON serialization and deserialization in REST API</source>
          <target state="new">Include AzureSearchHelper.cs for JSON serialization and deserialization in REST API</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Unlike the .NET library which does this step for you, the Service REST APIs must serialize and deserialize the JSON documents in the request-response exchange with the service.</source>
          <target state="new">Unlike the .NET library which does this step for you, the Service REST APIs must serialize and deserialize the JSON documents in the request-response exchange with the service.</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>JSON is the payload format for data transmission when loading or refreshing documents in the index.</source>
          <target state="new">JSON is the payload format for data transmission when loading or refreshing documents in the index.</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Code for JSON serialization can be found in several of samples, in a file named <bpt id="p1">**</bpt>AzureSearchHelper.cs<ept id="p1">**</ept>:</source>
          <target state="new">Code for JSON serialization can be found in several of samples, in a file named <bpt id="p1">**</bpt>AzureSearchHelper.cs<ept id="p1">**</ept>:</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="new">Next steps</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>To further your understanding of Azure Search and ASP.NET integration, visit the following links:</source>
          <target state="new">To further your understanding of Azure Search and ASP.NET integration, visit the following links:</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>How to use Azure Search from a .NET Application</source>
          <target state="new">How to use Azure Search from a .NET Application</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Azure Search Developer Case Study</source>
          <target state="new">Azure Search Developer Case Study</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Typical workflow for Azure Search development</source>
          <target state="new">Typical workflow for Azure Search development</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cd9ae9b9878204b0563c34a98ac750bfd39b5ec8</xliffext:olfilehash>
  </header>
</xliff>