<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>DocumentDB programming: Stored procedures, triggers, and UDFs | Microsoft Azure</source>
          <target state="new">DocumentDB programming: Stored procedures, triggers, and UDFs | Microsoft Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Find out how to use Microsoft Azure DocumentDB to write stored procedures, triggers, and user defined functions (UDFs) natively in JavaScript.</source>
          <target state="new">Find out how to use Microsoft Azure DocumentDB to write stored procedures, triggers, and user defined functions (UDFs) natively in JavaScript.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>DocumentDB server-side programming: Stored procedures, triggers, and UDFs</source>
          <target state="new">DocumentDB server-side programming: Stored procedures, triggers, and UDFs</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Learn how DocumentDB’s language integrated, transactional execution of JavaScript lets developers write <bpt id="p1">**</bpt>stored procedures<ept id="p1">**</ept>, <bpt id="p2">**</bpt>triggers<ept id="p2">**</ept> and <bpt id="p3">**</bpt>user defined functions (UDFs)<ept id="p3">**</ept> natively in JavaScript.</source>
          <target state="new">Learn how DocumentDB’s language integrated, transactional execution of JavaScript lets developers write <bpt id="p1">**</bpt>stored procedures<ept id="p1">**</ept>, <bpt id="p2">**</bpt>triggers<ept id="p2">**</ept> and <bpt id="p3">**</bpt>user defined functions (UDFs)<ept id="p3">**</ept> natively in JavaScript.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This allows you to write application logic that can be shipped and executed directly on the database storage partitions</source>
          <target state="new">This allows you to write application logic that can be shipped and executed directly on the database storage partitions</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>We recommend getting started by watching the following video, where Andrew Liu provides a brief introduction to DocumentDB's server-side programming model.</source>
          <target state="new">We recommend getting started by watching the following video, where Andrew Liu provides a brief introduction to DocumentDB's server-side programming model.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Then, return to this article, where you'll learn the answers to the following questions:</source>
          <target state="new">Then, return to this article, where you'll learn the answers to the following questions:</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>How do I write a a stored procedure, trigger, or UDF using JavaScript?</source>
          <target state="new">How do I write a a stored procedure, trigger, or UDF using JavaScript?</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>How does DocumentDB guarantee ACID?</source>
          <target state="new">How does DocumentDB guarantee ACID?</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>How do transactions work in DocumentDB?</source>
          <target state="new">How do transactions work in DocumentDB?</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>What are pre-triggers and post-triggers and how do I write one?</source>
          <target state="new">What are pre-triggers and post-triggers and how do I write one?</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>How do I register and execute a stored procedure, trigger, or UDF in a RESTful manner by using HTTP?</source>
          <target state="new">How do I register and execute a stored procedure, trigger, or UDF in a RESTful manner by using HTTP?</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>What DocumentDB SDKs are available to create and execute stored procedures, triggers, and UDFs?</source>
          <target state="new">What DocumentDB SDKs are available to create and execute stored procedures, triggers, and UDFs?</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="new">Introduction</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>This approach of <bpt id="p1">*</bpt>“JavaScript as a modern day T-SQL”<ept id="p1">*</ept> frees application developers from the complexities of type system mismatches and object-relational mapping technologies.</source>
          <target state="new">This approach of <bpt id="p1">*</bpt>“JavaScript as a modern day T-SQL”<ept id="p1">*</ept> frees application developers from the complexities of type system mismatches and object-relational mapping technologies.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>It also has a number of intrinsic advantages that can be utilized to build rich applications:</source>
          <target state="new">It also has a number of intrinsic advantages that can be utilized to build rich applications:</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Procedural Logic:<ept id="p1">**</ept> JavaScript as a high level programming language, provides a rich and familiar interface to express business logic.</source>
          <target state="new"><bpt id="p1">**</bpt>Procedural Logic:<ept id="p1">**</ept> JavaScript as a high level programming language, provides a rich and familiar interface to express business logic.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You can perform complex sequences of operations closer to the data.</source>
          <target state="new">You can perform complex sequences of operations closer to the data.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Atomic Transactions:<ept id="p1">**</ept> DocumentDB guarantees that database operations performed inside a single stored procedure or trigger are atomic.</source>
          <target state="new"><bpt id="p1">**</bpt>Atomic Transactions:<ept id="p1">**</ept> DocumentDB guarantees that database operations performed inside a single stored procedure or trigger are atomic.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This lets an application combine related operations in a single batch so that either all of them succeed or none of them succeed.</source>
          <target state="new">This lets an application combine related operations in a single batch so that either all of them succeed or none of them succeed.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Performance:<ept id="p1">**</ept> The fact that JSON is intrinsically mapped to the Javascript language type system and is also the basic unit of storage in DocumentDB allows for a number of optimizations like lazy materialization of JSON documents in the buffer pool and making them available on-demand to the executing code.</source>
          <target state="new"><bpt id="p1">**</bpt>Performance:<ept id="p1">**</ept> The fact that JSON is intrinsically mapped to the Javascript language type system and is also the basic unit of storage in DocumentDB allows for a number of optimizations like lazy materialization of JSON documents in the buffer pool and making them available on-demand to the executing code.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>There are more performance benefits associated with shipping business logic to the database:</source>
          <target state="new">There are more performance benefits associated with shipping business logic to the database:</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Batching – Developers can group operations like inserts and submit them in bulk.</source>
          <target state="new">Batching – Developers can group operations like inserts and submit them in bulk.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The network traffic latency cost and the store overhead to create separate transactions are reduced significantly.</source>
          <target state="new">The network traffic latency cost and the store overhead to create separate transactions are reduced significantly.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Pre-compilation – DocumentDB precompiles stored procedures, triggers and user defined functions (UDFs) to avoid JavaScript compilation cost for each invocation.</source>
          <target state="new">Pre-compilation – DocumentDB precompiles stored procedures, triggers and user defined functions (UDFs) to avoid JavaScript compilation cost for each invocation.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The overhead of building the byte code for the procedural logic is amortized to a minimal value.</source>
          <target state="new">The overhead of building the byte code for the procedural logic is amortized to a minimal value.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Sequencing – Many operations need a side-effect (“trigger”) that potentially involves doing one or many secondary store operations.</source>
          <target state="new">Sequencing – Many operations need a side-effect (“trigger”) that potentially involves doing one or many secondary store operations.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Aside from atomicity, this is more performant when moved to the server.</source>
          <target state="new">Aside from atomicity, this is more performant when moved to the server.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Encapsulation:<ept id="p1">**</ept> Stored procedures can be used to group business logic in one place.</source>
          <target state="new"><bpt id="p1">**</bpt>Encapsulation:<ept id="p1">**</ept> Stored procedures can be used to group business logic in one place.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>This has two advantages:</source>
          <target state="new">This has two advantages:</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>It adds an abstraction layer on top of the raw data, which enables data architects to evolve their applications independently from the data.</source>
          <target state="new">It adds an abstraction layer on top of the raw data, which enables data architects to evolve their applications independently from the data.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>This is particularly advantageous when the data is schema-less, due to the brittle assumptions that may need to be baked into the application if they have to deal with data directly.</source>
          <target state="new">This is particularly advantageous when the data is schema-less, due to the brittle assumptions that may need to be baked into the application if they have to deal with data directly.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>This abstraction lets enterprises keep their data secure by streamlining the access from the scripts.</source>
          <target state="new">This abstraction lets enterprises keep their data secure by streamlining the access from the scripts.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The creation and execution of triggers, stored procedure and custom query operators is supported through the <bpt id="p1">[</bpt>REST API<ept id="p1">](https://msdn.microsoft.com/library/azure/dn781481.aspx)</ept>, and <bpt id="p2">[</bpt>client SDKs<ept id="p2">](https://msdn.microsoft.com/library/azure/dn781482.aspx)</ept> in many platforms including .NET, Node.js and JavaScript.</source>
          <target state="new">The creation and execution of triggers, stored procedure and custom query operators is supported through the <bpt id="p1">[</bpt>REST API<ept id="p1">](https://msdn.microsoft.com/library/azure/dn781481.aspx)</ept>, and <bpt id="p2">[</bpt>client SDKs<ept id="p2">](https://msdn.microsoft.com/library/azure/dn781482.aspx)</ept> in many platforms including .NET, Node.js and JavaScript.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>This tutorial uses the <bpt id="p2">[</bpt>Node.js SDK<ept id="p2">](http://dl.windowsazure.com/documentDB/nodedocs/)</ept><ept id="p1">**</ept> to illustrate syntax and usage of stored procedures, triggers, and UDFs.</source>
          <target state="new"><bpt id="p1">**</bpt>This tutorial uses the <bpt id="p2">[</bpt>Node.js SDK<ept id="p2">](http://dl.windowsazure.com/documentDB/nodedocs/)</ept><ept id="p1">**</ept> to illustrate syntax and usage of stored procedures, triggers, and UDFs.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Stored procedures</source>
          <target state="new">Stored procedures</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Example: Write a simple stored procedure</source>
          <target state="new">Example: Write a simple stored procedure</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Let’s start with a simple stored procedure that returns a “Hello World” response.</source>
          <target state="new">Let’s start with a simple stored procedure that returns a “Hello World” response.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Stored procedures are registered per collection, and can operate on any document and attachment present in that collection.</source>
          <target state="new">Stored procedures are registered per collection, and can operate on any document and attachment present in that collection.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The following snippet shows how to register the helloWorld stored procedure with a collection.</source>
          <target state="new">The following snippet shows how to register the helloWorld stored procedure with a collection.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Once the stored procedure is registered, we can execute it against the collection, and read the results back at the client.</source>
          <target state="new">Once the stored procedure is registered, we can execute it against the collection, and read the results back at the client.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The context object provides access to all operations that can be performed on DocumentDB storage, as well as access to the request and response objects.</source>
          <target state="new">The context object provides access to all operations that can be performed on DocumentDB storage, as well as access to the request and response objects.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>In this case, we used the response object to set the body of the response that was sent back to the client.</source>
          <target state="new">In this case, we used the response object to set the body of the response that was sent back to the client.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>For more details, refer to the <bpt id="p1">[</bpt>DocumentDB JavaScript server SDK documentation<ept id="p1">](http://dl.windowsazure.com/documentDB/jsserverdocs/)</ept>.</source>
          <target state="new">For more details, refer to the <bpt id="p1">[</bpt>DocumentDB JavaScript server SDK documentation<ept id="p1">](http://dl.windowsazure.com/documentDB/jsserverdocs/)</ept>.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Let us expand on this example and add more database related functionality to the stored procedure.</source>
          <target state="new">Let us expand on this example and add more database related functionality to the stored procedure.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Stored procedures can create, update, read, query and delete documents and attachments inside the collection.</source>
          <target state="new">Stored procedures can create, update, read, query and delete documents and attachments inside the collection.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Example: Write a stored procedure to create a document</source>
          <target state="new">Example: Write a stored procedure to create a document</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The next snippet shows how to use the context object to interact with DocumentDB resources.</source>
          <target state="new">The next snippet shows how to use the context object to interact with DocumentDB resources.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>This stored procedure takes as input documentToCreate, the body of a document to be created in the current collection.</source>
          <target state="new">This stored procedure takes as input documentToCreate, the body of a document to be created in the current collection.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>All such operations are asynchronous and depend on JavaScript function callbacks.</source>
          <target state="new">All such operations are asynchronous and depend on JavaScript function callbacks.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The callback function has two parameters, one for the error object in case the operation fails, and one for the created object.</source>
          <target state="new">The callback function has two parameters, one for the error object in case the operation fails, and one for the created object.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Inside the callback, users can either handle the exception or throw an error.</source>
          <target state="new">Inside the callback, users can either handle the exception or throw an error.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>In case a callback is not provided and there is an error, the DocumentDB runtime throws an error.</source>
          <target state="new">In case a callback is not provided and there is an error, the DocumentDB runtime throws an error.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>In the example above, the callback throws an error if the operation failed.</source>
          <target state="new">In the example above, the callback throws an error if the operation failed.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Otherwise, it sets the id of the created document as the body of the response to the client.</source>
          <target state="new">Otherwise, it sets the id of the created document as the body of the response to the client.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Here is how this stored procedure is executed with input parameters.</source>
          <target state="new">Here is how this stored procedure is executed with input parameters.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Note that this stored procedure can be modified to take an array of document bodies as input and create them all in the same stored procedure execution instead of multiple network requests to create each of them individually.</source>
          <target state="new">Note that this stored procedure can be modified to take an array of document bodies as input and create them all in the same stored procedure execution instead of multiple network requests to create each of them individually.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>This can be used to implement an efficient bulk importer for DocumentDB (discussed later in this tutorial).</source>
          <target state="new">This can be used to implement an efficient bulk importer for DocumentDB (discussed later in this tutorial).</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The example described demonstrated how to use stored procedures.</source>
          <target state="new">The example described demonstrated how to use stored procedures.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>We will cover triggers and user defined functions (UDFs) later in the tutorial.</source>
          <target state="new">We will cover triggers and user defined functions (UDFs) later in the tutorial.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Transactions</source>
          <target state="new">Transactions</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Transaction in a typical database can be defined as a sequence of operations performed as a single logical unit of work.</source>
          <target state="new">Transaction in a typical database can be defined as a sequence of operations performed as a single logical unit of work.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Each transaction provides <bpt id="p1">**</bpt>ACID guarantees<ept id="p1">**</ept>.</source>
          <target state="new">Each transaction provides <bpt id="p1">**</bpt>ACID guarantees<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>ACID is a well-known acronym that stands for four properties -  Atomicity, Consistency, Isolation and Durability.</source>
          <target state="new">ACID is a well-known acronym that stands for four properties -  Atomicity, Consistency, Isolation and Durability.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Briefly, atomicity guarantees that all the work done inside a transaction is treated as a single unit where either all of it is committed or none.</source>
          <target state="new">Briefly, atomicity guarantees that all the work done inside a transaction is treated as a single unit where either all of it is committed or none.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Consistency makes sure that the data is always in a good internal state across transactions.</source>
          <target state="new">Consistency makes sure that the data is always in a good internal state across transactions.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Isolation guarantees that no two transactions interfere with each other – generally, most commercial systems provide multiple isolation levels that can be used based on the application needs.</source>
          <target state="new">Isolation guarantees that no two transactions interfere with each other – generally, most commercial systems provide multiple isolation levels that can be used based on the application needs.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Durability ensures that any change that’s committed in the database will always be present.</source>
          <target state="new">Durability ensures that any change that’s committed in the database will always be present.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>In DocumentDB, JavaScript is hosted in the same memory space as the database.</source>
          <target state="new">In DocumentDB, JavaScript is hosted in the same memory space as the database.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Hence, requests made within stored procedures and triggers execute in the same scope of a database session.</source>
          <target state="new">Hence, requests made within stored procedures and triggers execute in the same scope of a database session.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>This enables DocumentDB to guarantee ACID for all operations that are part of a single stored procedure/trigger.</source>
          <target state="new">This enables DocumentDB to guarantee ACID for all operations that are part of a single stored procedure/trigger.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Consider the following stored procedure definition:</source>
          <target state="new">Consider the following stored procedure definition:</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>This stored procedure uses transactions within a gaming app to trade items between two players in a single operation.</source>
          <target state="new">This stored procedure uses transactions within a gaming app to trade items between two players in a single operation.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The stored procedure attempts to read two documents each corresponding to the player IDs passed in as an argument.</source>
          <target state="new">The stored procedure attempts to read two documents each corresponding to the player IDs passed in as an argument.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>If both player documents are found, then the stored procedure updates the documents by swapping their items.</source>
          <target state="new">If both player documents are found, then the stored procedure updates the documents by swapping their items.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>If any errors are encountered along the way, it throws a JavaScript exception that implicitly aborts the transaction.</source>
          <target state="new">If any errors are encountered along the way, it throws a JavaScript exception that implicitly aborts the transaction.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Commit and rollback</source>
          <target state="new">Commit and rollback</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Transactions are deeply and natively integrated into DocumentDB’s JavaScript programming model.</source>
          <target state="new">Transactions are deeply and natively integrated into DocumentDB’s JavaScript programming model.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Inside a JavaScript function, all operations are automatically wrapped under a single transaction.</source>
          <target state="new">Inside a JavaScript function, all operations are automatically wrapped under a single transaction.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>If the JavaScript completes without any exception, the operations to the database are committed.</source>
          <target state="new">If the JavaScript completes without any exception, the operations to the database are committed.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>In effect, the “BEGIN TRANSACTION” and “COMMIT TRANSACTION” statements in relational databases are implicit in DocumentDB.</source>
          <target state="new">In effect, the “BEGIN TRANSACTION” and “COMMIT TRANSACTION” statements in relational databases are implicit in DocumentDB.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>If there is any exception that’s propagated from the script, DocumentDB’s JavaScript runtime will roll back the whole transaction.</source>
          <target state="new">If there is any exception that’s propagated from the script, DocumentDB’s JavaScript runtime will roll back the whole transaction.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>As shown in the earlier example, throwing an exception is effectively equivalent to a “ROLLBACK TRANSACTION” in DocumentDB.</source>
          <target state="new">As shown in the earlier example, throwing an exception is effectively equivalent to a “ROLLBACK TRANSACTION” in DocumentDB.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Data consistency</source>
          <target state="new">Data consistency</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Stored procedures and triggers are always executed on the primary replica of the DocumentDB collection.</source>
          <target state="new">Stored procedures and triggers are always executed on the primary replica of the DocumentDB collection.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>This ensures that reads from inside stored procedures offer strong consistency.</source>
          <target state="new">This ensures that reads from inside stored procedures offer strong consistency.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Queries using user defined functions can be executed on the primary or any secondary replica, but we ensure to meet the requested consistency level by choosing the appropriate replica.</source>
          <target state="new">Queries using user defined functions can be executed on the primary or any secondary replica, but we ensure to meet the requested consistency level by choosing the appropriate replica.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Bounded execution</source>
          <target state="new">Bounded execution</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>All DocumentDB operations must complete within the server specified request timeout duration.</source>
          <target state="new">All DocumentDB operations must complete within the server specified request timeout duration.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>This constraint also applies to JavaScript functions (stored procedures, triggers and user-defined functions).</source>
          <target state="new">This constraint also applies to JavaScript functions (stored procedures, triggers and user-defined functions).</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>If an operation does not complete with that time limit, the transaction is rolled back.</source>
          <target state="new">If an operation does not complete with that time limit, the transaction is rolled back.</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>JavaScript functions must finish within the time limit or implement a continuation based model to batch/resume execution.</source>
          <target state="new">JavaScript functions must finish within the time limit or implement a continuation based model to batch/resume execution.</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>In order to simplify development of stored procedures and triggers to handle time limits, all functions under the collection object (for create, read, replace, and delete of documents and attachments) return a Boolean value that represents whether that operation will complete.</source>
          <target state="new">In order to simplify development of stored procedures and triggers to handle time limits, all functions under the collection object (for create, read, replace, and delete of documents and attachments) return a Boolean value that represents whether that operation will complete.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>If this value is false, it is an indication that the time limit is about to expire and that the procedure must wrap up execution.</source>
          <target state="new">If this value is false, it is an indication that the time limit is about to expire and that the procedure must wrap up execution.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Operations queued prior to the first unaccepted store operation are guaranteed to complete if the stored procedure completes in time and does not queue any more requests.</source>
          <target state="new">Operations queued prior to the first unaccepted store operation are guaranteed to complete if the stored procedure completes in time and does not queue any more requests.</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>JavaScript functions are also bounded on resource consumption.</source>
          <target state="new">JavaScript functions are also bounded on resource consumption.</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>DocumentDB reserves throughput per collection based on the provisioned size of a database account.</source>
          <target state="new">DocumentDB reserves throughput per collection based on the provisioned size of a database account.</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Throughput is expressed in terms of a normalized unit of CPU, memory and IO consumption called request units or RUs.</source>
          <target state="new">Throughput is expressed in terms of a normalized unit of CPU, memory and IO consumption called request units or RUs.</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>JavaScript functions can potentially use up a large number of RUs within a short time, and might get rate-limited if the collection’s limit is reached.</source>
          <target state="new">JavaScript functions can potentially use up a large number of RUs within a short time, and might get rate-limited if the collection’s limit is reached.</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Resource intensive stored procedures might also be quarantined to ensure availability of primitive database operations.</source>
          <target state="new">Resource intensive stored procedures might also be quarantined to ensure availability of primitive database operations.</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Example: Bulk importing data</source>
          <target state="new">Example: Bulk importing data</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Below is an example of a stored procedure that is written to bulk-import documents into a collection.</source>
          <target state="new">Below is an example of a stored procedure that is written to bulk-import documents into a collection.</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Note how the stored procedure handles bounded execution by checking the Boolean return value from createDocument, and then uses the count of documents inserted in each invocation of the stored procedure to track and resume progress across batches.</source>
          <target state="new">Note how the stored procedure handles bounded execution by checking the Boolean return value from createDocument, and then uses the count of documents inserted in each invocation of the stored procedure to track and resume progress across batches.</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a id="trigger"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> Triggers</source>
          <target state="new"><ph id="ph1">&lt;a id="trigger"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> Triggers</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Pre-Triggers</source>
          <target state="new">Pre-Triggers</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>DocumentDB provides triggers that are executed or triggered by an operation on a document.</source>
          <target state="new">DocumentDB provides triggers that are executed or triggered by an operation on a document.</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>For example, you can specify a pre-trigger when you are creating a document – this pre-trigger will run before the document is created.</source>
          <target state="new">For example, you can specify a pre-trigger when you are creating a document – this pre-trigger will run before the document is created.</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The following is an example of how pre-triggers can be used to validate the properties of a document that is being created:</source>
          <target state="new">The following is an example of how pre-triggers can be used to validate the properties of a document that is being created:</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>And the corresponding Node.js client-side registration code for the trigger:</source>
          <target state="new">And the corresponding Node.js client-side registration code for the trigger:</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Pre-triggers cannot have any input parameters.</source>
          <target state="new">Pre-triggers cannot have any input parameters.</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The request object can be used to manipulate the request message associated with the operation.</source>
          <target state="new">The request object can be used to manipulate the request message associated with the operation.</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Here, the pre-trigger is being run with the creation of a document, and the request message body contains the document to be created in JSON format.</source>
          <target state="new">Here, the pre-trigger is being run with the creation of a document, and the request message body contains the document to be created in JSON format.</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>When triggers are registered, users can specify the operations that it can run with.</source>
          <target state="new">When triggers are registered, users can specify the operations that it can run with.</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>This trigger was created with TriggerOperation.Create, which means the following is not permitted.</source>
          <target state="new">This trigger was created with TriggerOperation.Create, which means the following is not permitted.</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Post-triggers</source>
          <target state="new">Post-triggers</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Post-triggers, like pre-triggers, are associated with an operation on a document and don’t take any input parameters.</source>
          <target state="new">Post-triggers, like pre-triggers, are associated with an operation on a document and don’t take any input parameters.</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>They run <bpt id="p1">**</bpt>after<ept id="p1">**</ept> the operation has completed, and have access to the response message that is sent to the client.</source>
          <target state="new">They run <bpt id="p1">**</bpt>after<ept id="p1">**</ept> the operation has completed, and have access to the response message that is sent to the client.</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The following example shows post-triggers in action:</source>
          <target state="new">The following example shows post-triggers in action:</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The trigger can be registered as shown in the following sample.</source>
          <target state="new">The trigger can be registered as shown in the following sample.</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>This trigger queries for the metadata document and updates it with details about the newly created document.</source>
          <target state="new">This trigger queries for the metadata document and updates it with details about the newly created document.</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>One thing that is important to note is the <bpt id="p1">**</bpt>transactional<ept id="p1">**</ept> execution of triggers in DocumentDB.</source>
          <target state="new">One thing that is important to note is the <bpt id="p1">**</bpt>transactional<ept id="p1">**</ept> execution of triggers in DocumentDB.</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>This post-trigger runs as part of the same transaction as the creation of the original document.</source>
          <target state="new">This post-trigger runs as part of the same transaction as the creation of the original document.</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Therefore, if we throw an exception from the post-trigger (say if we are unable to update the metadata document), the whole transaction will fail and be rolled back.</source>
          <target state="new">Therefore, if we throw an exception from the post-trigger (say if we are unable to update the metadata document), the whole transaction will fail and be rolled back.</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>No document will be created, and an exception will be returned.</source>
          <target state="new">No document will be created, and an exception will be returned.</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a id="udf"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>User-defined functions</source>
          <target state="new"><ph id="ph1">&lt;a id="udf"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>User-defined functions</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>User-defined functions (UDFs) are used to extend the DocumentDB SQL query language grammar and implement custom business logic.</source>
          <target state="new">User-defined functions (UDFs) are used to extend the DocumentDB SQL query language grammar and implement custom business logic.</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>They can only be called from inside queries.</source>
          <target state="new">They can only be called from inside queries.</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>They do not have access to the context object and are meant to be used as compute-only JavaScript.</source>
          <target state="new">They do not have access to the context object and are meant to be used as compute-only JavaScript.</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Therefore, UDFs can be run on secondary replicas of the DocumentDB service.</source>
          <target state="new">Therefore, UDFs can be run on secondary replicas of the DocumentDB service.</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The following sample creates a UDF to calculate income tax based on rates for various income brackets, and then uses it inside a query to find all people who paid more than $20,000 in taxes.</source>
          <target state="new">The following sample creates a UDF to calculate income tax based on rates for various income brackets, and then uses it inside a query to find all people who paid more than $20,000 in taxes.</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The UDF can subsequently be used in queries like in the following sample:</source>
          <target state="new">The UDF can subsequently be used in queries like in the following sample:</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>JavaScript language-integrated query API</source>
          <target state="new">JavaScript language-integrated query API</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>In addition to issuing queries using DocumentDB’s SQL grammar, the server-side SDK allows you to perform optimized queries using a fluent JavaScript interface without any knowledge of SQL.</source>
          <target state="new">In addition to issuing queries using DocumentDB’s SQL grammar, the server-side SDK allows you to perform optimized queries using a fluent JavaScript interface without any knowledge of SQL.</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The JavaScript query API allows you to programmatically build queries by passing predicate functions into chainable function calls, with a syntax familiar to ECMAScript5's Array built-ins and popular JavaScript libraries like lodash.</source>
          <target state="new">The JavaScript query API allows you to programmatically build queries by passing predicate functions into chainable function calls, with a syntax familiar to ECMAScript5's Array built-ins and popular JavaScript libraries like lodash.</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Queries are parsed by the JavaScript runtime to be executed efficiently using DocumentDB’s indices.</source>
          <target state="new">Queries are parsed by the JavaScript runtime to be executed efficiently using DocumentDB’s indices.</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> <ph id="ph2">`__`</ph> (double-underscore) is an alias to <ph id="ph3">`getContext().getCollection()`</ph>.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> <ph id="ph2">`__`</ph> (double-underscore) is an alias to <ph id="ph3">`getContext().getCollection()`</ph>.</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>In other words, you can use <ph id="ph1">`__`</ph> or <ph id="ph2">`getContext().getCollection()`</ph> to access the JavaScript query API.</source>
          <target state="new">In other words, you can use <ph id="ph1">`__`</ph> or <ph id="ph2">`getContext().getCollection()`</ph> to access the JavaScript query API.</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Supported functions include:</source>
          <target state="new">Supported functions include:</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
&lt;b&gt;</ph>chain() ... .value([callback] [, options])<ph id="ph2">&lt;/b&gt;</ph><ph id="ph3">
</ph></source>
          <target state="new"><ph id="ph1">
&lt;b&gt;</ph>chain() ... .value([callback] [, options])<ph id="ph2">&lt;/b&gt;</ph><ph id="ph3">
</ph></target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Starts a chained call which must be terminated with value().</source>
          <target state="new">Starts a chained call which must be terminated with value().</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
&lt;b&gt;</ph>filter(predicateFunction [, options] [, callback])<ph id="ph2">&lt;/b&gt;</ph><ph id="ph3">
</ph></source>
          <target state="new"><ph id="ph1">
&lt;b&gt;</ph>filter(predicateFunction [, options] [, callback])<ph id="ph2">&lt;/b&gt;</ph><ph id="ph3">
</ph></target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Filters the input using a predicate function which returns true/false in order to filter in/out input documents into the resulting set.</source>
          <target state="new">Filters the input using a predicate function which returns true/false in order to filter in/out input documents into the resulting set.</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>This behaves similar to a WHERE clause in SQL.</source>
          <target state="new">This behaves similar to a WHERE clause in SQL.</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
&lt;b&gt;</ph>map(transformationFunction [, options] [, callback])<ph id="ph2">&lt;/b&gt;</ph><ph id="ph3">
</ph></source>
          <target state="new"><ph id="ph1">
&lt;b&gt;</ph>map(transformationFunction [, options] [, callback])<ph id="ph2">&lt;/b&gt;</ph><ph id="ph3">
</ph></target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Applies a projection given a transformation function which maps each input item to a JavaScript object or value.</source>
          <target state="new">Applies a projection given a transformation function which maps each input item to a JavaScript object or value.</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>This behaves similar to a SELECT clause in SQL.</source>
          <target state="new">This behaves similar to a SELECT clause in SQL.</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
&lt;b&gt;</ph>pluck([propertyName] [, options] [, callback])<ph id="ph2">&lt;/b&gt;</ph><ph id="ph3">
</ph></source>
          <target state="new"><ph id="ph1">
&lt;b&gt;</ph>pluck([propertyName] [, options] [, callback])<ph id="ph2">&lt;/b&gt;</ph><ph id="ph3">
</ph></target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>This is a shortcut for a map which extracts the value of a single property from each input item.</source>
          <target state="new">This is a shortcut for a map which extracts the value of a single property from each input item.</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
&lt;b&gt;</ph>flatten([isShallow] [, options] [, callback])<ph id="ph2">&lt;/b&gt;</ph><ph id="ph3">
</ph></source>
          <target state="new"><ph id="ph1">
&lt;b&gt;</ph>flatten([isShallow] [, options] [, callback])<ph id="ph2">&lt;/b&gt;</ph><ph id="ph3">
</ph></target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Combines and flattens arrays from each input item in to a single array.</source>
          <target state="new">Combines and flattens arrays from each input item in to a single array.</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>This behaves similar to SelectMany in LINQ.</source>
          <target state="new">This behaves similar to SelectMany in LINQ.</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
&lt;b&gt;</ph>sortBy([predicate] [, options] [, callback])<ph id="ph2">&lt;/b&gt;</ph><ph id="ph3">
</ph></source>
          <target state="new"><ph id="ph1">
&lt;b&gt;</ph>sortBy([predicate] [, options] [, callback])<ph id="ph2">&lt;/b&gt;</ph><ph id="ph3">
</ph></target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Produce a new set of documents by sorting the documents in the input document stream in ascending order using the given predicate.</source>
          <target state="new">Produce a new set of documents by sorting the documents in the input document stream in ascending order using the given predicate.</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>This behaves similar to a ORDER BY clause in SQL.</source>
          <target state="new">This behaves similar to a ORDER BY clause in SQL.</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
&lt;b&gt;</ph>sortByDescending([predicate] [, options] [, callback])<ph id="ph2">&lt;/b&gt;</ph><ph id="ph3">
</ph></source>
          <target state="new"><ph id="ph1">
&lt;b&gt;</ph>sortByDescending([predicate] [, options] [, callback])<ph id="ph2">&lt;/b&gt;</ph><ph id="ph3">
</ph></target>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Produce a new set of documents by sorting the documents in the input document stream in descending order using the given predicate.</source>
          <target state="new">Produce a new set of documents by sorting the documents in the input document stream in descending order using the given predicate.</target>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>This behaves similar to a ORDER BY x DESC clause in SQL.</source>
          <target state="new">This behaves similar to a ORDER BY x DESC clause in SQL.</target>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>When included inside predicate and/or selector functions, the following JavaScript constructs get automatically optimized to run directly on DocumentDB indices:</source>
          <target state="new">When included inside predicate and/or selector functions, the following JavaScript constructs get automatically optimized to run directly on DocumentDB indices:</target>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Simple operators: = + - * / % | ^ &amp;amp; == != === !=== &amp;lt; &amp;gt; &amp;lt;= &amp;gt;= || &amp;amp;&amp;amp; &amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt;!</source>
          <target state="new">Simple operators: = + - * / % | ^ &amp;amp; == != === !=== &amp;lt; &amp;gt; &amp;lt;= &amp;gt;= || &amp;amp;&amp;amp; &amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt;!</target>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Literals, including the object literal: {}</source>
          <target state="new">Literals, including the object literal: {}</target>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>var, return</source>
          <target state="new">var, return</target>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>The following JavaScript constructs do not get optimized for DocumentDB indices:</source>
          <target state="new">The following JavaScript constructs do not get optimized for DocumentDB indices:</target>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Control flow (e.g. if, for, while)</source>
          <target state="new">Control flow (e.g. if, for, while)</target>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Function calls</source>
          <target state="new">Function calls</target>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>For more information, please see our <bpt id="p1">[</bpt>Server-Side JSDocs<ept id="p1">](http://dl.windowsazure.com/documentDB/jsserverdocs/)</ept>.</source>
          <target state="new">For more information, please see our <bpt id="p1">[</bpt>Server-Side JSDocs<ept id="p1">](http://dl.windowsazure.com/documentDB/jsserverdocs/)</ept>.</target>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Example: Write a stored procedure using the JavaScript query API</source>
          <target state="new">Example: Write a stored procedure using the JavaScript query API</target>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The following code sample is an example of how the JavaScript Query API can be used in the context of a stored procedure.</source>
          <target state="new">The following code sample is an example of how the JavaScript Query API can be used in the context of a stored procedure.</target>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>The stored procedure inserts a document, given by an input parameter, and updates a metadata document, using the <ph id="ph1">`__.filter()`</ph> method, with minSize, maxSize, and totalSize based upon the input document's size property.</source>
          <target state="new">The stored procedure inserts a document, given by an input parameter, and updates a metadata document, using the <ph id="ph1">`__.filter()`</ph> method, with minSize, maxSize, and totalSize based upon the input document's size property.</target>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>SQL to Javascript cheat sheet</source>
          <target state="new">SQL to Javascript cheat sheet</target>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>The following table presents various SQL queries and the corresponding JavaScript queries.</source>
          <target state="new">The following table presents various SQL queries and the corresponding JavaScript queries.</target>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>As with SQL queries, document property keys (e.g. <ph id="ph1">`doc.id`</ph>) are case-sensitive.</source>
          <target state="new">As with SQL queries, document property keys (e.g. <ph id="ph1">`doc.id`</ph>) are case-sensitive.</target>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>SQL</source>
          <target state="new">SQL</target>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>JavaScript Query API</source>
          <target state="new">JavaScript Query API</target>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="new">Details</target>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>SELECT *</source>
          <target state="new">SELECT *</target>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>FROM docs</source>
          <target state="new">FROM docs</target>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>__.map(function(doc) {</source>
          <target state="new">__.map(function(doc) {</target>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>return doc;</source>
          <target state="new">return doc;</target>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>});</source>
          <target state="new">});</target>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Results in all documents (paginated with continuation token) as is.</source>
          <target state="new">Results in all documents (paginated with continuation token) as is.</target>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>SELECT docs.id, docs.message AS msg, docs.actions</source>
          <target state="new">SELECT docs.id, docs.message AS msg, docs.actions</target>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>FROM docs</source>
          <target state="new">FROM docs</target>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>__.map(function(doc) {</source>
          <target state="new">__.map(function(doc) {</target>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>return {</source>
          <target state="new">return {</target>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>id: doc.id,</source>
          <target state="new">id: doc.id,</target>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>msg: doc.message,</source>
          <target state="new">msg: doc.message,</target>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>actions: doc.actions</source>
          <target state="new">actions: doc.actions</target>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>};</source>
          <target state="new">};</target>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>});</source>
          <target state="new">});</target>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Projects the id, message (aliased to msg), and action from all documents.</source>
          <target state="new">Projects the id, message (aliased to msg), and action from all documents.</target>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>SELECT *</source>
          <target state="new">SELECT *</target>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>FROM docs</source>
          <target state="new">FROM docs</target>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>WHERE docs.id="X998_Y998"</source>
          <target state="new">WHERE docs.id="X998_Y998"</target>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>__.filter(function(doc) {</source>
          <target state="new">__.filter(function(doc) {</target>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>return doc.id === "X998_Y998";</source>
          <target state="new">return doc.id === "X998_Y998";</target>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>});</source>
          <target state="new">});</target>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Queries for documents with the predicate: id = "X998_Y998".</source>
          <target state="new">Queries for documents with the predicate: id = "X998_Y998".</target>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>SELECT *</source>
          <target state="new">SELECT *</target>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>FROM docs</source>
          <target state="new">FROM docs</target>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>WHERE ARRAY_CONTAINS(docs.Tags, 123)</source>
          <target state="new">WHERE ARRAY_CONTAINS(docs.Tags, 123)</target>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>__.filter(function(x) {</source>
          <target state="new">__.filter(function(x) {</target>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>return x.Tags &amp;&amp; x.Tags.indexOf(123) &gt; -1;</source>
          <target state="new">return x.Tags &amp;&amp; x.Tags.indexOf(123) &gt; -1;</target>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>});</source>
          <target state="new">});</target>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Queries for documents that have a Tags property and Tags is an array containing the value 123.</source>
          <target state="new">Queries for documents that have a Tags property and Tags is an array containing the value 123.</target>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>SELECT docs.id, docs.message AS msg</source>
          <target state="new">SELECT docs.id, docs.message AS msg</target>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>FROM docs</source>
          <target state="new">FROM docs</target>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>WHERE docs.id="X998_Y998"</source>
          <target state="new">WHERE docs.id="X998_Y998"</target>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>__.chain()</source>
          <target state="new">__.chain()</target>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>.filter(function(doc) {</source>
          <target state="new">.filter(function(doc) {</target>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>return doc.id === "X998_Y998";</source>
          <target state="new">return doc.id === "X998_Y998";</target>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>})</source>
          <target state="new">})</target>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>.map(function(doc) {</source>
          <target state="new">.map(function(doc) {</target>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>return {</source>
          <target state="new">return {</target>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>id: doc.id,</source>
          <target state="new">id: doc.id,</target>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>msg: doc.message</source>
          <target state="new">msg: doc.message</target>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>};</source>
          <target state="new">};</target>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>})</source>
          <target state="new">})</target>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>.value();</source>
          <target state="new">.value();</target>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Queries for documents with a predicate, id = "X998_Y998", and then projects the id and message (aliased to msg).</source>
          <target state="new">Queries for documents with a predicate, id = "X998_Y998", and then projects the id and message (aliased to msg).</target>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>SELECT VALUE tag</source>
          <target state="new">SELECT VALUE tag</target>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>FROM docs</source>
          <target state="new">FROM docs</target>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>JOIN tag IN docs.Tags</source>
          <target state="new">JOIN tag IN docs.Tags</target>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>ORDER BY docs._ts</source>
          <target state="new">ORDER BY docs._ts</target>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>__.chain()</source>
          <target state="new">__.chain()</target>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>.filter(function(doc) {</source>
          <target state="new">.filter(function(doc) {</target>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>return doc.Tags &amp;&amp; Array.isArray(doc.Tags);</source>
          <target state="new">return doc.Tags &amp;&amp; Array.isArray(doc.Tags);</target>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>})</source>
          <target state="new">})</target>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>.sortBy(function(doc) {</source>
          <target state="new">.sortBy(function(doc) {</target>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>return doc._ts;</source>
          <target state="new">return doc._ts;</target>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>})</source>
          <target state="new">})</target>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>.pluck("Tags")</source>
          <target state="new">.pluck("Tags")</target>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>.flatten()</source>
          <target state="new">.flatten()</target>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>.value()</source>
          <target state="new">.value()</target>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Filters for documents which have an array property, Tags, and sorts the resulting documents by the _ts timestamp system property, and then projects + flattens the Tags array.</source>
          <target state="new">Filters for documents which have an array property, Tags, and sorts the resulting documents by the _ts timestamp system property, and then projects + flattens the Tags array.</target>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Runtime support</source>
          <target state="new">Runtime support</target>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>DocumentDB JavaScript server side SDK<ept id="p1">](http://dl.windowsazure.com/documentDB/jsserverdocs/)</ept> provides support for the most of the mainstream JavaScript language features as standardized by <bpt id="p2">[</bpt>ECMA-262<ept id="p2">](documentdb-interactions-with-resources.md)</ept>.</source>
          <target state="new"><bpt id="p1">[</bpt>DocumentDB JavaScript server side SDK<ept id="p1">](http://dl.windowsazure.com/documentDB/jsserverdocs/)</ept> provides support for the most of the mainstream JavaScript language features as standardized by <bpt id="p2">[</bpt>ECMA-262<ept id="p2">](documentdb-interactions-with-resources.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Security</source>
          <target state="new">Security</target>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>JavaScript stored procedures and triggers are sandboxed so that the effects of one script do not leak to the other without going through the snapshot transaction isolation at the database level.</source>
          <target state="new">JavaScript stored procedures and triggers are sandboxed so that the effects of one script do not leak to the other without going through the snapshot transaction isolation at the database level.</target>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>The runtime environments are pooled but cleaned of the context after each run.</source>
          <target state="new">The runtime environments are pooled but cleaned of the context after each run.</target>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Hence they are guaranteed to be safe of any unintended side effects from each other.</source>
          <target state="new">Hence they are guaranteed to be safe of any unintended side effects from each other.</target>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>Pre-compilation</source>
          <target state="new">Pre-compilation</target>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Stored procedures, triggers and UDFs are implicitly precompiled to the byte code format in order to avoid compilation cost at the time of each script invocation.</source>
          <target state="new">Stored procedures, triggers and UDFs are implicitly precompiled to the byte code format in order to avoid compilation cost at the time of each script invocation.</target>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>This ensures invocations of stored procedures are fast and have a low footprint.</source>
          <target state="new">This ensures invocations of stored procedures are fast and have a low footprint.</target>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Client SDK support</source>
          <target state="new">Client SDK support</target>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>In addition to the <bpt id="p1">[</bpt>Node.js<ept id="p1">](http://dl.windowsazure.com/documentDB/nodedocs/)</ept> client, DocumentDB supports <bpt id="p2">[</bpt>.NET<ept id="p2">](https://msdn.microsoft.com/library/azure/dn783362.aspx)</ept>, <bpt id="p3">[</bpt>Java<ept id="p3">](http://dl.windowsazure.com/documentdb/javadoc/)</ept>, <bpt id="p4">[</bpt>JavaScript<ept id="p4">](http://dl.windowsazure.com/documentDB/jsclientdocs/)</ept>, and <bpt id="p5">[</bpt>Python SDKs<ept id="p5">](http://dl.windowsazure.com/documentDB/pythondocs/)</ept>.</source>
          <target state="new">In addition to the <bpt id="p1">[</bpt>Node.js<ept id="p1">](http://dl.windowsazure.com/documentDB/nodedocs/)</ept> client, DocumentDB supports <bpt id="p2">[</bpt>.NET<ept id="p2">](https://msdn.microsoft.com/library/azure/dn783362.aspx)</ept>, <bpt id="p3">[</bpt>Java<ept id="p3">](http://dl.windowsazure.com/documentdb/javadoc/)</ept>, <bpt id="p4">[</bpt>JavaScript<ept id="p4">](http://dl.windowsazure.com/documentDB/jsclientdocs/)</ept>, and <bpt id="p5">[</bpt>Python SDKs<ept id="p5">](http://dl.windowsazure.com/documentDB/pythondocs/)</ept>.</target>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Stored procedures, triggers and UDFs can be created and executed using any of these SDKs as well.</source>
          <target state="new">Stored procedures, triggers and UDFs can be created and executed using any of these SDKs as well.</target>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>The following example shows how to create and execute a stored procedure using the .NET client.</source>
          <target state="new">The following example shows how to create and execute a stored procedure using the .NET client.</target>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>Note how the .NET types are passed into the stored procedure as JSON and read back.</source>
          <target state="new">Note how the .NET types are passed into the stored procedure as JSON and read back.</target>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>This sample shows how to use the <bpt id="p1">[</bpt>.NET SDK<ept id="p1">](https://msdn.microsoft.com/library/azure/dn783362.aspx)</ept> to create a pre-trigger and create a document with the trigger enabled.</source>
          <target state="new">This sample shows how to use the <bpt id="p1">[</bpt>.NET SDK<ept id="p1">](https://msdn.microsoft.com/library/azure/dn783362.aspx)</ept> to create a pre-trigger and create a document with the trigger enabled.</target>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>And the following example shows how to create a user defined function (UDF) and use it in a <bpt id="p1">[</bpt>DocumentDB SQL query<ept id="p1">](documentdb-sql-query.md)</ept>.</source>
          <target state="new">And the following example shows how to create a user defined function (UDF) and use it in a <bpt id="p1">[</bpt>DocumentDB SQL query<ept id="p1">](documentdb-sql-query.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>REST API</source>
          <target state="new">REST API</target>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>All DocumentDB operations can be performed in a RESTful manner.</source>
          <target state="new">All DocumentDB operations can be performed in a RESTful manner.</target>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Stored procedures, triggers and user-defined functions can be registered under a collection by using HTTP POST.</source>
          <target state="new">Stored procedures, triggers and user-defined functions can be registered under a collection by using HTTP POST.</target>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>The following is an example of how to register a stored procedure:</source>
          <target state="new">The following is an example of how to register a stored procedure:</target>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The stored procedure is registered by executing a POST request against the URI dbs/sehcAA==/colls/sehcAIE2Qy4=/sprocs with the body containing the stored procedure to create.</source>
          <target state="new">The stored procedure is registered by executing a POST request against the URI dbs/sehcAA==/colls/sehcAIE2Qy4=/sprocs with the body containing the stored procedure to create.</target>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Triggers and UDFs can be registered similarly by issuing a POST against /triggers and /udfs respectively.</source>
          <target state="new">Triggers and UDFs can be registered similarly by issuing a POST against /triggers and /udfs respectively.</target>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>This stored procedure can then be executed by issuing a POST request against its resource link:</source>
          <target state="new">This stored procedure can then be executed by issuing a POST request against its resource link:</target>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Here, the input to the stored procedure is passed in the request body.</source>
          <target state="new">Here, the input to the stored procedure is passed in the request body.</target>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Note that the input is passed as a JSON array of input parameters.</source>
          <target state="new">Note that the input is passed as a JSON array of input parameters.</target>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>The stored procedure takes the first input as a document that is a response body.</source>
          <target state="new">The stored procedure takes the first input as a document that is a response body.</target>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>The response we receive is as follows:</source>
          <target state="new">The response we receive is as follows:</target>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Triggers, unlike stored procedures, cannot be executed directly.</source>
          <target state="new">Triggers, unlike stored procedures, cannot be executed directly.</target>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Instead they are executed as part of an operation on a document.</source>
          <target state="new">Instead they are executed as part of an operation on a document.</target>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>We can specify the triggers to run with a request using HTTP headers.</source>
          <target state="new">We can specify the triggers to run with a request using HTTP headers.</target>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>The following is request to create a document.</source>
          <target state="new">The following is request to create a document.</target>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Here the pre-trigger to be run with the request is specified in the x-ms-documentdb-pre-trigger-include header.</source>
          <target state="new">Here the pre-trigger to be run with the request is specified in the x-ms-documentdb-pre-trigger-include header.</target>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>Correspondingly, any post-triggers are given in the x-ms-documentdb-post-trigger-include header.</source>
          <target state="new">Correspondingly, any post-triggers are given in the x-ms-documentdb-post-trigger-include header.</target>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Note that both pre- and post-triggers can be specified for a given request.</source>
          <target state="new">Note that both pre- and post-triggers can be specified for a given request.</target>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>Sample code</source>
          <target state="new">Sample code</target>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>You can find more server-side code examples (including <bpt id="p1">[</bpt>upsert<ept id="p1">](https://github.com/Azure/azure-documentdb-js/blob/master/server-side/samples/stored-procedures/upsert.js)</ept>, <bpt id="p2">[</bpt>bulk-delete<ept id="p2">](https://github.com/Azure/azure-documentdb-js/blob/master/server-side/samples/stored-procedures/bulkDelete.js)</ept>, and <bpt id="p3">[</bpt>update<ept id="p3">](https://github.com/Azure/azure-documentdb-js/blob/master/server-side/samples/stored-procedures/update.js)</ept>) on our <bpt id="p4">[</bpt>Github repository<ept id="p4">](https://github.com/Azure/azure-documentdb-js/tree/master/server-side/samples)</ept>.</source>
          <target state="new">You can find more server-side code examples (including <bpt id="p1">[</bpt>upsert<ept id="p1">](https://github.com/Azure/azure-documentdb-js/blob/master/server-side/samples/stored-procedures/upsert.js)</ept>, <bpt id="p2">[</bpt>bulk-delete<ept id="p2">](https://github.com/Azure/azure-documentdb-js/blob/master/server-side/samples/stored-procedures/bulkDelete.js)</ept>, and <bpt id="p3">[</bpt>update<ept id="p3">](https://github.com/Azure/azure-documentdb-js/blob/master/server-side/samples/stored-procedures/update.js)</ept>) on our <bpt id="p4">[</bpt>Github repository<ept id="p4">](https://github.com/Azure/azure-documentdb-js/tree/master/server-side/samples)</ept>.</target>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>Want to share your awesome stored procedure?</source>
          <target state="new">Want to share your awesome stored procedure?</target>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>Please, send us a pull-request!</source>
          <target state="new">Please, send us a pull-request!</target>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="new">Next steps</target>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Once you have one or more stored procedures, triggers, and user-defined functions created, you can load them and view them in the Azure Preview portal using Script Explorer.</source>
          <target state="new">Once you have one or more stored procedures, triggers, and user-defined functions created, you can load them and view them in the Azure Preview portal using Script Explorer.</target>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>View stored procedures, triggers, and user-defined functions using the DocumentDB Script Explorer<ept id="p1">](documentdb-view-scripts.md)</ept>.</source>
          <target state="new">For more information, see <bpt id="p1">[</bpt>View stored procedures, triggers, and user-defined functions using the DocumentDB Script Explorer<ept id="p1">](documentdb-view-scripts.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>You may also find the following references and resources useful in your path to learn more about DocumentDB server-side programming:</source>
          <target state="new">You may also find the following references and resources useful in your path to learn more about DocumentDB server-side programming:</target>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>Azure DocumentDB SDKs</source>
          <target state="new">Azure DocumentDB SDKs</target>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="new">JSON</target>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>JavaScript ECMA-262</source>
          <target state="new">JavaScript ECMA-262</target>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>JavaScript – JSON type system</source>
          <target state="new">JavaScript – JSON type system</target>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>Secure and Portable Database Extensibility</source>
          <target state="new">Secure and Portable Database Extensibility</target>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Service Oriented Database Architecture</source>
          <target state="new">Service Oriented Database Architecture</target>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Hosting the .NET Runtime in Microsoft SQL server<ept id="p1">](http://dl.acm.org/citation.cfm?id=1007669)</ept></source>
          <target state="new"><bpt id="p1">[</bpt>Hosting the .NET Runtime in Microsoft SQL server<ept id="p1">](http://dl.acm.org/citation.cfm?id=1007669)</ept></target>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>test</source>
          <target state="new">test</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">79674b281a9cc986d11f1e8b7abbe5d00a65d0c9</xliffext:olfilehash>
  </header>
</xliff>