<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Modeling data in Azure DocumentDB | Microsoft Azure</source>
          <target state="new">Modeling data in Azure DocumentDB | Microsoft Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Learn how to model data for a NoSQL document database like Azure DocumentDB.</source>
          <target state="new">Learn how to model data for a NoSQL document database like Azure DocumentDB.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Modeling data in DocumentDB</source>
          <target state="new">Modeling data in DocumentDB</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>While schema-free databases, like DocumentDB, make it super easy to embrace changes to your data model you should still spend some time thinking about your data.</source>
          <target state="new">While schema-free databases, like DocumentDB, make it super easy to embrace changes to your data model you should still spend some time thinking about your data.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>How is data going to be stored?</source>
          <target state="new">How is data going to be stored?</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>How is your application going to retrieve and query data?</source>
          <target state="new">How is your application going to retrieve and query data?</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Is your application read heavy, or write heavy?</source>
          <target state="new">Is your application read heavy, or write heavy?</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>After reading this article, you will be able to answer the following questions:</source>
          <target state="new">After reading this article, you will be able to answer the following questions:</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>How should I think about a document in a document database?</source>
          <target state="new">How should I think about a document in a document database?</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>What is data modeling and why should I care?</source>
          <target state="new">What is data modeling and why should I care?</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>How is modeling data in a document database different to a relational database?</source>
          <target state="new">How is modeling data in a document database different to a relational database?</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>How do I express data relationships in a non-relational database?</source>
          <target state="new">How do I express data relationships in a non-relational database?</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>When do I embed data and when do I link to data?</source>
          <target state="new">When do I embed data and when do I link to data?</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Embedding data</source>
          <target state="new">Embedding data</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>When you start modeling data in a document store, such as DocumentDB, try to treat your entities as <bpt id="p1">**</bpt>self-contained documents<ept id="p1">**</ept> represented in JSON.</source>
          <target state="new">When you start modeling data in a document store, such as DocumentDB, try to treat your entities as <bpt id="p1">**</bpt>self-contained documents<ept id="p1">**</ept> represented in JSON.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Before we dive in too much further, let us take a few steps back and have a look at how we might model something in a relational database, a subject many of us are already familiar with.</source>
          <target state="new">Before we dive in too much further, let us take a few steps back and have a look at how we might model something in a relational database, a subject many of us are already familiar with.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The following example shows how a person might be stored in a relational database.</source>
          <target state="new">The following example shows how a person might be stored in a relational database.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Relational database model</source>
          <target state="new">Relational database model</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>When working with relational databases, we've been taught for years to normalize, normalize, normalize.</source>
          <target state="new">When working with relational databases, we've been taught for years to normalize, normalize, normalize.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Normalizing your data typically involves taking an entity, such as a person, and breaking it down in to discreet pieces of data.</source>
          <target state="new">Normalizing your data typically involves taking an entity, such as a person, and breaking it down in to discreet pieces of data.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>In the example above, a person can have multiple contact detail records as well as multiple address records.</source>
          <target state="new">In the example above, a person can have multiple contact detail records as well as multiple address records.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>We even go one step further and break down contact details by further extracting common fields like a type.</source>
          <target state="new">We even go one step further and break down contact details by further extracting common fields like a type.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Same for address, each record here has a type like <bpt id="p1">*</bpt>Home<ept id="p1">*</ept> or <bpt id="p2">*</bpt>Business<ept id="p2">*</ept></source>
          <target state="new">Same for address, each record here has a type like <bpt id="p1">*</bpt>Home<ept id="p1">*</ept> or <bpt id="p2">*</bpt>Business<ept id="p2">*</ept></target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The guiding premise when normalizing data is to <bpt id="p1">**</bpt>avoid storing redundant data<ept id="p1">**</ept> on each record and rather refer to data.</source>
          <target state="new">The guiding premise when normalizing data is to <bpt id="p1">**</bpt>avoid storing redundant data<ept id="p1">**</ept> on each record and rather refer to data.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>In this example, to read a person, with all their contact details and addresses, you need to use JOINS to effectively aggregate your data at run time.</source>
          <target state="new">In this example, to read a person, with all their contact details and addresses, you need to use JOINS to effectively aggregate your data at run time.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Updating a single person with their contact details and addresses requires write operations across many individual tables.</source>
          <target state="new">Updating a single person with their contact details and addresses requires write operations across many individual tables.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Now let's take a look at how we would model the same data as a self-contained entity in a document database.</source>
          <target state="new">Now let's take a look at how we would model the same data as a self-contained entity in a document database.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Using the approach above we have now <bpt id="p1">**</bpt>denormalized<ept id="p1">**</ept> the person record where we <bpt id="p2">**</bpt>embedded<ept id="p2">**</ept> all the information relating to this person, such as their contact details and addresses, in to a single JSON document.</source>
          <target state="new">Using the approach above we have now <bpt id="p1">**</bpt>denormalized<ept id="p1">**</ept> the person record where we <bpt id="p2">**</bpt>embedded<ept id="p2">**</ept> all the information relating to this person, such as their contact details and addresses, in to a single JSON document.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In addition, because we're not confined to a fixed schema we have the flexibility to do things like having contact details of different shapes entirely.</source>
          <target state="new">In addition, because we're not confined to a fixed schema we have the flexibility to do things like having contact details of different shapes entirely.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Retrieving a complete person record from the database is now a single read operation against a single collection and for a single document.</source>
          <target state="new">Retrieving a complete person record from the database is now a single read operation against a single collection and for a single document.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Updating a person record, with their contact details and addresses, is also a single write operation against a single document.</source>
          <target state="new">Updating a person record, with their contact details and addresses, is also a single write operation against a single document.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>By denormalizing data, your application may need to issue fewer queries and updates to complete common operations.</source>
          <target state="new">By denormalizing data, your application may need to issue fewer queries and updates to complete common operations.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>When to embed</source>
          <target state="new">When to embed</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>In general, use embedded data models when:</source>
          <target state="new">In general, use embedded data models when:</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>There are <bpt id="p1">**</bpt>contains<ept id="p1">**</ept> relationships between entities.</source>
          <target state="new">There are <bpt id="p1">**</bpt>contains<ept id="p1">**</ept> relationships between entities.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>There are <bpt id="p1">**</bpt>one-to-few<ept id="p1">**</ept> relationships between entities.</source>
          <target state="new">There are <bpt id="p1">**</bpt>one-to-few<ept id="p1">**</ept> relationships between entities.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>There is embedded data that <bpt id="p1">**</bpt>changes infrequently<ept id="p1">**</ept>.</source>
          <target state="new">There is embedded data that <bpt id="p1">**</bpt>changes infrequently<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>There is embedded data won't grow <bpt id="p1">**</bpt>without bound<ept id="p1">**</ept>.</source>
          <target state="new">There is embedded data won't grow <bpt id="p1">**</bpt>without bound<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>There is embedded data that is <bpt id="p1">**</bpt>integral<ept id="p1">**</ept> to data in a document.</source>
          <target state="new">There is embedded data that is <bpt id="p1">**</bpt>integral<ept id="p1">**</ept> to data in a document.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Typically denormalized data models provide better <bpt id="p1">**</bpt>read<ept id="p1">**</ept> performance.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Typically denormalized data models provide better <bpt id="p1">**</bpt>read<ept id="p1">**</ept> performance.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>When not to embed</source>
          <target state="new">When not to embed</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>While the rule of thumb in a document database is to denormalize everything and embed all data in to a single document, this can lead to some situations that should be avoided.</source>
          <target state="new">While the rule of thumb in a document database is to denormalize everything and embed all data in to a single document, this can lead to some situations that should be avoided.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Take this JSON snippet.</source>
          <target state="new">Take this JSON snippet.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>This might be what a post entity with embedded comments would look like if we were modeling a typical blog, or CMS, system.</source>
          <target state="new">This might be what a post entity with embedded comments would look like if we were modeling a typical blog, or CMS, system.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The problem with this example is that the comments array is <bpt id="p1">**</bpt>unbounded<ept id="p1">**</ept>, meaning that there is no (practical) limit to the number of comments any single post can have.</source>
          <target state="new">The problem with this example is that the comments array is <bpt id="p1">**</bpt>unbounded<ept id="p1">**</ept>, meaning that there is no (practical) limit to the number of comments any single post can have.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>This will become a problem as the size of the document could grow significantly.</source>
          <target state="new">This will become a problem as the size of the document could grow significantly.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.TIP]</ph> Documents in DocumentDB have a maximum size.</source>
          <target state="new"><ph id="ph1">[AZURE.TIP]</ph> Documents in DocumentDB have a maximum size.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For more on this refer to <bpt id="p1">[</bpt>DocumentDB limits<ept id="p1">](documentdb-limits.md)</ept>.</source>
          <target state="new">For more on this refer to <bpt id="p1">[</bpt>DocumentDB limits<ept id="p1">](documentdb-limits.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>As the size of the document grows the ability to transmit the data over the wire as well as reading and updating the document, at scale, will be impacted.</source>
          <target state="new">As the size of the document grows the ability to transmit the data over the wire as well as reading and updating the document, at scale, will be impacted.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>In this case it would be better to consider the following model.</source>
          <target state="new">In this case it would be better to consider the following model.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>This model has the three most recent comments embedded on the post itself, which is an array with a fixed bound this time.</source>
          <target state="new">This model has the three most recent comments embedded on the post itself, which is an array with a fixed bound this time.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The other comments are grouped in to batches of 100 comments and stored in separate documents.</source>
          <target state="new">The other comments are grouped in to batches of 100 comments and stored in separate documents.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The size of the batch was chosen as 100 because our fictitious application allows the user to load 100 comments at a time.</source>
          <target state="new">The size of the batch was chosen as 100 because our fictitious application allows the user to load 100 comments at a time.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Another case where embedding data is not a good idea is when the embedded data is used often across documents and will change frequently.</source>
          <target state="new">Another case where embedding data is not a good idea is when the embedded data is used often across documents and will change frequently.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Take this JSON snippet.</source>
          <target state="new">Take this JSON snippet.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>This could represent a person's stock portfolio.</source>
          <target state="new">This could represent a person's stock portfolio.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>We have chosen to embed the stock information in to each portfolio document.</source>
          <target state="new">We have chosen to embed the stock information in to each portfolio document.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>In an environment where related data is changing frequently, like a stock trading application, embedding data that changes frequently is going to mean that you are constantly updating each portfolio document every time a stock is traded.</source>
          <target state="new">In an environment where related data is changing frequently, like a stock trading application, embedding data that changes frequently is going to mean that you are constantly updating each portfolio document every time a stock is traded.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Stock <bpt id="p1">*</bpt>zaza<ept id="p1">*</ept> may be traded many hundreds of times in a single day and thousands of users could have <bpt id="p2">*</bpt>zaza<ept id="p2">*</ept> on their portfolio.</source>
          <target state="new">Stock <bpt id="p1">*</bpt>zaza<ept id="p1">*</ept> may be traded many hundreds of times in a single day and thousands of users could have <bpt id="p2">*</bpt>zaza<ept id="p2">*</ept> on their portfolio.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>With a data model like the above we would have to update many thousands of portfolio documents many times every day leading to a system that won't scale very well.</source>
          <target state="new">With a data model like the above we would have to update many thousands of portfolio documents many times every day leading to a system that won't scale very well.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a id="Refer"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Referencing data</source>
          <target state="new"><ph id="ph1">&lt;a id="Refer"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Referencing data</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>So, embedding data works nicely for many cases but it is clear that there are scenarios when denormalizing your data will cause more problems than it is worth.</source>
          <target state="new">So, embedding data works nicely for many cases but it is clear that there are scenarios when denormalizing your data will cause more problems than it is worth.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>So what do we do now?</source>
          <target state="new">So what do we do now?</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Relational databases are not the only place where you can create relationships between entities.</source>
          <target state="new">Relational databases are not the only place where you can create relationships between entities.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>In a document database you can have information in one document that actually relates to data in other documents.</source>
          <target state="new">In a document database you can have information in one document that actually relates to data in other documents.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Now, I am not advocating for even one minute that we build systems that would be better suited to a relational database in DocumentDB, or any other document database, but simple relationships are fine and can be very useful.</source>
          <target state="new">Now, I am not advocating for even one minute that we build systems that would be better suited to a relational database in DocumentDB, or any other document database, but simple relationships are fine and can be very useful.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>In the JSON below we chose to use the example of a stock portfolio from earlier but this time we refer to the stock item on the portfolio instead of embedding it.</source>
          <target state="new">In the JSON below we chose to use the example of a stock portfolio from earlier but this time we refer to the stock item on the portfolio instead of embedding it.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>This way, when the stock item changes frequently throughout the day the only document that needs to be updated is the single stock document.</source>
          <target state="new">This way, when the stock item changes frequently throughout the day the only document that needs to be updated is the single stock document.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>An immediate downside to this approach though is if your application is required to show information about each stock that is held when displaying a person's portfolio; in this case you would need to make multiple trips to the database to load the information for each stock document.</source>
          <target state="new">An immediate downside to this approach though is if your application is required to show information about each stock that is held when displaying a person's portfolio; in this case you would need to make multiple trips to the database to load the information for each stock document.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Here we've made a decision to improve the efficiency of write operations, which happen frequently throughout the day, but in turn compromised on the read operations that potentially have less impact on the performance of this particular system.</source>
          <target state="new">Here we've made a decision to improve the efficiency of write operations, which happen frequently throughout the day, but in turn compromised on the read operations that potentially have less impact on the performance of this particular system.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Normalized data models <bpt id="p1">**</bpt>can require more round trips<ept id="p1">**</ept> to the server.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Normalized data models <bpt id="p1">**</bpt>can require more round trips<ept id="p1">**</ept> to the server.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>What about foreign keys?</source>
          <target state="new">What about foreign keys?</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Because there is currently no concept of a constraint, foreign-key or otherwise, any inter-document relationships that you have in documents are effectively "weak links" and will not be verified by the database itself.</source>
          <target state="new">Because there is currently no concept of a constraint, foreign-key or otherwise, any inter-document relationships that you have in documents are effectively "weak links" and will not be verified by the database itself.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>If you want to ensure that the data a document is referring to actually exists, then you need to do this in your application, or through the use of server-side triggers or stored procedures on DocumentDB.</source>
          <target state="new">If you want to ensure that the data a document is referring to actually exists, then you need to do this in your application, or through the use of server-side triggers or stored procedures on DocumentDB.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>When to reference</source>
          <target state="new">When to reference</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>In general, use normalized data models when:</source>
          <target state="new">In general, use normalized data models when:</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Representing <bpt id="p1">**</bpt>one-to-many<ept id="p1">**</ept> relationships.</source>
          <target state="new">Representing <bpt id="p1">**</bpt>one-to-many<ept id="p1">**</ept> relationships.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Representing <bpt id="p1">**</bpt>many-to-many<ept id="p1">**</ept> relationships.</source>
          <target state="new">Representing <bpt id="p1">**</bpt>many-to-many<ept id="p1">**</ept> relationships.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Related data <bpt id="p1">**</bpt>changes frequently<ept id="p1">**</ept>.</source>
          <target state="new">Related data <bpt id="p1">**</bpt>changes frequently<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Referenced data could be <bpt id="p1">**</bpt>unbounded<ept id="p1">**</ept>.</source>
          <target state="new">Referenced data could be <bpt id="p1">**</bpt>unbounded<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Typically normalizing provides better <bpt id="p1">**</bpt>write<ept id="p1">**</ept> performance.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Typically normalizing provides better <bpt id="p1">**</bpt>write<ept id="p1">**</ept> performance.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Where do I put the relationship?</source>
          <target state="new">Where do I put the relationship?</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The growth of the relationship will help determine in which document to store the reference.</source>
          <target state="new">The growth of the relationship will help determine in which document to store the reference.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>If we look at the JSON below that models publishers and books.</source>
          <target state="new">If we look at the JSON below that models publishers and books.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>If the number of the books per publisher is small with limited growth, then storing the book reference inside the publisher document may be useful.</source>
          <target state="new">If the number of the books per publisher is small with limited growth, then storing the book reference inside the publisher document may be useful.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>However, if the number of books per publisher is unbounded, then this data model would lead to mutable, growing arrays, as in the example publisher document above.</source>
          <target state="new">However, if the number of books per publisher is unbounded, then this data model would lead to mutable, growing arrays, as in the example publisher document above.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Switching things around a bit would result in a model that still represents the same data but now avoids these large mutable collections.</source>
          <target state="new">Switching things around a bit would result in a model that still represents the same data but now avoids these large mutable collections.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>In the above example, we have dropped the unbounded collection on the publisher document.</source>
          <target state="new">In the above example, we have dropped the unbounded collection on the publisher document.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Instead we just have a a reference to the publisher on each book document.</source>
          <target state="new">Instead we just have a a reference to the publisher on each book document.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>How do I model many:many relationships?</source>
          <target state="new">How do I model many:many relationships?</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>In a relational database <bpt id="p1">*</bpt>many:many<ept id="p1">*</ept> relationships are often modeled with join tables, which just join records from other tables together.</source>
          <target state="new">In a relational database <bpt id="p1">*</bpt>many:many<ept id="p1">*</ept> relationships are often modeled with join tables, which just join records from other tables together.</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Join tables</source>
          <target state="new">Join tables</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>You might be tempted to replicate the same thing using documents and produce a data model that looks similar to the following.</source>
          <target state="new">You might be tempted to replicate the same thing using documents and produce a data model that looks similar to the following.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>This would work.</source>
          <target state="new">This would work.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>However, loading either an author with their books, or loading a book with its author, would always require at least two additional queries against the database.</source>
          <target state="new">However, loading either an author with their books, or loading a book with its author, would always require at least two additional queries against the database.</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>One query to the joining document and then another query to fetch the actual document being joined.</source>
          <target state="new">One query to the joining document and then another query to fetch the actual document being joined.</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>If all this join table is doing is gluing together two pieces of data, then why not drop it completely?</source>
          <target state="new">If all this join table is doing is gluing together two pieces of data, then why not drop it completely?</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Consider the following.</source>
          <target state="new">Consider the following.</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Now, if I had an author, I immediately know which books they have written, and conversely if I had a book document loaded I would know the ids of the author(s).</source>
          <target state="new">Now, if I had an author, I immediately know which books they have written, and conversely if I had a book document loaded I would know the ids of the author(s).</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>This saves that intermediary query against the join table reducing the number of server round trips your application has to make.</source>
          <target state="new">This saves that intermediary query against the join table reducing the number of server round trips your application has to make.</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a id="WrapUp"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Hybrid data models</source>
          <target state="new"><ph id="ph1">&lt;a id="WrapUp"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Hybrid data models</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>We've now looked embedding (or denormalizing) and referencing (or normalizing) data, each have their upsides and each have compromises as we have seen.</source>
          <target state="new">We've now looked embedding (or denormalizing) and referencing (or normalizing) data, each have their upsides and each have compromises as we have seen.</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>It doesn't always have to be either or, don't be scared to mix things up a little.</source>
          <target state="new">It doesn't always have to be either or, don't be scared to mix things up a little.</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Based on your application's specific usage patterns and workloads there may be cases where mixing embedded and referenced data makes sense and could lead to simpler application logic with fewer server round trips while still maintaining a good level of performance.</source>
          <target state="new">Based on your application's specific usage patterns and workloads there may be cases where mixing embedded and referenced data makes sense and could lead to simpler application logic with fewer server round trips while still maintaining a good level of performance.</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Consider the following JSON.</source>
          <target state="new">Consider the following JSON.</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Here we've (mostly) followed the embedded model, where data from other entities are embedded in the top-level document, but other data is referenced.</source>
          <target state="new">Here we've (mostly) followed the embedded model, where data from other entities are embedded in the top-level document, but other data is referenced.</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>If you look at the book document, we can see a few interesting fields when we look at the array of authors.</source>
          <target state="new">If you look at the book document, we can see a few interesting fields when we look at the array of authors.</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>There is an <bpt id="p1">*</bpt>id<ept id="p1">*</ept> field which is the field we use to refer back to an author document, standard practice in a normalized model, but then we also have <bpt id="p2">*</bpt>name<ept id="p2">*</ept> and <bpt id="p3">*</bpt>thumbnailUrl<ept id="p3">*</ept>.</source>
          <target state="new">There is an <bpt id="p1">*</bpt>id<ept id="p1">*</ept> field which is the field we use to refer back to an author document, standard practice in a normalized model, but then we also have <bpt id="p2">*</bpt>name<ept id="p2">*</ept> and <bpt id="p3">*</bpt>thumbnailUrl<ept id="p3">*</ept>.</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>We could've just stuck with <bpt id="p1">*</bpt>id<ept id="p1">*</ept> and left the application to get any additional information it needed from the respective author document using the "link", but because our application displays the author's name and a thumbnail picture with every book displayed we can save a round trip to the server per book in a list by denormalizing <bpt id="p2">**</bpt>some<ept id="p2">**</ept> data from the author.</source>
          <target state="new">We could've just stuck with <bpt id="p1">*</bpt>id<ept id="p1">*</ept> and left the application to get any additional information it needed from the respective author document using the "link", but because our application displays the author's name and a thumbnail picture with every book displayed we can save a round trip to the server per book in a list by denormalizing <bpt id="p2">**</bpt>some<ept id="p2">**</ept> data from the author.</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Sure, if the author's name changed or they wanted to update their photo we'd have to go an update every book they ever published but for our application, based on the assumption that authors don't change their names very often, this is an acceptable design decision.</source>
          <target state="new">Sure, if the author's name changed or they wanted to update their photo we'd have to go an update every book they ever published but for our application, based on the assumption that authors don't change their names very often, this is an acceptable design decision.</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>In the example there are <bpt id="p1">**</bpt>pre-calculated aggregates<ept id="p1">**</ept> values to save expensive processing on a read operation.</source>
          <target state="new">In the example there are <bpt id="p1">**</bpt>pre-calculated aggregates<ept id="p1">**</ept> values to save expensive processing on a read operation.</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>In the example, some of the data embedded in the author document is data that is calculated at run-time.</source>
          <target state="new">In the example, some of the data embedded in the author document is data that is calculated at run-time.</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Every time a new book is published, a book document is created <bpt id="p1">**</bpt>and<ept id="p1">**</ept> the countOfBooks field is set to a calculated value based on the number of book documents that exist for a particular author.</source>
          <target state="new">Every time a new book is published, a book document is created <bpt id="p1">**</bpt>and<ept id="p1">**</ept> the countOfBooks field is set to a calculated value based on the number of book documents that exist for a particular author.</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>This optimization would be good in read heavy systems where we can afford to do computations on writes in order to optimize reads.</source>
          <target state="new">This optimization would be good in read heavy systems where we can afford to do computations on writes in order to optimize reads.</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The ability to have a model with pre-calculated fields is made possible because DocumentDB supports <bpt id="p1">**</bpt>multi-document transactions<ept id="p1">**</ept>.</source>
          <target state="new">The ability to have a model with pre-calculated fields is made possible because DocumentDB supports <bpt id="p1">**</bpt>multi-document transactions<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Many NoSQL stores cannot do transactions across documents and therefore advocate design decisions, such as "always embed everything", due to this limitation.</source>
          <target state="new">Many NoSQL stores cannot do transactions across documents and therefore advocate design decisions, such as "always embed everything", due to this limitation.</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>With DocumentDB, you can use server-side triggers, or stored procedures, that insert books and update authors all within an ACID transaction.</source>
          <target state="new">With DocumentDB, you can use server-side triggers, or stored procedures, that insert books and update authors all within an ACID transaction.</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Now you don't <bpt id="p1">**</bpt>have<ept id="p1">**</ept> to embed everything in to one document just to be sure that your data remains consistent.</source>
          <target state="new">Now you don't <bpt id="p1">**</bpt>have<ept id="p1">**</ept> to embed everything in to one document just to be sure that your data remains consistent.</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="NextSteps"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Next steps</source>
          <target state="new"><ph id="ph1">&lt;a name="NextSteps"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Next steps</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The biggest takeaways from this article is to understand that data modeling in a schema-free world is just as important as ever.</source>
          <target state="new">The biggest takeaways from this article is to understand that data modeling in a schema-free world is just as important as ever.</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Just as there is no single way to represent a piece of data on a screen, there is no single way to model your data.</source>
          <target state="new">Just as there is no single way to represent a piece of data on a screen, there is no single way to model your data.</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>You need to understand your application and how it will produce, consume, and process the data.</source>
          <target state="new">You need to understand your application and how it will produce, consume, and process the data.</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Then, by applying some of the guidelines presented here you can set about creating a model that addresses the immediate needs of your application.</source>
          <target state="new">Then, by applying some of the guidelines presented here you can set about creating a model that addresses the immediate needs of your application.</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>When your applications need to change, you can leverage the flexibility of a schema-free database to embrace that change and evolve your data model easily.</source>
          <target state="new">When your applications need to change, you can leverage the flexibility of a schema-free database to embrace that change and evolve your data model easily.</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>To learn more about Azure DocumentDB, refer to the service’s <bpt id="p1">[</bpt>documentation<ept id="p1">]( ../../services/documentdb/)</ept> page.</source>
          <target state="new">To learn more about Azure DocumentDB, refer to the service’s <bpt id="p1">[</bpt>documentation<ept id="p1">]( ../../services/documentdb/)</ept> page.</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>To learn about tuning indexes in Azure DocumentDB, refer to the article on <bpt id="p1">[</bpt>indexing policies<ept id="p1">](documentdb-indexing-policies.md)</ept>.</source>
          <target state="new">To learn about tuning indexes in Azure DocumentDB, refer to the article on <bpt id="p1">[</bpt>indexing policies<ept id="p1">](documentdb-indexing-policies.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>To understand how to shard your data across multiple partitions, refer to <bpt id="p1">[</bpt>Partitioning Data in DocumentDB<ept id="p1">](documentdb-partition-data.md)</ept>.</source>
          <target state="new">To understand how to shard your data across multiple partitions, refer to <bpt id="p1">[</bpt>Partitioning Data in DocumentDB<ept id="p1">](documentdb-partition-data.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>And finally, for guidance on data modeling and sharding for multi-tenant applications, consult <bpt id="p1">[</bpt>Scaling a Multi-Tenant Application with Azure DocumentDB<ept id="p1">](http://blogs.msdn.com/b/documentdb/archive/2014/12/03/scaling-a-multi-tenant-application-with-azure-documentdb.aspx)</ept>.</source>
          <target state="new">And finally, for guidance on data modeling and sharding for multi-tenant applications, consult <bpt id="p1">[</bpt>Scaling a Multi-Tenant Application with Azure DocumentDB<ept id="p1">](http://blogs.msdn.com/b/documentdb/archive/2014/12/03/scaling-a-multi-tenant-application-with-azure-documentdb.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>test</source>
          <target state="new">test</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dde28b65ab0cf546b8b5ccdd236b5059d1edba44</xliffext:olfilehash>
  </header>
</xliff>