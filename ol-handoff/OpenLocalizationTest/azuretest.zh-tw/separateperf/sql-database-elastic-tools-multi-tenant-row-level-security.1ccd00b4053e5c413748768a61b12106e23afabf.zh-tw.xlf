<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Multi-tenant applications with elastic database tools and row-level security</source>
          <target state="new">Multi-tenant applications with elastic database tools and row-level security</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Learn how to use elastic database tools together with row-level security to build an application with a highly scalable data tier on Azure SQL Database that supports multi-tenant shards.</source>
          <target state="new">Learn how to use elastic database tools together with row-level security to build an application with a highly scalable data tier on Azure SQL Database that supports multi-tenant shards.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Multi-tenant applications with elastic database tools and row-level security</source>
          <target state="new">Multi-tenant applications with elastic database tools and row-level security</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Elastic database tools<ept id="p1">](sql-database-elastic-scale-get-started.md)</ept> and <bpt id="p2">[</bpt>row-level security (RLS)<ept id="p2">](https://msdn.microsoft.com/library/dn765131)</ept> offer a powerful set of capabilities for flexibly and efficiently scaling the data tier of a multi-tenant application with Azure SQL Database.</source>
          <target state="new"><bpt id="p1">[</bpt>Elastic database tools<ept id="p1">](sql-database-elastic-scale-get-started.md)</ept> and <bpt id="p2">[</bpt>row-level security (RLS)<ept id="p2">](https://msdn.microsoft.com/library/dn765131)</ept> offer a powerful set of capabilities for flexibly and efficiently scaling the data tier of a multi-tenant application with Azure SQL Database.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This article illustrates how to use these technologies together to build an application with a highly scalable data tier that supports multi-tenant shards, using <bpt id="p1">**</bpt>ADO.NET SqlClient<ept id="p1">**</ept> and/or <bpt id="p2">**</bpt>Entity Framework<ept id="p2">**</ept>.</source>
          <target state="new">This article illustrates how to use these technologies together to build an application with a highly scalable data tier that supports multi-tenant shards, using <bpt id="p1">**</bpt>ADO.NET SqlClient<ept id="p1">**</ept> and/or <bpt id="p2">**</bpt>Entity Framework<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Elastic database tools<ept id="p1">**</ept> enables developers to scale out the data tier of an application via industry-standard sharding practices using a set of .NET libraries and Azure service templates.</source>
          <target state="new"><bpt id="p1">**</bpt>Elastic database tools<ept id="p1">**</ept> enables developers to scale out the data tier of an application via industry-standard sharding practices using a set of .NET libraries and Azure service templates.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Managing shards with using the Elastic Database Client Library helps automate and streamline many of the infrastructural tasks typically associated with sharding.</source>
          <target state="new">Managing shards with using the Elastic Database Client Library helps automate and streamline many of the infrastructural tasks typically associated with sharding.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Row-level security<ept id="p1">**</ept> enables developers to store data for multiple tenants in the same database using security policies to filter out rows that do not belong to the tenant executing a query.</source>
          <target state="new"><bpt id="p1">**</bpt>Row-level security<ept id="p1">**</ept> enables developers to store data for multiple tenants in the same database using security policies to filter out rows that do not belong to the tenant executing a query.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Centralizing access logic with RLS inside the database, rather than in the application, simplifies maintenance and reduces the risk of error as an application’s codebase grows.</source>
          <target state="new">Centralizing access logic with RLS inside the database, rather than in the application, simplifies maintenance and reduces the risk of error as an application’s codebase grows.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>RLS requires the latest <bpt id="p1">[</bpt>Azure SQL Database update (V12)<ept id="p1">](sql-database-preview-whats-new.md)</ept>.</source>
          <target state="new">RLS requires the latest <bpt id="p1">[</bpt>Azure SQL Database update (V12)<ept id="p1">](sql-database-preview-whats-new.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Using these features together, an application can benefit from cost savings and efficiency gains by storing data for multiple tenants in the same shard database.</source>
          <target state="new">Using these features together, an application can benefit from cost savings and efficiency gains by storing data for multiple tenants in the same shard database.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>At the same time, an application still has the flexibility to offer isolated, single-tenant shards for “premium” tenants who require stricter performance guarantees since multi-tenant shards do not guarantee equal resource distribution among tenants.</source>
          <target state="new">At the same time, an application still has the flexibility to offer isolated, single-tenant shards for “premium” tenants who require stricter performance guarantees since multi-tenant shards do not guarantee equal resource distribution among tenants.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>In short, the elastic database client library’s <bpt id="p1">[</bpt>data dependent routing<ept id="p1">](sql-database-elastic-scale-data-dependent-routing.md)</ept> APIs automatically connect tenants to the correct shard database containing their sharding key (generally a “TenantId”).</source>
          <target state="new">In short, the elastic database client library’s <bpt id="p1">[</bpt>data dependent routing<ept id="p1">](sql-database-elastic-scale-data-dependent-routing.md)</ept> APIs automatically connect tenants to the correct shard database containing their sharding key (generally a “TenantId”).</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Once connected, an RLS security policy within the database ensures that tenants can only access rows that contain their TenantId.</source>
          <target state="new">Once connected, an RLS security policy within the database ensures that tenants can only access rows that contain their TenantId.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>It is assumed that all tables contain a TenantId column to indicate which rows belong to each tenant.</source>
          <target state="new">It is assumed that all tables contain a TenantId column to indicate which rows belong to each tenant.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>![Blogging app architecture][1]</source>
          <target state="new">![Blogging app architecture][1]</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Download the sample project</source>
          <target state="new">Download the sample project</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="new">Prerequisites</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Use Visual Studio (2012 or higher)</source>
          <target state="new">Use Visual Studio (2012 or higher)</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Create three Azure SQL Databases</source>
          <target state="new">Create three Azure SQL Databases</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Download sample project: <bpt id="p1">[</bpt>Elastic DB Tools for Azure SQL - Multi-Tenant Shards<ept id="p1">](http://go.microsoft.com/?linkid=9888163)</ept></source>
          <target state="new">Download sample project: <bpt id="p1">[</bpt>Elastic DB Tools for Azure SQL - Multi-Tenant Shards<ept id="p1">](http://go.microsoft.com/?linkid=9888163)</ept></target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Fill in the information for your databases at the beginning of <bpt id="p1">**</bpt>Program.cs<ept id="p1">**</ept></source>
          <target state="new">Fill in the information for your databases at the beginning of <bpt id="p1">**</bpt>Program.cs<ept id="p1">**</ept></target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>This project extends the one described in <bpt id="p1">[</bpt>Elastic DB Tools for Azure SQL - Entity Framework Integration<ept id="p1">](sql-database-elastic-scale-use-entity-framework-applications-visual-studio.md)</ept> by adding support for multi-tenant shard databases.</source>
          <target state="new">This project extends the one described in <bpt id="p1">[</bpt>Elastic DB Tools for Azure SQL - Entity Framework Integration<ept id="p1">](sql-database-elastic-scale-use-entity-framework-applications-visual-studio.md)</ept> by adding support for multi-tenant shard databases.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>It builds a simple console application for creating blogs and posts, with four tenants and two multi-tenant shard databases as illustrated in the above diagram.</source>
          <target state="new">It builds a simple console application for creating blogs and posts, with four tenants and two multi-tenant shard databases as illustrated in the above diagram.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Build and run the application.</source>
          <target state="new">Build and run the application.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>This will bootstrap the elastic database tools’ shard map manager and run the following tests:</source>
          <target state="new">This will bootstrap the elastic database tools’ shard map manager and run the following tests:</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Using Entity Framework and LINQ, create a new blog and then display all blogs for each tenant</source>
          <target state="new">Using Entity Framework and LINQ, create a new blog and then display all blogs for each tenant</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Using ADO.NET SqlClient, display all blogs for a tenant</source>
          <target state="new">Using ADO.NET SqlClient, display all blogs for a tenant</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Try to insert a blog for the wrong tenant to verify that an error is thrown</source>
          <target state="new">Try to insert a blog for the wrong tenant to verify that an error is thrown</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Notice that because RLS has not yet been enabled in the shard databases, each of these tests reveals a problem: tenants are able to see blogs that do not belong to them, and the application is not prevented from inserting a blog for the wrong tenant.</source>
          <target state="new">Notice that because RLS has not yet been enabled in the shard databases, each of these tests reveals a problem: tenants are able to see blogs that do not belong to them, and the application is not prevented from inserting a blog for the wrong tenant.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The remainder of this article describes how to resolve these problems by enforcing tenant isolation with RLS.</source>
          <target state="new">The remainder of this article describes how to resolve these problems by enforcing tenant isolation with RLS.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>There are two steps:</source>
          <target state="new">There are two steps:</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Application tier<ept id="p1">**</ept>: Modify the application code to always set CONTEXT_INFO to the current TenantId after opening a connection.</source>
          <target state="new"><bpt id="p1">**</bpt>Application tier<ept id="p1">**</ept>: Modify the application code to always set CONTEXT_INFO to the current TenantId after opening a connection.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The sample project has already done this.</source>
          <target state="new">The sample project has already done this.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Data tier<ept id="p1">**</ept>: Create an RLS security policy in each shard database to filter rows based on the value of CONTEXT_INFO.</source>
          <target state="new"><bpt id="p1">**</bpt>Data tier<ept id="p1">**</ept>: Create an RLS security policy in each shard database to filter rows based on the value of CONTEXT_INFO.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>You will need to do this for each of your shard databases, otherwise rows in multi-tenant shards will not be filtered.</source>
          <target state="new">You will need to do this for each of your shard databases, otherwise rows in multi-tenant shards will not be filtered.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Step 1) Application tier: Set CONTEXT_INFO to TenantId</source>
          <target state="new">Step 1) Application tier: Set CONTEXT_INFO to TenantId</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>After connecting to a shard database using the elastic database client library’s data dependent routing APIs, the application still needs to tell the database which TenantId is using that connection so that an RLS security policy can filter out rows belonging to other tenants.</source>
          <target state="new">After connecting to a shard database using the elastic database client library’s data dependent routing APIs, the application still needs to tell the database which TenantId is using that connection so that an RLS security policy can filter out rows belonging to other tenants.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The recommended way to pass this information is to set <bpt id="p1">[</bpt>CONTEXT_INFO<ept id="p1">](https://msdn.microsoft.com/library/ms180125)</ept> to the current TenantId for that connection.</source>
          <target state="new">The recommended way to pass this information is to set <bpt id="p1">[</bpt>CONTEXT_INFO<ept id="p1">](https://msdn.microsoft.com/library/ms180125)</ept> to the current TenantId for that connection.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Note that on Azure SQL Database, CONTEXT_INFO is pre-populated with a session-specific GUID, so you <bpt id="p1">*</bpt>must<ept id="p1">*</ept> set CONTEXT_INFO to the correct TenantId before executing any queries on a new connection to ensure that no rows are inadvertently leaked.</source>
          <target state="new">Note that on Azure SQL Database, CONTEXT_INFO is pre-populated with a session-specific GUID, so you <bpt id="p1">*</bpt>must<ept id="p1">*</ept> set CONTEXT_INFO to the correct TenantId before executing any queries on a new connection to ensure that no rows are inadvertently leaked.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Entity Framework</source>
          <target state="new">Entity Framework</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>For applications using Entity Framework, the easiest approach is to set CONTEXT_INFO within the ElasticScaleContext override described in <bpt id="p1">[</bpt>Data Dependent Routing using EF DbContext<ept id="p1">](sql-database-elastic-scale-use-entity-framework-applications-visual-studio.md/#data-dependent-routing-using-ef-dbcontext)</ept>.</source>
          <target state="new">For applications using Entity Framework, the easiest approach is to set CONTEXT_INFO within the ElasticScaleContext override described in <bpt id="p1">[</bpt>Data Dependent Routing using EF DbContext<ept id="p1">](sql-database-elastic-scale-use-entity-framework-applications-visual-studio.md/#data-dependent-routing-using-ef-dbcontext)</ept>.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Before returning the connection brokered through data dependent routing, simply create and execute a SqlCommand that sets CONTEXT_INFO to the shardingKey (TenantId) specified for that connection.</source>
          <target state="new">Before returning the connection brokered through data dependent routing, simply create and execute a SqlCommand that sets CONTEXT_INFO to the shardingKey (TenantId) specified for that connection.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>This way, you only need to write code once to set CONTEXT_INFO.</source>
          <target state="new">This way, you only need to write code once to set CONTEXT_INFO.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Now CONTEXT_INFO is automatically set to the specified TenantId whenever ElasticScaleContext is invoked:</source>
          <target state="new">Now CONTEXT_INFO is automatically set to the specified TenantId whenever ElasticScaleContext is invoked:</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>ADO.NET SqlClient</source>
          <target state="new">ADO.NET SqlClient</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For applications using ADO.NET SqlClient, the recommended approach is to create a wrapper function around ShardMap.OpenConnectionForKey() that automatically sets CONTEXT_INFO to the correct TenantId before returning a connection.</source>
          <target state="new">For applications using ADO.NET SqlClient, the recommended approach is to create a wrapper function around ShardMap.OpenConnectionForKey() that automatically sets CONTEXT_INFO to the correct TenantId before returning a connection.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>To ensure that CONTEXT_INFO is always set properly, you should only open connections using this wrapper function.</source>
          <target state="new">To ensure that CONTEXT_INFO is always set properly, you should only open connections using this wrapper function.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Step 2) Data tier: Create row-level security policy and constraints</source>
          <target state="new">Step 2) Data tier: Create row-level security policy and constraints</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Create a security policy to filter SELECT, UPDATE, and DELETE queries</source>
          <target state="new">Create a security policy to filter SELECT, UPDATE, and DELETE queries</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Now that the application is setting CONTEXT_INFO to the current TenantId before querying, an RLS security policy can filter queries and exclude rows that have a different TenantId.</source>
          <target state="new">Now that the application is setting CONTEXT_INFO to the current TenantId before querying, an RLS security policy can filter queries and exclude rows that have a different TenantId.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>RLS is implemented in T-SQL: a user-defined predicate function defines the filtering logic, and a security policy binds this function to any number of tables.</source>
          <target state="new">RLS is implemented in T-SQL: a user-defined predicate function defines the filtering logic, and a security policy binds this function to any number of tables.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For this project, the predicate function will simply verify that the application (rather than some other SQL user) is connected to the database, and that the value of CONTEXT_INFO matches the TenantId of a given row.</source>
          <target state="new">For this project, the predicate function will simply verify that the application (rather than some other SQL user) is connected to the database, and that the value of CONTEXT_INFO matches the TenantId of a given row.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Rows that meet these conditions will be allowed through the filter for SELECT, UPDATE, and DELETE queries.</source>
          <target state="new">Rows that meet these conditions will be allowed through the filter for SELECT, UPDATE, and DELETE queries.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>If CONTEXT_INFO has not been set, no rows will be returned.</source>
          <target state="new">If CONTEXT_INFO has not been set, no rows will be returned.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>To enable RLS, execute the following T-SQL on all shards using either Visual Studio (SSDT), SSMS, or the PowerShell script included in the project (or if you are using <bpt id="p1">[</bpt>Elastic Database Jobs<ept id="p1">](sql-database-elastic-jobs-overview.md)</ept>, you can use it to automate execution of this T-SQL on all shards):</source>
          <target state="new">To enable RLS, execute the following T-SQL on all shards using either Visual Studio (SSDT), SSMS, or the PowerShell script included in the project (or if you are using <bpt id="p1">[</bpt>Elastic Database Jobs<ept id="p1">](sql-database-elastic-jobs-overview.md)</ept>, you can use it to automate execution of this T-SQL on all shards):</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.TIP]</ph> For more complex projects that need to add the predicate function on hundreds of tables, you can use a helper stored procedure that automatically generates a security policy adding a predicate on all tables in a schema.</source>
          <target state="new"><ph id="ph1">[AZURE.TIP]</ph> For more complex projects that need to add the predicate function on hundreds of tables, you can use a helper stored procedure that automatically generates a security policy adding a predicate on all tables in a schema.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Apply Row-Level Security to all tables – helper script (blog)<ept id="p1">](http://blogs.msdn.com/b/sqlsecurity/archive/2015/03/31/apply-row-level-security-to-all-tables-helper-script)</ept>.</source>
          <target state="new">See <bpt id="p1">[</bpt>Apply Row-Level Security to all tables – helper script (blog)<ept id="p1">](http://blogs.msdn.com/b/sqlsecurity/archive/2015/03/31/apply-row-level-security-to-all-tables-helper-script)</ept>.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>If you add a new table later on, simply ALTER the security policy and add a filter predicate on the new table:</source>
          <target state="new">If you add a new table later on, simply ALTER the security policy and add a filter predicate on the new table:</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Now if you run the sample application again, tenants will not be able to see rows that do not belong to them.</source>
          <target state="new">Now if you run the sample application again, tenants will not be able to see rows that do not belong to them.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Add check constraints to block wrong-tenant INSERTs and UPDATEs</source>
          <target state="new">Add check constraints to block wrong-tenant INSERTs and UPDATEs</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>At present, RLS security policies will not prevent the application from accidentally inserting rows for the wrong TenantId, or updating the TenantId of a visible row to be a new value.</source>
          <target state="new">At present, RLS security policies will not prevent the application from accidentally inserting rows for the wrong TenantId, or updating the TenantId of a visible row to be a new value.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>For some applications, such as read-only reporting apps, this is not a problem.</source>
          <target state="new">For some applications, such as read-only reporting apps, this is not a problem.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>However, since this application allows tenants to insert new blogs, it is worthwhile to create an additional safeguard that throws an error if the application code mistakenly tries to insert or update rows such that violate the filter predicate.</source>
          <target state="new">However, since this application allows tenants to insert new blogs, it is worthwhile to create an additional safeguard that throws an error if the application code mistakenly tries to insert or update rows such that violate the filter predicate.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>As described in <bpt id="p1">[</bpt>Row-Level Security: Blocking unauthorized INSERTs (blog)<ept id="p1">](http://blogs.msdn.com/b/sqlsecurity/archive/2015/03/23/row-level-security-blocking-unauthorized-inserts)</ept>, the recommended solution is to create a check constraint on each table to enforce the same RLS filter predicate for insert and update operations.</source>
          <target state="new">As described in <bpt id="p1">[</bpt>Row-Level Security: Blocking unauthorized INSERTs (blog)<ept id="p1">](http://blogs.msdn.com/b/sqlsecurity/archive/2015/03/23/row-level-security-blocking-unauthorized-inserts)</ept>, the recommended solution is to create a check constraint on each table to enforce the same RLS filter predicate for insert and update operations.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>To add check constraints, execute the following T-SQL on all shards, using SSMS, SSDT, or the included PowerShell script (or Elastic Database Jobs) as described above:</source>
          <target state="new">To add check constraints, execute the following T-SQL on all shards, using SSMS, SSDT, or the included PowerShell script (or Elastic Database Jobs) as described above:</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Now the application cannot insert rows that belong to tenants other than the one currently connected to the shard database.</source>
          <target state="new">Now the application cannot insert rows that belong to tenants other than the one currently connected to the shard database.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Likewise the application cannot update visible rows to have a different TenantId.</source>
          <target state="new">Likewise the application cannot update visible rows to have a different TenantId.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>If the application attempts to do either, a DbUpdateException will be raised.</source>
          <target state="new">If the application attempts to do either, a DbUpdateException will be raised.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Add default constraints to automatically populate TenantId for INSERTs</source>
          <target state="new">Add default constraints to automatically populate TenantId for INSERTs</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>In addition to using check constraints to block wrong-tenant inserts, you can put a default constraint on each table to automatically populate the TenantId with the current value of CONTEXT_INFO when inserting rows.</source>
          <target state="new">In addition to using check constraints to block wrong-tenant inserts, you can put a default constraint on each table to automatically populate the TenantId with the current value of CONTEXT_INFO when inserting rows.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="new">For example:</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Now the application does not need to specify a TenantId when inserting rows:</source>
          <target state="new">Now the application does not need to specify a TenantId when inserting rows:</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> If you use default constraints for an Entity Framework project, it is recommended that you do NOT include the TenantId column in your EF data model.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> If you use default constraints for an Entity Framework project, it is recommended that you do NOT include the TenantId column in your EF data model.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>This is because Entity Framework queries automatically supply default values that will override the default constraints created in T-SQL that use CONTEXT_INFO.</source>
          <target state="new">This is because Entity Framework queries automatically supply default values that will override the default constraints created in T-SQL that use CONTEXT_INFO.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>To use default constraints in the sample project, for instance, you should remove TenantId from DataClasses.cs (and run Add-Migration in the Package Manager Console) and use T-SQL to ensure that the field only exists in the database tables.</source>
          <target state="new">To use default constraints in the sample project, for instance, you should remove TenantId from DataClasses.cs (and run Add-Migration in the Package Manager Console) and use T-SQL to ensure that the field only exists in the database tables.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>This way, EF will not automatically supply incorrect default values when inserting data.</source>
          <target state="new">This way, EF will not automatically supply incorrect default values when inserting data.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>(Optional) Enable a "superuser" to access all rows</source>
          <target state="new">(Optional) Enable a "superuser" to access all rows</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Some applications may want to create a "superuser" who can access all rows, for instance, in order to enable reporting across all tenants on all shards, or to perform Split/Merge operations on shards that involve moving tenant rows between databases.</source>
          <target state="new">Some applications may want to create a "superuser" who can access all rows, for instance, in order to enable reporting across all tenants on all shards, or to perform Split/Merge operations on shards that involve moving tenant rows between databases.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>To enable this, you should create a new SQL user ("superuser" in this example) in each shard database.</source>
          <target state="new">To enable this, you should create a new SQL user ("superuser" in this example) in each shard database.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Then alter the security policy with a new predicate function that allows this user to access all rows:</source>
          <target state="new">Then alter the security policy with a new predicate function that allows this user to access all rows:</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Maintenance</source>
          <target state="new">Maintenance</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Adding new shards<ept id="p1">**</ept>: You must execute the T-SQL script to enable RLS (and add check constraints) on any new shards, otherwise queries on these shards will not be filtered.</source>
          <target state="new"><bpt id="p1">**</bpt>Adding new shards<ept id="p1">**</ept>: You must execute the T-SQL script to enable RLS (and add check constraints) on any new shards, otherwise queries on these shards will not be filtered.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Adding new tables<ept id="p1">**</ept>: You must add a filter predicate to the security policy on all shards whenever a new table is created, otherwise queries on the new table will not be filtered.</source>
          <target state="new"><bpt id="p1">**</bpt>Adding new tables<ept id="p1">**</ept>: You must add a filter predicate to the security policy on all shards whenever a new table is created, otherwise queries on the new table will not be filtered.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>This can be automated using a DDL trigger, as described in <bpt id="p1">[</bpt>Apply Row-Level Security automatically to newly created tables (blog)<ept id="p1">](http://blogs.msdn.com/b/sqlsecurity/archive/2015/05/22/apply-row-level-security-automatically-to-newly-created-tables.aspx)</ept>.</source>
          <target state="new">This can be automated using a DDL trigger, as described in <bpt id="p1">[</bpt>Apply Row-Level Security automatically to newly created tables (blog)<ept id="p1">](http://blogs.msdn.com/b/sqlsecurity/archive/2015/05/22/apply-row-level-security-automatically-to-newly-created-tables.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="new">Summary</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Elastic database tools and row-level security can be used together to scale out an application’s data tier with support for both multi-tenant and single-tenant shards.</source>
          <target state="new">Elastic database tools and row-level security can be used together to scale out an application’s data tier with support for both multi-tenant and single-tenant shards.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Multi-tenant shards can be used to store data more efficiently (particularly in cases where a large number of tenants have only a few rows of data), while single-tenant shards can be used to support premium tenants with stricter performance and isolation requirements.</source>
          <target state="new">Multi-tenant shards can be used to store data more efficiently (particularly in cases where a large number of tenants have only a few rows of data), while single-tenant shards can be used to support premium tenants with stricter performance and isolation requirements.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Elastic Database Tools Documentation Map<ept id="p1">](sql-database-elastic-scale-documentation-map.md)</ept> or the <bpt id="p2">[</bpt>Row-Level Security reference<ept id="p2">](https://msdn.microsoft.com/library/dn765131)</ept> on MSDN.</source>
          <target state="new">For more information, see the <bpt id="p1">[</bpt>Elastic Database Tools Documentation Map<ept id="p1">](sql-database-elastic-scale-documentation-map.md)</ept> or the <bpt id="p2">[</bpt>Row-Level Security reference<ept id="p2">](https://msdn.microsoft.com/library/dn765131)</ept> on MSDN.</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">35cbc10e67b2cba3c2d4328812f8d5302eed19fe</xliffext:olfilehash>
  </header>
</xliff>