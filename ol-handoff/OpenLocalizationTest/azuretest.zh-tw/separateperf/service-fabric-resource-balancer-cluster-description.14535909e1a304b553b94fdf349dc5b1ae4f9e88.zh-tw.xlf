<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Resource Balancer Cluster Description</source>
          <target state="new">Resource Balancer Cluster Description</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Specifying a cluster description for the Resource Balancer</source>
          <target state="new">Specifying a cluster description for the Resource Balancer</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Cluster Description</source>
          <target state="new">Cluster Description</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The Service Fabric Resource Balancer provides several mechanisms to describe a cluster.</source>
          <target state="new">The Service Fabric Resource Balancer provides several mechanisms to describe a cluster.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>During runtime, the Resource Balancer uses these pieces of information to ensure that it places services in ways that ensure high availability of the services running in the cluster while also ensuring maximum utilization of the cluster resources.</source>
          <target state="new">During runtime, the Resource Balancer uses these pieces of information to ensure that it places services in ways that ensure high availability of the services running in the cluster while also ensuring maximum utilization of the cluster resources.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The Resource Balancer features that describe a cluster are fault domains, upgrade domains, node properties, and node capacities.</source>
          <target state="new">The Resource Balancer features that describe a cluster are fault domains, upgrade domains, node properties, and node capacities.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Additionally, the Resource Balancer has some configuration options that can tweak its performance.</source>
          <target state="new">Additionally, the Resource Balancer has some configuration options that can tweak its performance.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Key Concepts</source>
          <target state="new">Key Concepts</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Fault Domains:</source>
          <target state="new">Fault Domains:</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Fault domains enable cluster administrators to define the physical nodes that are likely to experience failure at the same time due to shared physical dependencies such as power and networking sources.</source>
          <target state="new">Fault domains enable cluster administrators to define the physical nodes that are likely to experience failure at the same time due to shared physical dependencies such as power and networking sources.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Fault domains typically represent hierarchies that are related to these shared dependencies, with more nodes likely to fail together from a higher point in the fault domain tree.</source>
          <target state="new">Fault domains typically represent hierarchies that are related to these shared dependencies, with more nodes likely to fail together from a higher point in the fault domain tree.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The following figure shows several nodes that are organized via hierarchical fault domains in the order of data center, rack, and blade.</source>
          <target state="new">The following figure shows several nodes that are organized via hierarchical fault domains in the order of data center, rack, and blade.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>![Fault Domains][Image1]</source>
          <target state="new">![Fault Domains][Image1]</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>During runtime, the Service Fabric Resource Manager considers the fault domains in the cluster and attempts to spread out the replicas for a given service so that they are all in separate fault domains.</source>
          <target state="new">During runtime, the Service Fabric Resource Manager considers the fault domains in the cluster and attempts to spread out the replicas for a given service so that they are all in separate fault domains.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>This process helps ensure, in case of failure of any one fault domain, that the availability of that service and its state is not compromised.</source>
          <target state="new">This process helps ensure, in case of failure of any one fault domain, that the availability of that service and its state is not compromised.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The following figure shows the replicas of a service that is spread over several fault domains even though there is enough room to concentrate them in only one or two domains.</source>
          <target state="new">The following figure shows the replicas of a service that is spread over several fault domains even though there is enough room to concentrate them in only one or two domains.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>![Fault Domains][Image2]</source>
          <target state="new">![Fault Domains][Image2]</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Fault domains are configured within the cluster manifest.</source>
          <target state="new">Fault domains are configured within the cluster manifest.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Each node is defined to be within a particular fault domain.</source>
          <target state="new">Each node is defined to be within a particular fault domain.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>During runtime, the Resource Manager combines the reports from all the nodes to develop a complete overview of all of the fault domains in the system.</source>
          <target state="new">During runtime, the Resource Manager combines the reports from all the nodes to develop a complete overview of all of the fault domains in the system.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Upgrade Domains</source>
          <target state="new">Upgrade Domains</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Upgrade domains are another piece of information that is consumed by the Resource Manager.</source>
          <target state="new">Upgrade domains are another piece of information that is consumed by the Resource Manager.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Upgrade domains, like fault domains, describe sets of nodes that are shut down for upgrades at approximately the same time.</source>
          <target state="new">Upgrade domains, like fault domains, describe sets of nodes that are shut down for upgrades at approximately the same time.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Upgrade domains are not hierarchical and can be thought of as tags.</source>
          <target state="new">Upgrade domains are not hierarchical and can be thought of as tags.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Whereas fault domains are defined by the physical layout of the nodes in the cluster, upgrade domains are determined by cluster administrators that are based on policies.</source>
          <target state="new">Whereas fault domains are defined by the physical layout of the nodes in the cluster, upgrade domains are determined by cluster administrators that are based on policies.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The policies are related to upgrades within the cluster.</source>
          <target state="new">The policies are related to upgrades within the cluster.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>More upgrade domains make upgrades more granular by limiting impact on the running cluster and services and by preventing any failure from affecting a large number of services.</source>
          <target state="new">More upgrade domains make upgrades more granular by limiting impact on the running cluster and services and by preventing any failure from affecting a large number of services.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Depending on other policies, such as the time that Service Fabric should wait after upgrading a domain before Service Fabric moves to the next domain, more upgrade domains can also increase the amount of time it takes to complete an upgrade in the cluster.</source>
          <target state="new">Depending on other policies, such as the time that Service Fabric should wait after upgrading a domain before Service Fabric moves to the next domain, more upgrade domains can also increase the amount of time it takes to complete an upgrade in the cluster.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>For these reasons, the Resource Manager collects upgrade domain information and spreads replicas among the upgrade domains in a cluster just like fault domains.</source>
          <target state="new">For these reasons, the Resource Manager collects upgrade domain information and spreads replicas among the upgrade domains in a cluster just like fault domains.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Upgrade domains might or might not correspond one-to-one with fault domains, but generally are not expected to correspond one-to-one.</source>
          <target state="new">Upgrade domains might or might not correspond one-to-one with fault domains, but generally are not expected to correspond one-to-one.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The following figure shows a layer of several upgrade domains on top of the previously defined fault domains.</source>
          <target state="new">The following figure shows a layer of several upgrade domains on top of the previously defined fault domains.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The Resource Manager still spreads the replicas across domains so that no fault or upgrade domain becomes concentrated with replicas to ensure high availability for the service, in spite of either upgrades or faults in the cluster.</source>
          <target state="new">The Resource Manager still spreads the replicas across domains so that no fault or upgrade domain becomes concentrated with replicas to ensure high availability for the service, in spite of either upgrades or faults in the cluster.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>![Upgrade Domains][Image3]</source>
          <target state="new">![Upgrade Domains][Image3]</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Upgrade domains and fault domains are both configured as a part of the node definition within the cluster manifest, as shown below:</source>
          <target state="new">Upgrade domains and fault domains are both configured as a part of the node definition within the cluster manifest, as shown below:</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>In Azure deployments, fault domains and upgrade domains are assigned by Azure; therefore, the definition of your nodes and roles within the Infrastructure option for Azure does not include fault domain or upgrade domain information.</source>
          <target state="new">In Azure deployments, fault domains and upgrade domains are assigned by Azure; therefore, the definition of your nodes and roles within the Infrastructure option for Azure does not include fault domain or upgrade domain information.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Node Properties</source>
          <target state="new">Node Properties</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Node properties are user-defined key/value pairs that provide extra metadata for a given node.</source>
          <target state="new">Node properties are user-defined key/value pairs that provide extra metadata for a given node.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Examples of node properties include whether the node had a hard drive or video card, the number of spindles in its hard drive, cores, and other physical properties.</source>
          <target state="new">Examples of node properties include whether the node had a hard drive or video card, the number of spindles in its hard drive, cores, and other physical properties.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Node properties can also be used to specify more abstract properties to aid in placing policy decisions.</source>
          <target state="new">Node properties can also be used to specify more abstract properties to aid in placing policy decisions.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For example, several nodes within a cluster can be assigned a "color" as a means of segmenting the cluster into different sections.</source>
          <target state="new">For example, several nodes within a cluster can be assigned a "color" as a means of segmenting the cluster into different sections.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The code example shows that node properties are defined for nodes via the cluster manifest as a part of node type definitions, which can then be applied to multiple nodes within the cluster.</source>
          <target state="new">The code example shows that node properties are defined for nodes via the cluster manifest as a part of node type definitions, which can then be applied to multiple nodes within the cluster.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The NodeName, NodeType, FaultDomain, and UpgradeDomain placement properties have default values.</source>
          <target state="new">The NodeName, NodeType, FaultDomain, and UpgradeDomain placement properties have default values.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Service Fabric will automatically supply default values for you so that you can use them when creating your service.</source>
          <target state="new">Service Fabric will automatically supply default values for you so that you can use them when creating your service.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Users should not specify their own placement properties with these same names.</source>
          <target state="new">Users should not specify their own placement properties with these same names.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>During runtime, the Resource Balancer uses node property information to ensure that services that require specific capabilities are placed on the appropriate nodes.</source>
          <target state="new">During runtime, the Resource Balancer uses node property information to ensure that services that require specific capabilities are placed on the appropriate nodes.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Node Capacities</source>
          <target state="new">Node Capacities</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Node capacities are key/value pairs that define the name and amount of a particular resource that a particular node has available for consumption.</source>
          <target state="new">Node capacities are key/value pairs that define the name and amount of a particular resource that a particular node has available for consumption.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The code example shows a node that it has capacity for a metric called "MemoryInMb" and that it has 2048 MB in memory available by default.</source>
          <target state="new">The code example shows a node that it has capacity for a metric called "MemoryInMb" and that it has 2048 MB in memory available by default.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Capacities are defined via the cluster manifest, much like node properties.</source>
          <target state="new">Capacities are defined via the cluster manifest, much like node properties.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>![Node Capacity][Image4]</source>
          <target state="new">![Node Capacity][Image4]</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Because services that run on a node can update their capacity requirements via Reporting Load, the Resource Balancer also checks periodically whether a node is at or over capacity for any of its metrics.</source>
          <target state="new">Because services that run on a node can update their capacity requirements via Reporting Load, the Resource Balancer also checks periodically whether a node is at or over capacity for any of its metrics.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>If it is, the Resource Balancer can move services to less loaded nodes to decrease resource contention and to improve overall performance and utilization.</source>
          <target state="new">If it is, the Resource Balancer can move services to less loaded nodes to decrease resource contention and to improve overall performance and utilization.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Note that while a given metric could also be listed in the property section of the node type, it is better to list it as a capacity if this is a property of the node that can be consumed during runtime.</source>
          <target state="new">Note that while a given metric could also be listed in the property section of the node type, it is better to list it as a capacity if this is a property of the node that can be consumed during runtime.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>To list it additionally as a property enables a service that depends on "minimum hardware requirements” to query for the node with placement constraints, which might be necessary if the resource is consumed by other services during runtime.</source>
          <target state="new">To list it additionally as a property enables a service that depends on "minimum hardware requirements” to query for the node with placement constraints, which might be necessary if the resource is consumed by other services during runtime.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>We recommend also including it as a capacity so that the Resource Balancer can take additional actions.</source>
          <target state="new">We recommend also including it as a capacity so that the Resource Balancer can take additional actions.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>When new services are created, the Service Fabric Cluster Resource Balancer uses the information about the capacity of existing nodes and the consumption of existing services to determine if there is sufficient available in the capacity to place the entire new service.</source>
          <target state="new">When new services are created, the Service Fabric Cluster Resource Balancer uses the information about the capacity of existing nodes and the consumption of existing services to determine if there is sufficient available in the capacity to place the entire new service.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>If there is insufficient capacity then the Create Service request is rejected with an error message indicating that there is insufficient cluster capacity remaining.</source>
          <target state="new">If there is insufficient capacity then the Create Service request is rejected with an error message indicating that there is insufficient cluster capacity remaining.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Resource Balancer Configurations</source>
          <target state="new">Resource Balancer Configurations</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Within the cluster manifest, the following several different configuration values that define the overall behavior of the Resource Balancer:</source>
          <target state="new">Within the cluster manifest, the following several different configuration values that define the overall behavior of the Resource Balancer:</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Balancing Thresholds govern how imbalanced the cluster can become with regard to a particular metric before the Resource Balancer reacts.</source>
          <target state="new">Balancing Thresholds govern how imbalanced the cluster can become with regard to a particular metric before the Resource Balancer reacts.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>A balancing threshold is the maximum ratio between the maximally used and minimally used nodes that the Resource Balancer allows to exist before it rebalances the clusters.</source>
          <target state="new">A balancing threshold is the maximum ratio between the maximally used and minimally used nodes that the Resource Balancer allows to exist before it rebalances the clusters.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The following figure shows two examples, where the balancing threshold for the given metric to be is 10.</source>
          <target state="new">The following figure shows two examples, where the balancing threshold for the given metric to be is 10.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>![Balancing Threshold][Image5]</source>
          <target state="new">![Balancing Threshold][Image5]</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Note that at this time, the "utilization" on a node does not take into consideration the size of the node as determined by the capacity of the node, but only the absolute use that is currently reported on the node for the specified metric.</source>
          <target state="new">Note that at this time, the "utilization" on a node does not take into consideration the size of the node as determined by the capacity of the node, but only the absolute use that is currently reported on the node for the specified metric.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The code example shows that balancing thresholds for metrics are configured per metric via the FabricSettings element within the cluster manifest.</source>
          <target state="new">The code example shows that balancing thresholds for metrics are configured per metric via the FabricSettings element within the cluster manifest.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Activity Thresholds act as a gate on how often the Resource Balancer runs by limiting the cases that the Resource Balancer reacts to when a significant absolute amount of load is present.</source>
          <target state="new">Activity Thresholds act as a gate on how often the Resource Balancer runs by limiting the cases that the Resource Balancer reacts to when a significant absolute amount of load is present.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>In this way, if the cluster is not very busy for a particular metric, the Resource Balancer does not run even if that small amount of metric is very imbalanced within the cluster.</source>
          <target state="new">In this way, if the cluster is not very busy for a particular metric, the Resource Balancer does not run even if that small amount of metric is very imbalanced within the cluster.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>This measure prevents wasting resources by rebalancing the cluster for substantively little gain.</source>
          <target state="new">This measure prevents wasting resources by rebalancing the cluster for substantively little gain.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The following figure shows that the balancing threshold for the metric is 4 and that the activity threshold is 1536.</source>
          <target state="new">The following figure shows that the balancing threshold for the metric is 4 and that the activity threshold is 1536.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>![Activity Threshold][Image6]</source>
          <target state="new">![Activity Threshold][Image6]</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Note also that both the activity and balancing thresholds must be exceeded for the same metric to cause the Resource Balancer to run.</source>
          <target state="new">Note also that both the activity and balancing thresholds must be exceeded for the same metric to cause the Resource Balancer to run.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Triggering either for two separate metrics does not cause the Resource Balancer to run.</source>
          <target state="new">Triggering either for two separate metrics does not cause the Resource Balancer to run.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The code example shows that just like balancing thresholds, activity thresholds are configured per metric via the FabricSettings element within the cluster manifest.</source>
          <target state="new">The code example shows that just like balancing thresholds, activity thresholds are configured per metric via the FabricSettings element within the cluster manifest.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>PLBRefreshInterval – Governs how frequently the Resource Balancer scans the information that it must check for constraint violations.</source>
          <target state="new">PLBRefreshInterval – Governs how frequently the Resource Balancer scans the information that it must check for constraint violations.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Constraint violations include placement constraints that are not met, services with fewer than their required number of instances or replicas, nodes over capacity for some metric, and overloaded fault or upgrade domains, or cluster imbalances by using the balancing and activity thresholds and its current view of load on the nodes in the cluster.</source>
          <target state="new">Constraint violations include placement constraints that are not met, services with fewer than their required number of instances or replicas, nodes over capacity for some metric, and overloaded fault or upgrade domains, or cluster imbalances by using the balancing and activity thresholds and its current view of load on the nodes in the cluster.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The refresh interval is defined in seconds, and the default is 1.</source>
          <target state="new">The refresh interval is defined in seconds, and the default is 1.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Frequency of constraint check and placement can alternatively be controlled by two new intervals (MinConstraintCheckInterval and MinPlacementInterval) and if the new parameters are defined, PLBRefreshInterval will not be used and cannot be defined.</source>
          <target state="new">Frequency of constraint check and placement can alternatively be controlled by two new intervals (MinConstraintCheckInterval and MinPlacementInterval) and if the new parameters are defined, PLBRefreshInterval will not be used and cannot be defined.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>MinConstraintCheckInterval - Governs how frequently the Resource Balancer scans the information that it must check for constraint violations.</source>
          <target state="new">MinConstraintCheckInterval - Governs how frequently the Resource Balancer scans the information that it must check for constraint violations.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Constraint violations include placement constraints that are not met, services with fewer than their required number of instances or replicas, nodes over capacity for some metric, and overloaded fault or upgrade domains, or cluster imbalances by using the balancing and activity thresholds and its current view of load on the nodes in the cluster.</source>
          <target state="new">Constraint violations include placement constraints that are not met, services with fewer than their required number of instances or replicas, nodes over capacity for some metric, and overloaded fault or upgrade domains, or cluster imbalances by using the balancing and activity thresholds and its current view of load on the nodes in the cluster.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The constraint check interval is defined in seconds.</source>
          <target state="new">The constraint check interval is defined in seconds.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>If constraint check interval is not defined, its default value will be equal to the value of PLBRefreshInterval (both values cannot be specified at the same time).</source>
          <target state="new">If constraint check interval is not defined, its default value will be equal to the value of PLBRefreshInterval (both values cannot be specified at the same time).</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>MinPlacementInterval – Governs how frequently the Resource Balancer checks if there are new instances or replicas that need to be placed and tries to place them.</source>
          <target state="new">MinPlacementInterval – Governs how frequently the Resource Balancer checks if there are new instances or replicas that need to be placed and tries to place them.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The placement interval is defined in seconds.</source>
          <target state="new">The placement interval is defined in seconds.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>If placement interval is not defined, default value is equal to the value of PLBRefreshInterval (both values cannot be specified at the same time).</source>
          <target state="new">If placement interval is not defined, default value is equal to the value of PLBRefreshInterval (both values cannot be specified at the same time).</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>MinLoadBalancingInterval – Establishes the minimum amount of time between Resource Balancing rounds.</source>
          <target state="new">MinLoadBalancingInterval – Establishes the minimum amount of time between Resource Balancing rounds.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>If the Resource Balancer took action based on information from the scan that is performed during the last PLBRefreshInterval interval, it does not run again for at least the same amount of time.</source>
          <target state="new">If the Resource Balancer took action based on information from the scan that is performed during the last PLBRefreshInterval interval, it does not run again for at least the same amount of time.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>It is defined in seconds, and the default is 5.</source>
          <target state="new">It is defined in seconds, and the default is 5.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Note that these values are aggressive, but that load balancing overall only occurs in the cluster if the balancing and activity thresholds are met for a given metric.</source>
          <target state="new">Note that these values are aggressive, but that load balancing overall only occurs in the cluster if the balancing and activity thresholds are met for a given metric.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The code example shows that if accurate and active load balancing is not required for a particular cluster, these values can be made less aggressive through the following configuration within the FabricSettings element.</source>
          <target state="new">The code example shows that if accurate and active load balancing is not required for a particular cluster, these values can be made less aggressive through the following configuration within the FabricSettings element.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>In this example configuration, minimal time distance between two constraint checks is 10 seconds, for placement 5 seconds while load balancing will occur every 5 minutes.</source>
          <target state="new">In this example configuration, minimal time distance between two constraint checks is 10 seconds, for placement 5 seconds while load balancing will occur every 5 minutes.</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Note that PLBRefreshInterval is not defined in this case.</source>
          <target state="new">Note that PLBRefreshInterval is not defined in this case.</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>In the second example configuration below we have PLBRefreshInterval and MinLoadBalancingInterval defined.</source>
          <target state="new">In the second example configuration below we have PLBRefreshInterval and MinLoadBalancingInterval defined.</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Since PLBRefreshInterval is set to 2 seconds, both MinPlacementInterval and MinConstraintCheckInterval will have their value set to 2 seconds as well.</source>
          <target state="new">Since PLBRefreshInterval is set to 2 seconds, both MinPlacementInterval and MinConstraintCheckInterval will have their value set to 2 seconds as well.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
##</ph> Next steps

For more information: <bpt id="p1">[</bpt><ept id="p1">Resource Balancer Architecture](service-fabric-resource-balancer-architecture.md)</ept><ph id="ph2">


[Image1]: media/service-fabric-resource-balancer-cluster-description/FD1.png
[Image2]: media/service-fabric-resource-balancer-cluster-description/FD2.png
[Image3]: media/service-fabric-resource-balancer-cluster-description/UD.png
[Image4]: media/service-fabric-resource-balancer-cluster-description/NC.png
[Image5]: media/service-fabric-resource-balancer-cluster-description/Config.png
[Image6]: media/service-fabric-resource-balancer-cluster-description/Thresholds.png</ph></source>
          <target state="new"><ph id="ph1">
##</ph> Next steps

For more information: <bpt id="p1">[</bpt><ept id="p1">Resource Balancer Architecture](service-fabric-resource-balancer-architecture.md)</ept><ph id="ph2">


[Image1]: media/service-fabric-resource-balancer-cluster-description/FD1.png
[Image2]: media/service-fabric-resource-balancer-cluster-description/FD2.png
[Image3]: media/service-fabric-resource-balancer-cluster-description/UD.png
[Image4]: media/service-fabric-resource-balancer-cluster-description/NC.png
[Image5]: media/service-fabric-resource-balancer-cluster-description/Config.png
[Image6]: media/service-fabric-resource-balancer-cluster-description/Thresholds.png</ph></target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">811b09cdfa3ef30e2305bd97673077bb61e9e052</xliffext:olfilehash>
  </header>
</xliff>