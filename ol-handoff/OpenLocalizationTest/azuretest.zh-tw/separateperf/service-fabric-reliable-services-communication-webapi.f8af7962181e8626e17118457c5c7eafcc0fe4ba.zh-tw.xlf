<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Service Fabric Web API Services with OWIN self-host | Microsoft Azure</source>
          <target state="new">Service Fabric Web API Services with OWIN self-host | Microsoft Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>This Service Fabric article explains how to implement service communication using ASP.NET Web API with OWIN self-hosting in Reliable Services.</source>
          <target state="new">This Service Fabric article explains how to implement service communication using ASP.NET Web API with OWIN self-hosting in Reliable Services.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Getting Started with Microsoft Azure Service Fabric Web API services with OWIN self-host</source>
          <target state="new">Getting Started with Microsoft Azure Service Fabric Web API services with OWIN self-host</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Service Fabric puts the power in your hands when deciding how you want your services to communicate with users and with each other.</source>
          <target state="new">Service Fabric puts the power in your hands when deciding how you want your services to communicate with users and with each other.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This tutorial focuses on implementing service communication using ASP.NET Web API with OWIN self-hosting in Service Fabric's <bpt id="p1">*</bpt>Reliable Services<ept id="p1">*</ept> API.</source>
          <target state="new">This tutorial focuses on implementing service communication using ASP.NET Web API with OWIN self-hosting in Service Fabric's <bpt id="p1">*</bpt>Reliable Services<ept id="p1">*</ept> API.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>We'll go in depth into the <bpt id="p1">*</bpt>Reliable Services<ept id="p1">*</ept> pluggable communication API and show you step-by-step how to set up a custom communication listener for you service with Web API used as an example.</source>
          <target state="new">We'll go in depth into the <bpt id="p1">*</bpt>Reliable Services<ept id="p1">*</ept> pluggable communication API and show you step-by-step how to set up a custom communication listener for you service with Web API used as an example.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>To see a complete example of a Web API communication listener, check out the <bpt id="p1">[</bpt>Service Fabric WebApplication sample on GitHub<ept id="p1">](https://github.com/Azure/servicefabric-samples/tree/master/samples/Services/VS2015/WebApplication)</ept>.</source>
          <target state="new">To see a complete example of a Web API communication listener, check out the <bpt id="p1">[</bpt>Service Fabric WebApplication sample on GitHub<ept id="p1">](https://github.com/Azure/servicefabric-samples/tree/master/samples/Services/VS2015/WebApplication)</ept>.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Intro to Web API in Service Fabric</source>
          <target state="new">Intro to Web API in Service Fabric</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>ASP.NET Web API is a popular and powerful framework for building HTTP APIs on top of the .NET Framework.</source>
          <target state="new">ASP.NET Web API is a popular and powerful framework for building HTTP APIs on top of the .NET Framework.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Head on over to <bpt id="p1">[</bpt>www.asp.net/webapi<ept id="p1">](http://www.asp.net/web-api/overview/getting-started-with-aspnet-web-api/tutorial-your-first-web-api)</ept> to learn more about Web API if you're not familiar with it already.</source>
          <target state="new">Head on over to <bpt id="p1">[</bpt>www.asp.net/webapi<ept id="p1">](http://www.asp.net/web-api/overview/getting-started-with-aspnet-web-api/tutorial-your-first-web-api)</ept> to learn more about Web API if you're not familiar with it already.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Web API in Service Fabric is the same ASP.NET Web API you know and love.</source>
          <target state="new">Web API in Service Fabric is the same ASP.NET Web API you know and love.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The difference is in how you <bpt id="p1">*</bpt>host<ept id="p1">*</ept> a Web API application (hint: you won't be using IIS).</source>
          <target state="new">The difference is in how you <bpt id="p1">*</bpt>host<ept id="p1">*</ept> a Web API application (hint: you won't be using IIS).</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>To better understand the difference, let's break it into two parts:</source>
          <target state="new">To better understand the difference, let's break it into two parts:</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The Web API application (your controllers, models, etc.)</source>
          <target state="new">The Web API application (your controllers, models, etc.)</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The host (the web server, usually IIS)</source>
          <target state="new">The host (the web server, usually IIS)</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The Web API application itself doesn't change here - it's no different from Web API applications you may have written in the past, and you should be able to simply move most of your application code right over.</source>
          <target state="new">The Web API application itself doesn't change here - it's no different from Web API applications you may have written in the past, and you should be able to simply move most of your application code right over.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Hosting the application may be a little different from what you're used to if you're used to hosting on IIS.</source>
          <target state="new">Hosting the application may be a little different from what you're used to if you're used to hosting on IIS.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>But before we get into the hosting part, let's start with the more familiar part: the Web API application.</source>
          <target state="new">But before we get into the hosting part, let's start with the more familiar part: the Web API application.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Set up a Web API application</source>
          <target state="new">Set up a Web API application</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Start by creating a new application, with a single stateless service, in Visual Studio 2015:</source>
          <target state="new">Start by creating a new application, with a single stateless service, in Visual Studio 2015:</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Create a new Service Fabric application</source>
          <target state="new">Create a new Service Fabric application</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Create a single stateless service</source>
          <target state="new">Create a single stateless service</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>This gives us an empty Stateless Service that will host the Web API application.</source>
          <target state="new">This gives us an empty Stateless Service that will host the Web API application.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>We're going to set the application up from scratch to see how it's all put together.</source>
          <target state="new">We're going to set the application up from scratch to see how it's all put together.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The first step is to pull in some NuGet packages for Web API.</source>
          <target state="new">The first step is to pull in some NuGet packages for Web API.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The package we want to use is <bpt id="p1">**</bpt>Microsoft.AspNet.WebApi.OwinSelfHost<ept id="p1">**</ept>.</source>
          <target state="new">The package we want to use is <bpt id="p1">**</bpt>Microsoft.AspNet.WebApi.OwinSelfHost<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>This package includes all the necessary Web API packages and the <bpt id="p1">*</bpt>host<ept id="p1">*</ept> packages - this will be important later.</source>
          <target state="new">This package includes all the necessary Web API packages and the <bpt id="p1">*</bpt>host<ept id="p1">*</ept> packages - this will be important later.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>With the packages installed, we can begin building out the basic Web API project structure.</source>
          <target state="new">With the packages installed, we can begin building out the basic Web API project structure.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If you've used  Web API, the project structure should look very familiar.</source>
          <target state="new">If you've used  Web API, the project structure should look very familiar.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Start by creating the basic Web API directories:</source>
          <target state="new">Start by creating the basic Web API directories:</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>App_Start</source>
          <target state="new">App_Start</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Controllers</source>
          <target state="new">Controllers</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Models</source>
          <target state="new">Models</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Add the basic Web API configuration classes in the App_Start directory:</source>
          <target state="new">Add the basic Web API configuration classes in the App_Start directory:</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>FormatterConfig.cs</source>
          <target state="new">FormatterConfig.cs</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>RouteConfig.cs</source>
          <target state="new">RouteConfig.cs</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Add a default controller in the Controllers directory:</source>
          <target state="new">Add a default controller in the Controllers directory:</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>DefaultController.cs</source>
          <target state="new">DefaultController.cs</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Finally, add a Startup class at the project root to register the routing, formatters, and any other configuration setup.</source>
          <target state="new">Finally, add a Startup class at the project root to register the routing, formatters, and any other configuration setup.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This is also where Web API plugs in to the <bpt id="p1">*</bpt>host<ept id="p1">*</ept>, which will be revisited again later.</source>
          <target state="new">This is also where Web API plugs in to the <bpt id="p1">*</bpt>host<ept id="p1">*</ept>, which will be revisited again later.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>While setting up the Startup class, create an interface called <bpt id="p1">*</bpt>IOwinAppBuilder<ept id="p1">*</ept> for the Startup class that defines the Configuration method.</source>
          <target state="new">While setting up the Startup class, create an interface called <bpt id="p1">*</bpt>IOwinAppBuilder<ept id="p1">*</ept> for the Startup class that defines the Configuration method.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Although not technically required for Web API to work, it will allow more flexible use of the Startup class later.</source>
          <target state="new">Although not technically required for Web API to work, it will allow more flexible use of the Startup class later.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Startup.cs</source>
          <target state="new">Startup.cs</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>IOwinAppBuilder.cs</source>
          <target state="new">IOwinAppBuilder.cs</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>That's it for the application part.</source>
          <target state="new">That's it for the application part.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>At this point we've just set up the basic Web API project layout.</source>
          <target state="new">At this point we've just set up the basic Web API project layout.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Compared to Web API projects you may have written in the past or to the basic Web API template, it shouldn't look much different so far.</source>
          <target state="new">Compared to Web API projects you may have written in the past or to the basic Web API template, it shouldn't look much different so far.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Your business logic goes in the controllers and models as usual.</source>
          <target state="new">Your business logic goes in the controllers and models as usual.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Now what do we do about hosting so we can actually run it?</source>
          <target state="new">Now what do we do about hosting so we can actually run it?</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Service Hosting</source>
          <target state="new">Service Hosting</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>In Service Fabric, your service runs in a <bpt id="p1">*</bpt>service host process<ept id="p1">*</ept> - an executable that runs your service code.</source>
          <target state="new">In Service Fabric, your service runs in a <bpt id="p1">*</bpt>service host process<ept id="p1">*</ept> - an executable that runs your service code.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>When writing a service using the Reliable Services API, and in fact in most cases when you're writing a service on Service Fabric in .NET, your service project just compiles to an .EXE that registers your service type and runs your code.</source>
          <target state="new">When writing a service using the Reliable Services API, and in fact in most cases when you're writing a service on Service Fabric in .NET, your service project just compiles to an .EXE that registers your service type and runs your code.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>In fact, if you open <bpt id="p1">**</bpt>Program.cs<ept id="p1">**</ept> in the stateless service project, you should see:</source>
          <target state="new">In fact, if you open <bpt id="p1">**</bpt>Program.cs<ept id="p1">**</ept> in the stateless service project, you should see:</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>If that looks suspiciously like the entry point to a console application, that's because it is:</source>
          <target state="new">If that looks suspiciously like the entry point to a console application, that's because it is:</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Details about the service host process and service registration is beyond the scope of this article, but it's important to know for now that <bpt id="p1">**</bpt>your service code is running in its own process<ept id="p1">**</ept>.</source>
          <target state="new">Details about the service host process and service registration is beyond the scope of this article, but it's important to know for now that <bpt id="p1">**</bpt>your service code is running in its own process<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Self-hosting Web API with an OWIN host</source>
          <target state="new">Self-hosting Web API with an OWIN host</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Given that your Web API application code is hosted in its own process, how do we hook it up to a web server?</source>
          <target state="new">Given that your Web API application code is hosted in its own process, how do we hook it up to a web server?</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Enter <bpt id="p1">[</bpt>OWIN<ept id="p1">](http://owin.org/)</ept>.</source>
          <target state="new">Enter <bpt id="p1">[</bpt>OWIN<ept id="p1">](http://owin.org/)</ept>.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>OWIN is simply a contract between .NET web applications and web servers.</source>
          <target state="new">OWIN is simply a contract between .NET web applications and web servers.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Traditionally with ASP.NET - up to MVC 5 - the web application was tightly coupled to IIS through System.Web.</source>
          <target state="new">Traditionally with ASP.NET - up to MVC 5 - the web application was tightly coupled to IIS through System.Web.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>However, Web API implements OWIN, which allows you to write a web application that is decoupled from the web server that hosts it.</source>
          <target state="new">However, Web API implements OWIN, which allows you to write a web application that is decoupled from the web server that hosts it.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>This allows you to use a <bpt id="p1">*</bpt>self-host<ept id="p1">*</ept> OWIN web server that you can start in your own process, which fits perfectly in the Service Fabric hosting model we just described.</source>
          <target state="new">This allows you to use a <bpt id="p1">*</bpt>self-host<ept id="p1">*</ept> OWIN web server that you can start in your own process, which fits perfectly in the Service Fabric hosting model we just described.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>In this article, we'll use Katana as the OWIN host for the Web API application.</source>
          <target state="new">In this article, we'll use Katana as the OWIN host for the Web API application.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Katana is an open-source OWIN host implementation.</source>
          <target state="new">Katana is an open-source OWIN host implementation.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> To learn more about Katana, head over to the <bpt id="p1">[</bpt>Katana site<ept id="p1">](http://www.asp.net/aspnet/overview/owin-and-katana/an-overview-of-project-katana)</ept>, and for a quick overview of how to use Katana to self-host Web API, check out this article on how to <bpt id="p2">[</bpt>Use OWIN to Self-Host ASP.NET Web API 2<ept id="p2">](http://www.asp.net/web-api/overview/hosting-aspnet-web-api/use-owin-to-self-host-web-api)</ept>.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> To learn more about Katana, head over to the <bpt id="p1">[</bpt>Katana site<ept id="p1">](http://www.asp.net/aspnet/overview/owin-and-katana/an-overview-of-project-katana)</ept>, and for a quick overview of how to use Katana to self-host Web API, check out this article on how to <bpt id="p2">[</bpt>Use OWIN to Self-Host ASP.NET Web API 2<ept id="p2">](http://www.asp.net/web-api/overview/hosting-aspnet-web-api/use-owin-to-self-host-web-api)</ept>.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Set up the web server</source>
          <target state="new">Set up the web server</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The Reliable Services API provides two entry points for your business logic:</source>
          <target state="new">The Reliable Services API provides two entry points for your business logic:</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>An open-ended entry point method where you can begin executing any workload you want, intended mainly for long-running compute workloads:</source>
          <target state="new">An open-ended entry point method where you can begin executing any workload you want, intended mainly for long-running compute workloads:</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>A communication entry point where you can plug in your communication stack of choice:</source>
          <target state="new">A communication entry point where you can plug in your communication stack of choice:</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The web server - and any other communication stack you may use in the future, such as WebSockets - should use the ICommunicationListener interface to correctly integrate with the system.</source>
          <target state="new">The web server - and any other communication stack you may use in the future, such as WebSockets - should use the ICommunicationListener interface to correctly integrate with the system.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The reasons for this will become more apparent in the following steps.</source>
          <target state="new">The reasons for this will become more apparent in the following steps.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>First create a class called OwinCommunicationListener that implements ICommunicationListener:</source>
          <target state="new">First create a class called OwinCommunicationListener that implements ICommunicationListener:</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>OwinCommunicationListener.cs:</source>
          <target state="new">OwinCommunicationListener.cs:</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The ICommunicationListener interface provides 4 methods to manage a communication listener for your service:</source>
          <target state="new">The ICommunicationListener interface provides 4 methods to manage a communication listener for your service:</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Initialize<ept id="p1">**</ept>: this is typically where you set up the address that the service will be listening on.</source>
          <target state="new"><bpt id="p1">**</bpt>Initialize<ept id="p1">**</ept>: this is typically where you set up the address that the service will be listening on.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>For the web server, this is where the URL is set up.</source>
          <target state="new">For the web server, this is where the URL is set up.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>OpenAsync<ept id="p1">**</ept>: start listening for requests.</source>
          <target state="new"><bpt id="p1">**</bpt>OpenAsync<ept id="p1">**</ept>: start listening for requests.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CloseAsync<ept id="p1">**</ept>: stop listening for requests, finish any in-flight requests, and shut down gracefully.</source>
          <target state="new"><bpt id="p1">**</bpt>CloseAsync<ept id="p1">**</ept>: stop listening for requests, finish any in-flight requests, and shut down gracefully.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Abort<ept id="p1">**</ept>: cancel everything and stop immediately.</source>
          <target state="new"><bpt id="p1">**</bpt>Abort<ept id="p1">**</ept>: cancel everything and stop immediately.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>To get started, add private class members for a URL path prefix and the <bpt id="p1">**</bpt>Startup<ept id="p1">**</ept> class that was created earlier.</source>
          <target state="new">To get started, add private class members for a URL path prefix and the <bpt id="p1">**</bpt>Startup<ept id="p1">**</ept> class that was created earlier.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>These will be initialized through the constructor and used later when setting up the listening URL.</source>
          <target state="new">These will be initialized through the constructor and used later when setting up the listening URL.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Also add private class members to save the listening address and the server handle that are created during initialization and later when the server is started, respectively.</source>
          <target state="new">Also add private class members to save the listening address and the server handle that are created during initialization and later when the server is started, respectively.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Initialize</source>
          <target state="new">Initialize</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The web server URL will be set up here.</source>
          <target state="new">The web server URL will be set up here.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>To do this, you need a couple pieces of information:</source>
          <target state="new">To do this, you need a couple pieces of information:</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>A URL path prefix<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>A URL path prefix<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Although optional, it's good to set this up now so you can safely host multiple web services in your application.</source>
          <target state="new">Although optional, it's good to set this up now so you can safely host multiple web services in your application.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>A port<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>A port<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Before we grab a port for the web server, it's important to understand that Service Fabric provides an application layer that acts as a buffer between your application and the underlying operating system that it runs on.</source>
          <target state="new">Before we grab a port for the web server, it's important to understand that Service Fabric provides an application layer that acts as a buffer between your application and the underlying operating system that it runs on.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>As such, Service Fabric provides a way to configure <bpt id="p1">*</bpt>endpoints<ept id="p1">*</ept> for your services.</source>
          <target state="new">As such, Service Fabric provides a way to configure <bpt id="p1">*</bpt>endpoints<ept id="p1">*</ept> for your services.</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Service Fabric takes care of making sure the endpoint is available for your service to use so that you don't have to configure it yourself with the underlying OS environment.</source>
          <target state="new">Service Fabric takes care of making sure the endpoint is available for your service to use so that you don't have to configure it yourself with the underlying OS environment.</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>This allows you to easily host your Service Fabric application in different environments without having to make any changes to your application (for example, you can host the same application in Azure or in your own data center).</source>
          <target state="new">This allows you to easily host your Service Fabric application in different environments without having to make any changes to your application (for example, you can host the same application in Azure or in your own data center).</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Configure an HTTP endpoint in PackageRoot\ServiceManifest.xml:</source>
          <target state="new">Configure an HTTP endpoint in PackageRoot\ServiceManifest.xml:</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>This step is important because the service host process runs under restricted credentials (Network Service on Windows), which means your service won't have access to set up an HTTP endpoint on its own.</source>
          <target state="new">This step is important because the service host process runs under restricted credentials (Network Service on Windows), which means your service won't have access to set up an HTTP endpoint on its own.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>By using the endpoint configuration, Service Fabric knows to set up the proper ACL for the URL that the service will listen on while providing a standard place to configure endpoints.</source>
          <target state="new">By using the endpoint configuration, Service Fabric knows to set up the proper ACL for the URL that the service will listen on while providing a standard place to configure endpoints.</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Back in OwinCommunicationListener.cs, get the endpoint information in the Initialize method to get the port.</source>
          <target state="new">Back in OwinCommunicationListener.cs, get the endpoint information in the Initialize method to get the port.</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Create the URL that the service will listen on and save it to the class member variable created earlier.</source>
          <target state="new">Create the URL that the service will listen on and save it to the class member variable created earlier.</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>This will be used in OpenAsync to start the web server.</source>
          <target state="new">This will be used in OpenAsync to start the web server.</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Note that "http://+" is used here.</source>
          <target state="new">Note that "http://+" is used here.</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>This is to make sure the web server is listening on all available addresses, including localhost, FQDN, and the machine IP.</source>
          <target state="new">This is to make sure the web server is listening on all available addresses, including localhost, FQDN, and the machine IP.</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>OpenAsync</source>
          <target state="new">OpenAsync</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>OpenAsync is called by the platform after Initialize.</source>
          <target state="new">OpenAsync is called by the platform after Initialize.</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>This is where you use the address that was created in Initialize to open the web server.</source>
          <target state="new">This is where you use the address that was created in Initialize to open the web server.</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Implementing OpenAsync is one of the most important reasons why the web server (or any communication stack) is implemented as an ICommunicationListener rather than just opening it directly from RunAsync() in the Service.</source>
          <target state="new">Implementing OpenAsync is one of the most important reasons why the web server (or any communication stack) is implemented as an ICommunicationListener rather than just opening it directly from RunAsync() in the Service.</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The return value from OpenAsync is the address that the web server is listening on.</source>
          <target state="new">The return value from OpenAsync is the address that the web server is listening on.</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>When this address is returned to the system, it registers the address with the service.</source>
          <target state="new">When this address is returned to the system, it registers the address with the service.</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Service Fabric provides an API that allows clients or other services to then ask for this address by service name.</source>
          <target state="new">Service Fabric provides an API that allows clients or other services to then ask for this address by service name.</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>This is important because  the service address is not static as services are moved around in the cluster for resource balancing and availability purposes.</source>
          <target state="new">This is important because  the service address is not static as services are moved around in the cluster for resource balancing and availability purposes.</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>This is the mechanism that allows clients to resolve the listening address for a service.</source>
          <target state="new">This is the mechanism that allows clients to resolve the listening address for a service.</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>With that in mind, OpenAsync starts the web server and return the address it's listening on.</source>
          <target state="new">With that in mind, OpenAsync starts the web server and return the address it's listening on.</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Note that it listens on "http://+", but before returning the address, the "+" is replaced with the IP or FQDN of the node it is currently on.</source>
          <target state="new">Note that it listens on "http://+", but before returning the address, the "+" is replaced with the IP or FQDN of the node it is currently on.</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The reason for this is that this address that is being returned by the method is what's registered with the system, and it's what clients and other service will see when they ask for the service's address.</source>
          <target state="new">The reason for this is that this address that is being returned by the method is what's registered with the system, and it's what clients and other service will see when they ask for the service's address.</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>For clients to correctly connect to it, they need an actual IP or FQDN in the address.</source>
          <target state="new">For clients to correctly connect to it, they need an actual IP or FQDN in the address.</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Note that this references the <bpt id="p1">**</bpt>Startup<ept id="p1">**</ept> class that was passed in to the OwinCommunicationListener in the constructor.</source>
          <target state="new">Note that this references the <bpt id="p1">**</bpt>Startup<ept id="p1">**</ept> class that was passed in to the OwinCommunicationListener in the constructor.</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>This Startup instance is used by the web server to bootstrap the Web API application.</source>
          <target state="new">This Startup instance is used by the web server to bootstrap the Web API application.</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The ServiceEventSource.Current.Message() line will appear in the diagnostics event window later when you run the application to let you know the web server has started successfully.</source>
          <target state="new">The ServiceEventSource.Current.Message() line will appear in the diagnostics event window later when you run the application to let you know the web server has started successfully.</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>CloseAsync and Abort</source>
          <target state="new">CloseAsync and Abort</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Finally, implement both CloseAsync and Abort to stop the web server.</source>
          <target state="new">Finally, implement both CloseAsync and Abort to stop the web server.</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The web server can be stopped by disposing the server handle that was created during OpenAsync.</source>
          <target state="new">The web server can be stopped by disposing the server handle that was created during OpenAsync.</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>In this example implementation, both CloseAsync and Abort simply stop the web server.</source>
          <target state="new">In this example implementation, both CloseAsync and Abort simply stop the web server.</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>You may opt to perform a more gracefully coordinated shut down of the web server in CloseAsync; for example, waiting for in-flight requests to complete before returning.</source>
          <target state="new">You may opt to perform a more gracefully coordinated shut down of the web server in CloseAsync; for example, waiting for in-flight requests to complete before returning.</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Start the web server</source>
          <target state="new">Start the web server</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>You're now ready to create and return an instance of OwinCommunicationListener to start the web server.</source>
          <target state="new">You're now ready to create and return an instance of OwinCommunicationListener to start the web server.</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Back in the Service class (Service.cs), override the <bpt id="p1">**</bpt>CreateCommunicationListener()<ept id="p1">**</ept> method:</source>
          <target state="new">Back in the Service class (Service.cs), override the <bpt id="p1">**</bpt>CreateCommunicationListener()<ept id="p1">**</ept> method:</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>This is where the Web API <bpt id="p1">*</bpt>application<ept id="p1">*</ept> and the OWIN <bpt id="p2">*</bpt>host<ept id="p2">*</ept> finally meet: The <bpt id="p3">*</bpt>host<ept id="p3">*</ept> (<bpt id="p4">**</bpt>OwinCommunicationListener<ept id="p4">**</ept>) is given an instance of the <bpt id="p5">*</bpt>application<ept id="p5">*</ept> (Web API via <bpt id="p6">**</bpt>Startup<ept id="p6">**</ept>), and Service Fabric manages its lifecycle.</source>
          <target state="new">This is where the Web API <bpt id="p1">*</bpt>application<ept id="p1">*</ept> and the OWIN <bpt id="p2">*</bpt>host<ept id="p2">*</ept> finally meet: The <bpt id="p3">*</bpt>host<ept id="p3">*</ept> (<bpt id="p4">**</bpt>OwinCommunicationListener<ept id="p4">**</ept>) is given an instance of the <bpt id="p5">*</bpt>application<ept id="p5">*</ept> (Web API via <bpt id="p6">**</bpt>Startup<ept id="p6">**</ept>), and Service Fabric manages its lifecycle.</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>This same pattern can typically be followed with any communication stack.</source>
          <target state="new">This same pattern can typically be followed with any communication stack.</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Putting it all together</source>
          <target state="new">Putting it all together</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>In this example, you don't need to do anything in the RunAsync() method, so that override can simply be removed.</source>
          <target state="new">In this example, you don't need to do anything in the RunAsync() method, so that override can simply be removed.</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The final Service implementation should be very simple, as it only needs to create the communication listener:</source>
          <target state="new">The final Service implementation should be very simple, as it only needs to create the communication listener:</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>And the complete OwinCommunicationListener class:</source>
          <target state="new">And the complete OwinCommunicationListener class:</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>With all the pieces in place, your project should now look like a typical Web API application with the Reliable Services API entry points and an OWIN host:</source>
          <target state="new">With all the pieces in place, your project should now look like a typical Web API application with the Reliable Services API entry points and an OWIN host:</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Run and connect through a web browser</source>
          <target state="new">Run and connect through a web browser</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>If you haven't done so, <bpt id="p1">[</bpt>set up your development environment<ept id="p1">](service-fabric-get-started.md)</ept>.</source>
          <target state="new">If you haven't done so, <bpt id="p1">[</bpt>set up your development environment<ept id="p1">](service-fabric-get-started.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>You can now build and deploy your service.</source>
          <target state="new">You can now build and deploy your service.</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Press <bpt id="p1">**</bpt>F5<ept id="p1">**</ept> in Visual Studio to build and deploy the application.</source>
          <target state="new">Press <bpt id="p1">**</bpt>F5<ept id="p1">**</ept> in Visual Studio to build and deploy the application.</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>In the Diagnostics Events window, you should see a message indicating the web server opened on <bpt id="p1">**</bpt>http://localhost:80/api<ept id="p1">**</ept></source>
          <target state="new">In the Diagnostics Events window, you should see a message indicating the web server opened on <bpt id="p1">**</bpt>http://localhost:80/api<ept id="p1">**</ept></target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> If the port is already be open by another process on your machine, you may see an error here indicating the listener couldn't be opened.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> If the port is already be open by another process on your machine, you may see an error here indicating the listener couldn't be opened.</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>If that's the case, try using a different port in the Endpoint configuration in ServiceManifest.xml.</source>
          <target state="new">If that's the case, try using a different port in the Endpoint configuration in ServiceManifest.xml.</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Once the service is running, open a browser and navigate to <bpt id="p1">[</bpt>http://localhost/api<ept id="p1">](http://localhost/api)</ept> to test it out.</source>
          <target state="new">Once the service is running, open a browser and navigate to <bpt id="p1">[</bpt>http://localhost/api<ept id="p1">](http://localhost/api)</ept> to test it out.</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Scale it out</source>
          <target state="new">Scale it out</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Scaling out stateless web apps typically means adding more machines and spinning up the web app on them.</source>
          <target state="new">Scaling out stateless web apps typically means adding more machines and spinning up the web app on them.</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Service Fabric's orchestration engine can do this for you whenever new nodes are added to a cluster.</source>
          <target state="new">Service Fabric's orchestration engine can do this for you whenever new nodes are added to a cluster.</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>When creating instances of a stateless service, you can specify the number of instances you want to create.</source>
          <target state="new">When creating instances of a stateless service, you can specify the number of instances you want to create.</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Service Fabric will place that number of instances on nodes in the cluster accordingly, making sure not to create more than one instance on any one node.</source>
          <target state="new">Service Fabric will place that number of instances on nodes in the cluster accordingly, making sure not to create more than one instance on any one node.</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>You can also instruct Service Fabric to always create an instance on every node by specifying "-1" for the instance count.</source>
          <target state="new">You can also instruct Service Fabric to always create an instance on every node by specifying "-1" for the instance count.</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>This guarantees that whenever you add nodes to scale out your cluster, an instance of your stateless service will be created on the new nodes.</source>
          <target state="new">This guarantees that whenever you add nodes to scale out your cluster, an instance of your stateless service will be created on the new nodes.</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>This value is a property of the service instance, so it is set when creating a service instance either through PowerShell:</source>
          <target state="new">This value is a property of the service instance, so it is set when creating a service instance either through PowerShell:</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Or when defining a default service in a Visual Studio Stateless Service project:</source>
          <target state="new">Or when defining a default service in a Visual Studio Stateless Service project:</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>For more information on creating application and service instances, see <bpt id="p1">[</bpt>how to deploy and remove applications<ept id="p1">](service-fabric-deploy-remove-applications.md)</ept>.</source>
          <target state="new">For more information on creating application and service instances, see <bpt id="p1">[</bpt>how to deploy and remove applications<ept id="p1">](service-fabric-deploy-remove-applications.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>ASP.NET 5</source>
          <target state="new">ASP.NET 5</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>In ASP.NET 5, the concept and programming model of separating the <bpt id="p1">*</bpt>application<ept id="p1">*</ept> from the <bpt id="p2">*</bpt>host<ept id="p2">*</ept> in web applications remains the same.</source>
          <target state="new">In ASP.NET 5, the concept and programming model of separating the <bpt id="p1">*</bpt>application<ept id="p1">*</ept> from the <bpt id="p2">*</bpt>host<ept id="p2">*</ept> in web applications remains the same.</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>It can also be applied to other forms of communication.</source>
          <target state="new">It can also be applied to other forms of communication.</target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>In addition, although the <bpt id="p1">*</bpt>host<ept id="p1">*</ept> may differ in ASP.NET 5, the Web API <bpt id="p2">*</bpt>application<ept id="p2">*</ept> layer remains the same, which is where the bulk of application logic actually lives.</source>
          <target state="new">In addition, although the <bpt id="p1">*</bpt>host<ept id="p1">*</ept> may differ in ASP.NET 5, the Web API <bpt id="p2">*</bpt>application<ept id="p2">*</ept> layer remains the same, which is where the bulk of application logic actually lives.</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="new">Next Steps</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Debugging your Service Fabric Application in Visual Studio</source>
          <target state="new">Debugging your Service Fabric Application in Visual Studio</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e33e138345a8566b2131919ea5400891b020f4e9</xliffext:olfilehash>
  </header>
</xliff>