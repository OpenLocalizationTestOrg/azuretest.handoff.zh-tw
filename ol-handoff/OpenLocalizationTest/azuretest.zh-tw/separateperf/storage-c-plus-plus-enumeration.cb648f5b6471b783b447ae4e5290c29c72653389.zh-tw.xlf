<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>List Azure Storage Resources with the Microsoft Azure Storage Client Library for C++ | Microsoft Azure</source>
          <target state="new">List Azure Storage Resources with the Microsoft Azure Storage Client Library for C++ | Microsoft Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Learn how to use the listing APIs in Microsoft Azure Storage Client Library for C++ to enumerate containers, blobs, queues, tables, and entities.</source>
          <target state="new">Learn how to use the listing APIs in Microsoft Azure Storage Client Library for C++ to enumerate containers, blobs, queues, tables, and entities.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>List Azure Storage Resources in C++</source>
          <target state="new">List Azure Storage Resources in C++</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Listing operations are key to many development scenarios with Azure Storage.</source>
          <target state="new">Listing operations are key to many development scenarios with Azure Storage.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This article describes how to most efficiently enumerate objects in Azure Storage using the listing APIs provided in the Microsoft Azure Storage Client Library for C++.</source>
          <target state="new">This article describes how to most efficiently enumerate objects in Azure Storage using the listing APIs provided in the Microsoft Azure Storage Client Library for C++.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> This guide targets the Azure Storage Client Library for C++ version 1.x, which is available via <bpt id="p1">[</bpt>NuGet<ept id="p1">](http://www.nuget.org/packages/wastorage)</ept> or <bpt id="p2">[</bpt>GitHub<ept id="p2">](https://github.com/Azure/azure-storage-cpp)</ept>.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> This guide targets the Azure Storage Client Library for C++ version 1.x, which is available via <bpt id="p1">[</bpt>NuGet<ept id="p1">](http://www.nuget.org/packages/wastorage)</ept> or <bpt id="p2">[</bpt>GitHub<ept id="p2">](https://github.com/Azure/azure-storage-cpp)</ept>.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The Storage Client Library provides a variety of methods to list or query objects in Azure Storage.</source>
          <target state="new">The Storage Client Library provides a variety of methods to list or query objects in Azure Storage.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>This article addresses the following scenarios:</source>
          <target state="new">This article addresses the following scenarios:</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>List containers in an account</source>
          <target state="new">List containers in an account</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>List blobs in a container or virtual blob directory</source>
          <target state="new">List blobs in a container or virtual blob directory</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>List queues in an account</source>
          <target state="new">List queues in an account</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>List tables in an account</source>
          <target state="new">List tables in an account</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Query entities in a table</source>
          <target state="new">Query entities in a table</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Each of these methods is shown using different overloads for different scenarios.</source>
          <target state="new">Each of these methods is shown using different overloads for different scenarios.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Asynchronous versus synchronous</source>
          <target state="new">Asynchronous versus synchronous</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Because the Storage Client Library for C++ is built on top of the <bpt id="p1">[</bpt>C++ REST library (Project Casablanca)<ept id="p1">](http://casablanca.codeplex.com/)</ept>, we inherently support asynchronous operations by using <bpt id="p2">[</bpt>pplx::task<ept id="p2">](http://microsoft.github.io/cpprestsdk/classpplx_1_1task.html)</ept>.</source>
          <target state="new">Because the Storage Client Library for C++ is built on top of the <bpt id="p1">[</bpt>C++ REST library (Project Casablanca)<ept id="p1">](http://casablanca.codeplex.com/)</ept>, we inherently support asynchronous operations by using <bpt id="p2">[</bpt>pplx::task<ept id="p2">](http://microsoft.github.io/cpprestsdk/classpplx_1_1task.html)</ept>.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="new">For example:</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Synchronous operations wrap the corresponding asynchronous operations:</source>
          <target state="new">Synchronous operations wrap the corresponding asynchronous operations:</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>If you are working with multiple threading applications or services, we recommend that you use the async APIs directly instead of creating a thread to call the sync APIs, which significantly impacts your performance.</source>
          <target state="new">If you are working with multiple threading applications or services, we recommend that you use the async APIs directly instead of creating a thread to call the sync APIs, which significantly impacts your performance.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Segmented listing</source>
          <target state="new">Segmented listing</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The scale of cloud storage requires segmented listing.</source>
          <target state="new">The scale of cloud storage requires segmented listing.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For example, you can have over a million blobs in an Azure blob container or over a billion entities in an Azure Table.</source>
          <target state="new">For example, you can have over a million blobs in an Azure blob container or over a billion entities in an Azure Table.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>These are not theoretical numbers, but real customer usage cases.</source>
          <target state="new">These are not theoretical numbers, but real customer usage cases.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>It is therefore impractical to list all objects in a single response.</source>
          <target state="new">It is therefore impractical to list all objects in a single response.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Instead, you can list objects using paging.</source>
          <target state="new">Instead, you can list objects using paging.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Each of the listing APIs has a <bpt id="p1">*</bpt>segmented<ept id="p1">*</ept> overload.</source>
          <target state="new">Each of the listing APIs has a <bpt id="p1">*</bpt>segmented<ept id="p1">*</ept> overload.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The response for a segmented listing operation includes:</source>
          <target state="new">The response for a segmented listing operation includes:</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;i&gt;</ph>_segment<ph id="ph2">&lt;/i&gt;</ph>, which contains the set of results returned for a single call to the listing API.</source>
          <target state="new"><ph id="ph1">&lt;i&gt;</ph>_segment<ph id="ph2">&lt;/i&gt;</ph>, which contains the set of results returned for a single call to the listing API.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>continuation_token<ept id="p1">*</ept>, which is passed to the next call in order to get the next page of results.</source>
          <target state="new"><bpt id="p1">*</bpt>continuation_token<ept id="p1">*</ept>, which is passed to the next call in order to get the next page of results.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>When there are no more results to return, the continuation token is null.</source>
          <target state="new">When there are no more results to return, the continuation token is null.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For example, a typical call to list all blobs in a container may look like the following code snippet.</source>
          <target state="new">For example, a typical call to list all blobs in a container may look like the following code snippet.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The code is available in our <bpt id="p1">[</bpt>samples<ept id="p1">](https://github.com/Azure/azure-storage-cpp/blob/master/Microsoft.WindowsAzure.Storage/samples/BlobsGettingStarted/Application.cpp)</ept>:</source>
          <target state="new">The code is available in our <bpt id="p1">[</bpt>samples<ept id="p1">](https://github.com/Azure/azure-storage-cpp/blob/master/Microsoft.WindowsAzure.Storage/samples/BlobsGettingStarted/Application.cpp)</ept>:</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Note that the number of results returned in a page can be controlled by the parameter <bpt id="p1">*</bpt>max_results<ept id="p1">*</ept> in the overload of each API, for example:</source>
          <target state="new">Note that the number of results returned in a page can be controlled by the parameter <bpt id="p1">*</bpt>max_results<ept id="p1">*</ept> in the overload of each API, for example:</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>If you do not specify the <bpt id="p1">*</bpt>max_results<ept id="p1">*</ept> parameter, the default maximum value of up to 5000 results is returned in a single page.</source>
          <target state="new">If you do not specify the <bpt id="p1">*</bpt>max_results<ept id="p1">*</ept> parameter, the default maximum value of up to 5000 results is returned in a single page.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Also note that a query against Azure Table storage may return no records, or fewer records than the value of the <bpt id="p1">*</bpt>max_results<ept id="p1">*</ept> parameter that you specified, even if the continuation token is not empty.</source>
          <target state="new">Also note that a query against Azure Table storage may return no records, or fewer records than the value of the <bpt id="p1">*</bpt>max_results<ept id="p1">*</ept> parameter that you specified, even if the continuation token is not empty.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>One reason might be that the query could not complete in five seconds.</source>
          <target state="new">One reason might be that the query could not complete in five seconds.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>As long as the continuation token is not empty, the query should continue, and your code should not assume the size of segment results.</source>
          <target state="new">As long as the continuation token is not empty, the query should continue, and your code should not assume the size of segment results.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The recommended coding pattern for most scenarios is segmented listing, which provides explicit progress of listing or querying, and how the service responds to each request.</source>
          <target state="new">The recommended coding pattern for most scenarios is segmented listing, which provides explicit progress of listing or querying, and how the service responds to each request.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Particularly for C++ applications or services, lower-level control of the listing progress may help control memory and performance.</source>
          <target state="new">Particularly for C++ applications or services, lower-level control of the listing progress may help control memory and performance.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Greedy listing</source>
          <target state="new">Greedy listing</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Earlier versions of the Storage Client Library for C++ (versions 0.5.0 Preview and earlier) included non-segmented listing APIs for tables and queues, as in the following example:</source>
          <target state="new">Earlier versions of the Storage Client Library for C++ (versions 0.5.0 Preview and earlier) included non-segmented listing APIs for tables and queues, as in the following example:</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>These methods were implemented as wrappers of segmented APIs.</source>
          <target state="new">These methods were implemented as wrappers of segmented APIs.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>For each response of segmented listing, the code appended the results to a vector and returned all results after the full containers were scanned.</source>
          <target state="new">For each response of segmented listing, the code appended the results to a vector and returned all results after the full containers were scanned.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>This approach might work when the storage account or table contains a small number of objects.</source>
          <target state="new">This approach might work when the storage account or table contains a small number of objects.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>However, with an increase in the number of objects, the memory required could increase without limit, because all results remained in memory.</source>
          <target state="new">However, with an increase in the number of objects, the memory required could increase without limit, because all results remained in memory.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>One listing operation can take a very long time, during which the caller had no information about its progress.</source>
          <target state="new">One listing operation can take a very long time, during which the caller had no information about its progress.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>These greedy listing APIs in the SDK do not exist in C#, Java, or the JavaScript Node.js environment.</source>
          <target state="new">These greedy listing APIs in the SDK do not exist in C#, Java, or the JavaScript Node.js environment.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>To avoid the potential issues of using these greedy APIs, we removed them in version 0.6.0 Preview.</source>
          <target state="new">To avoid the potential issues of using these greedy APIs, we removed them in version 0.6.0 Preview.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>If your code is calling these greedy APIs:</source>
          <target state="new">If your code is calling these greedy APIs:</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Then you should modify your code to use the segmented listing APIs:</source>
          <target state="new">Then you should modify your code to use the segmented listing APIs:</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>By specifying the <bpt id="p1">*</bpt>max_results<ept id="p1">*</ept> parameter of the segment, you can balance between the numbers of requests and memory usage to meet performance considerations for your application.</source>
          <target state="new">By specifying the <bpt id="p1">*</bpt>max_results<ept id="p1">*</ept> parameter of the segment, you can balance between the numbers of requests and memory usage to meet performance considerations for your application.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Additionally, if you’re using segmented listing APIs, but store the data in a local collection in a "greedy" style, we also strongly recommend that you refactor your code to handle storing data in a local collection carefully at scale.</source>
          <target state="new">Additionally, if you’re using segmented listing APIs, but store the data in a local collection in a "greedy" style, we also strongly recommend that you refactor your code to handle storing data in a local collection carefully at scale.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Lazy listing</source>
          <target state="new">Lazy listing</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Although greedy listing raised potential issues, it is convenient if there are not too many objects in the container.</source>
          <target state="new">Although greedy listing raised potential issues, it is convenient if there are not too many objects in the container.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>If you’re also using C# or Oracle Java SDKs, you should be familiar with the Enumerable programming model, which offers a lazy-style listing, where the data at a certain offset is only fetched if it is required.</source>
          <target state="new">If you’re also using C# or Oracle Java SDKs, you should be familiar with the Enumerable programming model, which offers a lazy-style listing, where the data at a certain offset is only fetched if it is required.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>In C++, the iterator-based template also provides a similar approach.</source>
          <target state="new">In C++, the iterator-based template also provides a similar approach.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>A typical lazy listing API, using <bpt id="p1">**</bpt>list_blobs<ept id="p1">**</ept> as an example, looks like this:</source>
          <target state="new">A typical lazy listing API, using <bpt id="p1">**</bpt>list_blobs<ept id="p1">**</ept> as an example, looks like this:</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>A typical code snippet that uses the lazy listing pattern might look like this:</source>
          <target state="new">A typical code snippet that uses the lazy listing pattern might look like this:</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Note that lazy listing is only available in synchronous mode.</source>
          <target state="new">Note that lazy listing is only available in synchronous mode.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Compared with greedy listing, lazy listing fetches data only when necessary.</source>
          <target state="new">Compared with greedy listing, lazy listing fetches data only when necessary.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Under the covers, it fetches data from Azure Storage only when the next iterator moves into next segment.</source>
          <target state="new">Under the covers, it fetches data from Azure Storage only when the next iterator moves into next segment.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Therefore, memory usage is controlled with a bounded size, and the operation is fast.</source>
          <target state="new">Therefore, memory usage is controlled with a bounded size, and the operation is fast.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Lazy listing APIs are included in the Storage Client Library for C++ in version 1.0.0.</source>
          <target state="new">Lazy listing APIs are included in the Storage Client Library for C++ in version 1.0.0.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="new">Conclusion</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>In this article, we discussed different overloads for listing APIs for various objects in the Storage Client Library for C++ .</source>
          <target state="new">In this article, we discussed different overloads for listing APIs for various objects in the Storage Client Library for C++ .</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>To summarize:</source>
          <target state="new">To summarize:</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Async APIs are strongly recommended under multiple threading scenarios.</source>
          <target state="new">Async APIs are strongly recommended under multiple threading scenarios.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Segmented listing is recommended for most scenarios.</source>
          <target state="new">Segmented listing is recommended for most scenarios.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Lazy listing is provided in the library as a convenient wrapper in synchronous scenarios.</source>
          <target state="new">Lazy listing is provided in the library as a convenient wrapper in synchronous scenarios.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Greedy listing is not recommended and has been removed from the library.</source>
          <target state="new">Greedy listing is not recommended and has been removed from the library.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="new">Next steps</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>For more information about Azure Storage and Client Library for C++, see the following resources.</source>
          <target state="new">For more information about Azure Storage and Client Library for C++, see the following resources.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>How to use Blob Storage from C++</source>
          <target state="new">How to use Blob Storage from C++</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>How to use Table Storage from C++</source>
          <target state="new">How to use Table Storage from C++</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>How to use Queue Storage from C++</source>
          <target state="new">How to use Queue Storage from C++</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Azure Storage Client Library for C++ API documentation.</source>
          <target state="new">Azure Storage Client Library for C++ API documentation.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Azure Storage Team Blog</source>
          <target state="new">Azure Storage Team Blog</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Azure Storage Documentation</source>
          <target state="new">Azure Storage Documentation</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0b137a7f1a8b943f7fd6e8f1bbecaf18d12fce8d</xliffext:olfilehash>
  </header>
</xliff>