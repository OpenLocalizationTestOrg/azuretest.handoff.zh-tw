<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Table design in SQL Data Warehouse | Microsoft Azure</source>
          <target state="new">Table design in SQL Data Warehouse | Microsoft Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Tips for designing tables in Azure SQL Data Warehouse for developing solutions.</source>
          <target state="new">Tips for designing tables in Azure SQL Data Warehouse for developing solutions.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Table design in SQL Data Warehouse</source>
          <target state="new">Table design in SQL Data Warehouse</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>SQL Data Warehouse is a massively parallel processing (MPP) distributed database system.</source>
          <target state="new">SQL Data Warehouse is a massively parallel processing (MPP) distributed database system.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Consequently, it stores data across many different locations known as <bpt id="p1">**</bpt>distributions<ept id="p1">**</ept>.</source>
          <target state="new">Consequently, it stores data across many different locations known as <bpt id="p1">**</bpt>distributions<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Each <bpt id="p1">**</bpt>distribution<ept id="p1">**</ept> is like a bucket; storing a unique subset of the data in the data warehouse.</source>
          <target state="new">Each <bpt id="p1">**</bpt>distribution<ept id="p1">**</ept> is like a bucket; storing a unique subset of the data in the data warehouse.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>By spreading the data and processing capability across multiple nodes SQL Data Warehouse is able to offer huge scalability - far beyond any single system.</source>
          <target state="new">By spreading the data and processing capability across multiple nodes SQL Data Warehouse is able to offer huge scalability - far beyond any single system.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>When a table is created in SQL Data Warehouse, it is actually spread across all of the the distributions.</source>
          <target state="new">When a table is created in SQL Data Warehouse, it is actually spread across all of the the distributions.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This article will cover the following topics:</source>
          <target state="new">This article will cover the following topics:</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Supported data types</source>
          <target state="new">Supported data types</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Principles of data distribution</source>
          <target state="new">Principles of data distribution</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Round Robin Distribution</source>
          <target state="new">Round Robin Distribution</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Hash Distribution</source>
          <target state="new">Hash Distribution</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Table Partitioning</source>
          <target state="new">Table Partitioning</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Statistics</source>
          <target state="new">Statistics</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Unsupported features</source>
          <target state="new">Unsupported features</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Supported data types</source>
          <target state="new">Supported data types</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>SQL Data Warehouse supports the common business data types:</source>
          <target state="new">SQL Data Warehouse supports the common business data types:</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>bigint</source>
          <target state="new">bigint</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>binary</source>
          <target state="new">binary</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>bit</source>
          <target state="new">bit</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>char</source>
          <target state="new">char</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>date</source>
          <target state="new">date</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>datetime</source>
          <target state="new">datetime</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>datetime2</source>
          <target state="new">datetime2</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>datetimeoffset</source>
          <target state="new">datetimeoffset</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>decimal</source>
          <target state="new">decimal</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>float</source>
          <target state="new">float</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>int</source>
          <target state="new">int</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>money</source>
          <target state="new">money</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>nchar</source>
          <target state="new">nchar</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>nvarchar</source>
          <target state="new">nvarchar</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>real</source>
          <target state="new">real</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>smalldatetime</source>
          <target state="new">smalldatetime</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>smallint</source>
          <target state="new">smallint</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>smallmoney</source>
          <target state="new">smallmoney</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>time</source>
          <target state="new">time</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>tinyint</source>
          <target state="new">tinyint</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>varbinary</source>
          <target state="new">varbinary</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>varchar</source>
          <target state="new">varchar</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>You can identify columns in your data warehouse that contain incompatible types using the following query:</source>
          <target state="new">You can identify columns in your data warehouse that contain incompatible types using the following query:</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The query includes any user defined data types which are also not supported.</source>
          <target state="new">The query includes any user defined data types which are also not supported.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>If you have unsupported types in your database do not worry.</source>
          <target state="new">If you have unsupported types in your database do not worry.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Some alternatives you can use instead are proposed below.</source>
          <target state="new">Some alternatives you can use instead are proposed below.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="new">Instead of:</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>geometry<ept id="p1">**</ept>, use a varbinary type</source>
          <target state="new"><bpt id="p1">**</bpt>geometry<ept id="p1">**</ept>, use a varbinary type</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>geography<ept id="p1">**</ept>, use a varbinary type</source>
          <target state="new"><bpt id="p1">**</bpt>geography<ept id="p1">**</ept>, use a varbinary type</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>hierarchyid<ept id="p1">**</ept>, CLR type not native</source>
          <target state="new"><bpt id="p1">**</bpt>hierarchyid<ept id="p1">**</ept>, CLR type not native</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>image<ept id="p1">**</ept>, <bpt id="p2">**</bpt>text<ept id="p2">**</ept>, <bpt id="p3">**</bpt>ntext<ept id="p3">**</ept> when text based use varchar/nvarchar (smaller the better)</source>
          <target state="new"><bpt id="p1">**</bpt>image<ept id="p1">**</ept>, <bpt id="p2">**</bpt>text<ept id="p2">**</ept>, <bpt id="p3">**</bpt>ntext<ept id="p3">**</ept> when text based use varchar/nvarchar (smaller the better)</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>nvarchar(max)<ept id="p1">**</ept>, use varchar(4000) or smaller for better performance</source>
          <target state="new"><bpt id="p1">**</bpt>nvarchar(max)<ept id="p1">**</ept>, use varchar(4000) or smaller for better performance</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>numeric<ept id="p1">**</ept>, use decimal</source>
          <target state="new"><bpt id="p1">**</bpt>numeric<ept id="p1">**</ept>, use decimal</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>sql_variant<ept id="p1">**</ept>, split column into several strongly typed columns</source>
          <target state="new"><bpt id="p1">**</bpt>sql_variant<ept id="p1">**</ept>, split column into several strongly typed columns</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>sysname<ept id="p1">**</ept>, use nvarchar(128)</source>
          <target state="new"><bpt id="p1">**</bpt>sysname<ept id="p1">**</ept>, use nvarchar(128)</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>table<ept id="p1">**</ept>, convert to temporary tables</source>
          <target state="new"><bpt id="p1">**</bpt>table<ept id="p1">**</ept>, convert to temporary tables</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>timestamp<ept id="p1">**</ept>, re-work code to use datetime2 and <ph id="ph1">`CURRENT_TIMESTAMP`</ph> function.</source>
          <target state="new"><bpt id="p1">**</bpt>timestamp<ept id="p1">**</ept>, re-work code to use datetime2 and <ph id="ph1">`CURRENT_TIMESTAMP`</ph> function.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Note you cannot have current_timestamp as a default constraint and the value will not automatically update.</source>
          <target state="new">Note you cannot have current_timestamp as a default constraint and the value will not automatically update.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>If you need to migrate rowversion values from a timestamp typed column then use BINARY(8) or VARBINARY(8) for NOT NULL or NULL row version values.</source>
          <target state="new">If you need to migrate rowversion values from a timestamp typed column then use BINARY(8) or VARBINARY(8) for NOT NULL or NULL row version values.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>varchar(max)<ept id="p1">**</ept>, use varchar(8000) or smaller for better performance</source>
          <target state="new"><bpt id="p1">**</bpt>varchar(max)<ept id="p1">**</ept>, use varchar(8000) or smaller for better performance</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>uniqueidentifier<ept id="p1">**</ept>, use varbinary(8)</source>
          <target state="new"><bpt id="p1">**</bpt>uniqueidentifier<ept id="p1">**</ept>, use varbinary(8)</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>user defined types<ept id="p1">**</ept>, convert back to their native types where possible</source>
          <target state="new"><bpt id="p1">**</bpt>user defined types<ept id="p1">**</ept>, convert back to their native types where possible</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>xml<ept id="p1">**</ept>, use a varchar(8000) or smaller for better performance - split across columns if needed</source>
          <target state="new"><bpt id="p1">**</bpt>xml<ept id="p1">**</ept>, use a varchar(8000) or smaller for better performance - split across columns if needed</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Partial support:</source>
          <target state="new">Partial support:</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Default constraints support literals and constants only.</source>
          <target state="new">Default constraints support literals and constants only.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Non-deterministic expressions or functions, such as <ph id="ph1">`GETDATE()`</ph> or <ph id="ph2">`CURRENT_TIMESTAMP`</ph>, are not supported.</source>
          <target state="new">Non-deterministic expressions or functions, such as <ph id="ph1">`GETDATE()`</ph> or <ph id="ph2">`CURRENT_TIMESTAMP`</ph>, are not supported.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Define your tables so that the maximum possible row size, including the full length of variable length columns, does not exceed 32,767 bytes.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Define your tables so that the maximum possible row size, including the full length of variable length columns, does not exceed 32,767 bytes.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>While you can define a row with variable length data that can exceed this figure, you will not be be able to insert data into the table.</source>
          <target state="new">While you can define a row with variable length data that can exceed this figure, you will not be be able to insert data into the table.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Also, try to limit the size of your variable length columns for even better throughput for running queries.</source>
          <target state="new">Also, try to limit the size of your variable length columns for even better throughput for running queries.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Principles of data distribution</source>
          <target state="new">Principles of data distribution</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>There are two choices for distributing data in SQL Data Warehouse:</source>
          <target state="new">There are two choices for distributing data in SQL Data Warehouse:</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Distribute data based on hashing values from a single column</source>
          <target state="new">Distribute data based on hashing values from a single column</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Distribute data evenly but randomly</source>
          <target state="new">Distribute data evenly but randomly</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Data distribution is decided at the table level.</source>
          <target state="new">Data distribution is decided at the table level.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>All tables are distributed so you will have the opportunity to make this decision for each table in your SQL Data Warehouse database.</source>
          <target state="new">All tables are distributed so you will have the opportunity to make this decision for each table in your SQL Data Warehouse database.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The first option is known as <bpt id="p1">**</bpt>round-robin<ept id="p1">**</ept> distribution - sometimes known as the random hash.</source>
          <target state="new">The first option is known as <bpt id="p1">**</bpt>round-robin<ept id="p1">**</ept> distribution - sometimes known as the random hash.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>You can think of this as the default or fail safe option.</source>
          <target state="new">You can think of this as the default or fail safe option.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The second option is known as the <bpt id="p1">**</bpt>hash<ept id="p1">**</ept> distribution.</source>
          <target state="new">The second option is known as the <bpt id="p1">**</bpt>hash<ept id="p1">**</ept> distribution.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>You can consider it an optimized form of data distribution.</source>
          <target state="new">You can consider it an optimized form of data distribution.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>It is preferred where clusters of tables share common joining and/or aggregation criteria.</source>
          <target state="new">It is preferred where clusters of tables share common joining and/or aggregation criteria.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Round-robin distribution</source>
          <target state="new">Round-robin distribution</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Round-Robin distribution is a method of spreading data as evenly as possible across all distributions.</source>
          <target state="new">Round-Robin distribution is a method of spreading data as evenly as possible across all distributions.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Buffers containing rows of data are allocated in turn (hence the name round robin) to each distribution.</source>
          <target state="new">Buffers containing rows of data are allocated in turn (hence the name round robin) to each distribution.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The process is repeated until all data buffers have been allocated.</source>
          <target state="new">The process is repeated until all data buffers have been allocated.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>At no stage is the data sorted or ordered in a round robin distributed table.</source>
          <target state="new">At no stage is the data sorted or ordered in a round robin distributed table.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>A round robin distribution is sometimes called a random hash for this reason.</source>
          <target state="new">A round robin distribution is sometimes called a random hash for this reason.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The data is simply spread as evenly as possible across the distributions.</source>
          <target state="new">The data is simply spread as evenly as possible across the distributions.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Below is an example of round robin distributed table:</source>
          <target state="new">Below is an example of round robin distributed table:</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This is also an example of a round robin distributed table:</source>
          <target state="new">This is also an example of a round robin distributed table:</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Notice that the second example above makes no mention of the distribution key.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Notice that the second example above makes no mention of the distribution key.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Round Robin is the default and so it is not absolutely required.</source>
          <target state="new">Round Robin is the default and so it is not absolutely required.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Being explicit however, is considered to be a good practice as ensures that your peers are aware of your intentions when reviewing the table design.</source>
          <target state="new">Being explicit however, is considered to be a good practice as ensures that your peers are aware of your intentions when reviewing the table design.</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>This table type is commonly used when there is no obvious key column to hash the data by.</source>
          <target state="new">This table type is commonly used when there is no obvious key column to hash the data by.</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>It can also be used by smaller or less significant tables where the movement cost may not be so great.</source>
          <target state="new">It can also be used by smaller or less significant tables where the movement cost may not be so great.</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Loading data into a round robin distributed table tends to be faster than loading into a hash distributed table.</source>
          <target state="new">Loading data into a round robin distributed table tends to be faster than loading into a hash distributed table.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>With a round-robin distributed table there is no need to understand the data or perform the hash prior to loading.</source>
          <target state="new">With a round-robin distributed table there is no need to understand the data or perform the hash prior to loading.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>For this reason Round-Robin tables often make good good loading targets.</source>
          <target state="new">For this reason Round-Robin tables often make good good loading targets.</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> When data is round robin distributed the data is allocated to the distribution at the <bpt id="p1">*</bpt>buffer<ept id="p1">*</ept> level.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> When data is round robin distributed the data is allocated to the distribution at the <bpt id="p1">*</bpt>buffer<ept id="p1">*</ept> level.</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Recommendations</source>
          <target state="new">Recommendations</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Consider using Round Robin distribution for your table in the following scenarios:</source>
          <target state="new">Consider using Round Robin distribution for your table in the following scenarios:</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>When there is no obvious joining key</source>
          <target state="new">When there is no obvious joining key</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>If a candidate hash distribution key is not known</source>
          <target state="new">If a candidate hash distribution key is not known</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>If the table does not share a common joining key with other tables</source>
          <target state="new">If the table does not share a common joining key with other tables</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>If the join is less significant than other joins in the query</source>
          <target state="new">If the join is less significant than other joins in the query</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>When the table is an initial loading table</source>
          <target state="new">When the table is an initial loading table</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Hash distribution</source>
          <target state="new">Hash distribution</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Hash distribution uses an internal function to spread a dataset across the distributions by hashing a single column.</source>
          <target state="new">Hash distribution uses an internal function to spread a dataset across the distributions by hashing a single column.</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>When data is hashed there is no explicit order to the data being allocated to a distribution.</source>
          <target state="new">When data is hashed there is no explicit order to the data being allocated to a distribution.</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>However, the hash itself is a deterministic process.</source>
          <target state="new">However, the hash itself is a deterministic process.</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>This makes the results of the hash predictable.</source>
          <target state="new">This makes the results of the hash predictable.</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>For example, hashing an integer column containing the value 10 will always yield the same hash value.</source>
          <target state="new">For example, hashing an integer column containing the value 10 will always yield the same hash value.</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>This means that <bpt id="p1">***</bpt>any<ept id="p1">***</ept> hashed integer column  containing the value 10 would end up being allocated to the same distribution.</source>
          <target state="new">This means that <bpt id="p1">***</bpt>any<ept id="p1">***</ept> hashed integer column  containing the value 10 would end up being allocated to the same distribution.</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>This is true even across tables.</source>
          <target state="new">This is true even across tables.</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The predictability of the hash is extremely important.</source>
          <target state="new">The predictability of the hash is extremely important.</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>It means that hash distributing the data can lead to performance improvements when reading data and joining tables together.</source>
          <target state="new">It means that hash distributing the data can lead to performance improvements when reading data and joining tables together.</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>As you will see below, hash distribution can be very effective for query optimization.</source>
          <target state="new">As you will see below, hash distribution can be very effective for query optimization.</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>This is why it is considered to be an optimized form of data distribution.</source>
          <target state="new">This is why it is considered to be an optimized form of data distribution.</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Remember!</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Remember!</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The hash is not based on the value of the data but rather on the type of the data being hashed.</source>
          <target state="new">The hash is not based on the value of the data but rather on the type of the data being hashed.</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Below is a table that has been hash distributed by ProductKey.</source>
          <target state="new">Below is a table that has been hash distributed by ProductKey.</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> When data is hash distributed the data is allocated to the distribution at the row level.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> When data is hash distributed the data is allocated to the distribution at the row level.</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Table partitions</source>
          <target state="new">Table partitions</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Table partitions are supported and easy to define.</source>
          <target state="new">Table partitions are supported and easy to define.</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Example SQL Data Warehouse partitioned <ph id="ph1">`CREATE TABLE`</ph> command:</source>
          <target state="new">Example SQL Data Warehouse partitioned <ph id="ph1">`CREATE TABLE`</ph> command:</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Notice that there is no partitioning function or scheme in the definition.</source>
          <target state="new">Notice that there is no partitioning function or scheme in the definition.</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>All that is taken care of when the table is created.</source>
          <target state="new">All that is taken care of when the table is created.</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>All you have to do is identify the boundary points for the column that is going to be the partitioning key.</source>
          <target state="new">All you have to do is identify the boundary points for the column that is going to be the partitioning key.</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Statistics</source>
          <target state="new">Statistics</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>SQL Data Warehouse uses a distributed query optimizer to create the appropriate query plan when users query tables.</source>
          <target state="new">SQL Data Warehouse uses a distributed query optimizer to create the appropriate query plan when users query tables.</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Once created, the query plan provides the strategy and method used by the database to access the data and fulfill the user request.</source>
          <target state="new">Once created, the query plan provides the strategy and method used by the database to access the data and fulfill the user request.</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>SQL Data Warehouse's query optimizer is based on cost.</source>
          <target state="new">SQL Data Warehouse's query optimizer is based on cost.</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>In other words it compares various options (plans) based on their relative cost and chooses the most efficient plan available to it.</source>
          <target state="new">In other words it compares various options (plans) based on their relative cost and chooses the most efficient plan available to it.</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Consequently, SQL Data Warehouse needs a lot of information to make informed, cost based decisions.</source>
          <target state="new">Consequently, SQL Data Warehouse needs a lot of information to make informed, cost based decisions.</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>It holds statistics information about the table (for table size) and in database objects known as <ph id="ph1">`STATISTICS`</ph>.</source>
          <target state="new">It holds statistics information about the table (for table size) and in database objects known as <ph id="ph1">`STATISTICS`</ph>.</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Statistics are held against single or multiple columns of indexes or tables.</source>
          <target state="new">Statistics are held against single or multiple columns of indexes or tables.</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>They provide the cost-based optimizer with important information concerning cardinality and selectivity of values.</source>
          <target state="new">They provide the cost-based optimizer with important information concerning cardinality and selectivity of values.</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>This is of particular interest when the optimizer needs to evaluate JOINs, GROUP BY, HAVING and WHERE clauses in a query.</source>
          <target state="new">This is of particular interest when the optimizer needs to evaluate JOINs, GROUP BY, HAVING and WHERE clauses in a query.</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>It is therefore very important that the information contained in these statistics objects <bpt id="p1">*</bpt>accurately<ept id="p1">*</ept> reflects the current state of the table.</source>
          <target state="new">It is therefore very important that the information contained in these statistics objects <bpt id="p1">*</bpt>accurately<ept id="p1">*</ept> reflects the current state of the table.</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>It is vital to understand that it is the accuracy of the cost that is important.</source>
          <target state="new">It is vital to understand that it is the accuracy of the cost that is important.</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>If the statistics accurately reflect the state of the table then plans can be compared for lowest cost.</source>
          <target state="new">If the statistics accurately reflect the state of the table then plans can be compared for lowest cost.</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>If they aren't accurate then SQL Data Warehouse may choose the wrong plan.</source>
          <target state="new">If they aren't accurate then SQL Data Warehouse may choose the wrong plan.</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Column-level statistics in SQL Data Warehouse are user-defined.</source>
          <target state="new">Column-level statistics in SQL Data Warehouse are user-defined.</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>In other words we have to create them ourselves.</source>
          <target state="new">In other words we have to create them ourselves.</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>As we have just learned, this is not something to overlook.</source>
          <target state="new">As we have just learned, this is not something to overlook.</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>This is an important difference between SQL Server and SQL Data Warehouse.</source>
          <target state="new">This is an important difference between SQL Server and SQL Data Warehouse.</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>SQL Server will automatically create statistics when columns are queried.</source>
          <target state="new">SQL Server will automatically create statistics when columns are queried.</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>By default, SQL Server will also automatically update those statistics.</source>
          <target state="new">By default, SQL Server will also automatically update those statistics.</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>However, in SQL Data Warehouse statistics need to be created manually and managed manually.</source>
          <target state="new">However, in SQL Data Warehouse statistics need to be created manually and managed manually.</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Recommendations</source>
          <target state="new">Recommendations</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Apply the following recommendations for generating statistics:</source>
          <target state="new">Apply the following recommendations for generating statistics:</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Create Single column statistics on columns used in <ph id="ph1">`WHERE`</ph>, <ph id="ph2">`JOIN`</ph>, <ph id="ph3">`GROUP BY`</ph>, <ph id="ph4">`ORDER BY`</ph> and <ph id="ph5">`DISTINCT`</ph> clauses</source>
          <target state="new">Create Single column statistics on columns used in <ph id="ph1">`WHERE`</ph>, <ph id="ph2">`JOIN`</ph>, <ph id="ph3">`GROUP BY`</ph>, <ph id="ph4">`ORDER BY`</ph> and <ph id="ph5">`DISTINCT`</ph> clauses</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Generate multi-column statistics on composite clauses</source>
          <target state="new">Generate multi-column statistics on composite clauses</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Update statistics periodically.</source>
          <target state="new">Update statistics periodically.</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Remember that this is not done automatically!</source>
          <target state="new">Remember that this is not done automatically!</target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> It is common for SQL Server Data Warehouse to rely solely on <ph id="ph2">`AUTOSTATS`</ph> to keep the column statistics up to date.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> It is common for SQL Server Data Warehouse to rely solely on <ph id="ph2">`AUTOSTATS`</ph> to keep the column statistics up to date.</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>This is not a best practice even for SQL Server data warehouses.</source>
          <target state="new">This is not a best practice even for SQL Server data warehouses.</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`AUTOSTATS`</ph> are triggered by a 20% rate of change which for large fact tables containing millions or billions of rows may not be sufficient.</source>
          <target state="new"><ph id="ph1">`AUTOSTATS`</ph> are triggered by a 20% rate of change which for large fact tables containing millions or billions of rows may not be sufficient.</target>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>It is therefore always a good idea to keep on top of statistics updates to ensure that the statistics accurately reflect the cardinality of the table.</source>
          <target state="new">It is therefore always a good idea to keep on top of statistics updates to ensure that the statistics accurately reflect the cardinality of the table.</target>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Unsupported features</source>
          <target state="new">Unsupported features</target>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>SQL Data Warehouse does not use or support these features:</source>
          <target state="new">SQL Data Warehouse does not use or support these features:</target>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>primary keys</source>
          <target state="new">primary keys</target>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>foreign keys</source>
          <target state="new">foreign keys</target>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>check constraints</source>
          <target state="new">check constraints</target>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>unique constraints</source>
          <target state="new">unique constraints</target>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>unique indexes</source>
          <target state="new">unique indexes</target>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>computed columns</source>
          <target state="new">computed columns</target>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>sparse columns</source>
          <target state="new">sparse columns</target>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>user-defined types</source>
          <target state="new">user-defined types</target>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>indexed views</source>
          <target state="new">indexed views</target>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>identities</source>
          <target state="new">identities</target>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>sequences</source>
          <target state="new">sequences</target>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>triggers</source>
          <target state="new">triggers</target>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>synonyms</source>
          <target state="new">synonyms</target>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="new">Next steps</target>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>For more development tips, see <bpt id="p1">[</bpt>development overview<ept id="p1">][]</ept>.</source>
          <target state="new">For more development tips, see <bpt id="p1">[</bpt>development overview<ept id="p1">][]</ept>.</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">38d08d5f0777c92425e4a083fce57a802fbb42d5</xliffext:olfilehash>
  </header>
</xliff>