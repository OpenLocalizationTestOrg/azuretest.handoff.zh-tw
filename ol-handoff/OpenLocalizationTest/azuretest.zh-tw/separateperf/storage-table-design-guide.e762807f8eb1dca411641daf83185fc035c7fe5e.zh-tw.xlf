<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Azure Storage Table Design Guide | Microsoft Azure</source>
          <target state="new">Azure Storage Table Design Guide | Microsoft Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Design Scalable and Performant Tables in Azure Table Storage</source>
          <target state="new">Design Scalable and Performant Tables in Azure Table Storage</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Azure Storage Table Design Guide: Designing Scalable and Performant Tables</source>
          <target state="new">Azure Storage Table Design Guide: Designing Scalable and Performant Tables</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="new">Overview</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>To design scalable and performant tables you must consider a number of factors such as performance, scalability, and cost.</source>
          <target state="new">To design scalable and performant tables you must consider a number of factors such as performance, scalability, and cost.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>If you have previously designed schemas for relational databases, these considerations will be familiar to you, but while there are some similarities between the Azure Table service storage model and relational models, there are also many important differences.</source>
          <target state="new">If you have previously designed schemas for relational databases, these considerations will be familiar to you, but while there are some similarities between the Azure Table service storage model and relational models, there are also many important differences.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>These differences typically lead to very different designs that may look counter-intuitive or wrong to someone familiar with relational databases, but which do make good sense if you are designing for a NoSQL key/value store such as the Azure Table service.</source>
          <target state="new">These differences typically lead to very different designs that may look counter-intuitive or wrong to someone familiar with relational databases, but which do make good sense if you are designing for a NoSQL key/value store such as the Azure Table service.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Many of your design differences will reflect the fact that the Table service is designed to support cloud-scale applications that can contain billions of entities (rows in relational database terminology) of data or for datasets that must support very high transaction volumes: therefore, you need to think differently about how you store your data and understand how the Table service works.</source>
          <target state="new">Many of your design differences will reflect the fact that the Table service is designed to support cloud-scale applications that can contain billions of entities (rows in relational database terminology) of data or for datasets that must support very high transaction volumes: therefore, you need to think differently about how you store your data and understand how the Table service works.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A well designed NoSQL data store can enable your solution to scale much further (and at a lower cost) than a solution that uses a relational database.</source>
          <target state="new">A well designed NoSQL data store can enable your solution to scale much further (and at a lower cost) than a solution that uses a relational database.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>This guide helps you with these topics.</source>
          <target state="new">This guide helps you with these topics.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>About the Azure Table service</source>
          <target state="new">About the Azure Table service</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This section highlights some of the key features of the Table service that are especially relevant to designing for performance and scalability.</source>
          <target state="new">This section highlights some of the key features of the Table service that are especially relevant to designing for performance and scalability.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>If you are new to Azure Storage and the Table service, first read <bpt id="p1">[</bpt>Introduction to Microsoft Azure Storage<ept id="p1">](storage-introduction.md)</ept> and <bpt id="p2">[</bpt>How to use Table Storage from .NET<ept id="p2">](storage-dotnet-how-to-use-tables.md)</ept> before reading the remainder of this article.</source>
          <target state="new">If you are new to Azure Storage and the Table service, first read <bpt id="p1">[</bpt>Introduction to Microsoft Azure Storage<ept id="p1">](storage-introduction.md)</ept> and <bpt id="p2">[</bpt>How to use Table Storage from .NET<ept id="p2">](storage-dotnet-how-to-use-tables.md)</ept> before reading the remainder of this article.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Although the focus of this guide is on the Table service, it will include some discussion of the Azure Queue and Blob services, and how you might use them along with the Table service in a solution.</source>
          <target state="new">Although the focus of this guide is on the Table service, it will include some discussion of the Azure Queue and Blob services, and how you might use them along with the Table service in a solution.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>What is the Table service?</source>
          <target state="new">What is the Table service?</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>As you might expect from the name, the Table service uses a tabular format to store data.</source>
          <target state="new">As you might expect from the name, the Table service uses a tabular format to store data.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>In the standard terminology, each row of the table represents an entity, and the columns store the various properties of that entity.</source>
          <target state="new">In the standard terminology, each row of the table represents an entity, and the columns store the various properties of that entity.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Every entity has a pair of keys to uniquely identify it, and a timestamp column that the Table service uses to track when the entity was last updated (this happens automatically and you cannot manually overwrite the timestamp with an arbitrary value).</source>
          <target state="new">Every entity has a pair of keys to uniquely identify it, and a timestamp column that the Table service uses to track when the entity was last updated (this happens automatically and you cannot manually overwrite the timestamp with an arbitrary value).</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The Table service uses this last-modified timestamp (LMT) to manage optimistic concurrency.</source>
          <target state="new">The Table service uses this last-modified timestamp (LMT) to manage optimistic concurrency.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> The Table service REST API operations also return an <bpt id="p1">**</bpt>ETag<ept id="p1">**</ept> value that it derives from the last-modified timestamp (LMT).</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> The Table service REST API operations also return an <bpt id="p1">**</bpt>ETag<ept id="p1">**</ept> value that it derives from the last-modified timestamp (LMT).</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>In this document we will use the terms ETag and LMT interchangeably because they refer to the same underlying data.</source>
          <target state="new">In this document we will use the terms ETag and LMT interchangeably because they refer to the same underlying data.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The following example shows a simple table design to store employee and department entities.</source>
          <target state="new">The following example shows a simple table design to store employee and department entities.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Many of the examples shown later in this guide are based on this simple design.</source>
          <target state="new">Many of the examples shown later in this guide are based on this simple design.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>PartitionKey</source>
          <target state="new">PartitionKey</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>RowKey</source>
          <target state="new">RowKey</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Timestamp</source>
          <target state="new">Timestamp</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Marketing</source>
          <target state="new">Marketing</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>00001</source>
          <target state="new">00001</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>2014-08-22T00:50:32Z</source>
          <target state="new">2014-08-22T00:50:32Z</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>FirstName</source>
          <target state="new">FirstName</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>LastName</source>
          <target state="new">LastName</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Age</source>
          <target state="new">Age</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Email</source>
          <target state="new">Email</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Don</source>
          <target state="new">Don</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Hall</source>
          <target state="new">Hall</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>34</source>
          <target state="new">34</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>donh@contoso.com</source>
          <target state="new">donh@contoso.com</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Marketing</source>
          <target state="new">Marketing</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>00002</source>
          <target state="new">00002</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>2014-08-22T00:50:34Z</source>
          <target state="new">2014-08-22T00:50:34Z</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>FirstName</source>
          <target state="new">FirstName</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>LastName</source>
          <target state="new">LastName</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Age</source>
          <target state="new">Age</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Email</source>
          <target state="new">Email</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Jun</source>
          <target state="new">Jun</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Cao</source>
          <target state="new">Cao</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>47</source>
          <target state="new">47</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>junc@contoso.com</source>
          <target state="new">junc@contoso.com</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Marketing</source>
          <target state="new">Marketing</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Department</source>
          <target state="new">Department</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>2014-08-22T00:50:30Z</source>
          <target state="new">2014-08-22T00:50:30Z</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>DepartmentName</source>
          <target state="new">DepartmentName</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>EmployeeCount</source>
          <target state="new">EmployeeCount</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Marketing</source>
          <target state="new">Marketing</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>153</source>
          <target state="new">153</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Sales</source>
          <target state="new">Sales</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>00010</source>
          <target state="new">00010</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>2014-08-22T00:50:44Z</source>
          <target state="new">2014-08-22T00:50:44Z</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>FirstName</source>
          <target state="new">FirstName</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>LastName</source>
          <target state="new">LastName</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Age</source>
          <target state="new">Age</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Email</source>
          <target state="new">Email</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Ken</source>
          <target state="new">Ken</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Kwok</source>
          <target state="new">Kwok</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>23</source>
          <target state="new">23</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>kenk@contoso.com</source>
          <target state="new">kenk@contoso.com</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>So far, this looks very similar to a table in a relational database with the key differences being the mandatory columns, and the ability to store multiple entity types in the same table.</source>
          <target state="new">So far, this looks very similar to a table in a relational database with the key differences being the mandatory columns, and the ability to store multiple entity types in the same table.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In addition, each of the user-defined properties such as <bpt id="p1">**</bpt>FirstName<ept id="p1">**</ept> or <bpt id="p2">**</bpt>Age<ept id="p2">**</ept> has a data type, such as integer or string, just like a column in a relational database.</source>
          <target state="new">In addition, each of the user-defined properties such as <bpt id="p1">**</bpt>FirstName<ept id="p1">**</ept> or <bpt id="p2">**</bpt>Age<ept id="p2">**</ept> has a data type, such as integer or string, just like a column in a relational database.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Although unlike in a relational database, the schema-less nature of the Table service means that a property need not have the same data type on each entity.</source>
          <target state="new">Although unlike in a relational database, the schema-less nature of the Table service means that a property need not have the same data type on each entity.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>To store complex data types in a single property, you must use a serialized format such as JSON or XML.</source>
          <target state="new">To store complex data types in a single property, you must use a serialized format such as JSON or XML.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For more information about the table service such as supported data types, supported date ranges, naming rules, and size constraints, see <bpt id="p1">[</bpt>Understanding the Table Service Data Model<ept id="p1">](http://msdn.microsoft.com/library/azure/dd179338.aspx)</ept> on MSDN.</source>
          <target state="new">For more information about the table service such as supported data types, supported date ranges, naming rules, and size constraints, see <bpt id="p1">[</bpt>Understanding the Table Service Data Model<ept id="p1">](http://msdn.microsoft.com/library/azure/dd179338.aspx)</ept> on MSDN.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>As you will see, your choice of <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> is fundamental to good table design.</source>
          <target state="new">As you will see, your choice of <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> is fundamental to good table design.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Every entity stored in a table must have a unique combination of <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept>.</source>
          <target state="new">Every entity stored in a table must have a unique combination of <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>As with keys in a relational database table, the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values are indexed to create a clustered index that enables fast look-ups; however, the Table service does not create any secondary indexes so these are the only two indexed properties (some of the patterns described later show how you can work around this apparent limitation).</source>
          <target state="new">As with keys in a relational database table, the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values are indexed to create a clustered index that enables fast look-ups; however, the Table service does not create any secondary indexes so these are the only two indexed properties (some of the patterns described later show how you can work around this apparent limitation).</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>A table is made up of one or more partitions, and as you will see, many of the design decisions you make will be around choosing a suitable <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> to optimize your solution.</source>
          <target state="new">A table is made up of one or more partitions, and as you will see, many of the design decisions you make will be around choosing a suitable <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> to optimize your solution.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>A solution could consist of just a single table that contains all your entities organized into partitions, but typically a solution will have multiple tables.</source>
          <target state="new">A solution could consist of just a single table that contains all your entities organized into partitions, but typically a solution will have multiple tables.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Tables help you to logically organize your entities, help you manage access to the data using access control lists, and you can drop an entire table using a single storage operation.</source>
          <target state="new">Tables help you to logically organize your entities, help you manage access to the data using access control lists, and you can drop an entire table using a single storage operation.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Table partitions</source>
          <target state="new">Table partitions</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The account name, table name and <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> together identify the partition within the storage service where the table service stores the entity.</source>
          <target state="new">The account name, table name and <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> together identify the partition within the storage service where the table service stores the entity.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>As well as being part of the addressing scheme for entities, partitions define a scope for transactions (see <bpt id="p1">[</bpt>Entity Group Transactions<ept id="p1">](#entity-group-transactions)</ept> below), and form the basis of how the table service scales.</source>
          <target state="new">As well as being part of the addressing scheme for entities, partitions define a scope for transactions (see <bpt id="p1">[</bpt>Entity Group Transactions<ept id="p1">](#entity-group-transactions)</ept> below), and form the basis of how the table service scales.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>For more information on partitions see <bpt id="p1">[</bpt>Azure Storage Scalability and Performance Targets<ept id="p1">](http://msdn.microsoft.com/library/azure/dn249410.aspx)</ept>.</source>
          <target state="new">For more information on partitions see <bpt id="p1">[</bpt>Azure Storage Scalability and Performance Targets<ept id="p1">](http://msdn.microsoft.com/library/azure/dn249410.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>In the Table service, an individual node services one or more complete partitions and the service scales by dynamically load-balancing partitions across nodes.</source>
          <target state="new">In the Table service, an individual node services one or more complete partitions and the service scales by dynamically load-balancing partitions across nodes.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>If a node is under load, the table service can <bpt id="p1">*</bpt>split<ept id="p1">*</ept> the range of partitions serviced by that node onto different nodes; when traffic subsides, the service can <bpt id="p2">*</bpt>merge<ept id="p2">*</ept> the partition ranges from quiet nodes back onto a single node.</source>
          <target state="new">If a node is under load, the table service can <bpt id="p1">*</bpt>split<ept id="p1">*</ept> the range of partitions serviced by that node onto different nodes; when traffic subsides, the service can <bpt id="p2">*</bpt>merge<ept id="p2">*</ept> the partition ranges from quiet nodes back onto a single node.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For more information about the internal details of the Table service, and in particular how the service manages partitions, see the paper <bpt id="p1">[</bpt>Microsoft Azure Storage: A Highly Available
Cloud Storage Service with Strong Consistency<ept id="p1">](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)</ept>.</source>
          <target state="new">For more information about the internal details of the Table service, and in particular how the service manages partitions, see the paper <bpt id="p1">[</bpt>Microsoft Azure Storage: A Highly Available
Cloud Storage Service with Strong Consistency<ept id="p1">](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Entity Group Transactions</source>
          <target state="new">Entity Group Transactions</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>In the Table service, Entity Group Transactions (EGTs) are the only built-in mechanism for performing atomic updates across multiple entities.</source>
          <target state="new">In the Table service, Entity Group Transactions (EGTs) are the only built-in mechanism for performing atomic updates across multiple entities.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>EGTs are also referred to as <bpt id="p1">*</bpt>batch transactions<ept id="p1">*</ept> in some documentation.</source>
          <target state="new">EGTs are also referred to as <bpt id="p1">*</bpt>batch transactions<ept id="p1">*</ept> in some documentation.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>EGTs can only operate on entities stored in the same partition (share the same partition key in a given table), so anytime you need atomic transactional behavior across multiple entities you need to ensure that those entities are in the same partition.</source>
          <target state="new">EGTs can only operate on entities stored in the same partition (share the same partition key in a given table), so anytime you need atomic transactional behavior across multiple entities you need to ensure that those entities are in the same partition.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>This is often a reason for keeping multiple entity types in the same table (and partition) and not using multiple tables for different entity types.</source>
          <target state="new">This is often a reason for keeping multiple entity types in the same table (and partition) and not using multiple tables for different entity types.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>A single EGT can operate on at most 100 entities.</source>
          <target state="new">A single EGT can operate on at most 100 entities.</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>If you submit multiple concurrent EGTs for processing it is important to ensure  those EGTs do not operate on entities that are common across EGTs as otherwise processing can be delayed.</source>
          <target state="new">If you submit multiple concurrent EGTs for processing it is important to ensure  those EGTs do not operate on entities that are common across EGTs as otherwise processing can be delayed.</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>EGTs also introduce a potential trade-off for you to evaluate in your design: using more partitions will increase the scalability of your application because Azure has more opportunities for load balancing requests across nodes, but this might limit the ability of your application to perform atomic transactions and maintain strong consistency for your data.</source>
          <target state="new">EGTs also introduce a potential trade-off for you to evaluate in your design: using more partitions will increase the scalability of your application because Azure has more opportunities for load balancing requests across nodes, but this might limit the ability of your application to perform atomic transactions and maintain strong consistency for your data.</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Furthermore, there are specific scalability targets at the level of a partition that might limit the throughput of transactions you can expect for a single node: for more information about the scalability targets for Azure storage accounts and the table service, see <bpt id="p1">[</bpt>Azure Storage Scalability and Performance Targets<ept id="p1">](http://msdn.microsoft.com/library/azure/dd179338.aspx)</ept> on MSDN.</source>
          <target state="new">Furthermore, there are specific scalability targets at the level of a partition that might limit the throughput of transactions you can expect for a single node: for more information about the scalability targets for Azure storage accounts and the table service, see <bpt id="p1">[</bpt>Azure Storage Scalability and Performance Targets<ept id="p1">](http://msdn.microsoft.com/library/azure/dd179338.aspx)</ept> on MSDN.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Later sections of this guide discuss various design strategies that help you manage trade-offs such as this one, and discuss how best to choose your partition key based on the specific requirements of your client application.</source>
          <target state="new">Later sections of this guide discuss various design strategies that help you manage trade-offs such as this one, and discuss how best to choose your partition key based on the specific requirements of your client application.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Capacity considerations</source>
          <target state="new">Capacity considerations</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The following table includes some of the key values to be aware of when you are designing a Table service solution:</source>
          <target state="new">The following table includes some of the key values to be aware of when you are designing a Table service solution:</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Total capacity of an Azure storage account</source>
          <target state="new">Total capacity of an Azure storage account</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>500 TB</source>
          <target state="new">500 TB</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Number of tables in an Azure storage account</source>
          <target state="new">Number of tables in an Azure storage account</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Limited only by the capacity of the storage account</source>
          <target state="new">Limited only by the capacity of the storage account</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Number of partitions in a table</source>
          <target state="new">Number of partitions in a table</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Limited only by the capacity of the storage account</source>
          <target state="new">Limited only by the capacity of the storage account</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Number of entities in a partition</source>
          <target state="new">Number of entities in a partition</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Limited only by the capacity of the storage account</source>
          <target state="new">Limited only by the capacity of the storage account</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Size of an individual entity</source>
          <target state="new">Size of an individual entity</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Up to 1 MB with a maximum of 255 properties (including the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept>, <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept>, and <bpt id="p3">**</bpt>Timestamp<ept id="p3">**</ept>)</source>
          <target state="new">Up to 1 MB with a maximum of 255 properties (including the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept>, <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept>, and <bpt id="p3">**</bpt>Timestamp<ept id="p3">**</ept>)</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Size of the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept></source>
          <target state="new">Size of the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept></target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>A string up to 1 KB in size</source>
          <target state="new">A string up to 1 KB in size</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Size of the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept></source>
          <target state="new">Size of the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept></target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>A string up to 1 KB in size</source>
          <target state="new">A string up to 1 KB in size</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Size of an Entity Group Transaction</source>
          <target state="new">Size of an Entity Group Transaction</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>A transaction can include at most 100 entities and the payload must be less than 4 MB in size.</source>
          <target state="new">A transaction can include at most 100 entities and the payload must be less than 4 MB in size.</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>An EGT can only update an entity once.</source>
          <target state="new">An EGT can only update an entity once.</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Understanding the Table Service Data Model<ept id="p1">](http://msdn.microsoft.com/library/azure/dd179338.aspx)</ept> on MSDN.</source>
          <target state="new">For more information, see <bpt id="p1">[</bpt>Understanding the Table Service Data Model<ept id="p1">](http://msdn.microsoft.com/library/azure/dd179338.aspx)</ept> on MSDN.</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Cost considerations</source>
          <target state="new">Cost considerations</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Table storage is relatively inexpensive, but you should include cost estimates for both capacity usage and the quantity of transactions as part of your evaluation of any solution that uses the Table service.</source>
          <target state="new">Table storage is relatively inexpensive, but you should include cost estimates for both capacity usage and the quantity of transactions as part of your evaluation of any solution that uses the Table service.</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>However, in many scenarios storing denormalized or duplicate data in order to improve the performance or scalability of your solution is a valid approach to take.</source>
          <target state="new">However, in many scenarios storing denormalized or duplicate data in order to improve the performance or scalability of your solution is a valid approach to take.</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>For more information about pricing, see <bpt id="p1">[</bpt>Storage Pricing Details<ept id="p1">](http://azure.microsoft.com/pricing/details/storage/)</ept>.</source>
          <target state="new">For more information about pricing, see <bpt id="p1">[</bpt>Storage Pricing Details<ept id="p1">](http://azure.microsoft.com/pricing/details/storage/)</ept>.</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Comparing Azure Tables and SQL Azure</source>
          <target state="new">Comparing Azure Tables and SQL Azure</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>For a comparison between Azure SQL Database (a relational database service) and the Table service, see <bpt id="p1">[</bpt>Microsoft Azure Table Storage and Microsoft Azure SQL Database - Compared and Contrasted<ept id="p1">](http://msdn.microsoft.com/library/azure/jj553018.aspx)</ept> on MSDN.</source>
          <target state="new">For a comparison between Azure SQL Database (a relational database service) and the Table service, see <bpt id="p1">[</bpt>Microsoft Azure Table Storage and Microsoft Azure SQL Database - Compared and Contrasted<ept id="p1">](http://msdn.microsoft.com/library/azure/jj553018.aspx)</ept> on MSDN.</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Guidelines for table design</source>
          <target state="new">Guidelines for table design</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>These lists summarize some of the key guidelines you should keep in mind when you are designing your tables, and this guide will address them all in more detail later in.</source>
          <target state="new">These lists summarize some of the key guidelines you should keep in mind when you are designing your tables, and this guide will address them all in more detail later in.</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>These guidelines are very different from the guidelines you would typically follow for relational database design.</source>
          <target state="new">These guidelines are very different from the guidelines you would typically follow for relational database design.</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Designing your Table service solution to be <bpt id="p1">*</bpt>read<ept id="p1">*</ept> efficient:</source>
          <target state="new">Designing your Table service solution to be <bpt id="p1">*</bpt>read<ept id="p1">*</ept> efficient:</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Design for querying in read-heavy applications.</source>
          <target state="new">Design for querying in read-heavy applications.</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>When you are designing your tables, think about the queries (especially the latency sensitive ones) that you will execute before you think about how you will update your entities.</source>
          <target state="new">When you are designing your tables, think about the queries (especially the latency sensitive ones) that you will execute before you think about how you will update your entities.</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>This typically results in an efficient and performant solution.</source>
          <target state="new">This typically results in an efficient and performant solution.</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Specify both PartitionKey and RowKey in your queries.</source>
          <target state="new">Specify both PartitionKey and RowKey in your queries.</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Point queries<ept id="p1">*</ept> such as these are the most efficient table service queries.</source>
          <target state="new"><bpt id="p1">*</bpt>Point queries<ept id="p1">*</ept> such as these are the most efficient table service queries.</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Consider storing duplicate copies of entities.</source>
          <target state="new">Consider storing duplicate copies of entities.</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Table storage is cheap so consider storing the same entity multiple times (with different keys) to enable more efficient queries.</source>
          <target state="new">Table storage is cheap so consider storing the same entity multiple times (with different keys) to enable more efficient queries.</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Consider denormalizing your data.</source>
          <target state="new">Consider denormalizing your data.</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Table storage is cheap so consider denormalizing your data.</source>
          <target state="new">Table storage is cheap so consider denormalizing your data.</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>For example, store summary entities so that queries for aggregate data only need to access a single entity.</source>
          <target state="new">For example, store summary entities so that queries for aggregate data only need to access a single entity.</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Use compound key values.</source>
          <target state="new">Use compound key values.</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The only keys you have are <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept>.</source>
          <target state="new">The only keys you have are <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>For example, use compound key values to enable alternate keyed access paths to entities.</source>
          <target state="new">For example, use compound key values to enable alternate keyed access paths to entities.</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Use query projection.</source>
          <target state="new">Use query projection.</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>You can reduce the amount of data that you transfer over the network by using queries that select just the fields you need.</source>
          <target state="new">You can reduce the amount of data that you transfer over the network by using queries that select just the fields you need.</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Designing your Table service solution to be <bpt id="p1">*</bpt>write<ept id="p1">*</ept> efficient:</source>
          <target state="new">Designing your Table service solution to be <bpt id="p1">*</bpt>write<ept id="p1">*</ept> efficient:</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Do not create hot partitions.</source>
          <target state="new">Do not create hot partitions.</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Choose keys that enable you to spread your requests across multiple partitions at any point of time.</source>
          <target state="new">Choose keys that enable you to spread your requests across multiple partitions at any point of time.</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Avoid spikes in traffic.</source>
          <target state="new">Avoid spikes in traffic.</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Smooth the traffic over a reasonable period of time and avoid spikes in traffic.</source>
          <target state="new">Smooth the traffic over a reasonable period of time and avoid spikes in traffic.</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Dont necessarily create a separate table for each type of entity.</source>
          <target state="new">Dont necessarily create a separate table for each type of entity.</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>When you require atomic transactions across entity types, you can store these multiple entity types in the same partition in the same table.</source>
          <target state="new">When you require atomic transactions across entity types, you can store these multiple entity types in the same partition in the same table.</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Consider the maximum throughput you must achieve.</source>
          <target state="new">Consider the maximum throughput you must achieve.</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>You must be aware of the scalability targets for the Table service and ensure that your design will not cause you to exceed them.</source>
          <target state="new">You must be aware of the scalability targets for the Table service and ensure that your design will not cause you to exceed them.</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>As you read this guide, you will see examples that put all of these principles into practice.</source>
          <target state="new">As you read this guide, you will see examples that put all of these principles into practice.</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Design for querying</source>
          <target state="new">Design for querying</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Table service solutions may be read intensive, write intensive, or a mix of the two.</source>
          <target state="new">Table service solutions may be read intensive, write intensive, or a mix of the two.</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>This section focuses on the things to bear in mind when you are designing your Table service to support read operations efficiently.</source>
          <target state="new">This section focuses on the things to bear in mind when you are designing your Table service to support read operations efficiently.</target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Typically, a design that supports read operations efficiently is also efficient for write operations.</source>
          <target state="new">Typically, a design that supports read operations efficiently is also efficient for write operations.</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>However, there are additional considerations to bear in mind when designing to support write operations, which the next section, <bpt id="p1">[</bpt>Design for data modification<ept id="p1">](#design-for-data-modification)</ept>, discusses.</source>
          <target state="new">However, there are additional considerations to bear in mind when designing to support write operations, which the next section, <bpt id="p1">[</bpt>Design for data modification<ept id="p1">](#design-for-data-modification)</ept>, discusses.</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>A good starting point for designing your Table service solution to enable you to read data efficiently is to ask "What queries will my application need to execute to retrieve the data it needs from the Table service?"</source>
          <target state="new">A good starting point for designing your Table service solution to enable you to read data efficiently is to ask "What queries will my application need to execute to retrieve the data it needs from the Table service?"</target>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> With the Table service, its important to get the design correct up front because its difficult and expensive to change it later.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> With the Table service, its important to get the design correct up front because its difficult and expensive to change it later.</target>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>For example, in a relational database its often possible to address performance issues simply by adding indexes to an existing database: this is not an option with the Table service.</source>
          <target state="new">For example, in a relational database its often possible to address performance issues simply by adding indexes to an existing database: this is not an option with the Table service.</target>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>This section focuses on the key issues you must address when you design your tables for querying.</source>
          <target state="new">This section focuses on the key issues you must address when you design your tables for querying.</target>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>The topics covered in this section include:</source>
          <target state="new">The topics covered in this section include:</target>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>How your choice of PartitionKey and RowKey impacts query performance</source>
          <target state="new">How your choice of PartitionKey and RowKey impacts query performance</target>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Choosing an appropriate PartitionKey</source>
          <target state="new">Choosing an appropriate PartitionKey</target>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Optimizing queries with a key value store for the Table service</source>
          <target state="new">Optimizing queries with a key value store for the Table service</target>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Sorting data in a key value store in the Table service</source>
          <target state="new">Sorting data in a key value store in the Table service</target>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>How your choice of PartitionKey and RowKey impacts query performance</source>
          <target state="new">How your choice of PartitionKey and RowKey impacts query performance</target>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The following examples assume the table service is storing employee entities with the following structure (most of the examples omit the <bpt id="p1">**</bpt>Timestamp<ept id="p1">**</ept> property for clarity):</source>
          <target state="new">The following examples assume the table service is storing employee entities with the following structure (most of the examples omit the <bpt id="p1">**</bpt>Timestamp<ept id="p1">**</ept> property for clarity):</target>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Column name</source>
          <target state="new">Column name</target>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Data type</source>
          <target state="new">Data type</target>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> (Department Name)</source>
          <target state="new"><bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> (Department Name)</target>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="new">String</target>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> (Employee Id)</source>
          <target state="new"><bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> (Employee Id)</target>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="new">String</target>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>FirstName</source>
          <target state="new">FirstName</target>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="new">String</target>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>LastName</source>
          <target state="new">LastName</target>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="new">String</target>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Age</source>
          <target state="new">Age</target>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="new">Integer</target>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>EmailAddress</source>
          <target state="new">EmailAddress</target>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="new">String</target>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>The earlier section <bpt id="p1">[</bpt>Azure Table service overview<ept id="p1">](#azure-table-service-overview)</ept> describes some of the key features of the Azure Table service that have a direct influence on designing for query.</source>
          <target state="new">The earlier section <bpt id="p1">[</bpt>Azure Table service overview<ept id="p1">](#azure-table-service-overview)</ept> describes some of the key features of the Azure Table service that have a direct influence on designing for query.</target>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>These result in the following general guidelines for designing Table service queries.</source>
          <target state="new">These result in the following general guidelines for designing Table service queries.</target>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Note that the filter syntax used in the examples below is from the Table service REST API, for more information see <bpt id="p1">[</bpt>Query Entities<ept id="p1">](http://msdn.microsoft.com/library/azure/dd179421.aspx)</ept> on MSDN.</source>
          <target state="new">Note that the filter syntax used in the examples below is from the Table service REST API, for more information see <bpt id="p1">[</bpt>Query Entities<ept id="p1">](http://msdn.microsoft.com/library/azure/dd179421.aspx)</ept> on MSDN.</target>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">***</bpt>Point Query<ept id="p1">***</ept> is the most efficient lookup to use and is recommended to be used for high-volume lookups or lookups requiring lowest latency.</source>
          <target state="new">A <bpt id="p1">***</bpt>Point Query<ept id="p1">***</ept> is the most efficient lookup to use and is recommended to be used for high-volume lookups or lookups requiring lowest latency.</target>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Such a query can use the indexes to locate an individual entity very efficiently by specifying both the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values.</source>
          <target state="new">Such a query can use the indexes to locate an individual entity very efficiently by specifying both the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values.</target>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="new">For example:</target>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>$filter=(PartitionKey eq 'Sales') and (RowKey eq '2')</source>
          <target state="new">$filter=(PartitionKey eq 'Sales') and (RowKey eq '2')</target>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Second best is a <bpt id="p1">***</bpt>Range Query<ept id="p1">***</ept> that uses the <bpt id="p2">**</bpt>PartitionKey<ept id="p2">**</ept> and filters on a range of <bpt id="p3">**</bpt>RowKey<ept id="p3">**</ept> values to return more than one entity.</source>
          <target state="new">Second best is a <bpt id="p1">***</bpt>Range Query<ept id="p1">***</ept> that uses the <bpt id="p2">**</bpt>PartitionKey<ept id="p2">**</ept> and filters on a range of <bpt id="p3">**</bpt>RowKey<ept id="p3">**</ept> values to return more than one entity.</target>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> value identifies a specific partition, and the <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values identify a subset of the entities in that partition.</source>
          <target state="new">The <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> value identifies a specific partition, and the <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values identify a subset of the entities in that partition.</target>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="new">For example:</target>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>$filter=PartitionKey eq 'Sales' and RowKey ge 'S' and RowKey lt 'T'</source>
          <target state="new">$filter=PartitionKey eq 'Sales' and RowKey ge 'S' and RowKey lt 'T'</target>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Third best is a <bpt id="p1">***</bpt>Partition Scan<ept id="p1">***</ept> that uses the <bpt id="p2">**</bpt>PartitionKey<ept id="p2">**</ept> and filters on another non-key property and that may return more than one entity.</source>
          <target state="new">Third best is a <bpt id="p1">***</bpt>Partition Scan<ept id="p1">***</ept> that uses the <bpt id="p2">**</bpt>PartitionKey<ept id="p2">**</ept> and filters on another non-key property and that may return more than one entity.</target>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> value identifies a specific partition, and the property values select for a subset of the entities in that partition.</source>
          <target state="new">The <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> value identifies a specific partition, and the property values select for a subset of the entities in that partition.</target>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="new">For example:</target>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>$filter=PartitionKey eq 'Sales' and LastName eq 'Smith'</source>
          <target state="new">$filter=PartitionKey eq 'Sales' and LastName eq 'Smith'</target>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">***</bpt>Table Scan<ept id="p1">***</ept> does not include the <bpt id="p2">**</bpt>PartitionKey<ept id="p2">**</ept> and is very inefficient because it searches all of the partitions that make up your table in turn for any matching entities.</source>
          <target state="new">A <bpt id="p1">***</bpt>Table Scan<ept id="p1">***</ept> does not include the <bpt id="p2">**</bpt>PartitionKey<ept id="p2">**</ept> and is very inefficient because it searches all of the partitions that make up your table in turn for any matching entities.</target>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>It will perform a table scan regardless of whether or not your filter uses the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept>.</source>
          <target state="new">It will perform a table scan regardless of whether or not your filter uses the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="new">For example:</target>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>$filter=LastName eq 'Jones'</source>
          <target state="new">$filter=LastName eq 'Jones'</target>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Queries that return multiple entities return them sorted in <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> order.</source>
          <target state="new">Queries that return multiple entities return them sorted in <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> order.</target>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>To avoid resorting the entities in the client chose a <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> that defines the most common sort order.</source>
          <target state="new">To avoid resorting the entities in the client chose a <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> that defines the most common sort order.</target>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Note that using an "<bpt id="p1">**</bpt>or<ept id="p1">**</ept>" to specify a filter based on <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values results in a partition scan and is not treated as a range query.</source>
          <target state="new">Note that using an "<bpt id="p1">**</bpt>or<ept id="p1">**</ept>" to specify a filter based on <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values results in a partition scan and is not treated as a range query.</target>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Therefore, you should avoid queries that use filters such as:</source>
          <target state="new">Therefore, you should avoid queries that use filters such as:</target>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>$filter=PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322')</source>
          <target state="new">$filter=PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322')</target>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>For examples of client-side code that use the Storage Client Library to execute efficient queries, see:</source>
          <target state="new">For examples of client-side code that use the Storage Client Library to execute efficient queries, see:</target>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Retrieving a single entity using the Storage Client Library</source>
          <target state="new">Retrieving a single entity using the Storage Client Library</target>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Retrieving multiple entities using LINQ</source>
          <target state="new">Retrieving multiple entities using LINQ</target>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Server-side projection</source>
          <target state="new">Server-side projection</target>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>For examples of client-side code that can handle multiple entity types stored in the same table, see:</source>
          <target state="new">For examples of client-side code that can handle multiple entity types stored in the same table, see:</target>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Working with heterogeneous entity types</source>
          <target state="new">Working with heterogeneous entity types</target>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Choosing an appropriate PartitionKey</source>
          <target state="new">Choosing an appropriate PartitionKey</target>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Your choice of <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> should balance the need to enables the use of EGTs (to ensure consistency) against the requirement to distribute your entities across multiple partitions (to ensure a scalable solution).</source>
          <target state="new">Your choice of <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> should balance the need to enables the use of EGTs (to ensure consistency) against the requirement to distribute your entities across multiple partitions (to ensure a scalable solution).</target>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>At one extreme, you could store all your entities in a single partition, but this may limit the scalability of your solution and would prevent the table service from being able to load-balance requests.</source>
          <target state="new">At one extreme, you could store all your entities in a single partition, but this may limit the scalability of your solution and would prevent the table service from being able to load-balance requests.</target>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>At the other extreme, you could store one entity per partition, which would be highly scalable and which enables the table service to load-balance requests, but which would prevent you from using entity group transactions.</source>
          <target state="new">At the other extreme, you could store one entity per partition, which would be highly scalable and which enables the table service to load-balance requests, but which would prevent you from using entity group transactions.</target>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>An ideal <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> is one that enables you to use efficient queries and that has sufficient partitions to ensure your solution is scalable.</source>
          <target state="new">An ideal <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> is one that enables you to use efficient queries and that has sufficient partitions to ensure your solution is scalable.</target>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Typically, you will find that your entities will have a suitable property that distributes your entities across sufficient partitions.</source>
          <target state="new">Typically, you will find that your entities will have a suitable property that distributes your entities across sufficient partitions.</target>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> For example, in a system that stores information about users or employees, UserID may be a good PartitionKey.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> For example, in a system that stores information about users or employees, UserID may be a good PartitionKey.</target>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>You may have several entities that use a given UserID as the partition key.</source>
          <target state="new">You may have several entities that use a given UserID as the partition key.</target>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Each entity that stores data about a user is grouped into a single partition, and so these entities are accessible via entity group transactions, while still being highly scalable.</source>
          <target state="new">Each entity that stores data about a user is grouped into a single partition, and so these entities are accessible via entity group transactions, while still being highly scalable.</target>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>There are additional considerations in your choice of <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> that relate to how you will insert, update, and delete entities: see the section <bpt id="p2">[</bpt>Design for data modification<ept id="p2">](#design-for-data-modification)</ept> below.</source>
          <target state="new">There are additional considerations in your choice of <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> that relate to how you will insert, update, and delete entities: see the section <bpt id="p2">[</bpt>Design for data modification<ept id="p2">](#design-for-data-modification)</ept> below.</target>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Optimizing queries for the Table service</source>
          <target state="new">Optimizing queries for the Table service</target>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>The Table service automatically indexes your entities using the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values in a single clustered index, hence the reason that point queries are the most efficient to use.</source>
          <target state="new">The Table service automatically indexes your entities using the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values in a single clustered index, hence the reason that point queries are the most efficient to use.</target>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>However, there are no indexes other than that on the clustered index on the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept>.</source>
          <target state="new">However, there are no indexes other than that on the clustered index on the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Many designs must meet requirements to enable lookup of entities based on multiple criteria.</source>
          <target state="new">Many designs must meet requirements to enable lookup of entities based on multiple criteria.</target>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>For example, locating employee entities based on email, employee id, or last name.</source>
          <target state="new">For example, locating employee entities based on email, employee id, or last name.</target>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The following patterns in the section <bpt id="p1">[</bpt>Table Design Patterns<ept id="p1">](#table-design-patterns)</ept> address these types of requirement and describe ways of working around the fact that the Table service does not provide secondary indexes:</source>
          <target state="new">The following patterns in the section <bpt id="p1">[</bpt>Table Design Patterns<ept id="p1">](#table-design-patterns)</ept> address these types of requirement and describe ways of working around the fact that the Table service does not provide secondary indexes:</target>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Intra-partition secondary index pattern<ept id="p1">](#intra-partition-secondary-index-pattern)</ept> - Store multiple copies of each entity using different <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different <bpt id="p3">**</bpt>RowKey<ept id="p3">**</ept> values.</source>
          <target state="new"><bpt id="p1">[</bpt>Intra-partition secondary index pattern<ept id="p1">](#intra-partition-secondary-index-pattern)</ept> - Store multiple copies of each entity using different <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different <bpt id="p3">**</bpt>RowKey<ept id="p3">**</ept> values.</target>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Inter-partition secondary index pattern<ept id="p1">](#inter-partition-secondary-index-pattern)</ept> - Store multiple copies of each entity using different RowKey values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values.</source>
          <target state="new"><bpt id="p1">[</bpt>Inter-partition secondary index pattern<ept id="p1">](#inter-partition-secondary-index-pattern)</ept> - Store multiple copies of each entity using different RowKey values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values.</target>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Index Entities Pattern<ept id="p1">](#index-entities-pattern)</ept> - Maintain index entities to enable efficient searches that return lists of entities.</source>
          <target state="new"><bpt id="p1">[</bpt>Index Entities Pattern<ept id="p1">](#index-entities-pattern)</ept> - Maintain index entities to enable efficient searches that return lists of entities.</target>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Sorting data in in the Table service</source>
          <target state="new">Sorting data in in the Table service</target>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>The Table service returns entities sorted in ascending order based on <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and then by <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept>.</source>
          <target state="new">The Table service returns entities sorted in ascending order based on <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and then by <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>These keys are string values and to ensure that numeric values sort correctly, you should convert them to a fixed length and pad them with zeroes.</source>
          <target state="new">These keys are string values and to ensure that numeric values sort correctly, you should convert them to a fixed length and pad them with zeroes.</target>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>For example, if the employee id value you use as the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> is an integer value, you should convert employee id <bpt id="p2">**</bpt>123<ept id="p2">**</ept> to <bpt id="p3">**</bpt>00000123<ept id="p3">**</ept>.</source>
          <target state="new">For example, if the employee id value you use as the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> is an integer value, you should convert employee id <bpt id="p2">**</bpt>123<ept id="p2">**</ept> to <bpt id="p3">**</bpt>00000123<ept id="p3">**</ept>.</target>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Many applications have requirements to use data sorted in different orders: for example, sorting employees by name, or by joining date.</source>
          <target state="new">Many applications have requirements to use data sorted in different orders: for example, sorting employees by name, or by joining date.</target>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>The following patterns in the section <bpt id="p1">[</bpt>Table Design Patterns<ept id="p1">](#table-design-patterns)</ept> address how to alternate sort orders for your entities:</source>
          <target state="new">The following patterns in the section <bpt id="p1">[</bpt>Table Design Patterns<ept id="p1">](#table-design-patterns)</ept> address how to alternate sort orders for your entities:</target>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Intra-partition secondary index pattern<ept id="p1">](#intra-partition-secondary-index-pattern)</ept> - Store multiple copies of each entity using different RowKey values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different RowKey values.</source>
          <target state="new"><bpt id="p1">[</bpt>Intra-partition secondary index pattern<ept id="p1">](#intra-partition-secondary-index-pattern)</ept> - Store multiple copies of each entity using different RowKey values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different RowKey values.</target>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Inter-partition secondary index pattern<ept id="p1">](#inter-partition-secondary-index-pattern)</ept> - Store multiple copies of each entity using different RowKey values in separate partitions in separate tables to enable fast and efficient lookups and alternate sort orders by using different RowKey values.</source>
          <target state="new"><bpt id="p1">[</bpt>Inter-partition secondary index pattern<ept id="p1">](#inter-partition-secondary-index-pattern)</ept> - Store multiple copies of each entity using different RowKey values in separate partitions in separate tables to enable fast and efficient lookups and alternate sort orders by using different RowKey values.</target>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Log tail pattern<ept id="p1">](#log-tail-pattern)</ept> - Retrieve the <bpt id="p2">*</bpt>n<ept id="p2">*</ept> entities most recently added to a partition by using a <bpt id="p3">**</bpt>RowKey<ept id="p3">**</ept> value that sorts in reverse date and time order.</source>
          <target state="new"><bpt id="p1">[</bpt>Log tail pattern<ept id="p1">](#log-tail-pattern)</ept> - Retrieve the <bpt id="p2">*</bpt>n<ept id="p2">*</ept> entities most recently added to a partition by using a <bpt id="p3">**</bpt>RowKey<ept id="p3">**</ept> value that sorts in reverse date and time order.</target>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Design for data modification</source>
          <target state="new">Design for data modification</target>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>This section focuses on the design considerations for optimizing inserts, updates, and deletes.</source>
          <target state="new">This section focuses on the design considerations for optimizing inserts, updates, and deletes.</target>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>In some cases, you will need to evaluate the trade-off between designs that optimize for querying against designs that optimize for data modification just as you do in designs for relational databases (although the techniques for managing the design trade-offs are different in a relational database).</source>
          <target state="new">In some cases, you will need to evaluate the trade-off between designs that optimize for querying against designs that optimize for data modification just as you do in designs for relational databases (although the techniques for managing the design trade-offs are different in a relational database).</target>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>The section <bpt id="p1">[</bpt>Table Design Patterns<ept id="p1">](#table-design-patterns)</ept> describes some detailed design patterns for the Table service and highlights some these trade-offs.</source>
          <target state="new">The section <bpt id="p1">[</bpt>Table Design Patterns<ept id="p1">](#table-design-patterns)</ept> describes some detailed design patterns for the Table service and highlights some these trade-offs.</target>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>In practice, you will find that many designs optimized for querying entities also work well for modifying entities.</source>
          <target state="new">In practice, you will find that many designs optimized for querying entities also work well for modifying entities.</target>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Optimizing the performance of insert, update, and delete operations</source>
          <target state="new">Optimizing the performance of insert, update, and delete operations</target>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>To update or delete an entity, you must be able to identify it by using the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values.</source>
          <target state="new">To update or delete an entity, you must be able to identify it by using the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values.</target>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>In this respect, your choice of <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> for modifying entities should follow similar criteria to your choice to support point queries because you want to identify entities as efficiently as possible.</source>
          <target state="new">In this respect, your choice of <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> for modifying entities should follow similar criteria to your choice to support point queries because you want to identify entities as efficiently as possible.</target>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>You do not want to use an inefficient partition or table scan to locate an entity in order to discover the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values you need to update or delete it.</source>
          <target state="new">You do not want to use an inefficient partition or table scan to locate an entity in order to discover the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values you need to update or delete it.</target>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>The following patterns in the section <bpt id="p1">[</bpt>Table Design Patterns<ept id="p1">](#table-design-patterns)</ept> address optimizing the performance or your insert, update, and delete operations:</source>
          <target state="new">The following patterns in the section <bpt id="p1">[</bpt>Table Design Patterns<ept id="p1">](#table-design-patterns)</ept> address optimizing the performance or your insert, update, and delete operations:</target>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>High volume delete pattern<ept id="p1">](#high-volume-delete-pattern)</ept> - Enable the deletion of a high volume of entities by storing all the entities for simultaneous deletion in their own separate table; you delete the entities by deleting the table.</source>
          <target state="new"><bpt id="p1">[</bpt>High volume delete pattern<ept id="p1">](#high-volume-delete-pattern)</ept> - Enable the deletion of a high volume of entities by storing all the entities for simultaneous deletion in their own separate table; you delete the entities by deleting the table.</target>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Data series pattern<ept id="p1">](#data-series-pattern)</ept> - Store complete data series in a single entity to minimize the number of requests you make.</source>
          <target state="new"><bpt id="p1">[</bpt>Data series pattern<ept id="p1">](#data-series-pattern)</ept> - Store complete data series in a single entity to minimize the number of requests you make.</target>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Wide entities pattern<ept id="p1">](#wide-entities-pattern)</ept> - Use multiple physical entities to store logical entities with more than 252 properties.</source>
          <target state="new"><bpt id="p1">[</bpt>Wide entities pattern<ept id="p1">](#wide-entities-pattern)</ept> - Use multiple physical entities to store logical entities with more than 252 properties.</target>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Large entities pattern<ept id="p1">](#large-entities-pattern)</ept> - Use blob storage to store large property values.</source>
          <target state="new"><bpt id="p1">[</bpt>Large entities pattern<ept id="p1">](#large-entities-pattern)</ept> - Use blob storage to store large property values.</target>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Ensuring consistency in your stored entities</source>
          <target state="new">Ensuring consistency in your stored entities</target>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>The other key factor that influences your choice of keys for optimizing data modifications is how to ensure consistency by using atomic transactions.</source>
          <target state="new">The other key factor that influences your choice of keys for optimizing data modifications is how to ensure consistency by using atomic transactions.</target>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>You can only use an EGT to operate on entities stored in the same partition.</source>
          <target state="new">You can only use an EGT to operate on entities stored in the same partition.</target>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>The following patterns in the section <bpt id="p1">[</bpt>Table Design Patterns<ept id="p1">](#table-design-patterns)</ept> address managing consistency:</source>
          <target state="new">The following patterns in the section <bpt id="p1">[</bpt>Table Design Patterns<ept id="p1">](#table-design-patterns)</ept> address managing consistency:</target>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Intra-partition secondary index pattern<ept id="p1">](#intra-partition-secondary-index-pattern)</ept> - Store multiple copies of each entity using different <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different <bpt id="p3">**</bpt>RowKey<ept id="p3">**</ept> values.</source>
          <target state="new"><bpt id="p1">[</bpt>Intra-partition secondary index pattern<ept id="p1">](#intra-partition-secondary-index-pattern)</ept> - Store multiple copies of each entity using different <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different <bpt id="p3">**</bpt>RowKey<ept id="p3">**</ept> values.</target>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Inter-partition secondary index pattern<ept id="p1">](#inter-partition-secondary-index-pattern)</ept> - Store multiple copies of each entity using different RowKey values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values.</source>
          <target state="new"><bpt id="p1">[</bpt>Inter-partition secondary index pattern<ept id="p1">](#inter-partition-secondary-index-pattern)</ept> - Store multiple copies of each entity using different RowKey values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values.</target>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Eventually consistent transactions pattern<ept id="p1">](#eventually-consistent-transactions-pattern)</ept> - Enable eventually consistent behavior across partition boundaries or storage system boundaries by using Azure queues.</source>
          <target state="new"><bpt id="p1">[</bpt>Eventually consistent transactions pattern<ept id="p1">](#eventually-consistent-transactions-pattern)</ept> - Enable eventually consistent behavior across partition boundaries or storage system boundaries by using Azure queues.</target>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Index Entities Pattern<ept id="p1">](#index-entities-pattern)</ept> - Maintain index entities to enable efficient searches that return lists of entities.</source>
          <target state="new"><bpt id="p1">[</bpt>Index Entities Pattern<ept id="p1">](#index-entities-pattern)</ept> - Maintain index entities to enable efficient searches that return lists of entities.</target>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Denormalization pattern<ept id="p1">](#denormalization-pattern)</ept> - Combine related data together in a single entity to enable you to retrieve all the data you need with a single point query.</source>
          <target state="new"><bpt id="p1">[</bpt>Denormalization pattern<ept id="p1">](#denormalization-pattern)</ept> - Combine related data together in a single entity to enable you to retrieve all the data you need with a single point query.</target>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Data series pattern<ept id="p1">](#data-series-pattern)</ept> - Store complete data series in a single entity to minimize the number of requests you make.</source>
          <target state="new"><bpt id="p1">[</bpt>Data series pattern<ept id="p1">](#data-series-pattern)</ept> - Store complete data series in a single entity to minimize the number of requests you make.</target>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>For information about entity group transactions, see the section <bpt id="p1">[</bpt>Entity Group Transactions<ept id="p1">](#entity-group-transactions)</ept>.</source>
          <target state="new">For information about entity group transactions, see the section <bpt id="p1">[</bpt>Entity Group Transactions<ept id="p1">](#entity-group-transactions)</ept>.</target>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Ensuring your design for efficient modifications facilitates efficient queries</source>
          <target state="new">Ensuring your design for efficient modifications facilitates efficient queries</target>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>In many cases, a design for efficient querying results in efficient modifications, but you should always evaluate whether this is the case for your specific scenario.</source>
          <target state="new">In many cases, a design for efficient querying results in efficient modifications, but you should always evaluate whether this is the case for your specific scenario.</target>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>Some of the patterns in the section <bpt id="p1">[</bpt>Table Design Patterns<ept id="p1">](#table-design-patterns)</ept> explicitly evaluate trade-offs between querying and modifying entities, and you should always take into account the number of each type of operation.</source>
          <target state="new">Some of the patterns in the section <bpt id="p1">[</bpt>Table Design Patterns<ept id="p1">](#table-design-patterns)</ept> explicitly evaluate trade-offs between querying and modifying entities, and you should always take into account the number of each type of operation.</target>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>The following patterns in the section <bpt id="p1">[</bpt>Table Design Patterns<ept id="p1">](#table-design-patterns)</ept> address trade-offs between designing for efficient queries and designing for efficient data modification:</source>
          <target state="new">The following patterns in the section <bpt id="p1">[</bpt>Table Design Patterns<ept id="p1">](#table-design-patterns)</ept> address trade-offs between designing for efficient queries and designing for efficient data modification:</target>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Compound key pattern<ept id="p1">](#compound-key-pattern)</ept> - Use compound <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values to enable a client to lookup related data with a single point query.</source>
          <target state="new"><bpt id="p1">[</bpt>Compound key pattern<ept id="p1">](#compound-key-pattern)</ept> - Use compound <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values to enable a client to lookup related data with a single point query.</target>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Log tail pattern<ept id="p1">](#log-tail-pattern)</ept> - Retrieve the <bpt id="p2">*</bpt>n<ept id="p2">*</ept> entities most recently added to a partition by using a <bpt id="p3">**</bpt>RowKey<ept id="p3">**</ept> value that sorts in reverse date and time order.</source>
          <target state="new"><bpt id="p1">[</bpt>Log tail pattern<ept id="p1">](#log-tail-pattern)</ept> - Retrieve the <bpt id="p2">*</bpt>n<ept id="p2">*</ept> entities most recently added to a partition by using a <bpt id="p3">**</bpt>RowKey<ept id="p3">**</ept> value that sorts in reverse date and time order.</target>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Modelling relationships</source>
          <target state="new">Modelling relationships</target>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>Building domain models is a key step in the design of complex systems.</source>
          <target state="new">Building domain models is a key step in the design of complex systems.</target>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Typically, you use the modelling process to identify entities and the relationships between them as a way to understand the business domain and inform the design of your system.</source>
          <target state="new">Typically, you use the modelling process to identify entities and the relationships between them as a way to understand the business domain and inform the design of your system.</target>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>This section focuses on how you can translate some of the common relationship types found in domain models to designs for the Table service.</source>
          <target state="new">This section focuses on how you can translate some of the common relationship types found in domain models to designs for the Table service.</target>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The process of mapping from a logical data-model to a physical NoSQL based data-model is very different from that used when designing a relational database.</source>
          <target state="new">The process of mapping from a logical data-model to a physical NoSQL based data-model is very different from that used when designing a relational database.</target>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>Relational databases design typically assumes a data normalization process optimized for minimizing redundancy  and a declarative querying capability that abstracts how the implementation of how the database works.</source>
          <target state="new">Relational databases design typically assumes a data normalization process optimized for minimizing redundancy  and a declarative querying capability that abstracts how the implementation of how the database works.</target>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>One-to-many relationships</source>
          <target state="new">One-to-many relationships</target>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>One-to-many relationships between business domain objects occur very frequently: for example, one department has many employees.</source>
          <target state="new">One-to-many relationships between business domain objects occur very frequently: for example, one department has many employees.</target>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>There are several ways to implement one-to-many relationships in the Table service each with pros and cons that may be relevant to the particular scenario.</source>
          <target state="new">There are several ways to implement one-to-many relationships in the Table service each with pros and cons that may be relevant to the particular scenario.</target>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>Consider the example of a large multi-national corporation with tens of thousands of departments and employee entities where every department has many employees and each employee as associated with one specific department.</source>
          <target state="new">Consider the example of a large multi-national corporation with tens of thousands of departments and employee entities where every department has many employees and each employee as associated with one specific department.</target>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>One approach is to store separate department and employee entities such as these:</source>
          <target state="new">One approach is to store separate department and employee entities such as these:</target>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>This example shows an implicit one-to-many relationship between the types based on the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> value.</source>
          <target state="new">This example shows an implicit one-to-many relationship between the types based on the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> value.</target>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>Each department can have many employees.</source>
          <target state="new">Each department can have many employees.</target>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>This example also shows a department entity and its related employee entities in the same partition.</source>
          <target state="new">This example also shows a department entity and its related employee entities in the same partition.</target>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>You could choose to use different partitions, tables, or even storage accounts for the different entity types.</source>
          <target state="new">You could choose to use different partitions, tables, or even storage accounts for the different entity types.</target>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>An alternative approach is to denormalize your data and store only employee entities with denormalized department data as shown in the following example.</source>
          <target state="new">An alternative approach is to denormalize your data and store only employee entities with denormalized department data as shown in the following example.</target>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>In this particular scenario, this denormalized approach may not be the best if you have a requirement to be able to change the details of a department manager because to do this you need to update every employee in the department.</source>
          <target state="new">In this particular scenario, this denormalized approach may not be the best if you have a requirement to be able to change the details of a department manager because to do this you need to update every employee in the department.</target>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Denormalization pattern<ept id="p1">](#denormalization-pattern)</ept> later in this guide.</source>
          <target state="new">For more information, see the <bpt id="p1">[</bpt>Denormalization pattern<ept id="p1">](#denormalization-pattern)</ept> later in this guide.</target>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>The following table summarizes the pros and cons of each of the approaches outlined above for storing employee and department entities that have a one-to-many relationship.</source>
          <target state="new">The following table summarizes the pros and cons of each of the approaches outlined above for storing employee and department entities that have a one-to-many relationship.</target>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>You should also consider how often you expect to perform various operations: it may be acceptable to have a design that includes an expensive operation if that operation only happens infrequently.</source>
          <target state="new">You should also consider how often you expect to perform various operations: it may be acceptable to have a design that includes an expensive operation if that operation only happens infrequently.</target>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>Approach</source>
          <target state="new">Approach</target>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>Pros</source>
          <target state="new">Pros</target>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>Cons</source>
          <target state="new">Cons</target>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>Separate entity types, same partition, same table</source>
          <target state="new">Separate entity types, same partition, same table</target>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>You can update a department entity with a single operation.</source>
          <target state="new">You can update a department entity with a single operation.</target>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>You can use an EGT to maintain consistency if you have a requirement to modify a department entity whenever you update/insert/delete an employee entity.</source>
          <target state="new">You can use an EGT to maintain consistency if you have a requirement to modify a department entity whenever you update/insert/delete an employee entity.</target>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>For example if you maintain a departmental employee count for each department.</source>
          <target state="new">For example if you maintain a departmental employee count for each department.</target>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>You may need to retrieve both an employee and a department entity for some client activities.</source>
          <target state="new">You may need to retrieve both an employee and a department entity for some client activities.</target>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>Storage operations happen in the same partition.</source>
          <target state="new">Storage operations happen in the same partition.</target>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>At high transaction volumes, this may result in a hotspot.</source>
          <target state="new">At high transaction volumes, this may result in a hotspot.</target>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>You cannot move an employee to a new department using an EGT.</source>
          <target state="new">You cannot move an employee to a new department using an EGT.</target>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>Separate entity types, different partitions or tables or storage accounts</source>
          <target state="new">Separate entity types, different partitions or tables or storage accounts</target>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>You can update a department entity or employee entity with a single operation.</source>
          <target state="new">You can update a department entity or employee entity with a single operation.</target>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>At high transaction volumes, this may help spread the load across more partitions.</source>
          <target state="new">At high transaction volumes, this may help spread the load across more partitions.</target>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>You may need to retrieve both an employee and a department entity for some client activities.</source>
          <target state="new">You may need to retrieve both an employee and a department entity for some client activities.</target>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>You cannot use EGTs to maintain consistency when you update/insert/delete an employee and update a department.</source>
          <target state="new">You cannot use EGTs to maintain consistency when you update/insert/delete an employee and update a department.</target>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>For example, updating an employee count in a department entity.</source>
          <target state="new">For example, updating an employee count in a department entity.</target>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>You cannot move an employee to a new department using an EGT.</source>
          <target state="new">You cannot move an employee to a new department using an EGT.</target>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>Denormalize into single entity type</source>
          <target state="new">Denormalize into single entity type</target>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>You can retrieve all the information you need with a single request.</source>
          <target state="new">You can retrieve all the information you need with a single request.</target>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>It may be expensive to maintain consistency if you need to update department information (this would require you to update all the employees in a department).</source>
          <target state="new">It may be expensive to maintain consistency if you need to update department information (this would require you to update all the employees in a department).</target>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>How you choose between these options, and which of the pros and cons are most significant, depends on your specific application scenarios.</source>
          <target state="new">How you choose between these options, and which of the pros and cons are most significant, depends on your specific application scenarios.</target>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>For example, how often do you modify department entities; do all your employee queries need the additional departmental information; how close are you to the scalability limits on your partitions or your storage account?</source>
          <target state="new">For example, how often do you modify department entities; do all your employee queries need the additional departmental information; how close are you to the scalability limits on your partitions or your storage account?</target>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>One-to-one relationships</source>
          <target state="new">One-to-one relationships</target>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>Domain models may include one-to-one relationships between entities.</source>
          <target state="new">Domain models may include one-to-one relationships between entities.</target>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>If you need to implement a one-to-one relationship in the Table service, you must also choose how to link the two related entities when you need to retrieve them both.</source>
          <target state="new">If you need to implement a one-to-one relationship in the Table service, you must also choose how to link the two related entities when you need to retrieve them both.</target>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>This link can be either implicit, based on a convention in the key values, or explicit by storing a link in the form of <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values in each entity to its related entity.</source>
          <target state="new">This link can be either implicit, based on a convention in the key values, or explicit by storing a link in the form of <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values in each entity to its related entity.</target>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>For a discussion of whether you should store the related entities in the same partition, see the section <bpt id="p1">[</bpt>One-to-many relationships<ept id="p1">](#one-to-many-relationships)</ept>.</source>
          <target state="new">For a discussion of whether you should store the related entities in the same partition, see the section <bpt id="p1">[</bpt>One-to-many relationships<ept id="p1">](#one-to-many-relationships)</ept>.</target>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>Note that there are also implementation considerations that might lead you to implement one-to-one relationships in the Table service:</source>
          <target state="new">Note that there are also implementation considerations that might lead you to implement one-to-one relationships in the Table service:</target>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>Handling large entities (for more information, see <bpt id="p1">[</bpt>Working with large entities<ept id="p1">](#working-with-large-entities)</ept>).</source>
          <target state="new">Handling large entities (for more information, see <bpt id="p1">[</bpt>Working with large entities<ept id="p1">](#working-with-large-entities)</ept>).</target>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>Implementing access controls (for more information, see <bpt id="p1">[</bpt>Controlling access with Shared Access Signatures<ept id="p1">](#controlling-access-with-shared-access-signatures)</ept>).</source>
          <target state="new">Implementing access controls (for more information, see <bpt id="p1">[</bpt>Controlling access with Shared Access Signatures<ept id="p1">](#controlling-access-with-shared-access-signatures)</ept>).</target>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>Join in the client</source>
          <target state="new">Join in the client</target>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>Although there are ways to model relationships in the Table service, you should not forget that the two prime reasons for using the Table service are scalability and performance.</source>
          <target state="new">Although there are ways to model relationships in the Table service, you should not forget that the two prime reasons for using the Table service are scalability and performance.</target>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>If you find you are modelling many relationships that compromise the performance and scalability of your solution, you should ask yourself if it is necessary to build all the data relationships into your table design.</source>
          <target state="new">If you find you are modelling many relationships that compromise the performance and scalability of your solution, you should ask yourself if it is necessary to build all the data relationships into your table design.</target>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>You may be able to simplify the design and improve the scalability and performance of your solution if you let your client application perform any necessary joins.</source>
          <target state="new">You may be able to simplify the design and improve the scalability and performance of your solution if you let your client application perform any necessary joins.</target>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>For example, if you have small tables that contain data that does not change very often, then you can retrieve this data once and cache it on the client.</source>
          <target state="new">For example, if you have small tables that contain data that does not change very often, then you can retrieve this data once and cache it on the client.</target>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>This can avoid repeated roundtrips to retrieve the same data.</source>
          <target state="new">This can avoid repeated roundtrips to retrieve the same data.</target>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>In the examples we have looked at in this guide, the set of departments in a small organization is likely to be small and change infrequently making it a good candidate for data that client application can download once and cache as look up data.</source>
          <target state="new">In the examples we have looked at in this guide, the set of departments in a small organization is likely to be small and change infrequently making it a good candidate for data that client application can download once and cache as look up data.</target>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>Inheritance relationships</source>
          <target state="new">Inheritance relationships</target>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>If your client application uses a set of classes that form part of an inheritance relationship to represent business entities, you can easily persist those entities in the Table service.</source>
          <target state="new">If your client application uses a set of classes that form part of an inheritance relationship to represent business entities, you can easily persist those entities in the Table service.</target>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>For example, you might have the following set of classes defined in your client application where <bpt id="p1">**</bpt>Person<ept id="p1">**</ept> is an abstract class.</source>
          <target state="new">For example, you might have the following set of classes defined in your client application where <bpt id="p1">**</bpt>Person<ept id="p1">**</ept> is an abstract class.</target>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>You can persist instances of the two concrete classes in the Table service using a single Person table using entities in that look like this:</source>
          <target state="new">You can persist instances of the two concrete classes in the Table service using a single Person table using entities in that look like this:</target>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>For more information about working with multiple entity types in the same table in client code, see the section <bpt id="p1">[</bpt>Working with heterogeneous entity types<ept id="p1">](#working-with-heterogeneous-entity-types)</ept> later in this guide.</source>
          <target state="new">For more information about working with multiple entity types in the same table in client code, see the section <bpt id="p1">[</bpt>Working with heterogeneous entity types<ept id="p1">](#working-with-heterogeneous-entity-types)</ept> later in this guide.</target>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>This provides examples of how to recognize the entity type in client code.</source>
          <target state="new">This provides examples of how to recognize the entity type in client code.</target>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Table Design Patterns</source>
          <target state="new">Table Design Patterns</target>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>In previous sections, you have seen some detailed discussions about how to optimize your table design for both retrieving entity data using queries and for inserting, updating, and deleting entity data.</source>
          <target state="new">In previous sections, you have seen some detailed discussions about how to optimize your table design for both retrieving entity data using queries and for inserting, updating, and deleting entity data.</target>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>This section describes some patterns appropriate for use with Table service solutions.</source>
          <target state="new">This section describes some patterns appropriate for use with Table service solutions.</target>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>In addition, you will see how you can practically address some of the issues and trade-offs raised previously in this guide.</source>
          <target state="new">In addition, you will see how you can practically address some of the issues and trade-offs raised previously in this guide.</target>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>The following diagram summarizes the relationships between the different patterns:</source>
          <target state="new">The following diagram summarizes the relationships between the different patterns:</target>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>The pattern map above highlights some relationships between patterns (blue) and anti-patterns (orange) that are documented in this guide.</source>
          <target state="new">The pattern map above highlights some relationships between patterns (blue) and anti-patterns (orange) that are documented in this guide.</target>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>There are of course many other patterns that are worth considering.</source>
          <target state="new">There are of course many other patterns that are worth considering.</target>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>For example, one of the key scenarios for Table Service is to store <bpt id="p1">[</bpt>Materialized Views<ept id="p1">](https://msdn.microsoft.com/library/azure/dn589782.aspx)</ept> from the <bpt id="p2">[</bpt>Command Query Responsibility Segregation<ept id="p2">](https://msdn.microsoft.com/library/azure/jj554200.aspx)</ept> (CQRS) pattern.</source>
          <target state="new">For example, one of the key scenarios for Table Service is to store <bpt id="p1">[</bpt>Materialized Views<ept id="p1">](https://msdn.microsoft.com/library/azure/dn589782.aspx)</ept> from the <bpt id="p2">[</bpt>Command Query Responsibility Segregation<ept id="p2">](https://msdn.microsoft.com/library/azure/jj554200.aspx)</ept> (CQRS) pattern.</target>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>Intra-partition secondary index pattern</source>
          <target state="new">Intra-partition secondary index pattern</target>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>Store multiple copies of each entity using different <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values.</source>
          <target state="new">Store multiple copies of each entity using different <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values.</target>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>Updates between copies can be kept consistent using EGTs.</source>
          <target state="new">Updates between copies can be kept consistent using EGTs.</target>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>Context and problem</source>
          <target state="new">Context and problem</target>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>The Table service automatically indexes entities using the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values.</source>
          <target state="new">The Table service automatically indexes entities using the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values.</target>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>This enables a client application to retrieve an entity efficiently using these values.</source>
          <target state="new">This enables a client application to retrieve an entity efficiently using these values.</target>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>For example, using the table structure shown below, a client application can use a point query to retrieve an individual employee entity by using the department name and the employee id (the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values).</source>
          <target state="new">For example, using the table structure shown below, a client application can use a point query to retrieve an individual employee entity by using the department name and the employee id (the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values).</target>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>A client can also retrieve entities sorted by employee id within each department.</source>
          <target state="new">A client can also retrieve entities sorted by employee id within each department.</target>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>If you also want to be able to find an employee entity based on the value of another property, such as email address, you must use a less efficient partition scan to find a match.</source>
          <target state="new">If you also want to be able to find an employee entity based on the value of another property, such as email address, you must use a less efficient partition scan to find a match.</target>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>This is because the table service does not provide secondary indexes.</source>
          <target state="new">This is because the table service does not provide secondary indexes.</target>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>In addition, there is no option to request a list of employees sorted in a different order than <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> order.</source>
          <target state="new">In addition, there is no option to request a list of employees sorted in a different order than <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> order.</target>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="new">Solution</target>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>To work around the lack of secondary indexes, you can store multiple copies of each entity with each copy using a different <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> value.</source>
          <target state="new">To work around the lack of secondary indexes, you can store multiple copies of each entity with each copy using a different <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> value.</target>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>If you store an entity with the structures shown below, you can efficiently retrieve employee entities based on email address or employee id.</source>
          <target state="new">If you store an entity with the structures shown below, you can efficiently retrieve employee entities based on email address or employee id.</target>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>The prefix values for the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept>, "empid_" and "email_" enable you to query for a single employee or a range of employees by using a range of email addresses or employee ids.</source>
          <target state="new">The prefix values for the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept>, "empid_" and "email_" enable you to query for a single employee or a range of employees by using a range of email addresses or employee ids.</target>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>The following two filter criteria (one looking up by employee id and one looking up by email address) both specify point queries:</source>
          <target state="new">The following two filter criteria (one looking up by employee id and one looking up by email address) both specify point queries:</target>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>$filter=(PartitionKey eq 'Sales') and (RowKey eq 'empid_000223')</source>
          <target state="new">$filter=(PartitionKey eq 'Sales') and (RowKey eq 'empid_000223')</target>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>$filter=(PartitionKey eq 'Sales') and (RowKey eq 'email_jonesj@contoso.com')</source>
          <target state="new">$filter=(PartitionKey eq 'Sales') and (RowKey eq 'email_jonesj@contoso.com')</target>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>If you query for a range of employee entities, you can specify a range sorted in employee id order, or a range sorted in email address order by querying for entities with the appropriate prefix in the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept>.</source>
          <target state="new">If you query for a range of employee entities, you can specify a range sorted in employee id order, or a range sorted in email address order by querying for entities with the appropriate prefix in the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>To find all the employees in the Sales department with an employee id in the range 000100 to 000199 use:</source>
          <target state="new">To find all the employees in the Sales department with an employee id in the range 000100 to 000199 use:</target>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000100') and (RowKey le 'empid_000199')</source>
          <target state="new">$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000100') and (RowKey le 'empid_000199')</target>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>To find all the employees in the Sales department with an email address starting with the letter 'a' use:</source>
          <target state="new">To find all the employees in the Sales department with an email address starting with the letter 'a' use:</target>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>$filter=(PartitionKey eq 'Sales') and (RowKey ge 'email_a') and (RowKey lt 'email_b')</source>
          <target state="new">$filter=(PartitionKey eq 'Sales') and (RowKey ge 'email_a') and (RowKey lt 'email_b')</target>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>Note that the filter syntax used in the examples above is from the Table service REST API, for more information see <bpt id="p1">[</bpt>Query Entities<ept id="p1">](http://msdn.microsoft.com/library/azure/dd179421.aspx)</ept> on MSDN.</source>
          <target state="new">Note that the filter syntax used in the examples above is from the Table service REST API, for more information see <bpt id="p1">[</bpt>Query Entities<ept id="p1">](http://msdn.microsoft.com/library/azure/dd179421.aspx)</ept> on MSDN.</target>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>Issues and considerations</source>
          <target state="new">Issues and considerations</target>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>Consider the following points when deciding how to implement this pattern:</source>
          <target state="new">Consider the following points when deciding how to implement this pattern:</target>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>Table storage is relatively cheap to use so the cost overhead of storing duplicate data should not be a major concern.</source>
          <target state="new">Table storage is relatively cheap to use so the cost overhead of storing duplicate data should not be a major concern.</target>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>However, you should always evaluate the cost of your design based on your anticipated storage requirements and only add duplicate entities to support the queries your client application will execute.</source>
          <target state="new">However, you should always evaluate the cost of your design based on your anticipated storage requirements and only add duplicate entities to support the queries your client application will execute.</target>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>Because the secondary index entities are stored in the same partition as the original entities, you should ensure that you do not exceed the scalability targets for an individual partition.</source>
          <target state="new">Because the secondary index entities are stored in the same partition as the original entities, you should ensure that you do not exceed the scalability targets for an individual partition.</target>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>You can keep your duplicate entities consistent with each other by using EGTs to update the two copies of the entity atomically.</source>
          <target state="new">You can keep your duplicate entities consistent with each other by using EGTs to update the two copies of the entity atomically.</target>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>This implies that you should store all copies of an entity in the same partition.</source>
          <target state="new">This implies that you should store all copies of an entity in the same partition.</target>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>For more information, see the section <bpt id="p1">[</bpt>Using Entity Group Transactions<ept id="p1">](#entity-group-transactions)</ept>.</source>
          <target state="new">For more information, see the section <bpt id="p1">[</bpt>Using Entity Group Transactions<ept id="p1">](#entity-group-transactions)</ept>.</target>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>The value used for the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> must be unique for each entity.</source>
          <target state="new">The value used for the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> must be unique for each entity.</target>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>Consider using compound key values.</source>
          <target state="new">Consider using compound key values.</target>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>Padding numeric values in the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> (for example, the employee id 000223), enables correct sorting and filtering based on upper and lower bounds.</source>
          <target state="new">Padding numeric values in the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> (for example, the employee id 000223), enables correct sorting and filtering based on upper and lower bounds.</target>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>You do not necessarily need to duplicate all the properties of your entity.</source>
          <target state="new">You do not necessarily need to duplicate all the properties of your entity.</target>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>For example, if the queries that lookup the entities using the email address in the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> never need the employees age, these entities could have the following structure:</source>
          <target state="new">For example, if the queries that lookup the entities using the email address in the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> never need the employees age, these entities could have the following structure:</target>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>It is typically better to store duplicate data and ensure that you can retrieve all the data you need with a single query, than to use one query to locate an entity and another to lookup the required data.</source>
          <target state="new">It is typically better to store duplicate data and ensure that you can retrieve all the data you need with a single query, than to use one query to locate an entity and another to lookup the required data.</target>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>When to use this pattern</source>
          <target state="new">When to use this pattern</target>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>Use this pattern when your client application needs to retrieve entities using a variety of different keys, when your client needs to retrieve entities in different sort orders, and where you can identify each entity using a variety of unique values.</source>
          <target state="new">Use this pattern when your client application needs to retrieve entities using a variety of different keys, when your client needs to retrieve entities in different sort orders, and where you can identify each entity using a variety of unique values.</target>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>However, you should be sure that you do not exceed the partition scalability limits when you are performing entity lookups using the different <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> values.</source>
          <target state="new">However, you should be sure that you do not exceed the partition scalability limits when you are performing entity lookups using the different <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> values.</target>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>Related patterns and guidance</source>
          <target state="new">Related patterns and guidance</target>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>The following patterns and guidance may also be relevant when implementing this pattern:</source>
          <target state="new">The following patterns and guidance may also be relevant when implementing this pattern:</target>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>Inter-partition secondary index pattern</source>
          <target state="new">Inter-partition secondary index pattern</target>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>Compound key pattern</source>
          <target state="new">Compound key pattern</target>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>Entity Group Transactions</source>
          <target state="new">Entity Group Transactions</target>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>Working with heterogeneous entity types</source>
          <target state="new">Working with heterogeneous entity types</target>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>Inter-partition secondary index pattern</source>
          <target state="new">Inter-partition secondary index pattern</target>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>Store multiple copies of each entity using different <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values.</source>
          <target state="new">Store multiple copies of each entity using different <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values.</target>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>Context and problem</source>
          <target state="new">Context and problem</target>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>The Table service automatically indexes entities using the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values.</source>
          <target state="new">The Table service automatically indexes entities using the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values.</target>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>This enables a client application to retrieve an entity efficiently using these values.</source>
          <target state="new">This enables a client application to retrieve an entity efficiently using these values.</target>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>For example, using the table structure shown below, a client application can use a point query to retrieve an individual employee entity by using the department name and the employee id (the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values).</source>
          <target state="new">For example, using the table structure shown below, a client application can use a point query to retrieve an individual employee entity by using the department name and the employee id (the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values).</target>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>A client can also retrieve entities sorted by employee id within each department.</source>
          <target state="new">A client can also retrieve entities sorted by employee id within each department.</target>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>If you also want to be able to find an employee entity based on the value of another property, such as email address, you must use a less efficient partition scan to find a match.</source>
          <target state="new">If you also want to be able to find an employee entity based on the value of another property, such as email address, you must use a less efficient partition scan to find a match.</target>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>This is because the table service does not provide secondary indexes.</source>
          <target state="new">This is because the table service does not provide secondary indexes.</target>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>In addition, there is no option to request a list of employees sorted in a different order than <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> order.</source>
          <target state="new">In addition, there is no option to request a list of employees sorted in a different order than <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> order.</target>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>You are anticipating a very high volume of transactions against these entities and want to minimize the risk of the Table service throttling your client.</source>
          <target state="new">You are anticipating a very high volume of transactions against these entities and want to minimize the risk of the Table service throttling your client.</target>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="new">Solution</target>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>To work around the lack of secondary indexes, you can store multiple copies of each entity with each copy using different <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values.</source>
          <target state="new">To work around the lack of secondary indexes, you can store multiple copies of each entity with each copy using different <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values.</target>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>If you store an entity with the structures shown below, you can efficiently retrieve employee entities based on email address or employee id.</source>
          <target state="new">If you store an entity with the structures shown below, you can efficiently retrieve employee entities based on email address or employee id.</target>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>The prefix values for the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept>, "empid_" and "email_" enable you to identify which index you want to use for a query.</source>
          <target state="new">The prefix values for the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept>, "empid_" and "email_" enable you to identify which index you want to use for a query.</target>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>The following two filter criteria (one looking up by employee id and one looking up by email address) both specify point queries:</source>
          <target state="new">The following two filter criteria (one looking up by employee id and one looking up by email address) both specify point queries:</target>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>$filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')</source>
          <target state="new">$filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')</target>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>$filter=(PartitionKey eq 'email_Sales') and (RowKey eq 'jonesj@contoso.com')</source>
          <target state="new">$filter=(PartitionKey eq 'email_Sales') and (RowKey eq 'jonesj@contoso.com')</target>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>If you query for a range of employee entities, you can specify a range sorted in employee id order, or a range sorted in email address order by querying for entities with the appropriate prefix in the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept>.</source>
          <target state="new">If you query for a range of employee entities, you can specify a range sorted in employee id order, or a range sorted in email address order by querying for entities with the appropriate prefix in the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>To find all the employees in the Sales department with an employee id in the range <bpt id="p1">**</bpt>000100<ept id="p1">**</ept> to <bpt id="p2">**</bpt>000199<ept id="p2">**</ept> sorted in employee id order use:</source>
          <target state="new">To find all the employees in the Sales department with an employee id in the range <bpt id="p1">**</bpt>000100<ept id="p1">**</ept> to <bpt id="p2">**</bpt>000199<ept id="p2">**</ept> sorted in employee id order use:</target>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>$filter=(PartitionKey eq 'empid_Sales') and (RowKey ge '000100') and (RowKey le '000199')</source>
          <target state="new">$filter=(PartitionKey eq 'empid_Sales') and (RowKey ge '000100') and (RowKey le '000199')</target>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>To find all the employees in the Sales department with an email address that starts with 'a' sorted in email address order use:</source>
          <target state="new">To find all the employees in the Sales department with an email address that starts with 'a' sorted in email address order use:</target>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>$filter=(PartitionKey eq 'email_Sales') and (RowKey ge 'a') and (RowKey lt 'b')</source>
          <target state="new">$filter=(PartitionKey eq 'email_Sales') and (RowKey ge 'a') and (RowKey lt 'b')</target>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>Note that the filter syntax used in the examples above is from the Table service REST API, for more information see <bpt id="p1">[</bpt>Query Entities<ept id="p1">](http://msdn.microsoft.com/library/azure/dd179421.aspx)</ept> on MSDN.</source>
          <target state="new">Note that the filter syntax used in the examples above is from the Table service REST API, for more information see <bpt id="p1">[</bpt>Query Entities<ept id="p1">](http://msdn.microsoft.com/library/azure/dd179421.aspx)</ept> on MSDN.</target>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>Issues and considerations</source>
          <target state="new">Issues and considerations</target>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>Consider the following points when deciding how to implement this pattern:</source>
          <target state="new">Consider the following points when deciding how to implement this pattern:</target>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>You can keep your duplicate entities eventually consistent with each other by using the <bpt id="p1">[</bpt>Eventually consistent transactions pattern<ept id="p1">](#eventually-consistent-transactions-pattern)</ept> to maintain the primary and secondary index entities.</source>
          <target state="new">You can keep your duplicate entities eventually consistent with each other by using the <bpt id="p1">[</bpt>Eventually consistent transactions pattern<ept id="p1">](#eventually-consistent-transactions-pattern)</ept> to maintain the primary and secondary index entities.</target>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>Table storage is relatively cheap to use so the cost overhead of storing duplicate data should not be a major concern.</source>
          <target state="new">Table storage is relatively cheap to use so the cost overhead of storing duplicate data should not be a major concern.</target>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>However, you should always evaluate the cost of your design based on your anticipated storage requirements and only add duplicate entities to support the queries your client application will execute.</source>
          <target state="new">However, you should always evaluate the cost of your design based on your anticipated storage requirements and only add duplicate entities to support the queries your client application will execute.</target>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>The value used for the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> must be unique for each entity.</source>
          <target state="new">The value used for the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> must be unique for each entity.</target>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>Consider using compound key values.</source>
          <target state="new">Consider using compound key values.</target>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>Padding numeric values in the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> (for example, the employee id 000223), enables correct sorting and filtering based on upper and lower bounds.</source>
          <target state="new">Padding numeric values in the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> (for example, the employee id 000223), enables correct sorting and filtering based on upper and lower bounds.</target>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>You do not necessarily need to duplicate all the properties of your entity.</source>
          <target state="new">You do not necessarily need to duplicate all the properties of your entity.</target>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>For example, if the queries that lookup the entities using the email address in the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> never need the employees age, these entities could have the following structure:</source>
          <target state="new">For example, if the queries that lookup the entities using the email address in the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> never need the employees age, these entities could have the following structure:</target>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>It is typically better to store duplicate data and ensure that you can retrieve all the data you need with a single query than to use one query to locate an entity using the secondary index and another to lookup the required data in the primary index.</source>
          <target state="new">It is typically better to store duplicate data and ensure that you can retrieve all the data you need with a single query than to use one query to locate an entity using the secondary index and another to lookup the required data in the primary index.</target>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>When to use this pattern</source>
          <target state="new">When to use this pattern</target>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>Use this pattern when your client application needs to retrieve entities using a variety of different keys, when your client needs to retrieve entities in different sort orders, and where you can identify each entity using a variety of unique values.</source>
          <target state="new">Use this pattern when your client application needs to retrieve entities using a variety of different keys, when your client needs to retrieve entities in different sort orders, and where you can identify each entity using a variety of unique values.</target>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>Use this pattern when you want to avoid exceeding the partition scalability limits when you are performing entity lookups using the different <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> values.</source>
          <target state="new">Use this pattern when you want to avoid exceeding the partition scalability limits when you are performing entity lookups using the different <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> values.</target>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>Related patterns and guidance</source>
          <target state="new">Related patterns and guidance</target>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>The following patterns and guidance may also be relevant when implementing this pattern:</source>
          <target state="new">The following patterns and guidance may also be relevant when implementing this pattern:</target>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>Eventually consistent transactions pattern</source>
          <target state="new">Eventually consistent transactions pattern</target>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>Intra-partition secondary index pattern</source>
          <target state="new">Intra-partition secondary index pattern</target>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>Compound key pattern</source>
          <target state="new">Compound key pattern</target>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source>Entity Group Transactions</source>
          <target state="new">Entity Group Transactions</target>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>Working with heterogeneous entity types</source>
          <target state="new">Working with heterogeneous entity types</target>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>Eventually consistent transactions pattern</source>
          <target state="new">Eventually consistent transactions pattern</target>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>Enable eventually consistent behavior across partition boundaries or storage system boundaries by using Azure queues.</source>
          <target state="new">Enable eventually consistent behavior across partition boundaries or storage system boundaries by using Azure queues.</target>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source>Context and problem</source>
          <target state="new">Context and problem</target>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>EGTs enable atomic transactions across multiple entities that share the same partition key.</source>
          <target state="new">EGTs enable atomic transactions across multiple entities that share the same partition key.</target>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>For performance and scalability reasons, you might decide to store entities that have consistency requirements in separate partitions or in a separate storage system: in such a scenario, you cannot use EGTs to maintain consistency.</source>
          <target state="new">For performance and scalability reasons, you might decide to store entities that have consistency requirements in separate partitions or in a separate storage system: in such a scenario, you cannot use EGTs to maintain consistency.</target>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>For example, you might have a requirement to maintain eventual consistency between:</source>
          <target state="new">For example, you might have a requirement to maintain eventual consistency between:</target>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>Entities stored in two different partitions in the same table, in different tables, in in different storage accounts.</source>
          <target state="new">Entities stored in two different partitions in the same table, in different tables, in in different storage accounts.</target>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>An entity stored in the Table service and a blob stored in the Blob service.</source>
          <target state="new">An entity stored in the Table service and a blob stored in the Blob service.</target>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>An entity stored in the Table service and a file in a file system.</source>
          <target state="new">An entity stored in the Table service and a file in a file system.</target>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>An entity store in the Table service yet indexed using the Azure Search service.</source>
          <target state="new">An entity store in the Table service yet indexed using the Azure Search service.</target>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="new">Solution</target>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>By using Azure queues, you can implement a solution that delivers eventual consistency across two or more partitions or storage systems.</source>
          <target state="new">By using Azure queues, you can implement a solution that delivers eventual consistency across two or more partitions or storage systems.</target>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>To illustrate this approach, assume you have a requirement to be able to archive old employee entities.</source>
          <target state="new">To illustrate this approach, assume you have a requirement to be able to archive old employee entities.</target>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source>Old employee entities are rarely queried and should be excluded from any activities that deal with current employees.</source>
          <target state="new">Old employee entities are rarely queried and should be excluded from any activities that deal with current employees.</target>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source>To implement this requirement you store active employees in the <bpt id="p1">**</bpt>Current<ept id="p1">**</ept> table and old employees in the <bpt id="p2">**</bpt>Archive<ept id="p2">**</ept> table.</source>
          <target state="new">To implement this requirement you store active employees in the <bpt id="p1">**</bpt>Current<ept id="p1">**</ept> table and old employees in the <bpt id="p2">**</bpt>Archive<ept id="p2">**</ept> table.</target>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source>Archiving an employee requires you to delete the entity from the <bpt id="p1">**</bpt>Current<ept id="p1">**</ept> table and add the entity to the <bpt id="p2">**</bpt>Archive<ept id="p2">**</ept> table, but you cannot use an EGT to perform these two operations.</source>
          <target state="new">Archiving an employee requires you to delete the entity from the <bpt id="p1">**</bpt>Current<ept id="p1">**</ept> table and add the entity to the <bpt id="p2">**</bpt>Archive<ept id="p2">**</ept> table, but you cannot use an EGT to perform these two operations.</target>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>To avoid the risk that a failure causes an entity to appear in both or neither tables, the archive operation must be eventually consistent.</source>
          <target state="new">To avoid the risk that a failure causes an entity to appear in both or neither tables, the archive operation must be eventually consistent.</target>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>The following sequence diagram outlines the steps in this operation.</source>
          <target state="new">The following sequence diagram outlines the steps in this operation.</target>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>More detail is provided for exception paths in the text following.</source>
          <target state="new">More detail is provided for exception paths in the text following.</target>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>A client initiates the archive operation by placing a message on an Azure queue, in this example to archive employee #456.</source>
          <target state="new">A client initiates the archive operation by placing a message on an Azure queue, in this example to archive employee #456.</target>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>A worker role polls the queue for new messages; when it finds one, it reads the message and leaves a hidden copy on the queue.</source>
          <target state="new">A worker role polls the queue for new messages; when it finds one, it reads the message and leaves a hidden copy on the queue.</target>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>The worker role next fetches a copy of the entity from the <bpt id="p1">**</bpt>Current<ept id="p1">**</ept> table, inserts a copy in the <bpt id="p2">**</bpt>Archive<ept id="p2">**</ept> table, and then deletes the original from the <bpt id="p3">**</bpt>Current<ept id="p3">**</ept> table.</source>
          <target state="new">The worker role next fetches a copy of the entity from the <bpt id="p1">**</bpt>Current<ept id="p1">**</ept> table, inserts a copy in the <bpt id="p2">**</bpt>Archive<ept id="p2">**</ept> table, and then deletes the original from the <bpt id="p3">**</bpt>Current<ept id="p3">**</ept> table.</target>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>Finally, if there were no errors from the previous steps, the worker role deletes the hidden message from the queue.</source>
          <target state="new">Finally, if there were no errors from the previous steps, the worker role deletes the hidden message from the queue.</target>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>In this example, step 4 inserts the employee into the <bpt id="p1">**</bpt>Archive<ept id="p1">**</ept> table.</source>
          <target state="new">In this example, step 4 inserts the employee into the <bpt id="p1">**</bpt>Archive<ept id="p1">**</ept> table.</target>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>It could add the employee to a blob in the Blob service or a file in a file system.</source>
          <target state="new">It could add the employee to a blob in the Blob service or a file in a file system.</target>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>Recovering from failures</source>
          <target state="new">Recovering from failures</target>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>It is important that the operations in steps <bpt id="p1">**</bpt>4<ept id="p1">**</ept> and <bpt id="p2">**</bpt>5<ept id="p2">**</ept> must be <bpt id="p3">*</bpt>idempotent<ept id="p3">*</ept> in case the worker role needs to restart the archive operation.</source>
          <target state="new">It is important that the operations in steps <bpt id="p1">**</bpt>4<ept id="p1">**</ept> and <bpt id="p2">**</bpt>5<ept id="p2">**</ept> must be <bpt id="p3">*</bpt>idempotent<ept id="p3">*</ept> in case the worker role needs to restart the archive operation.</target>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>If you are using the Table service, for step <bpt id="p1">**</bpt>4<ept id="p1">**</ept> you should use an "insert or replace" operation; for step <bpt id="p2">**</bpt>5<ept id="p2">**</ept> you should use a "delete if exists" operation in the client library you are using.</source>
          <target state="new">If you are using the Table service, for step <bpt id="p1">**</bpt>4<ept id="p1">**</ept> you should use an "insert or replace" operation; for step <bpt id="p2">**</bpt>5<ept id="p2">**</ept> you should use a "delete if exists" operation in the client library you are using.</target>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>If you are using another storage system, you must use an appropriate idempotent operation.</source>
          <target state="new">If you are using another storage system, you must use an appropriate idempotent operation.</target>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>If the worker role never completes step <bpt id="p1">**</bpt>6<ept id="p1">**</ept>, then after a timeout the message reappears on the queue ready for the worker role to try to reprocess it.</source>
          <target state="new">If the worker role never completes step <bpt id="p1">**</bpt>6<ept id="p1">**</ept>, then after a timeout the message reappears on the queue ready for the worker role to try to reprocess it.</target>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>The worker role can check how many times a message on the queue has been read and, if necessary, flag it is a "poison" message for investigation by sending it to a separate queue.</source>
          <target state="new">The worker role can check how many times a message on the queue has been read and, if necessary, flag it is a "poison" message for investigation by sending it to a separate queue.</target>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>For more information about reading queue messages and checking the dequeue count, see <bpt id="p1">[</bpt>Get Messages<ept id="p1">](https://msdn.microsoft.com/library/azure/dd179474.aspx)</ept>.</source>
          <target state="new">For more information about reading queue messages and checking the dequeue count, see <bpt id="p1">[</bpt>Get Messages<ept id="p1">](https://msdn.microsoft.com/library/azure/dd179474.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>Some errors from the Table and Queue services are transient errors, and your client application should include suitable retry logic to handle them.</source>
          <target state="new">Some errors from the Table and Queue services are transient errors, and your client application should include suitable retry logic to handle them.</target>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>Issues and considerations</source>
          <target state="new">Issues and considerations</target>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>Consider the following points when deciding how to implement this pattern:</source>
          <target state="new">Consider the following points when deciding how to implement this pattern:</target>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>This solution does not provide for transaction isolation.</source>
          <target state="new">This solution does not provide for transaction isolation.</target>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>For example, a client could read the <bpt id="p1">**</bpt>Current<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Archive<ept id="p2">**</ept> tables when the worker role was between steps <bpt id="p3">**</bpt>4<ept id="p3">**</ept> and <bpt id="p4">**</bpt>5<ept id="p4">**</ept>, and see an inconsistent view of the data.</source>
          <target state="new">For example, a client could read the <bpt id="p1">**</bpt>Current<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Archive<ept id="p2">**</ept> tables when the worker role was between steps <bpt id="p3">**</bpt>4<ept id="p3">**</ept> and <bpt id="p4">**</bpt>5<ept id="p4">**</ept>, and see an inconsistent view of the data.</target>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>Note that the data will be consistent eventually.</source>
          <target state="new">Note that the data will be consistent eventually.</target>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>You must be sure that steps 4 and 5 are idempotent in order to ensure eventual consistency.</source>
          <target state="new">You must be sure that steps 4 and 5 are idempotent in order to ensure eventual consistency.</target>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source>You can scale the solution by using multiple queues and worker role instances.</source>
          <target state="new">You can scale the solution by using multiple queues and worker role instances.</target>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>When to use this pattern</source>
          <target state="new">When to use this pattern</target>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>Use this pattern when you want to guarantee eventual consistency between entities that exist in different partitions or tables.</source>
          <target state="new">Use this pattern when you want to guarantee eventual consistency between entities that exist in different partitions or tables.</target>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>You can extend this pattern to ensure eventual consistency for operations across the Table service and the Blob service and other non-Azure Storage data sources such as database or the file system.</source>
          <target state="new">You can extend this pattern to ensure eventual consistency for operations across the Table service and the Blob service and other non-Azure Storage data sources such as database or the file system.</target>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>Related patterns and guidance</source>
          <target state="new">Related patterns and guidance</target>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>The following patterns and guidance may also be relevant when implementing this pattern:</source>
          <target state="new">The following patterns and guidance may also be relevant when implementing this pattern:</target>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source>Entity Group Transactions</source>
          <target state="new">Entity Group Transactions</target>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>Merge or replace</source>
          <target state="new">Merge or replace</target>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> If transaction isolation is important to your solution, you should consider redesigning your tables to enable you to use EGTs.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> If transaction isolation is important to your solution, you should consider redesigning your tables to enable you to use EGTs.</target>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>Index Entities Pattern</source>
          <target state="new">Index Entities Pattern</target>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>Maintain index entities to enable efficient searches that return lists of entities.</source>
          <target state="new">Maintain index entities to enable efficient searches that return lists of entities.</target>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>Context and problem</source>
          <target state="new">Context and problem</target>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>The Table service automatically indexes entities using the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values.</source>
          <target state="new">The Table service automatically indexes entities using the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values.</target>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>This enables a client application to retrieve an entity efficiently using a point query.</source>
          <target state="new">This enables a client application to retrieve an entity efficiently using a point query.</target>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>For example, using the table structure shown below, a client application can efficiently retrieve an individual employee entity by using the department name and the employee id (the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept>).</source>
          <target state="new">For example, using the table structure shown below, a client application can efficiently retrieve an individual employee entity by using the department name and the employee id (the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept>).</target>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>If you also want to be able to retrieve a list of employee entities based on the value of another non-unique property, such as their last name, you must use a less efficient partition scan to find matches rather than using an index to look them up directly.</source>
          <target state="new">If you also want to be able to retrieve a list of employee entities based on the value of another non-unique property, such as their last name, you must use a less efficient partition scan to find matches rather than using an index to look them up directly.</target>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>This is because the table service does not provide secondary indexes.</source>
          <target state="new">This is because the table service does not provide secondary indexes.</target>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="new">Solution</target>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>To enable lookup by last name with the entity structure shown above, you must maintain lists of employee ids.</source>
          <target state="new">To enable lookup by last name with the entity structure shown above, you must maintain lists of employee ids.</target>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>If you want to retrieve the employee entities with a particular last name, such as Jones, you must first locate the list of employee ids for employees with Jones as their last name, and then retrieve those employee entities.</source>
          <target state="new">If you want to retrieve the employee entities with a particular last name, such as Jones, you must first locate the list of employee ids for employees with Jones as their last name, and then retrieve those employee entities.</target>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>There are three main options for storing the lists of employee ids:</source>
          <target state="new">There are three main options for storing the lists of employee ids:</target>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>Use blob storage.</source>
          <target state="new">Use blob storage.</target>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>Create index entities in the same partition as the employee entities.</source>
          <target state="new">Create index entities in the same partition as the employee entities.</target>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>Create index entities in a separate partition or table.</source>
          <target state="new">Create index entities in a separate partition or table.</target>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>Option #1: Use blob storage</source>
          <target state="new">Option #1: Use blob storage</target>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>For the first option, you create a blob for every unique last name, and in each blob store a list of the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> (department) and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> (employee id) values for employees that have that last name.</source>
          <target state="new">For the first option, you create a blob for every unique last name, and in each blob store a list of the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> (department) and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> (employee id) values for employees that have that last name.</target>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>When you add or delete an employee you should ensure that the content of the relevant blob is eventually consistent with the employee entities.</source>
          <target state="new">When you add or delete an employee you should ensure that the content of the relevant blob is eventually consistent with the employee entities.</target>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>Option #2:</source>
          <target state="new">Option #2:</target>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>Create index entities in the same partition</source>
          <target state="new">Create index entities in the same partition</target>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>For the second option, use index entities that store the following data:</source>
          <target state="new">For the second option, use index entities that store the following data:</target>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>EmployeeIDs<ept id="p1">**</ept> property contains a list of employee ids for employees with the last name stored in the <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept>.</source>
          <target state="new">The <bpt id="p1">**</bpt>EmployeeIDs<ept id="p1">**</ept> property contains a list of employee ids for employees with the last name stored in the <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>The following steps outline the process you should follow when you are adding a new employee if you are using the second option.</source>
          <target state="new">The following steps outline the process you should follow when you are adding a new employee if you are using the second option.</target>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>In this example, we are adding an employee with Id 000152 and a last name Jones in the Sales department:</source>
          <target state="new">In this example, we are adding an employee with Id 000152 and a last name Jones in the Sales department:</target>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>Retrieve the index entity with a <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> value "Sales" and the <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> value "Jones."</source>
          <target state="new">Retrieve the index entity with a <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> value "Sales" and the <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> value "Jones."</target>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>Save the ETag of this entity to use in step 2.</source>
          <target state="new">Save the ETag of this entity to use in step 2.</target>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>Create an entity group transaction (that is, a batch operation) that inserts the new employee entity (<bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> value "Sales" and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> value "000152"), and updates the index entity (<bpt id="p3">**</bpt>PartitionKey<ept id="p3">**</ept> value "Sales" and <bpt id="p4">**</bpt>RowKey<ept id="p4">**</ept> value "Jones") by adding the new employee id to the list in the EmployeeIDs field.</source>
          <target state="new">Create an entity group transaction (that is, a batch operation) that inserts the new employee entity (<bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> value "Sales" and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> value "000152"), and updates the index entity (<bpt id="p3">**</bpt>PartitionKey<ept id="p3">**</ept> value "Sales" and <bpt id="p4">**</bpt>RowKey<ept id="p4">**</ept> value "Jones") by adding the new employee id to the list in the EmployeeIDs field.</target>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>For more information about entity group transactions, see <bpt id="p1">[</bpt>Entity Group Transactions<ept id="p1">](#entity-group-transactions)</ept>.</source>
          <target state="new">For more information about entity group transactions, see <bpt id="p1">[</bpt>Entity Group Transactions<ept id="p1">](#entity-group-transactions)</ept>.</target>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>If the entity group transaction fails because of an optimistic concurrency error (someone else has just modified the index entity), then you need to start over at step 1 again.</source>
          <target state="new">If the entity group transaction fails because of an optimistic concurrency error (someone else has just modified the index entity), then you need to start over at step 1 again.</target>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>You can use a similar approach to deleting an employee if you are using the second option.</source>
          <target state="new">You can use a similar approach to deleting an employee if you are using the second option.</target>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>Changing an employee's last name is slightly more complex because you will need to execute an entity group transaction that updates three entities: the employee entity, the index entity for the old last name, and the index entity for the new last name.</source>
          <target state="new">Changing an employee's last name is slightly more complex because you will need to execute an entity group transaction that updates three entities: the employee entity, the index entity for the old last name, and the index entity for the new last name.</target>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source>You must retrieve each entity before making any changes in order to retrieve the ETag values that you can then use to perform the updates using optimistic concurrency.</source>
          <target state="new">You must retrieve each entity before making any changes in order to retrieve the ETag values that you can then use to perform the updates using optimistic concurrency.</target>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>The following steps outline the process you should follow when you need to look up all the employees with a given last name in a department if you are using the second option.</source>
          <target state="new">The following steps outline the process you should follow when you need to look up all the employees with a given last name in a department if you are using the second option.</target>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>In this example, we are looking up all the employees with last name Jones in the Sales department:</source>
          <target state="new">In this example, we are looking up all the employees with last name Jones in the Sales department:</target>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>Retrieve the index entity with a <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> value "Sales" and the <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> value "Jones."</source>
          <target state="new">Retrieve the index entity with a <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> value "Sales" and the <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> value "Jones."</target>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>Parse the list of employee Ids in the EmployeeIDs field.</source>
          <target state="new">Parse the list of employee Ids in the EmployeeIDs field.</target>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source>If you need additional information about each of these employees (such as their email addresses), retrieve each of the employee entities using <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> value "Sales" and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values from the list of employees you obtained in step 2.</source>
          <target state="new">If you need additional information about each of these employees (such as their email addresses), retrieve each of the employee entities using <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> value "Sales" and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> values from the list of employees you obtained in step 2.</target>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>Option #3:</source>
          <target state="new">Option #3:</target>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>Create index entities in a separate partition or table</source>
          <target state="new">Create index entities in a separate partition or table</target>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>For the third option, use index entities that store the following data:</source>
          <target state="new">For the third option, use index entities that store the following data:</target>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>EmployeeIDs<ept id="p1">**</ept> property contains a list of employee ids for employees with the last name stored in the <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept>.</source>
          <target state="new">The <bpt id="p1">**</bpt>EmployeeIDs<ept id="p1">**</ept> property contains a list of employee ids for employees with the last name stored in the <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>With the third option, you cannot use EGTs to maintain consistency because the index entities are in a separate partition from the employee entities.</source>
          <target state="new">With the third option, you cannot use EGTs to maintain consistency because the index entities are in a separate partition from the employee entities.</target>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve">
          <source>You should ensure that the index entities are eventually consistent with the employee entities.</source>
          <target state="new">You should ensure that the index entities are eventually consistent with the employee entities.</target>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>Issues and considerations</source>
          <target state="new">Issues and considerations</target>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>Consider the following points when deciding how to implement this pattern:</source>
          <target state="new">Consider the following points when deciding how to implement this pattern:</target>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>This solution requires at least two queries to retrieve matching entities: one to query the index entities to obtain the list of <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> values, and then queries to retrieve each entity in the list.</source>
          <target state="new">This solution requires at least two queries to retrieve matching entities: one to query the index entities to obtain the list of <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> values, and then queries to retrieve each entity in the list.</target>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>Given that an individual entity has a maximum size of 1 MB, option #2 and option #3 in the solution assume that the list of employee ids for any given last name is never greater than 1 MB.</source>
          <target state="new">Given that an individual entity has a maximum size of 1 MB, option #2 and option #3 in the solution assume that the list of employee ids for any given last name is never greater than 1 MB.</target>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source>If the list of employee ids is likely to be greater than 1 MB in size, use option #1 and store the index data in blob storage.</source>
          <target state="new">If the list of employee ids is likely to be greater than 1 MB in size, use option #1 and store the index data in blob storage.</target>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source>If you use option #2 (using EGTs to handle adding and deleting employees, and changing an employees last name) you must evaluate if the volume of transactions will approach the scalability limits in a given partition.</source>
          <target state="new">If you use option #2 (using EGTs to handle adding and deleting employees, and changing an employees last name) you must evaluate if the volume of transactions will approach the scalability limits in a given partition.</target>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source>If this is the case, you should consider an eventually consistent solution (option #1 or option #3) that uses queues to handle the update requests and enables you to store your index entities in a separate partition from the employee entities.</source>
          <target state="new">If this is the case, you should consider an eventually consistent solution (option #1 or option #3) that uses queues to handle the update requests and enables you to store your index entities in a separate partition from the employee entities.</target>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>Option #2 in this solution assumes that you want to look up by last name within a department: for example, you want to retrieve a list of employees with a last name Jones in the Sales department.</source>
          <target state="new">Option #2 in this solution assumes that you want to look up by last name within a department: for example, you want to retrieve a list of employees with a last name Jones in the Sales department.</target>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>If you want to be able to look up all the employees with a last name Jones across the whole organization, use either option #1 or option #3.</source>
          <target state="new">If you want to be able to look up all the employees with a last name Jones across the whole organization, use either option #1 or option #3.</target>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>You can implement a queue-based solution that delivers eventual consistency (see the <bpt id="p1">[</bpt>Eventually consistent transactions pattern<ept id="p1">](#eventually-consistent-transactions-pattern)</ept> for more details).</source>
          <target state="new">You can implement a queue-based solution that delivers eventual consistency (see the <bpt id="p1">[</bpt>Eventually consistent transactions pattern<ept id="p1">](#eventually-consistent-transactions-pattern)</ept> for more details).</target>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source>When to use this pattern</source>
          <target state="new">When to use this pattern</target>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source>Use this pattern when you want to lookup a set of entities that all share a common property value, such as all employees with the last name Jones.</source>
          <target state="new">Use this pattern when you want to lookup a set of entities that all share a common property value, such as all employees with the last name Jones.</target>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source>Related patterns and guidance</source>
          <target state="new">Related patterns and guidance</target>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source>The following patterns and guidance may also be relevant when implementing this pattern:</source>
          <target state="new">The following patterns and guidance may also be relevant when implementing this pattern:</target>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source>Compound key pattern</source>
          <target state="new">Compound key pattern</target>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source>Eventually consistent transactions pattern</source>
          <target state="new">Eventually consistent transactions pattern</target>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source>Entity Group Transactions</source>
          <target state="new">Entity Group Transactions</target>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>Working with heterogeneous entity types</source>
          <target state="new">Working with heterogeneous entity types</target>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>Denormalization pattern</source>
          <target state="new">Denormalization pattern</target>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>Combine related data together in a single entity to enable you to retrieve all the data you need with a single point query.</source>
          <target state="new">Combine related data together in a single entity to enable you to retrieve all the data you need with a single point query.</target>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>Context and problem</source>
          <target state="new">Context and problem</target>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>In a relational database, you typically normalize data to remove duplication resulting in queries that retrieve data from multiple tables.</source>
          <target state="new">In a relational database, you typically normalize data to remove duplication resulting in queries that retrieve data from multiple tables.</target>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source>If you normalize your data in Azure tables, you must make multiple round trips from the client to the server to retrieve your related data.</source>
          <target state="new">If you normalize your data in Azure tables, you must make multiple round trips from the client to the server to retrieve your related data.</target>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source>For example, with the table structure shown below you need two round trips to retrieve the details for a department: one to fetch the department entity that includes the managers id, and then another request to fetch the managers details in an employee entity.</source>
          <target state="new">For example, with the table structure shown below you need two round trips to retrieve the details for a department: one to fetch the department entity that includes the managers id, and then another request to fetch the managers details in an employee entity.</target>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="new">Solution</target>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>Instead of storing the data in two separate entities, denormalize the data and keep a copy of the managers details in the department entity.</source>
          <target state="new">Instead of storing the data in two separate entities, denormalize the data and keep a copy of the managers details in the department entity.</target>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="new">For example:</target>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>With department entities stored with these properties, you can now retrieve all the details you need about a department using a point query.</source>
          <target state="new">With department entities stored with these properties, you can now retrieve all the details you need about a department using a point query.</target>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>Issues and considerations</source>
          <target state="new">Issues and considerations</target>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>Consider the following points when deciding how to implement this pattern:</source>
          <target state="new">Consider the following points when deciding how to implement this pattern:</target>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>There is some cost overhead associated with storing some data twice.</source>
          <target state="new">There is some cost overhead associated with storing some data twice.</target>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source>The performance benefit (resulting from fewer requests to the storage service) typically outweighs the marginal increase in storage costs (and this cost is partially offset by a reduction in the number of transactions you require to fetch the details of a department).</source>
          <target state="new">The performance benefit (resulting from fewer requests to the storage service) typically outweighs the marginal increase in storage costs (and this cost is partially offset by a reduction in the number of transactions you require to fetch the details of a department).</target>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>You must maintain the consistency of the two entities that store information about managers.</source>
          <target state="new">You must maintain the consistency of the two entities that store information about managers.</target>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>You can handle the consistency issue by using EGTs to update multiple entities in a single atomic transaction: in this case, the department entity, and the employee entity for the department manager are stored in the same partition.</source>
          <target state="new">You can handle the consistency issue by using EGTs to update multiple entities in a single atomic transaction: in this case, the department entity, and the employee entity for the department manager are stored in the same partition.</target>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>When to use this pattern</source>
          <target state="new">When to use this pattern</target>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>Use this pattern when you frequently need to look up related information.</source>
          <target state="new">Use this pattern when you frequently need to look up related information.</target>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source>This pattern reduces the number of queries your client must make to retrieve the data it requires.</source>
          <target state="new">This pattern reduces the number of queries your client must make to retrieve the data it requires.</target>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source>Related patterns and guidance</source>
          <target state="new">Related patterns and guidance</target>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>The following patterns and guidance may also be relevant when implementing this pattern:</source>
          <target state="new">The following patterns and guidance may also be relevant when implementing this pattern:</target>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source>Compound key pattern</source>
          <target state="new">Compound key pattern</target>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>Entity Group Transactions</source>
          <target state="new">Entity Group Transactions</target>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve">
          <source>Working with heterogeneous entity types</source>
          <target state="new">Working with heterogeneous entity types</target>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve">
          <source>Compound key pattern</source>
          <target state="new">Compound key pattern</target>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>Use compound <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> values to enable a client to lookup related data with a single point query.</source>
          <target state="new">Use compound <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> values to enable a client to lookup related data with a single point query.</target>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>Context and problem</source>
          <target state="new">Context and problem</target>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>In a relational database, it is quite natural to use joins in queries to return related pieces of data to the client in a single query.</source>
          <target state="new">In a relational database, it is quite natural to use joins in queries to return related pieces of data to the client in a single query.</target>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>For example, you might use the employee id to look up a list of related entities that contain performance and review data for that employee.</source>
          <target state="new">For example, you might use the employee id to look up a list of related entities that contain performance and review data for that employee.</target>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>Assume you are storing employee entities in the Table service using the following structure:</source>
          <target state="new">Assume you are storing employee entities in the Table service using the following structure:</target>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve">
          <source>You also need to store historical data relating to reviews and performance for each year the employee has worked for your organization and you need to be able to access this information by year.</source>
          <target state="new">You also need to store historical data relating to reviews and performance for each year the employee has worked for your organization and you need to be able to access this information by year.</target>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve">
          <source>One option is to create another table that stores entities with the following structure:</source>
          <target state="new">One option is to create another table that stores entities with the following structure:</target>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve">
          <source>Notice that with this approach you may decide to duplicate some information (such as first name and last name) in the new entity to enable you to retrieve your data with a single request.</source>
          <target state="new">Notice that with this approach you may decide to duplicate some information (such as first name and last name) in the new entity to enable you to retrieve your data with a single request.</target>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve">
          <source>However, you cannot maintain strong consistency because you cannot use an EGT to update the two entities atomically.</source>
          <target state="new">However, you cannot maintain strong consistency because you cannot use an EGT to update the two entities atomically.</target>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="new">Solution</target>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve">
          <source>Store a new entity type in your original table using entities with the following structure:</source>
          <target state="new">Store a new entity type in your original table using entities with the following structure:</target>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve">
          <source>Notice how the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> is now a compound key made up of the employee id and the year of the review data that enables you to retrieve the employees performance and review data with a single request for a single entity.</source>
          <target state="new">Notice how the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> is now a compound key made up of the employee id and the year of the review data that enables you to retrieve the employees performance and review data with a single request for a single entity.</target>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>The following example outlines how you can retrieve all the review data for a particular employee (such as employee 000123 in the Sales department):</source>
          <target state="new">The following example outlines how you can retrieve all the review data for a particular employee (such as employee 000123 in the Sales department):</target>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000123') and (RowKey lt 'empid_000124')&amp;$select=RowKey,Manager Rating,Peer Rating,Comments</source>
          <target state="new">$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000123') and (RowKey lt 'empid_000124')&amp;$select=RowKey,Manager Rating,Peer Rating,Comments</target>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>Issues and considerations</source>
          <target state="new">Issues and considerations</target>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>Consider the following points when deciding how to implement this pattern:</source>
          <target state="new">Consider the following points when deciding how to implement this pattern:</target>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>You should use a suitable separator character that makes it easy to parse the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> value: for example, <bpt id="p2">**</bpt>000123_2012<ept id="p2">**</ept>.</source>
          <target state="new">You should use a suitable separator character that makes it easy to parse the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> value: for example, <bpt id="p2">**</bpt>000123_2012<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source>You are also storing this entity in the same partition as other entities that contain related data for the same employee, which means you can use EGTs to maintain strong consistency.</source>
          <target state="new">You are also storing this entity in the same partition as other entities that contain related data for the same employee, which means you can use EGTs to maintain strong consistency.</target>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>You should consider how frequently you will query the data to determine whether this pattern is appropriate.</source>
          <target state="new">You should consider how frequently you will query the data to determine whether this pattern is appropriate.</target>
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source>For example, if you will access the review data infrequently and the main employee data often you should keep them as separate entities.</source>
          <target state="new">For example, if you will access the review data infrequently and the main employee data often you should keep them as separate entities.</target>
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>When to use this pattern</source>
          <target state="new">When to use this pattern</target>
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>Use this pattern when you need to store one or more related entities that you query frequently.</source>
          <target state="new">Use this pattern when you need to store one or more related entities that you query frequently.</target>
        </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>Related patterns and guidance</source>
          <target state="new">Related patterns and guidance</target>
        </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve">
          <source>The following patterns and guidance may also be relevant when implementing this pattern:</source>
          <target state="new">The following patterns and guidance may also be relevant when implementing this pattern:</target>
        </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source>Entity Group Transactions</source>
          <target state="new">Entity Group Transactions</target>
        </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve">
          <source>Working with heterogeneous entity types</source>
          <target state="new">Working with heterogeneous entity types</target>
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>Eventually consistent transactions pattern</source>
          <target state="new">Eventually consistent transactions pattern</target>
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source>Log tail pattern</source>
          <target state="new">Log tail pattern</target>
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source>Retrieve the <bpt id="p1">*</bpt>n<ept id="p1">*</ept> entities most recently added to a partition by using a <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> value that sorts in reverse date and time order.</source>
          <target state="new">Retrieve the <bpt id="p1">*</bpt>n<ept id="p1">*</ept> entities most recently added to a partition by using a <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> value that sorts in reverse date and time order.</target>
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve">
          <source>Context and problem</source>
          <target state="new">Context and problem</target>
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source>A common requirement is be able to retrieve the most recently created entities, for example the ten most recent expense claims submitted by an employee.</source>
          <target state="new">A common requirement is be able to retrieve the most recently created entities, for example the ten most recent expense claims submitted by an employee.</target>
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve">
          <source>Table queries support a <bpt id="p1">**</bpt>$top<ept id="p1">**</ept> query operation to return the first <bpt id="p2">*</bpt>n<ept id="p2">*</ept> entities from a set: there is no equivalent query operation to return the last n entities in a set.</source>
          <target state="new">Table queries support a <bpt id="p1">**</bpt>$top<ept id="p1">**</ept> query operation to return the first <bpt id="p2">*</bpt>n<ept id="p2">*</ept> entities from a set: there is no equivalent query operation to return the last n entities in a set.</target>
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="new">Solution</target>
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve">
          <source>Store the entities using a <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> that naturally sorts in reverse date/time order by using so the most recent entry is always the first one in the table.</source>
          <target state="new">Store the entities using a <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> that naturally sorts in reverse date/time order by using so the most recent entry is always the first one in the table.</target>
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>For example, to be able to retrieve the ten most recent expense claims submitted by an employee, you can use a reverse tick value derived from the current date/time.</source>
          <target state="new">For example, to be able to retrieve the ten most recent expense claims submitted by an employee, you can use a reverse tick value derived from the current date/time.</target>
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source>The following C# code sample shows one way to create a suitable "inverted ticks" value for a <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> that sorts from the most recent to the oldest:</source>
          <target state="new">The following C# code sample shows one way to create a suitable "inverted ticks" value for a <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> that sorts from the most recent to the oldest:</target>
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source>You can get back to the date time value using the following code:</source>
          <target state="new">You can get back to the date time value using the following code:</target>
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>The table query looks like this:</source>
          <target state="new">The table query looks like this:</target>
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source>Issues and considerations</source>
          <target state="new">Issues and considerations</target>
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve">
          <source>Consider the following points when deciding how to implement this pattern:</source>
          <target state="new">Consider the following points when deciding how to implement this pattern:</target>
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve">
          <source>You must pad the reverse tick value with leading zeroes to ensure the string value sorts as expected.</source>
          <target state="new">You must pad the reverse tick value with leading zeroes to ensure the string value sorts as expected.</target>
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve">
          <source>You must be aware of the scalability targets at the level of a partition.</source>
          <target state="new">You must be aware of the scalability targets at the level of a partition.</target>
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve">
          <source>Be careful not create hot spot partitions.</source>
          <target state="new">Be careful not create hot spot partitions.</target>
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve">
          <source>When to use this pattern</source>
          <target state="new">When to use this pattern</target>
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve">
          <source>Use this pattern when you need to access entities in reverse date/time order or when you need to access the most recently added entities.</source>
          <target state="new">Use this pattern when you need to access entities in reverse date/time order or when you need to access the most recently added entities.</target>
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve">
          <source>Related patterns and guidance</source>
          <target state="new">Related patterns and guidance</target>
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve">
          <source>The following patterns and guidance may also be relevant when implementing this pattern:</source>
          <target state="new">The following patterns and guidance may also be relevant when implementing this pattern:</target>
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve">
          <source>Prepend / append anti-pattern</source>
          <target state="new">Prepend / append anti-pattern</target>
        </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve">
          <source>Retrieving entities</source>
          <target state="new">Retrieving entities</target>
        </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve">
          <source>High volume delete pattern</source>
          <target state="new">High volume delete pattern</target>
        </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve">
          <source>Enable the deletion of a high volume of entities by storing all the entities for simultaneous deletion in their own separate table; you delete the entities by deleting the table.</source>
          <target state="new">Enable the deletion of a high volume of entities by storing all the entities for simultaneous deletion in their own separate table; you delete the entities by deleting the table.</target>
        </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve">
          <source>Context and problem</source>
          <target state="new">Context and problem</target>
        </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve">
          <source>Many applications delete old data which no longer needs to be available to a client application, or that the application has archived to another storage medium.</source>
          <target state="new">Many applications delete old data which no longer needs to be available to a client application, or that the application has archived to another storage medium.</target>
        </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve">
          <source>You typically identify such data by a date: for example, you have a requirement to delete records of all login requests that are more than 60 days old.</source>
          <target state="new">You typically identify such data by a date: for example, you have a requirement to delete records of all login requests that are more than 60 days old.</target>
        </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve">
          <source>One possible design is to use the date and time of the login request in the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept>:</source>
          <target state="new">One possible design is to use the date and time of the login request in the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept>:</target>
        </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve">
          <source>This approach avoids partition hotspots because the application can insert and delete login entities for each user in a separate partition.</source>
          <target state="new">This approach avoids partition hotspots because the application can insert and delete login entities for each user in a separate partition.</target>
        </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve">
          <source>However, this approach may be costly and time consuming if you have a large number of entities because first you need to perform a table scan in order to identify all the entities to delete, and then you must delete each old entity.</source>
          <target state="new">However, this approach may be costly and time consuming if you have a large number of entities because first you need to perform a table scan in order to identify all the entities to delete, and then you must delete each old entity.</target>
        </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve">
          <source>Note that you can reduce the number of round trips to the server required to delete the old entities by batching multiple delete requests into EGTs.</source>
          <target state="new">Note that you can reduce the number of round trips to the server required to delete the old entities by batching multiple delete requests into EGTs.</target>
        </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="new">Solution</target>
        </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve">
          <source>Use a separate table for each day of login attempts.</source>
          <target state="new">Use a separate table for each day of login attempts.</target>
        </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve">
          <source>You can use the entity design above to avoid hotspots when you are inserting entities, and deleting old entities is now simply a question of deleting one table every day (a single storage operation) instead of finding and deleting hundreds and thousands of individual login entities every day.</source>
          <target state="new">You can use the entity design above to avoid hotspots when you are inserting entities, and deleting old entities is now simply a question of deleting one table every day (a single storage operation) instead of finding and deleting hundreds and thousands of individual login entities every day.</target>
        </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve">
          <source>Issues and considerations</source>
          <target state="new">Issues and considerations</target>
        </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve">
          <source>Consider the following points when deciding how to implement this pattern:</source>
          <target state="new">Consider the following points when deciding how to implement this pattern:</target>
        </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve">
          <source>Does your design support other ways your application will use the data such as looking up specific entities, linking with other data, or generating aggregate information?</source>
          <target state="new">Does your design support other ways your application will use the data such as looking up specific entities, linking with other data, or generating aggregate information?</target>
        </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve">
          <source>Does your design avoid hot spots when you are inserting new entities?</source>
          <target state="new">Does your design avoid hot spots when you are inserting new entities?</target>
        </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve">
          <source>Expect a delay if you want to reuse the same table name after deleting it.</source>
          <target state="new">Expect a delay if you want to reuse the same table name after deleting it.</target>
        </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve">
          <source>It's better to always use unique table names.</source>
          <target state="new">It's better to always use unique table names.</target>
        </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve">
          <source>Expect some throttling when you first use a new table while the Table service learns the access patterns and distributes the partitions across nodes.</source>
          <target state="new">Expect some throttling when you first use a new table while the Table service learns the access patterns and distributes the partitions across nodes.</target>
        </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve">
          <source>You should consider how frequently you need to create new tables.</source>
          <target state="new">You should consider how frequently you need to create new tables.</target>
        </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve">
          <source>When to use this pattern</source>
          <target state="new">When to use this pattern</target>
        </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve">
          <source>Use this pattern when you have a high volume of entities that you must delete at the same time.</source>
          <target state="new">Use this pattern when you have a high volume of entities that you must delete at the same time.</target>
        </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve">
          <source>Related patterns and guidance</source>
          <target state="new">Related patterns and guidance</target>
        </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve">
          <source>The following patterns and guidance may also be relevant when implementing this pattern:</source>
          <target state="new">The following patterns and guidance may also be relevant when implementing this pattern:</target>
        </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve">
          <source>Entity Group Transactions</source>
          <target state="new">Entity Group Transactions</target>
        </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve">
          <source>Modifying entities</source>
          <target state="new">Modifying entities</target>
        </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve">
          <source>Data series pattern</source>
          <target state="new">Data series pattern</target>
        </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source>Store complete data series in a single entity to minimize the number of requests you make.</source>
          <target state="new">Store complete data series in a single entity to minimize the number of requests you make.</target>
        </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve">
          <source>Context and problem</source>
          <target state="new">Context and problem</target>
        </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve">
          <source>A common scenario is for an application to store a series of data that it typically needs to retrieve all at once.</source>
          <target state="new">A common scenario is for an application to store a series of data that it typically needs to retrieve all at once.</target>
        </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve">
          <source>For example, your application might record how many IM messages each employee sends every hour, and then use this information to plot how many messages each user sent over the preceding 24 hours.</source>
          <target state="new">For example, your application might record how many IM messages each employee sends every hour, and then use this information to plot how many messages each user sent over the preceding 24 hours.</target>
        </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve">
          <source>One design might be to store 24 entities for each employee:</source>
          <target state="new">One design might be to store 24 entities for each employee:</target>
        </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve">
          <source>With this design, you can easily locate and update the entity to update for each employee whenever the application needs to update the message count value.</source>
          <target state="new">With this design, you can easily locate and update the entity to update for each employee whenever the application needs to update the message count value.</target>
        </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve">
          <source>However, to retrieve the information to plot a chart of the activity for the preceding 24 hours, you must retrieve 24 entities.</source>
          <target state="new">However, to retrieve the information to plot a chart of the activity for the preceding 24 hours, you must retrieve 24 entities.</target>
        </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="new">Solution</target>
        </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve">
          <source>Use the following design with a separate property to store the message count for each hour:</source>
          <target state="new">Use the following design with a separate property to store the message count for each hour:</target>
        </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve">
          <source>With this design, you can use a merge operation to update the message count for an employee for a specific hour.</source>
          <target state="new">With this design, you can use a merge operation to update the message count for an employee for a specific hour.</target>
        </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve">
          <source>Now, you can retrieve all the information you need to plot the chart using a request for a single entity.</source>
          <target state="new">Now, you can retrieve all the information you need to plot the chart using a request for a single entity.</target>
        </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve">
          <source>Issues and considerations</source>
          <target state="new">Issues and considerations</target>
        </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source>Consider the following points when deciding how to implement this pattern:</source>
          <target state="new">Consider the following points when deciding how to implement this pattern:</target>
        </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve">
          <source>If your complete data series does not fit into a single entity (an entity can have up to 252 properties), use an alternative data store such as a blob.</source>
          <target state="new">If your complete data series does not fit into a single entity (an entity can have up to 252 properties), use an alternative data store such as a blob.</target>
        </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source>If you have multiple clients updating an entity simultaneously, you will need to use the <bpt id="p1">**</bpt>ETag<ept id="p1">**</ept> to implement optimistic concurrency.</source>
          <target state="new">If you have multiple clients updating an entity simultaneously, you will need to use the <bpt id="p1">**</bpt>ETag<ept id="p1">**</ept> to implement optimistic concurrency.</target>
        </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source>If you have many clients, you may experience high contention.</source>
          <target state="new">If you have many clients, you may experience high contention.</target>
        </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve">
          <source>When to use this pattern</source>
          <target state="new">When to use this pattern</target>
        </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve">
          <source>Use this pattern when you need to update and retrieve a data series associated with an individual entity.</source>
          <target state="new">Use this pattern when you need to update and retrieve a data series associated with an individual entity.</target>
        </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve">
          <source>Related patterns and guidance</source>
          <target state="new">Related patterns and guidance</target>
        </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve">
          <source>The following patterns and guidance may also be relevant when implementing this pattern:</source>
          <target state="new">The following patterns and guidance may also be relevant when implementing this pattern:</target>
        </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve">
          <source>Large entity pattern</source>
          <target state="new">Large entity pattern</target>
        </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve">
          <source>Merge or replace</source>
          <target state="new">Merge or replace</target>
        </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Eventually consistent transactions pattern<ept id="p1">](#eventually-consistent-transactions-pattern)</ept> (if you are storing the data series in a blob)</source>
          <target state="new"><bpt id="p1">[</bpt>Eventually consistent transactions pattern<ept id="p1">](#eventually-consistent-transactions-pattern)</ept> (if you are storing the data series in a blob)</target>
        </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve">
          <source>Wide entities pattern</source>
          <target state="new">Wide entities pattern</target>
        </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve">
          <source>Use multiple physical entities to store logical entities with more than 252 properties.</source>
          <target state="new">Use multiple physical entities to store logical entities with more than 252 properties.</target>
        </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve">
          <source>Context and problem</source>
          <target state="new">Context and problem</target>
        </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve">
          <source>An individual entity can have no more than 252 properties (excluding the mandatory system properties) and cannot store more than 1 MB of data in total.</source>
          <target state="new">An individual entity can have no more than 252 properties (excluding the mandatory system properties) and cannot store more than 1 MB of data in total.</target>
        </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve">
          <source>In a relational database, you would typically get round any limits on the size of a row by adding a new table and enforcing a 1-to-1 relationship between them.</source>
          <target state="new">In a relational database, you would typically get round any limits on the size of a row by adding a new table and enforcing a 1-to-1 relationship between them.</target>
        </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="new">Solution</target>
        </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve">
          <source>Using the Table service, you can store multiple entities to represent a single large business object with more than 252 properties.</source>
          <target state="new">Using the Table service, you can store multiple entities to represent a single large business object with more than 252 properties.</target>
        </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve">
          <source>For example, if you want to store a count of the number of IM messages sent by each employee for the last 365 days, you could use the following design that uses two entities with different schemas:</source>
          <target state="new">For example, if you want to store a count of the number of IM messages sent by each employee for the last 365 days, you could use the following design that uses two entities with different schemas:</target>
        </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve">
          <source>If you need to make a change that requires updating both entities to keep them synchronized with each other you can use an EGT.</source>
          <target state="new">If you need to make a change that requires updating both entities to keep them synchronized with each other you can use an EGT.</target>
        </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve">
          <source>Otherwise, you can use a single merge operation to update the message count for a specific day.</source>
          <target state="new">Otherwise, you can use a single merge operation to update the message count for a specific day.</target>
        </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve">
          <source>To retrieve all the data for an individual employee you must retrieve both entities, which you can do with two efficient requests that use both a <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and a <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> value.</source>
          <target state="new">To retrieve all the data for an individual employee you must retrieve both entities, which you can do with two efficient requests that use both a <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and a <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> value.</target>
        </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve">
          <source>Issues and considerations</source>
          <target state="new">Issues and considerations</target>
        </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve">
          <source>Consider the following points when deciding how to implement this pattern:</source>
          <target state="new">Consider the following points when deciding how to implement this pattern:</target>
        </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve">
          <source>Retrieving a complete logical entity involves at least two storage transactions: one to retrieve each physical entity.</source>
          <target state="new">Retrieving a complete logical entity involves at least two storage transactions: one to retrieve each physical entity.</target>
        </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve">
          <source>When to use this pattern</source>
          <target state="new">When to use this pattern</target>
        </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve">
          <source>Use this pattern when  need to store entities whose size or number of properties exceeds the limits for an individual entity in the Table service.</source>
          <target state="new">Use this pattern when  need to store entities whose size or number of properties exceeds the limits for an individual entity in the Table service.</target>
        </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve">
          <source>Related patterns and guidance</source>
          <target state="new">Related patterns and guidance</target>
        </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source>The following patterns and guidance may also be relevant when implementing this pattern:</source>
          <target state="new">The following patterns and guidance may also be relevant when implementing this pattern:</target>
        </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source>Entity Group Transactions</source>
          <target state="new">Entity Group Transactions</target>
        </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve">
          <source>Merge or replace</source>
          <target state="new">Merge or replace</target>
        </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve">
          <source>Large entities pattern</source>
          <target state="new">Large entities pattern</target>
        </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve">
          <source>Use blob storage to store large property values.</source>
          <target state="new">Use blob storage to store large property values.</target>
        </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve">
          <source>Context and problem</source>
          <target state="new">Context and problem</target>
        </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve">
          <source>An individual entity cannot store more than 1 MB of data in total.</source>
          <target state="new">An individual entity cannot store more than 1 MB of data in total.</target>
        </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve">
          <source>If one or several of your properties store values that cause the total size of your entity to exceed this value, you cannot store the entire entity in the Table service.</source>
          <target state="new">If one or several of your properties store values that cause the total size of your entity to exceed this value, you cannot store the entire entity in the Table service.</target>
        </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="new">Solution</target>
        </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve">
          <source>If your entity exceeds 1 MB in size because one or more properties contain a large amount of data, you can store data in the Blob service and then store the address of the blob in a property in the entity.</source>
          <target state="new">If your entity exceeds 1 MB in size because one or more properties contain a large amount of data, you can store data in the Blob service and then store the address of the blob in a property in the entity.</target>
        </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve">
          <source>For example, you can store the photo of an employee in blob storage and store a link to the photo in the <bpt id="p1">**</bpt>Photo<ept id="p1">**</ept> property of your employee entity:</source>
          <target state="new">For example, you can store the photo of an employee in blob storage and store a link to the photo in the <bpt id="p1">**</bpt>Photo<ept id="p1">**</ept> property of your employee entity:</target>
        </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve">
          <source>Issues and considerations</source>
          <target state="new">Issues and considerations</target>
        </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve">
          <source>Consider the following points when deciding how to implement this pattern:</source>
          <target state="new">Consider the following points when deciding how to implement this pattern:</target>
        </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve">
          <source>To maintain eventual consistency between the entity in the Table service and the data in the Blob service, use the <bpt id="p1">[</bpt>Eventually consistent transactions pattern<ept id="p1">](#eventually-consistent-transactions-pattern)</ept> to maintain your entities.</source>
          <target state="new">To maintain eventual consistency between the entity in the Table service and the data in the Blob service, use the <bpt id="p1">[</bpt>Eventually consistent transactions pattern<ept id="p1">](#eventually-consistent-transactions-pattern)</ept> to maintain your entities.</target>
        </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve">
          <source>Retrieving a complete entity involves at least two storage transactions: one to retrieve the entity and one to retrieve the blob data.</source>
          <target state="new">Retrieving a complete entity involves at least two storage transactions: one to retrieve the entity and one to retrieve the blob data.</target>
        </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve">
          <source>When to use this pattern</source>
          <target state="new">When to use this pattern</target>
        </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve">
          <source>Use this pattern when you need to store entities whose size exceeds the limits for an individual entity in the Table service.</source>
          <target state="new">Use this pattern when you need to store entities whose size exceeds the limits for an individual entity in the Table service.</target>
        </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve">
          <source>Related patterns and guidance</source>
          <target state="new">Related patterns and guidance</target>
        </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve">
          <source>The following patterns and guidance may also be relevant when implementing this pattern:</source>
          <target state="new">The following patterns and guidance may also be relevant when implementing this pattern:</target>
        </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve">
          <source>Eventually consistent transactions pattern</source>
          <target state="new">Eventually consistent transactions pattern</target>
        </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve">
          <source>Wide entities pattern</source>
          <target state="new">Wide entities pattern</target>
        </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve">
          <source>Prepend/append anti-pattern</source>
          <target state="new">Prepend/append anti-pattern</target>
        </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve">
          <source>Increase scalability when you have a high volume of inserts by spreading the inserts across multiple partitions.</source>
          <target state="new">Increase scalability when you have a high volume of inserts by spreading the inserts across multiple partitions.</target>
        </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve">
          <source>Context and problem</source>
          <target state="new">Context and problem</target>
        </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve">
          <source>Prepending or appending entities to your stored entities typically results in the application adding new entities to the first or last partition of a sequence of partitions.</source>
          <target state="new">Prepending or appending entities to your stored entities typically results in the application adding new entities to the first or last partition of a sequence of partitions.</target>
        </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve">
          <source>In this case, all of the inserts at any given time are taking place in the same partition, creating a hotspot that prevents the table service from load balancing inserts across multiple nodes, and possibly causing your application to hit the scalability targets for partition.</source>
          <target state="new">In this case, all of the inserts at any given time are taking place in the same partition, creating a hotspot that prevents the table service from load balancing inserts across multiple nodes, and possibly causing your application to hit the scalability targets for partition.</target>
        </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve">
          <source>For example, if you have an application that logs network and resource access by employees, then an entity structure as shown below could result in the current hours partition becoming a hotspot if the volume of transactions reaches the scalability target for an individual partition:</source>
          <target state="new">For example, if you have an application that logs network and resource access by employees, then an entity structure as shown below could result in the current hours partition becoming a hotspot if the volume of transactions reaches the scalability target for an individual partition:</target>
        </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="new">Solution</target>
        </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve">
          <source>The following alternative entity structure avoids a hotspot on any particular partition as the application logs events:</source>
          <target state="new">The following alternative entity structure avoids a hotspot on any particular partition as the application logs events:</target>
        </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve">
          <source>Notice with this example how both the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> are compound keys.</source>
          <target state="new">Notice with this example how both the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> are compound keys.</target>
        </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> uses both the department and employee id to distribute the logging across multiple partitions.</source>
          <target state="new">The <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> uses both the department and employee id to distribute the logging across multiple partitions.</target>
        </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve">
          <source>Issues and considerations</source>
          <target state="new">Issues and considerations</target>
        </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve">
          <source>Consider the following points when deciding how to implement this pattern:</source>
          <target state="new">Consider the following points when deciding how to implement this pattern:</target>
        </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve">
          <source>Does the alternative key structure that avoids creating hot partitions on inserts efficiently support the queries your client application makes?</source>
          <target state="new">Does the alternative key structure that avoids creating hot partitions on inserts efficiently support the queries your client application makes?</target>
        </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve">
          <source>Does your anticipated volume of transactions mean that you are likely to reach the scalability targets for an individual partition and be throttled by the storage service?</source>
          <target state="new">Does your anticipated volume of transactions mean that you are likely to reach the scalability targets for an individual partition and be throttled by the storage service?</target>
        </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve">
          <source>When to use this pattern</source>
          <target state="new">When to use this pattern</target>
        </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve">
          <source>Avoid the prepend/append anti-pattern when your volume of transactions is likely to result in throttling by the storage service when you access a hot partition.</source>
          <target state="new">Avoid the prepend/append anti-pattern when your volume of transactions is likely to result in throttling by the storage service when you access a hot partition.</target>
        </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve">
          <source>Related patterns and guidance</source>
          <target state="new">Related patterns and guidance</target>
        </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve">
          <source>The following patterns and guidance may also be relevant when implementing this pattern:</source>
          <target state="new">The following patterns and guidance may also be relevant when implementing this pattern:</target>
        </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve">
          <source>Compound key pattern</source>
          <target state="new">Compound key pattern</target>
        </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve">
          <source>Log tail pattern</source>
          <target state="new">Log tail pattern</target>
        </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve">
          <source>Modifying entities</source>
          <target state="new">Modifying entities</target>
        </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve">
          <source>Log data anti-pattern</source>
          <target state="new">Log data anti-pattern</target>
        </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve">
          <source>Typically, you should use the Blob service instead of the Table service to store log data.</source>
          <target state="new">Typically, you should use the Blob service instead of the Table service to store log data.</target>
        </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve">
          <source>Context and problem</source>
          <target state="new">Context and problem</target>
        </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve">
          <source>A common use case for log data is to retrieve a selection of log entries for a specific date/time range: for example, you want to find all the error and critical messages that your application logged between 15:04 and 15:06 on a specific date.</source>
          <target state="new">A common use case for log data is to retrieve a selection of log entries for a specific date/time range: for example, you want to find all the error and critical messages that your application logged between 15:04 and 15:06 on a specific date.</target>
        </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve">
          <source>You do not want to use the date and time of the log message to determine the partition you save log entities to: that results in a hot partition because at any given time, all the log entities will share the same <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> value (see the section <bpt id="p2">[</bpt>Prepend/append anti-pattern<ept id="p2">](#prepend-append-anti-pattern)</ept>).</source>
          <target state="new">You do not want to use the date and time of the log message to determine the partition you save log entities to: that results in a hot partition because at any given time, all the log entities will share the same <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> value (see the section <bpt id="p2">[</bpt>Prepend/append anti-pattern<ept id="p2">](#prepend-append-anti-pattern)</ept>).</target>
        </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve">
          <source>For example, the following entity schema for a log message results in a hot partition because the application writes all log messages to the partition for the current date and hour:</source>
          <target state="new">For example, the following entity schema for a log message results in a hot partition because the application writes all log messages to the partition for the current date and hour:</target>
        </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve">
          <source>In this example, the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> includes the date and time of the log message to ensure that log messages are stored sorted in date/time order, and includes a message id in case multiple log messages share the same date and time.</source>
          <target state="new">In this example, the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> includes the date and time of the log message to ensure that log messages are stored sorted in date/time order, and includes a message id in case multiple log messages share the same date and time.</target>
        </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve">
          <source>Another approach is to use a <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> that ensures that the application writes messages across a range of partitions.</source>
          <target state="new">Another approach is to use a <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> that ensures that the application writes messages across a range of partitions.</target>
        </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source>For example, if the source of the log message provides a way to distribute messages across many partitions, you could use the following entity schema:</source>
          <target state="new">For example, if the source of the log message provides a way to distribute messages across many partitions, you could use the following entity schema:</target>
        </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source>However, the problem with this schema is that to retrieve all the log messages for a specific time span you must search every partition in the table.</source>
          <target state="new">However, the problem with this schema is that to retrieve all the log messages for a specific time span you must search every partition in the table.</target>
        </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="new">Solution</target>
        </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve">
          <source>The previous section highlighted the problem of trying to use the Table service to store log entries and suggested two, unsatisfactory, designs.</source>
          <target state="new">The previous section highlighted the problem of trying to use the Table service to store log entries and suggested two, unsatisfactory, designs.</target>
        </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve">
          <source>One solution led to a hot partition with the risk of poor performance writing log messages; the other solution resulted in poor query performance because of the requirement to scan every partition in the table to retrieve log messages for a specific time span.</source>
          <target state="new">One solution led to a hot partition with the risk of poor performance writing log messages; the other solution resulted in poor query performance because of the requirement to scan every partition in the table to retrieve log messages for a specific time span.</target>
        </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve">
          <source>Blob storage offers a better solution for this type of scenario and this is how Azure Storage Analytics stores the log data it collects.</source>
          <target state="new">Blob storage offers a better solution for this type of scenario and this is how Azure Storage Analytics stores the log data it collects.</target>
        </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve">
          <source>This section outlines how Storage Analytics stores log data in blob storage as an illustration of this approach to storing data that you typically query by range.</source>
          <target state="new">This section outlines how Storage Analytics stores log data in blob storage as an illustration of this approach to storing data that you typically query by range.</target>
        </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve">
          <source>Storage Analytics stores log messages in a delimited format in multiple blobs.</source>
          <target state="new">Storage Analytics stores log messages in a delimited format in multiple blobs.</target>
        </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve">
          <source>The delimited format makes it easy for a client application to parse the data in the log message.</source>
          <target state="new">The delimited format makes it easy for a client application to parse the data in the log message.</target>
        </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve">
          <source>Storage Analytics uses a naming convention for blobs that enables you to locate the blob (or blobs) that contain the log messages for which you are searching.</source>
          <target state="new">Storage Analytics uses a naming convention for blobs that enables you to locate the blob (or blobs) that contain the log messages for which you are searching.</target>
        </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve">
          <source>For example, a blob named "queue/2014/07/31/1800/000001.log" contains log messages that relate to the queue service for the hour starting at 18:00 on 31 July 2014.</source>
          <target state="new">For example, a blob named "queue/2014/07/31/1800/000001.log" contains log messages that relate to the queue service for the hour starting at 18:00 on 31 July 2014.</target>
        </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve">
          <source>The "000001" indicates that this is the first log file for this period.</source>
          <target state="new">The "000001" indicates that this is the first log file for this period.</target>
        </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve">
          <source>Storage Analytics also records the timestamps of the first and last log messages stored in the file as part of the blobs metadata.</source>
          <target state="new">Storage Analytics also records the timestamps of the first and last log messages stored in the file as part of the blobs metadata.</target>
        </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve">
          <source>The API for blob storage enables you locate blobs in a container based on a name prefix: to locate all the blobs that contain queue log data for the hour starting at 18:00, you can use the prefix "queue/2014/07/31/1800."</source>
          <target state="new">The API for blob storage enables you locate blobs in a container based on a name prefix: to locate all the blobs that contain queue log data for the hour starting at 18:00, you can use the prefix "queue/2014/07/31/1800."</target>
        </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve">
          <source>Storage Analytics buffers log messages internally and then periodically updates the appropriate blob or creates a new one with the latest batch of log entries.</source>
          <target state="new">Storage Analytics buffers log messages internally and then periodically updates the appropriate blob or creates a new one with the latest batch of log entries.</target>
        </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve">
          <source>This reduces the number of writes it must perform to the blob service.</source>
          <target state="new">This reduces the number of writes it must perform to the blob service.</target>
        </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve">
          <source>If you are implementing a similar solution in your own application, you must consider how to manage the trade-off between reliability (writing every log entry to blob storage as it happens) and cost and scalability (buffering updates in your application and writing them to blob storage in batches).</source>
          <target state="new">If you are implementing a similar solution in your own application, you must consider how to manage the trade-off between reliability (writing every log entry to blob storage as it happens) and cost and scalability (buffering updates in your application and writing them to blob storage in batches).</target>
        </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve">
          <source>Issues and considerations</source>
          <target state="new">Issues and considerations</target>
        </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve">
          <source>Consider the following points when deciding how to store log data:</source>
          <target state="new">Consider the following points when deciding how to store log data:</target>
        </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve">
          <source>If you create a table design that avoids potential hot partitions, you may find that you cannot access your log data efficiently.</source>
          <target state="new">If you create a table design that avoids potential hot partitions, you may find that you cannot access your log data efficiently.</target>
        </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve">
          <source>To process log data, a client often needs to load many records.</source>
          <target state="new">To process log data, a client often needs to load many records.</target>
        </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve">
          <source>Although log data is often structured, blob storage may be a better solution.</source>
          <target state="new">Although log data is often structured, blob storage may be a better solution.</target>
        </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve">
          <source>Implementation considerations</source>
          <target state="new">Implementation considerations</target>
        </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve">
          <source>This section discusses some of the considerations to bear in mind when you implement the patterns described in the previous sections.</source>
          <target state="new">This section discusses some of the considerations to bear in mind when you implement the patterns described in the previous sections.</target>
        </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve">
          <source>Most of this section uses examples written in C# that use the Storage Client Library (version 4.3.0 at the time of writing).</source>
          <target state="new">Most of this section uses examples written in C# that use the Storage Client Library (version 4.3.0 at the time of writing).</target>
        </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve">
          <source>Retrieving entities</source>
          <target state="new">Retrieving entities</target>
        </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve">
          <source>As discussed in the section <bpt id="p1">[</bpt>Design for querying<ept id="p1">](#design-for-querying)</ept>," the most efficient query is a point query.</source>
          <target state="new">As discussed in the section <bpt id="p1">[</bpt>Design for querying<ept id="p1">](#design-for-querying)</ept>," the most efficient query is a point query.</target>
        </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve">
          <source>However, in some scenarios you may need to retrieve multiple entities.</source>
          <target state="new">However, in some scenarios you may need to retrieve multiple entities.</target>
        </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve">
          <source>This section describes some common approaches to retrieving entities using the Storage Client Library.</source>
          <target state="new">This section describes some common approaches to retrieving entities using the Storage Client Library.</target>
        </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve">
          <source>Executing a point query using the Storage Client Library</source>
          <target state="new">Executing a point query using the Storage Client Library</target>
        </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve">
          <source>The easiest way to execute a point query is to use the <bpt id="p1">**</bpt>Retrieve<ept id="p1">**</ept> table operation as shown in the following C# code snippet that retrieves an entity with a <bpt id="p2">**</bpt>PartitionKey<ept id="p2">**</ept> of value "Sales" and a <bpt id="p3">**</bpt>RowKey<ept id="p3">**</ept> of value "212":</source>
          <target state="new">The easiest way to execute a point query is to use the <bpt id="p1">**</bpt>Retrieve<ept id="p1">**</ept> table operation as shown in the following C# code snippet that retrieves an entity with a <bpt id="p2">**</bpt>PartitionKey<ept id="p2">**</ept> of value "Sales" and a <bpt id="p3">**</bpt>RowKey<ept id="p3">**</ept> of value "212":</target>
        </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve">
          <source>Notice how this example expects the entity it retrieves to be of type <bpt id="p1">**</bpt>EmployeeEntity<ept id="p1">**</ept>.</source>
          <target state="new">Notice how this example expects the entity it retrieves to be of type <bpt id="p1">**</bpt>EmployeeEntity<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve">
          <source>Retrieving multiple entities using LINQ</source>
          <target state="new">Retrieving multiple entities using LINQ</target>
        </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve">
          <source>You can retrieve multiple entities by using LINQ with Storage Client Library and specifying a query with a <bpt id="p1">**</bpt>where<ept id="p1">**</ept> clause.</source>
          <target state="new">You can retrieve multiple entities by using LINQ with Storage Client Library and specifying a query with a <bpt id="p1">**</bpt>where<ept id="p1">**</ept> clause.</target>
        </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve">
          <source>To avoid a table scan, you should always include the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> value in the where clause, and if possible the <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> value to avoid table and partition scans.</source>
          <target state="new">To avoid a table scan, you should always include the <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> value in the where clause, and if possible the <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> value to avoid table and partition scans.</target>
        </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve">
          <source>The table service supports a limited set of comparison operators (greater than, greater than or equal, less than, less than or equal, equal, and not equal) to use in the where clause.</source>
          <target state="new">The table service supports a limited set of comparison operators (greater than, greater than or equal, less than, less than or equal, equal, and not equal) to use in the where clause.</target>
        </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve">
          <source>The following C# code snippet finds all the employees whose last name starts with "B" (assuming that the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> stores the last name) in the sales department (assuming the <bpt id="p2">**</bpt>PartitionKey<ept id="p2">**</ept> stores the department name):</source>
          <target state="new">The following C# code snippet finds all the employees whose last name starts with "B" (assuming that the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> stores the last name) in the sales department (assuming the <bpt id="p2">**</bpt>PartitionKey<ept id="p2">**</ept> stores the department name):</target>
        </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve">
          <source>Notice how the query specifies both a <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> and a <bpt id="p2">**</bpt>PartitionKey<ept id="p2">**</ept> to ensure better performance.</source>
          <target state="new">Notice how the query specifies both a <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> and a <bpt id="p2">**</bpt>PartitionKey<ept id="p2">**</ept> to ensure better performance.</target>
        </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve">
          <source>The following code sample shows equivalent functionality using the fluent API (for more information about fluent APIs in general, see <bpt id="p1">[</bpt>Best Practices for Designing a Fluent API<ept id="p1">](http://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)</ept>):</source>
          <target state="new">The following code sample shows equivalent functionality using the fluent API (for more information about fluent APIs in general, see <bpt id="p1">[</bpt>Best Practices for Designing a Fluent API<ept id="p1">](http://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)</ept>):</target>
        </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> The sample nests multiple <bpt id="p1">**</bpt>CombineFilters<ept id="p1">**</ept> methods to include the three filter conditions.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> The sample nests multiple <bpt id="p1">**</bpt>CombineFilters<ept id="p1">**</ept> methods to include the three filter conditions.</target>
        </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve">
          <source>Retrieving large numbers of entities from a query</source>
          <target state="new">Retrieving large numbers of entities from a query</target>
        </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve">
          <source>An optimal query returns an individual entity based on a <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> value and a <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> value.</source>
          <target state="new">An optimal query returns an individual entity based on a <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> value and a <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> value.</target>
        </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve">
          <source>However, in some scenarios you may have a requirement to return many entities from the same partition or even from many partitions.</source>
          <target state="new">However, in some scenarios you may have a requirement to return many entities from the same partition or even from many partitions.</target>
        </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve">
          <source>You should always fully test the performance of your application in such scenarios.</source>
          <target state="new">You should always fully test the performance of your application in such scenarios.</target>
        </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve">
          <source>A query against the table service may return a maximum of 1,000 entities at one time and may execute for a maximum of five seconds.</source>
          <target state="new">A query against the table service may return a maximum of 1,000 entities at one time and may execute for a maximum of five seconds.</target>
        </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve">
          <source>If the result set contains more than 1,000 entities, if the query did not complete within five seconds, or if the query crosses the partition boundary, the Table service returns a continuation token to enable the client application to request the next set of entities.</source>
          <target state="new">If the result set contains more than 1,000 entities, if the query did not complete within five seconds, or if the query crosses the partition boundary, the Table service returns a continuation token to enable the client application to request the next set of entities.</target>
        </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve">
          <source>For more information about how continuation tokens work, see <bpt id="p1">[</bpt>Query Timeout and Pagination<ept id="p1">](http://msdn.microsoft.com/library/azure/dd135718.aspx)</ept> on MSDN.</source>
          <target state="new">For more information about how continuation tokens work, see <bpt id="p1">[</bpt>Query Timeout and Pagination<ept id="p1">](http://msdn.microsoft.com/library/azure/dd135718.aspx)</ept> on MSDN.</target>
        </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve">
          <source>If you are using the Storage Client Library, it can automatically handle continuation tokens for you as it returns entities from the Table service.</source>
          <target state="new">If you are using the Storage Client Library, it can automatically handle continuation tokens for you as it returns entities from the Table service.</target>
        </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve">
          <source>The following C# code sample using the Storage Client Library automatically handles continuation tokens if the table service returns them in a response:</source>
          <target state="new">The following C# code sample using the Storage Client Library automatically handles continuation tokens if the table service returns them in a response:</target>
        </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve">
          <source>The following C# code handles continuation tokens explicitly:</source>
          <target state="new">The following C# code handles continuation tokens explicitly:</target>
        </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve">
          <source>By using continuation tokens explicitly, you can control when your application retrieves the next segment of data.</source>
          <target state="new">By using continuation tokens explicitly, you can control when your application retrieves the next segment of data.</target>
        </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve">
          <source>For example, if your client application enables users to page through the entities stored in a table, a user may decide not to page through all the entities retrieved by the query so your application would only use a continuation token to retrieve the next segment when the user had finished paging through all the entities in the current segment.</source>
          <target state="new">For example, if your client application enables users to page through the entities stored in a table, a user may decide not to page through all the entities retrieved by the query so your application would only use a continuation token to retrieve the next segment when the user had finished paging through all the entities in the current segment.</target>
        </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve">
          <source>This approach has several benefits:</source>
          <target state="new">This approach has several benefits:</target>
        </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve">
          <source>It enables you to limit the amount of data to retrieve from the Table service and that you move over the network.</source>
          <target state="new">It enables you to limit the amount of data to retrieve from the Table service and that you move over the network.</target>
        </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve">
          <source>It enables you to perform asynchronous IO in .NET.</source>
          <target state="new">It enables you to perform asynchronous IO in .NET.</target>
        </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve">
          <source>It enables you to serialize the continuation token to persistent storage so you can continue in the event of an application crash.</source>
          <target state="new">It enables you to serialize the continuation token to persistent storage so you can continue in the event of an application crash.</target>
        </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> A continuation token typically returns a segment containing 1,000 entities, although it may be fewer.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> A continuation token typically returns a segment containing 1,000 entities, although it may be fewer.</target>
        </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve">
          <source>This is also the case if you limit the number of entries a query returns by using <bpt id="p1">**</bpt>Take<ept id="p1">**</ept> to return the first n entities that match your lookup criteria: the table service may return a segment containing fewer than n entities along with a continuation token to enable you to retrieve the remaining entities.</source>
          <target state="new">This is also the case if you limit the number of entries a query returns by using <bpt id="p1">**</bpt>Take<ept id="p1">**</ept> to return the first n entities that match your lookup criteria: the table service may return a segment containing fewer than n entities along with a continuation token to enable you to retrieve the remaining entities.</target>
        </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve">
          <source>The following C# code shows how to modify the number of entities returned inside a segment:</source>
          <target state="new">The following C# code shows how to modify the number of entities returned inside a segment:</target>
        </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve">
          <source>Server-side projection</source>
          <target state="new">Server-side projection</target>
        </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve">
          <source>A single entity can have up to 255 properties and be up to 1 MB in size.</source>
          <target state="new">A single entity can have up to 255 properties and be up to 1 MB in size.</target>
        </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve">
          <source>When you query the table and retrieve entities, you may not need all the properties and can avoid transferring data unnecessarily (to help reduce latency and cost).</source>
          <target state="new">When you query the table and retrieve entities, you may not need all the properties and can avoid transferring data unnecessarily (to help reduce latency and cost).</target>
        </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve">
          <source>You can use server-side projection to transfer just the properties you need.</source>
          <target state="new">You can use server-side projection to transfer just the properties you need.</target>
        </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve">
          <source>The following example is retrieves just the <bpt id="p1">**</bpt>Email<ept id="p1">**</ept> property (along with <bpt id="p2">**</bpt>PartitionKey<ept id="p2">**</ept>, <bpt id="p3">**</bpt>RowKey<ept id="p3">**</ept>, <bpt id="p4">**</bpt>Timestamp<ept id="p4">**</ept>, and <bpt id="p5">**</bpt>ETag<ept id="p5">**</ept>) from the entities selected by the query.</source>
          <target state="new">The following example is retrieves just the <bpt id="p1">**</bpt>Email<ept id="p1">**</ept> property (along with <bpt id="p2">**</bpt>PartitionKey<ept id="p2">**</ept>, <bpt id="p3">**</bpt>RowKey<ept id="p3">**</ept>, <bpt id="p4">**</bpt>Timestamp<ept id="p4">**</ept>, and <bpt id="p5">**</bpt>ETag<ept id="p5">**</ept>) from the entities selected by the query.</target>
        </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve">
          <source>Notice how the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> value is available even though it was not included in the list of properties to retrieve.</source>
          <target state="new">Notice how the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> value is available even though it was not included in the list of properties to retrieve.</target>
        </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve">
          <source>Modifying entities</source>
          <target state="new">Modifying entities</target>
        </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve">
          <source>The Storage Client Library enables you to modify your entities stored in the table service by inserting, deleting, and updating entities.</source>
          <target state="new">The Storage Client Library enables you to modify your entities stored in the table service by inserting, deleting, and updating entities.</target>
        </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve">
          <source>You can use EGTs to batch multiple insert, update, and delete operations together to reduce the number of round trips required and improve the performance of your solution.</source>
          <target state="new">You can use EGTs to batch multiple insert, update, and delete operations together to reduce the number of round trips required and improve the performance of your solution.</target>
        </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve">
          <source>Note that exceptions thrown when the Storage Client Library executes an EGT typically include the index of the entity that caused the batch to fail.</source>
          <target state="new">Note that exceptions thrown when the Storage Client Library executes an EGT typically include the index of the entity that caused the batch to fail.</target>
        </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve">
          <source>This is helpful when you are debugging code that uses EGTs.</source>
          <target state="new">This is helpful when you are debugging code that uses EGTs.</target>
        </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve">
          <source>You should also consider how your design affects how your client application handles concurrency and update operations.</source>
          <target state="new">You should also consider how your design affects how your client application handles concurrency and update operations.</target>
        </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve">
          <source>Managing concurrency</source>
          <target state="new">Managing concurrency</target>
        </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve">
          <source>By default, the table service implements optimistic concurrency checks at the level of individual entities for <bpt id="p1">**</bpt>Insert<ept id="p1">**</ept>, <bpt id="p2">**</bpt>Merge<ept id="p2">**</ept>, and <bpt id="p3">**</bpt>Delete<ept id="p3">**</ept> operations, although it is possible for a client to force the table service to bypass these checks.</source>
          <target state="new">By default, the table service implements optimistic concurrency checks at the level of individual entities for <bpt id="p1">**</bpt>Insert<ept id="p1">**</ept>, <bpt id="p2">**</bpt>Merge<ept id="p2">**</ept>, and <bpt id="p3">**</bpt>Delete<ept id="p3">**</ept> operations, although it is possible for a client to force the table service to bypass these checks.</target>
        </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve">
          <source>For more information about how the table service manages concurrency, see  <bpt id="p1">[</bpt>Managing Concurrency in Microsoft Azure Storage<ept id="p1">](storage-concurrency.md)</ept> on the Microsoft Azure web site.</source>
          <target state="new">For more information about how the table service manages concurrency, see  <bpt id="p1">[</bpt>Managing Concurrency in Microsoft Azure Storage<ept id="p1">](storage-concurrency.md)</ept> on the Microsoft Azure web site.</target>
        </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve">
          <source>Merge or replace</source>
          <target state="new">Merge or replace</target>
        </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Replace<ept id="p1">**</ept> method of the <bpt id="p2">**</bpt>TableOperation<ept id="p2">**</ept> class always replaces the complete entity in the Table service.</source>
          <target state="new">The <bpt id="p1">**</bpt>Replace<ept id="p1">**</ept> method of the <bpt id="p2">**</bpt>TableOperation<ept id="p2">**</ept> class always replaces the complete entity in the Table service.</target>
        </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve">
          <source>If you do not include a property in the request when that property exists in the stored entity, the request removes that property from the stored entity.</source>
          <target state="new">If you do not include a property in the request when that property exists in the stored entity, the request removes that property from the stored entity.</target>
        </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve">
          <source>Unless you want to remove a property explicitly from a stored entity, you must include every property in the request.</source>
          <target state="new">Unless you want to remove a property explicitly from a stored entity, you must include every property in the request.</target>
        </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve">
          <source>You can use the <bpt id="p1">**</bpt>Merge<ept id="p1">**</ept> method of the <bpt id="p2">**</bpt>TableOperation<ept id="p2">**</ept> class to reduce the amount of data that you send to the Table service when you want to update an entity.</source>
          <target state="new">You can use the <bpt id="p1">**</bpt>Merge<ept id="p1">**</ept> method of the <bpt id="p2">**</bpt>TableOperation<ept id="p2">**</ept> class to reduce the amount of data that you send to the Table service when you want to update an entity.</target>
        </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Merge<ept id="p1">**</ept> method replaces any properties in the stored entity with property values from the entity included in the request, but leaves intact any properties in the stored entity that are not included in the request.</source>
          <target state="new">The <bpt id="p1">**</bpt>Merge<ept id="p1">**</ept> method replaces any properties in the stored entity with property values from the entity included in the request, but leaves intact any properties in the stored entity that are not included in the request.</target>
        </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve">
          <source>This is useful if you have large entities and only need to update a small number of properties in a request.</source>
          <target state="new">This is useful if you have large entities and only need to update a small number of properties in a request.</target>
        </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> The <bpt id="p1">**</bpt>Replace<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Merge<ept id="p2">**</ept> methods fail if the entity does not exist.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> The <bpt id="p1">**</bpt>Replace<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Merge<ept id="p2">**</ept> methods fail if the entity does not exist.</target>
        </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve">
          <source>As an alternative, you can use the <bpt id="p1">**</bpt>InsertOrReplace<ept id="p1">**</ept> and <bpt id="p2">**</bpt>InsertOrMerge<ept id="p2">**</ept> methods that create a new entity if it doesn't exist.</source>
          <target state="new">As an alternative, you can use the <bpt id="p1">**</bpt>InsertOrReplace<ept id="p1">**</ept> and <bpt id="p2">**</bpt>InsertOrMerge<ept id="p2">**</ept> methods that create a new entity if it doesn't exist.</target>
        </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve">
          <source>Working with heterogeneous entity types</source>
          <target state="new">Working with heterogeneous entity types</target>
        </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve">
          <source>The Table service is a <bpt id="p1">*</bpt>schema-less<ept id="p1">*</ept> table store that means that a single table can store entities of multiple types providing great flexibility in your design.</source>
          <target state="new">The Table service is a <bpt id="p1">*</bpt>schema-less<ept id="p1">*</ept> table store that means that a single table can store entities of multiple types providing great flexibility in your design.</target>
        </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve">
          <source>The following example illustrates a table storing both employee and department entities:</source>
          <target state="new">The following example illustrates a table storing both employee and department entities:</target>
        </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve">
          <source>PartitionKey</source>
          <target state="new">PartitionKey</target>
        </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve">
          <source>RowKey</source>
          <target state="new">RowKey</target>
        </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve">
          <source>Timestamp</source>
          <target state="new">Timestamp</target>
        </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve">
          <source>FirstName</source>
          <target state="new">FirstName</target>
        </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve">
          <source>LastName</source>
          <target state="new">LastName</target>
        </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve">
          <source>Age</source>
          <target state="new">Age</target>
        </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve">
          <source>Email</source>
          <target state="new">Email</target>
        </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve">
          <source>FirstName</source>
          <target state="new">FirstName</target>
        </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve">
          <source>LastName</source>
          <target state="new">LastName</target>
        </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve">
          <source>Age</source>
          <target state="new">Age</target>
        </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve">
          <source>Email</source>
          <target state="new">Email</target>
        </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve">
          <source>DepartmentName</source>
          <target state="new">DepartmentName</target>
        </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve">
          <source>EmployeeCount</source>
          <target state="new">EmployeeCount</target>
        </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve">
          <source>FirstName</source>
          <target state="new">FirstName</target>
        </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve">
          <source>LastName</source>
          <target state="new">LastName</target>
        </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve">
          <source>Age</source>
          <target state="new">Age</target>
        </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve">
          <source>Email</source>
          <target state="new">Email</target>
        </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve">
          <source>Note that each entity must still have <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept>, <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept>, and <bpt id="p3">**</bpt>Timestamp<ept id="p3">**</ept> values, but may have any set of properties.</source>
          <target state="new">Note that each entity must still have <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept>, <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept>, and <bpt id="p3">**</bpt>Timestamp<ept id="p3">**</ept> values, but may have any set of properties.</target>
        </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve">
          <source>Furthermore, there is nothing to indicate the type of an entity unless you choose to store that information somewhere.</source>
          <target state="new">Furthermore, there is nothing to indicate the type of an entity unless you choose to store that information somewhere.</target>
        </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve">
          <source>There are two options for identifying the entity type:</source>
          <target state="new">There are two options for identifying the entity type:</target>
        </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve">
          <source>Prepend the entity type to the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> (or possibly the <bpt id="p2">**</bpt>PartitionKey<ept id="p2">**</ept>).</source>
          <target state="new">Prepend the entity type to the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> (or possibly the <bpt id="p2">**</bpt>PartitionKey<ept id="p2">**</ept>).</target>
        </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">**</bpt>EMPLOYEE_000123<ept id="p1">**</ept> or <bpt id="p2">**</bpt>DEPARTMENT_SALES<ept id="p2">**</ept> as <bpt id="p3">**</bpt>RowKey<ept id="p3">**</ept> values.</source>
          <target state="new">For example, <bpt id="p1">**</bpt>EMPLOYEE_000123<ept id="p1">**</ept> or <bpt id="p2">**</bpt>DEPARTMENT_SALES<ept id="p2">**</ept> as <bpt id="p3">**</bpt>RowKey<ept id="p3">**</ept> values.</target>
        </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve">
          <source>Use a separate property to record the entity type as shown in the table below.</source>
          <target state="new">Use a separate property to record the entity type as shown in the table below.</target>
        </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve">
          <source>PartitionKey</source>
          <target state="new">PartitionKey</target>
        </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve">
          <source>RowKey</source>
          <target state="new">RowKey</target>
        </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve">
          <source>Timestamp</source>
          <target state="new">Timestamp</target>
        </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve">
          <source>EntityType</source>
          <target state="new">EntityType</target>
        </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve">
          <source>FirstName</source>
          <target state="new">FirstName</target>
        </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve">
          <source>LastName</source>
          <target state="new">LastName</target>
        </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve">
          <source>Age</source>
          <target state="new">Age</target>
        </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve">
          <source>Email</source>
          <target state="new">Email</target>
        </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve">
          <source>Employee</source>
          <target state="new">Employee</target>
        </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve">
          <source>EntityType</source>
          <target state="new">EntityType</target>
        </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve">
          <source>FirstName</source>
          <target state="new">FirstName</target>
        </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve">
          <source>LastName</source>
          <target state="new">LastName</target>
        </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve">
          <source>Age</source>
          <target state="new">Age</target>
        </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve">
          <source>Email</source>
          <target state="new">Email</target>
        </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve">
          <source>Employee</source>
          <target state="new">Employee</target>
        </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve">
          <source>EntityType</source>
          <target state="new">EntityType</target>
        </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve">
          <source>DepartmentName</source>
          <target state="new">DepartmentName</target>
        </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve">
          <source>EmployeeCount</source>
          <target state="new">EmployeeCount</target>
        </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve">
          <source>Department</source>
          <target state="new">Department</target>
        </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve">
          <source>EntityType</source>
          <target state="new">EntityType</target>
        </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve">
          <source>FirstName</source>
          <target state="new">FirstName</target>
        </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve">
          <source>LastName</source>
          <target state="new">LastName</target>
        </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve">
          <source>Age</source>
          <target state="new">Age</target>
        </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve">
          <source>Email</source>
          <target state="new">Email</target>
        </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve">
          <source>Employee</source>
          <target state="new">Employee</target>
        </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve">
          <source>The first option, prepending the entity type to the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept>, is useful if there is a possibility that two entities of different types might have the same key value.</source>
          <target state="new">The first option, prepending the entity type to the <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept>, is useful if there is a possibility that two entities of different types might have the same key value.</target>
        </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve">
          <source>It also groups entities of the same type together in the partition.</source>
          <target state="new">It also groups entities of the same type together in the partition.</target>
        </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve">
          <source>The techniques discussed in this section are especially relevant to the discussion <bpt id="p1">[</bpt>Inheritance relationships<ept id="p1">](#inheritance-relationships)</ept> earlier in this guide in the section <bpt id="p2">[</bpt>Modelling relationships<ept id="p2">](#modelling-relationships)</ept>.</source>
          <target state="new">The techniques discussed in this section are especially relevant to the discussion <bpt id="p1">[</bpt>Inheritance relationships<ept id="p1">](#inheritance-relationships)</ept> earlier in this guide in the section <bpt id="p2">[</bpt>Modelling relationships<ept id="p2">](#modelling-relationships)</ept>.</target>
        </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> You should consider including a version number in the entity type value to enable client applications to evolve POCO objects and work with different versions.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> You should consider including a version number in the entity type value to enable client applications to evolve POCO objects and work with different versions.</target>
        </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve">
          <source>The remainder of this section describes some of the features in the Storage Client Library that facilitate working with multiple entity types in the same table.</source>
          <target state="new">The remainder of this section describes some of the features in the Storage Client Library that facilitate working with multiple entity types in the same table.</target>
        </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve">
          <source>Retrieving heterogeneous entity types</source>
          <target state="new">Retrieving heterogeneous entity types</target>
        </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve">
          <source>If you are using the Storage Client Library, you have three options for working with multiple entity types.</source>
          <target state="new">If you are using the Storage Client Library, you have three options for working with multiple entity types.</target>
        </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve">
          <source>If you know the type of the entity stored with a specific <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>PartitionKey<ept id="p2">**</ept> values, then you can specify the entity type when you retrieve the entity as shown in the previous two examples that retrieve entities of type <bpt id="p3">**</bpt>EmployeeEntity<ept id="p3">**</ept>: <bpt id="p4">[</bpt>Retrieving a single entity using the Storage Client Library<ept id="p4">](#retrieving-a-single-entity-using-the-storage-client-library)</ept> and <bpt id="p5">[</bpt>Retrieving multiple entities using LINQ<ept id="p5">](#retrieving-multiple-entities-using-linq)</ept>.</source>
          <target state="new">If you know the type of the entity stored with a specific <bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>PartitionKey<ept id="p2">**</ept> values, then you can specify the entity type when you retrieve the entity as shown in the previous two examples that retrieve entities of type <bpt id="p3">**</bpt>EmployeeEntity<ept id="p3">**</ept>: <bpt id="p4">[</bpt>Retrieving a single entity using the Storage Client Library<ept id="p4">](#retrieving-a-single-entity-using-the-storage-client-library)</ept> and <bpt id="p5">[</bpt>Retrieving multiple entities using LINQ<ept id="p5">](#retrieving-multiple-entities-using-linq)</ept>.</target>
        </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve">
          <source>The second option is to use the <bpt id="p1">**</bpt>DynamicTableEntity<ept id="p1">**</ept> type (a property bag) instead of a concrete POCO entity type (this option may also improve performance because there is no need to serialize and deserialize the entity to .NET types).</source>
          <target state="new">The second option is to use the <bpt id="p1">**</bpt>DynamicTableEntity<ept id="p1">**</ept> type (a property bag) instead of a concrete POCO entity type (this option may also improve performance because there is no need to serialize and deserialize the entity to .NET types).</target>
        </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve">
          <source>The following C# code potentially retrieves multiple entities of different types from the table, but returns all entities as <bpt id="p1">**</bpt>DynamicTableEntity<ept id="p1">**</ept> instances.</source>
          <target state="new">The following C# code potentially retrieves multiple entities of different types from the table, but returns all entities as <bpt id="p1">**</bpt>DynamicTableEntity<ept id="p1">**</ept> instances.</target>
        </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve">
          <source>It then uses the <bpt id="p1">**</bpt>EntityType<ept id="p1">**</ept> property to determine the type of each entity:</source>
          <target state="new">It then uses the <bpt id="p1">**</bpt>EntityType<ept id="p1">**</ept> property to determine the type of each entity:</target>
        </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve">
          <source>Note that to retrieve other properties you must use the <bpt id="p1">**</bpt>TryGetValue<ept id="p1">**</ept> method on the <bpt id="p2">**</bpt>Properties<ept id="p2">**</ept> property of the <bpt id="p3">**</bpt>DynamicTableEntity<ept id="p3">**</ept> class.</source>
          <target state="new">Note that to retrieve other properties you must use the <bpt id="p1">**</bpt>TryGetValue<ept id="p1">**</ept> method on the <bpt id="p2">**</bpt>Properties<ept id="p2">**</ept> property of the <bpt id="p3">**</bpt>DynamicTableEntity<ept id="p3">**</ept> class.</target>
        </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve">
          <source>A third option is to combine using the <bpt id="p1">**</bpt>DynamicTableEntity<ept id="p1">**</ept> type and an <bpt id="p2">**</bpt>EntityResolver<ept id="p2">**</ept> instance.</source>
          <target state="new">A third option is to combine using the <bpt id="p1">**</bpt>DynamicTableEntity<ept id="p1">**</ept> type and an <bpt id="p2">**</bpt>EntityResolver<ept id="p2">**</ept> instance.</target>
        </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve">
          <source>This enables you to resolve to multiple POCO types in the same query.</source>
          <target state="new">This enables you to resolve to multiple POCO types in the same query.</target>
        </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve">
          <source>In this example, the <bpt id="p1">**</bpt>EntityResolver<ept id="p1">**</ept> delegate is using the <bpt id="p2">**</bpt>EntityType<ept id="p2">**</ept> property to distinguish between the two types of entity that the query returns.</source>
          <target state="new">In this example, the <bpt id="p1">**</bpt>EntityResolver<ept id="p1">**</ept> delegate is using the <bpt id="p2">**</bpt>EntityType<ept id="p2">**</ept> property to distinguish between the two types of entity that the query returns.</target>
        </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Resolve<ept id="p1">**</ept> method uses the <bpt id="p2">**</bpt>resolver<ept id="p2">**</ept> delegate to resolve <bpt id="p3">**</bpt>DynamicTableEntity<ept id="p3">**</ept> instances to <bpt id="p4">**</bpt>TableEntity<ept id="p4">**</ept> instances.</source>
          <target state="new">The <bpt id="p1">**</bpt>Resolve<ept id="p1">**</ept> method uses the <bpt id="p2">**</bpt>resolver<ept id="p2">**</ept> delegate to resolve <bpt id="p3">**</bpt>DynamicTableEntity<ept id="p3">**</ept> instances to <bpt id="p4">**</bpt>TableEntity<ept id="p4">**</ept> instances.</target>
        </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve">
          <source>Modifying heterogeneous entity types</source>
          <target state="new">Modifying heterogeneous entity types</target>
        </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve">
          <source>You do not need to know the type of an entity to delete it, and you always know the type of an entity when you insert it.</source>
          <target state="new">You do not need to know the type of an entity to delete it, and you always know the type of an entity when you insert it.</target>
        </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve">
          <source>However, you can use <bpt id="p1">**</bpt>DynamicTableEntity<ept id="p1">**</ept> type to update an entity without knowing its type and without using a POCO entity class.</source>
          <target state="new">However, you can use <bpt id="p1">**</bpt>DynamicTableEntity<ept id="p1">**</ept> type to update an entity without knowing its type and without using a POCO entity class.</target>
        </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve">
          <source>The following code sample retrieves a single entity, and checks the <bpt id="p1">**</bpt>EmployeeCount<ept id="p1">**</ept> property exists before updating it.</source>
          <target state="new">The following code sample retrieves a single entity, and checks the <bpt id="p1">**</bpt>EmployeeCount<ept id="p1">**</ept> property exists before updating it.</target>
        </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve">
          <source>Controlling access with Shared Access Signatures</source>
          <target state="new">Controlling access with Shared Access Signatures</target>
        </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve">
          <source>You can use Shared Access Signature (SAS) tokens to enable client applications to modify (and query) table entities directly without the need to authenticate directly with the table service.</source>
          <target state="new">You can use Shared Access Signature (SAS) tokens to enable client applications to modify (and query) table entities directly without the need to authenticate directly with the table service.</target>
        </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve">
          <source>Typically, there are three main benefits to using SAS in your application:</source>
          <target state="new">Typically, there are three main benefits to using SAS in your application:</target>
        </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve">
          <source>You do not need to distribute your storage account key to an insecure platform (such as a mobile device) in order to allow that device to access and modify entities in the Table service.</source>
          <target state="new">You do not need to distribute your storage account key to an insecure platform (such as a mobile device) in order to allow that device to access and modify entities in the Table service.</target>
        </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve">
          <source>You can offload some of the work that web and worker roles perform in managing your entities to client devices such as end-user computers and mobile devices.</source>
          <target state="new">You can offload some of the work that web and worker roles perform in managing your entities to client devices such as end-user computers and mobile devices.</target>
        </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve">
          <source>You can assign a constrained and time limited set of permissions to a client (such as allowing read-only access to specific resources).</source>
          <target state="new">You can assign a constrained and time limited set of permissions to a client (such as allowing read-only access to specific resources).</target>
        </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve">
          <source>For more information about using SAS tokens with the Table service, see <bpt id="p1">[</bpt>Shared Access Signatures, Part 1: Understanding the SAS Model<ept id="p1">](../storage-dotnet-shared-access-signature-part-1/)</ept>.</source>
          <target state="new">For more information about using SAS tokens with the Table service, see <bpt id="p1">[</bpt>Shared Access Signatures, Part 1: Understanding the SAS Model<ept id="p1">](../storage-dotnet-shared-access-signature-part-1/)</ept>.</target>
        </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve">
          <source>However, you must still generate the SAS tokens that grant a client application to the entities in the table service: you should do this in an environment that has secure access to your storage account keys.</source>
          <target state="new">However, you must still generate the SAS tokens that grant a client application to the entities in the table service: you should do this in an environment that has secure access to your storage account keys.</target>
        </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve">
          <source>Typically, you use a web or worker role to generate the SAS tokens and deliver them to the client applications that need access to your entities.</source>
          <target state="new">Typically, you use a web or worker role to generate the SAS tokens and deliver them to the client applications that need access to your entities.</target>
        </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve">
          <source>Because there is still an overhead involved in generating and delivering SAS tokens to clients, you should consider how best to reduce this overhead, especially in high-volume scenarios.</source>
          <target state="new">Because there is still an overhead involved in generating and delivering SAS tokens to clients, you should consider how best to reduce this overhead, especially in high-volume scenarios.</target>
        </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve">
          <source>It is possible to generate a SAS token that grants access to a subset of the entities in a table.</source>
          <target state="new">It is possible to generate a SAS token that grants access to a subset of the entities in a table.</target>
        </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve">
          <source>By default, you create a SAS token for an entire table, but it is also possible to specify that the SAS token grant access to either a range of <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> values, or a range of <bpt id="p2">**</bpt>PartitionKey<ept id="p2">**</ept> and <bpt id="p3">**</bpt>RowKey<ept id="p3">**</ept> values.</source>
          <target state="new">By default, you create a SAS token for an entire table, but it is also possible to specify that the SAS token grant access to either a range of <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> values, or a range of <bpt id="p2">**</bpt>PartitionKey<ept id="p2">**</ept> and <bpt id="p3">**</bpt>RowKey<ept id="p3">**</ept> values.</target>
        </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve">
          <source>You might choose to generate SAS tokens for individual users of your system such that each users SAS token only allows them access to their own entities in the table service.</source>
          <target state="new">You might choose to generate SAS tokens for individual users of your system such that each users SAS token only allows them access to their own entities in the table service.</target>
        </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve">
          <source>Asynchronous and parallel operations</source>
          <target state="new">Asynchronous and parallel operations</target>
        </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve">
          <source>Provided you are spreading your requests across multiple partitions, you can improve throughput and client responsiveness by using asynchronous or parallel queries.</source>
          <target state="new">Provided you are spreading your requests across multiple partitions, you can improve throughput and client responsiveness by using asynchronous or parallel queries.</target>
        </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve">
          <source>For example, you might have two or more worker role instances accessing your tables in parallel.</source>
          <target state="new">For example, you might have two or more worker role instances accessing your tables in parallel.</target>
        </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve">
          <source>You could have individual worker roles responsible for particular sets of partitions, or simply have multiple worker role instances, each able to access all the partitions in a table.</source>
          <target state="new">You could have individual worker roles responsible for particular sets of partitions, or simply have multiple worker role instances, each able to access all the partitions in a table.</target>
        </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve">
          <source>Within a client instance, you can improve throughput by executing storage operations asynchronously.</source>
          <target state="new">Within a client instance, you can improve throughput by executing storage operations asynchronously.</target>
        </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve">
          <source>The Storage Client Library makes it easy to write asynchronous queries and modifications.</source>
          <target state="new">The Storage Client Library makes it easy to write asynchronous queries and modifications.</target>
        </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve">
          <source>For example, you might start with the synchronous method that retrieves all the entities in a partition as shown in the following C# code:</source>
          <target state="new">For example, you might start with the synchronous method that retrieves all the entities in a partition as shown in the following C# code:</target>
        </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve">
          <source>You can easily modify this code so that the query runs asynchronously as follows:</source>
          <target state="new">You can easily modify this code so that the query runs asynchronously as follows:</target>
        </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve">
          <source>In this asynchronous example, you can see the following changes from the synchronous version:</source>
          <target state="new">In this asynchronous example, you can see the following changes from the synchronous version:</target>
        </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve">
          <source>The method signature now includes the <bpt id="p1">**</bpt>async<ept id="p1">**</ept> modifier and returns a <bpt id="p2">**</bpt>Task<ept id="p2">**</ept> instance.</source>
          <target state="new">The method signature now includes the <bpt id="p1">**</bpt>async<ept id="p1">**</ept> modifier and returns a <bpt id="p2">**</bpt>Task<ept id="p2">**</ept> instance.</target>
        </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve">
          <source>Instead of calling the <bpt id="p1">**</bpt>ExecuteSegmented<ept id="p1">**</ept> method to retrieve results, the method now calls the <bpt id="p2">**</bpt>ExecuteSegmentedAsync<ept id="p2">**</ept> method and uses the <bpt id="p3">**</bpt>await<ept id="p3">**</ept> modifier to retrieve results asynchronously.</source>
          <target state="new">Instead of calling the <bpt id="p1">**</bpt>ExecuteSegmented<ept id="p1">**</ept> method to retrieve results, the method now calls the <bpt id="p2">**</bpt>ExecuteSegmentedAsync<ept id="p2">**</ept> method and uses the <bpt id="p3">**</bpt>await<ept id="p3">**</ept> modifier to retrieve results asynchronously.</target>
        </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve">
          <source>The client application can call this method multiple times (with different values for the <bpt id="p1">**</bpt>department<ept id="p1">**</ept> parameter), and each query will run on a separate thread.</source>
          <target state="new">The client application can call this method multiple times (with different values for the <bpt id="p1">**</bpt>department<ept id="p1">**</ept> parameter), and each query will run on a separate thread.</target>
        </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve">
          <source>Note that there is no asynchronous version of the <bpt id="p1">**</bpt>Execute<ept id="p1">**</ept> method in the <bpt id="p2">**</bpt>TableQuery<ept id="p2">**</ept> class because the <bpt id="p3">**</bpt>IEnumerable<ept id="p3">**</ept> interface does not support asynchronous enumeration.</source>
          <target state="new">Note that there is no asynchronous version of the <bpt id="p1">**</bpt>Execute<ept id="p1">**</ept> method in the <bpt id="p2">**</bpt>TableQuery<ept id="p2">**</ept> class because the <bpt id="p3">**</bpt>IEnumerable<ept id="p3">**</ept> interface does not support asynchronous enumeration.</target>
        </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve">
          <source>You can also insert, update, and delete entities asynchronously.</source>
          <target state="new">You can also insert, update, and delete entities asynchronously.</target>
        </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve">
          <source>The following C# example shows a simple, synchronous method to insert or replace an employee entity:</source>
          <target state="new">The following C# example shows a simple, synchronous method to insert or replace an employee entity:</target>
        </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve">
          <source>You can easily modify this code so that the update runs asynchronously as follows:</source>
          <target state="new">You can easily modify this code so that the update runs asynchronously as follows:</target>
        </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve">
          <source>In this asynchronous example, you can see the following changes from the synchronous version:</source>
          <target state="new">In this asynchronous example, you can see the following changes from the synchronous version:</target>
        </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve">
          <source>The method signature now includes the <bpt id="p1">**</bpt>async<ept id="p1">**</ept> modifier and returns a <bpt id="p2">**</bpt>Task<ept id="p2">**</ept> instance.</source>
          <target state="new">The method signature now includes the <bpt id="p1">**</bpt>async<ept id="p1">**</ept> modifier and returns a <bpt id="p2">**</bpt>Task<ept id="p2">**</ept> instance.</target>
        </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve">
          <source>Instead of calling the <bpt id="p1">**</bpt>Execute<ept id="p1">**</ept> method to update the entity, the method now calls the <bpt id="p2">**</bpt>ExecuteAsync<ept id="p2">**</ept> method and uses the <bpt id="p3">**</bpt>await<ept id="p3">**</ept> modifier to retrieve results asynchronously.</source>
          <target state="new">Instead of calling the <bpt id="p1">**</bpt>Execute<ept id="p1">**</ept> method to update the entity, the method now calls the <bpt id="p2">**</bpt>ExecuteAsync<ept id="p2">**</ept> method and uses the <bpt id="p3">**</bpt>await<ept id="p3">**</ept> modifier to retrieve results asynchronously.</target>
        </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve">
          <source>The client application can call multiple asynchronous methods like this one, and each method invocation will run on a separate thread.</source>
          <target state="new">The client application can call multiple asynchronous methods like this one, and each method invocation will run on a separate thread.</target>
        </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve">
          <source>Credits</source>
          <target state="new">Credits</target>
        </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve">
          <source>We would like to thank the following members of the Azure team for their contributions: Dominic Betts, Jason Hogg, Jean Ghanem, Jai Haridas, Jeff Irwin, Vamshidhar Kommineni, Vinay Shah and Serdar Ozler as well as  Tom Hollander from Microsoft DX.</source>
          <target state="new">We would like to thank the following members of the Azure team for their contributions: Dominic Betts, Jason Hogg, Jean Ghanem, Jai Haridas, Jeff Irwin, Vamshidhar Kommineni, Vinay Shah and Serdar Ozler as well as  Tom Hollander from Microsoft DX.</target>
        </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve">
          <source>We would also like to thank the following Microsoft MVPs for their valuable feedback during review cycles: Igor Papirov and Edward Bakker.</source>
          <target state="new">We would also like to thank the following Microsoft MVPs for their valuable feedback during review cycles: Igor Papirov and Edward Bakker.</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">28cca48c528f57bc506d83dfa435b3a456eef949</xliffext:olfilehash>
  </header>
</xliff>