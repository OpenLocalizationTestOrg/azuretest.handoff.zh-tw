<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Reliable Actors for Internet of Things</source>
          <target state="new">Reliable Actors for Internet of Things</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Service Fabric Reliable Actors is the key building block (as a middle-tier) in a system that combines a messaging system front end that supports multiple transports such as HTTPS, MQTT or AMQP then communicates with actors that represent individual devices.</source>
          <target state="new">Service Fabric Reliable Actors is the key building block (as a middle-tier) in a system that combines a messaging system front end that supports multiple transports such as HTTPS, MQTT or AMQP then communicates with actors that represent individual devices.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Reliable Actors design pattern: Internet of Things</source>
          <target state="new">Reliable Actors design pattern: Internet of Things</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Since IoT became the new trend alongside the technological advancement in both devices and cloud services, developers started looking at key building blocks to develop their systems on.</source>
          <target state="new">Since IoT became the new trend alongside the technological advancement in both devices and cloud services, developers started looking at key building blocks to develop their systems on.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The following diagram illustrates the key scenarios achieved using Service Fabric Reliable Actors:</source>
          <target state="new">The following diagram illustrates the key scenarios achieved using Service Fabric Reliable Actors:</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>![][1]</source>
          <target state="new">![][1]</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Service Fabric Reliable Actors is the key building block (as a middle-tier) in a system that combines a messaging system front end that supports multiple transports such as HTTPS, MQTT or AMQP then communicates with actors that represent individual devices.</source>
          <target state="new">Service Fabric Reliable Actors is the key building block (as a middle-tier) in a system that combines a messaging system front end that supports multiple transports such as HTTPS, MQTT or AMQP then communicates with actors that represent individual devices.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Because the actors can maintain state, modelling streams—especially stateful stream processing—and aggregation per device is straightforward.</source>
          <target state="new">Because the actors can maintain state, modelling streams—especially stateful stream processing—and aggregation per device is straightforward.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>If the data must be persisted, then we can also easily flush on demand or on a timer while still easily maintaining the latest N bits of data in another variable for quick querying.</source>
          <target state="new">If the data must be persisted, then we can also easily flush on demand or on a timer while still easily maintaining the latest N bits of data in another variable for quick querying.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Note that in our samples, we deliberately omitted the details of the event/messaging tier, which will allow actors to communicate with devices, to keep the focus on the actor model.</source>
          <target state="new">Note that in our samples, we deliberately omitted the details of the event/messaging tier, which will allow actors to communicate with devices, to keep the focus on the actor model.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>There are essentially two scenarios usually composed together:</source>
          <target state="new">There are essentially two scenarios usually composed together:</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Collecting telemetry and state data from a single or a set of devices and maintaining their state<ept id="p1">*</ept>.</source>
          <target state="new"><bpt id="p1">*</bpt>Collecting telemetry and state data from a single or a set of devices and maintaining their state<ept id="p1">*</ept>.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Think about tens of thousands of mouse traps (yes, this is a real customer scenario) sending data, as basic as whether the device trapped a nasty pest inside or not.</source>
          <target state="new">Think about tens of thousands of mouse traps (yes, this is a real customer scenario) sending data, as basic as whether the device trapped a nasty pest inside or not.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Data is aggregated by region, and with enough mice trapped in one region, an engineer is dispatched to clean up the devices.</source>
          <target state="new">Data is aggregated by region, and with enough mice trapped in one region, an engineer is dispatched to clean up the devices.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>A mouse-trap as an actor?</source>
          <target state="new">A mouse-trap as an actor?</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Absolutely.</source>
          <target state="new">Absolutely.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>A group actor per region as the aggregator?</source>
          <target state="new">A group actor per region as the aggregator?</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You bet.</source>
          <target state="new">You bet.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Pushing device behavior and configuration to a single or set of devices<ept id="p1">*</ept>.</source>
          <target state="new"><bpt id="p1">*</bpt>Pushing device behavior and configuration to a single or set of devices<ept id="p1">*</ept>.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Think about home solar power devices where the vendor pushes different configurations based on consumption patterns and seasonality.</source>
          <target state="new">Think about home solar power devices where the vendor pushes different configurations based on consumption patterns and seasonality.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Telemetry data and device grouping</source>
          <target state="new">Telemetry data and device grouping</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>First let’s have a look at the case where devices, think tens of thousands, are grouped together and are all sending telemetry data to their associated group.</source>
          <target state="new">First let’s have a look at the case where devices, think tens of thousands, are grouped together and are all sending telemetry data to their associated group.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In the following example, the customer has deployed devices to each region.</source>
          <target state="new">In the following example, the customer has deployed devices to each region.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>When the device is switched on, the first thing it does is send an ActivateMe message with relevant information such as location, version, and so on.</source>
          <target state="new">When the device is switched on, the first thing it does is send an ActivateMe message with relevant information such as location, version, and so on.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>In turn, the actor associated with the device (through the Device Id) sets up the initial state for the device, such as saving state locally (could have been persisted also) and registering a group actor.</source>
          <target state="new">In turn, the actor associated with the device (through the Device Id) sets up the initial state for the device, such as saving state locally (could have been persisted also) and registering a group actor.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>In this case, we assign a random group for our simulation.</source>
          <target state="new">In this case, we assign a random group for our simulation.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>As part of the initialization process, we can configure the device by retrieving configuration data from a group actor or some other agent.</source>
          <target state="new">As part of the initialization process, we can configure the device by retrieving configuration data from a group actor or some other agent.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>This way the devices can initially be pretty dumb and get their "smarts" upon initialization.</source>
          <target state="new">This way the devices can initially be pretty dumb and get their "smarts" upon initialization.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Once this is done, the device and the actor are ready to send and process telemetry data.</source>
          <target state="new">Once this is done, the device and the actor are ready to send and process telemetry data.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>All the devices periodically send their telemetry information to the corresponding actor.</source>
          <target state="new">All the devices periodically send their telemetry information to the corresponding actor.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>If the actor is already activated then the same actor will be used.</source>
          <target state="new">If the actor is already activated then the same actor will be used.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Otherwise it will be activated.</source>
          <target state="new">Otherwise it will be activated.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>At this point it can recover state from a stable store if required.</source>
          <target state="new">At this point it can recover state from a stable store if required.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>When the actor receives telemetry information it stores it to a local variable.</source>
          <target state="new">When the actor receives telemetry information it stores it to a local variable.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>We are doing this to simplify the sample.</source>
          <target state="new">We are doing this to simplify the sample.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>In a real implementation we would probably save it to an external store to allow operations to monitor and diagnose device health and performance.</source>
          <target state="new">In a real implementation we would probably save it to an external store to allow operations to monitor and diagnose device health and performance.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Finally, we push telemetry data to the group actor that the device actor logically belongs to.</source>
          <target state="new">Finally, we push telemetry data to the group actor that the device actor logically belongs to.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>IoT code sample – Telemetry</source>
          <target state="new">IoT code sample – Telemetry</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>At the group level, as per our sample, our goal is to monitor the devices in the group and aggregate telemetry data to produce alerts for engineers.</source>
          <target state="new">At the group level, as per our sample, our goal is to monitor the devices in the group and aggregate telemetry data to produce alerts for engineers.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In this case, our customer would like to send engineers to specific regions where there are a certain number of fault devices.</source>
          <target state="new">In this case, our customer would like to send engineers to specific regions where there are a certain number of fault devices.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Of course our customer would like to reduce costs by minimizing engineering time spent on the road.</source>
          <target state="new">Of course our customer would like to reduce costs by minimizing engineering time spent on the road.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>For this reason, each group actor maintains an aggregated state of faulty devices per region.</source>
          <target state="new">For this reason, each group actor maintains an aggregated state of faulty devices per region.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>When this number hits a threshold, our customer dispatches an engineer to the region to replace/repair these devices.</source>
          <target state="new">When this number hits a threshold, our customer dispatches an engineer to the region to replace/repair these devices.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Let’s have a look how it is done:</source>
          <target state="new">Let’s have a look how it is done:</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>IoT code sample – grouping and aggregation</source>
          <target state="new">IoT code sample – grouping and aggregation</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>As we can see it is pretty straight forward.</source>
          <target state="new">As we can see it is pretty straight forward.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>After running simple tests, the output looks like this:</source>
          <target state="new">After running simple tests, the output looks like this:</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>By the way, you may think it would have been better if devices were grouped by region.</source>
          <target state="new">By the way, you may think it would have been better if devices were grouped by region.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Of course, it's entirely up to us in terms of how to group/partition devices—whether it is geo-location, device type, version, tenant, and so on.</source>
          <target state="new">Of course, it's entirely up to us in terms of how to group/partition devices—whether it is geo-location, device type, version, tenant, and so on.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>There is a point of caution here: Device State vs. Reporting/Analysis.</source>
          <target state="new">There is a point of caution here: Device State vs. Reporting/Analysis.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>This is why we made the pattern illustration explicit.</source>
          <target state="new">This is why we made the pattern illustration explicit.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>We must avoid fan-out queries to actors to build reporting actors; unnecessary instantiations and performance are just to name two drawbacks.</source>
          <target state="new">We must avoid fan-out queries to actors to build reporting actors; unnecessary instantiations and performance are just to name two drawbacks.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>We recommend two approaches for reporting:</source>
          <target state="new">We recommend two approaches for reporting:</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Use group level actor, such as an aggregator, to maintain a view for the group.</source>
          <target state="new">Use group level actor, such as an aggregator, to maintain a view for the group.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Let each actor push only relevant data proactively to this actor.</source>
          <target state="new">Let each actor push only relevant data proactively to this actor.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Then this group level actor can be used to view the status of the devices in the group.</source>
          <target state="new">Then this group level actor can be used to view the status of the devices in the group.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Maintain an explicit store that is designed for reporting.</source>
          <target state="new">Maintain an explicit store that is designed for reporting.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>An aggregator can buffer and periodically push data to a reporting store for further querying and analysis.</source>
          <target state="new">An aggregator can buffer and periodically push data to a reporting store for further querying and analysis.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Device operation</source>
          <target state="new">Device operation</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>So far so good, but how about operations on these devices?</source>
          <target state="new">So far so good, but how about operations on these devices?</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Like for devices, actors can expose operational interfaces so an administrator can carry out operations on devices.</source>
          <target state="new">Like for devices, actors can expose operational interfaces so an administrator can carry out operations on devices.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>For example, an administrator wants to push a new configuration to a group of home solar energy devices (yep, another real life scenario) based on seasonal/regional changes.</source>
          <target state="new">For example, an administrator wants to push a new configuration to a group of home solar energy devices (yep, another real life scenario) based on seasonal/regional changes.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The key idea here is we have granular control over each device using “Thing” actors as well as group operations using “ThingGroup” actors —whether it is aggregating data coming in from devices such as telemetry or sending data such as configuration to large number of devices.</source>
          <target state="new">The key idea here is we have granular control over each device using “Thing” actors as well as group operations using “ThingGroup” actors —whether it is aggregating data coming in from devices such as telemetry or sending data such as configuration to large number of devices.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The platform takes care of distribution of the device actors and messaging between them, which is totally transparent to the developer.</source>
          <target state="new">The platform takes care of distribution of the device actors and messaging between them, which is totally transparent to the developer.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>When it comes to machine to machine (M2M) communications, both the Hub and Spoke pattern we discussed in the distributed networks and graphs section or direct actor-to-actor interaction works well.</source>
          <target state="new">When it comes to machine to machine (M2M) communications, both the Hub and Spoke pattern we discussed in the distributed networks and graphs section or direct actor-to-actor interaction works well.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>For M2M scenarios, we could model a “Directory/Index” actor for a group of devices allowing them to discover and send messages to each other as illustrated below:</source>
          <target state="new">For M2M scenarios, we could model a “Directory/Index” actor for a group of devices allowing them to discover and send messages to each other as illustrated below:</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>![][2]</source>
          <target state="new">![][2]</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Azure Service Fabric Actors also takes care of the lifetime of the Actors.</source>
          <target state="new">Azure Service Fabric Actors also takes care of the lifetime of the Actors.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Think of it this way, we will have always-on devices and we will have occasionally-connected devices.</source>
          <target state="new">Think of it this way, we will have always-on devices and we will have occasionally-connected devices.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Why would we keep the actor that looks after the device that connects every 14 hours in memory?</source>
          <target state="new">Why would we keep the actor that looks after the device that connects every 14 hours in memory?</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Azure Service Fabric allow save and restore of device state when we want it and where we want it.</source>
          <target state="new">Azure Service Fabric allow save and restore of device state when we want it and where we want it.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>We conclude that more and more customers will look at Azure Service Fabric Actors as a key building block for their IoT implementations.</source>
          <target state="new">We conclude that more and more customers will look at Azure Service Fabric Actors as a key building block for their IoT implementations.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="new">Next Steps</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Pattern: Smart Cache</source>
          <target state="new">Pattern: Smart Cache</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Pattern: Distributed Networks and Graphs</source>
          <target state="new">Pattern: Distributed Networks and Graphs</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Pattern: Resource Governance</source>
          <target state="new">Pattern: Resource Governance</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Pattern: Stateful Service Composition</source>
          <target state="new">Pattern: Stateful Service Composition</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Pattern: Distributed Computation</source>
          <target state="new">Pattern: Distributed Computation</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Some Anti-patterns</source>
          <target state="new">Some Anti-patterns</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Introduction to Service Fabric Actors</source>
          <target state="new">Introduction to Service Fabric Actors</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">45854a20c6b495a95f7a50104b12c26144254817</xliffext:olfilehash>
  </header>
</xliff>