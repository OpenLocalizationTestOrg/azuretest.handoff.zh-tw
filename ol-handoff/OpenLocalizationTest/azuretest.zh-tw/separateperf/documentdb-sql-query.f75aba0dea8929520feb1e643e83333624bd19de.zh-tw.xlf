<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Query with DocumentDB SQL | Microsoft Azure</source>
          <target state="new">Query with DocumentDB SQL | Microsoft Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>DocumentDB, a NoSQL document database service, supports queries using SQL-like grammar over hierarchical JSON documents without requiring explicit an schema or creation of secondary indexes.</source>
          <target state="new">DocumentDB, a NoSQL document database service, supports queries using SQL-like grammar over hierarchical JSON documents without requiring explicit an schema or creation of secondary indexes.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Query DocumentDB</source>
          <target state="new">Query DocumentDB</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Microsoft Azure DocumentDB supports querying documents using SQL (Structured Query Language) over hierarchical JSON documents.</source>
          <target state="new">Microsoft Azure DocumentDB supports querying documents using SQL (Structured Query Language) over hierarchical JSON documents.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>DocumentDB is truly schema-free.</source>
          <target state="new">DocumentDB is truly schema-free.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>By virtue of its commitment to the JSON data model directly within the database engine, it provides automatic indexing of JSON documents without requiring explicit schema or creation of secondary indexes.</source>
          <target state="new">By virtue of its commitment to the JSON data model directly within the database engine, it provides automatic indexing of JSON documents without requiring explicit schema or creation of secondary indexes.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>While designing the query language for DocumentDB we had two goals in mind:</source>
          <target state="new">While designing the query language for DocumentDB we had two goals in mind:</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Embrace SQL<ept id="p1">**</ept> – Instead of inventing a new query language, we wanted to embrace SQL.</source>
          <target state="new"><bpt id="p1">**</bpt>Embrace SQL<ept id="p1">**</ept> – Instead of inventing a new query language, we wanted to embrace SQL.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>After all, SQL is one of the most familiar and popular query languages.</source>
          <target state="new">After all, SQL is one of the most familiar and popular query languages.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>DocumentDB SQL provides a formal programming model for rich queries over JSON documents.</source>
          <target state="new">DocumentDB SQL provides a formal programming model for rich queries over JSON documents.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Extend SQL<ept id="p1">**</ept> – As a JSON document database capable of executing JavaScript directly in the database engine, we wanted to use JavaScript's programming model as the foundation for our query language.</source>
          <target state="new"><bpt id="p1">**</bpt>Extend SQL<ept id="p1">**</ept> – As a JSON document database capable of executing JavaScript directly in the database engine, we wanted to use JavaScript's programming model as the foundation for our query language.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The DocumentDB SQL is rooted in JavaScript's type system, expression evaluation, and function invocation.</source>
          <target state="new">The DocumentDB SQL is rooted in JavaScript's type system, expression evaluation, and function invocation.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This in-turn provides a natural programming model for relational projections, hierarchical navigation across JSON documents, self joins, and invocation of user defined functions (UDFs) written entirely in JavaScript, among other features.</source>
          <target state="new">This in-turn provides a natural programming model for relational projections, hierarchical navigation across JSON documents, self joins, and invocation of user defined functions (UDFs) written entirely in JavaScript, among other features.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>We believe that these capabilities are key to reducing the friction between the application and the database and are crucial for developer productivity.</source>
          <target state="new">We believe that these capabilities are key to reducing the friction between the application and the database and are crucial for developer productivity.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>We recommend getting started by watching the following video, where Aravind Ramachandran shows DocumentDB's querying capabilities, and by visiting our <bpt id="p1">[</bpt>Query Playground<ept id="p1">](http://www.documentdb.com/sql/demo)</ept>, where you can try out DocumentDB and run SQL queries against our dataset.</source>
          <target state="new">We recommend getting started by watching the following video, where Aravind Ramachandran shows DocumentDB's querying capabilities, and by visiting our <bpt id="p1">[</bpt>Query Playground<ept id="p1">](http://www.documentdb.com/sql/demo)</ept>, where you can try out DocumentDB and run SQL queries against our dataset.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Then, return to this article, where we'll start by walking through some simple JSON documents and queries.</source>
          <target state="new">Then, return to this article, where we'll start by walking through some simple JSON documents and queries.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="new">Getting started</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>To see DocumentDB SQL at work, let's begin with a few simple JSON documents and walk through some simple queries against it.</source>
          <target state="new">To see DocumentDB SQL at work, let's begin with a few simple JSON documents and walk through some simple queries against it.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Consider these two JSON documents about two families.</source>
          <target state="new">Consider these two JSON documents about two families.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Note that with DocumentDB, we do not need to create any schemas or secondary indices explicitly.</source>
          <target state="new">Note that with DocumentDB, we do not need to create any schemas or secondary indices explicitly.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>We simply need to insert the JSON documents to a DocumentDB collection and subsequently query.</source>
          <target state="new">We simply need to insert the JSON documents to a DocumentDB collection and subsequently query.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Here we have a simple JSON document for the Andersen family, the parents, children (and their pets), address and registration information.</source>
          <target state="new">Here we have a simple JSON document for the Andersen family, the parents, children (and their pets), address and registration information.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The document has strings, numbers, booleans, arrays and nested properties.</source>
          <target state="new">The document has strings, numbers, booleans, arrays and nested properties.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Document</source>
          <target state="new">Document</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Here's a second document with one subtle difference – <ph id="ph1">`givenName`</ph> and <ph id="ph2">`familyName`</ph> are used instead of <ph id="ph3">`firstName`</ph> and <ph id="ph4">`lastName`</ph>.</source>
          <target state="new">Here's a second document with one subtle difference – <ph id="ph1">`givenName`</ph> and <ph id="ph2">`familyName`</ph> are used instead of <ph id="ph3">`firstName`</ph> and <ph id="ph4">`lastName`</ph>.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Document</source>
          <target state="new">Document</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Now let's try a few queries against this data to understand some of the key aspects of DocumentDB SQL.</source>
          <target state="new">Now let's try a few queries against this data to understand some of the key aspects of DocumentDB SQL.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>For example, the following query will return the documents where the id field matches <ph id="ph1">`AndersenFamily`</ph>.</source>
          <target state="new">For example, the following query will return the documents where the id field matches <ph id="ph1">`AndersenFamily`</ph>.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Since it's a <ph id="ph1">`SELECT *`</ph>, the output of the query is the complete JSON document:</source>
          <target state="new">Since it's a <ph id="ph1">`SELECT *`</ph>, the output of the query is the complete JSON document:</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Now consider the case where we need to reformat the JSON output in a different shape.</source>
          <target state="new">Now consider the case where we need to reformat the JSON output in a different shape.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>This query projects a new JSON object with two selected fields, Name and City, when the address' city has the same name as the state.</source>
          <target state="new">This query projects a new JSON object with two selected fields, Name and City, when the address' city has the same name as the state.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>In this case, "NY, NY" matches.</source>
          <target state="new">In this case, "NY, NY" matches.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The next query returns all the given names of children in the family whose id matches <ph id="ph1">`WakefieldFamily`</ph> ordered by the city of residence.</source>
          <target state="new">The next query returns all the given names of children in the family whose id matches <ph id="ph1">`WakefieldFamily`</ph> ordered by the city of residence.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>We would like to draw attention to a few noteworthy aspects of the DocumentDB query language through the examples we've seen so far:</source>
          <target state="new">We would like to draw attention to a few noteworthy aspects of the DocumentDB query language through the examples we've seen so far:</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Since DocumentDB SQL works on JSON values, it deals with tree shaped entities instead of rows and columns.</source>
          <target state="new">Since DocumentDB SQL works on JSON values, it deals with tree shaped entities instead of rows and columns.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Therefore, the language lets you refer to nodes of the tree at any arbitrary depth, like <ph id="ph1">`Node1.Node2.Node3…..Nodem`</ph>, similar to relational SQL referring to the two part reference of <ph id="ph2">`&lt;table&gt;.&lt;column&gt;`</ph>.</source>
          <target state="new">Therefore, the language lets you refer to nodes of the tree at any arbitrary depth, like <ph id="ph1">`Node1.Node2.Node3…..Nodem`</ph>, similar to relational SQL referring to the two part reference of <ph id="ph2">`&lt;table&gt;.&lt;column&gt;`</ph>.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The language works with schema-less data.</source>
          <target state="new">The language works with schema-less data.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Therefore, the type system needs to be bound dynamically.</source>
          <target state="new">Therefore, the type system needs to be bound dynamically.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The same expression could yield different types on different documents.</source>
          <target state="new">The same expression could yield different types on different documents.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The result of a query is a valid JSON value, but is not guaranteed to be of a fixed schema.</source>
          <target state="new">The result of a query is a valid JSON value, but is not guaranteed to be of a fixed schema.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>DocumentDB only supports strict JSON documents.</source>
          <target state="new">DocumentDB only supports strict JSON documents.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>This means the type system and expressions are restricted to deal only with JSON types.</source>
          <target state="new">This means the type system and expressions are restricted to deal only with JSON types.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Please refer to the <bpt id="p1">[</bpt>JSON specification<ept id="p1">](http://www.json.org/)</ept> for more details.</source>
          <target state="new">Please refer to the <bpt id="p1">[</bpt>JSON specification<ept id="p1">](http://www.json.org/)</ept> for more details.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>A DocumentDB collection is a schema-free container of JSON documents.</source>
          <target state="new">A DocumentDB collection is a schema-free container of JSON documents.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The relations in data entities within and across documents in a collection are implicitly captured by containment and not by primary key and foreign key relations.</source>
          <target state="new">The relations in data entities within and across documents in a collection are implicitly captured by containment and not by primary key and foreign key relations.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>This is an important aspect worth pointing out in light of the intra-document joins discussed later in this article.</source>
          <target state="new">This is an important aspect worth pointing out in light of the intra-document joins discussed later in this article.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>DocumentDB indexing</source>
          <target state="new">DocumentDB indexing</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Before we get into the DocumentDB SQL grammar, it is worth exploring the indexing design in DocumentDB.</source>
          <target state="new">Before we get into the DocumentDB SQL grammar, it is worth exploring the indexing design in DocumentDB.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The purpose of database indexes is to serve queries in their various forms and shapes with minimum resource consumption (like CPU and input/output) while providing good throughput and low latency.</source>
          <target state="new">The purpose of database indexes is to serve queries in their various forms and shapes with minimum resource consumption (like CPU and input/output) while providing good throughput and low latency.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Often, the choice of the right index for querying a database requires much planning and experimentation.</source>
          <target state="new">Often, the choice of the right index for querying a database requires much planning and experimentation.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>This approach poses a challenge for schema-less databases where the data doesn’t conform to a strict schema and evolves rapidly.</source>
          <target state="new">This approach poses a challenge for schema-less databases where the data doesn’t conform to a strict schema and evolves rapidly.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Therefore, when we designed the DocumentDB indexing subsystem, we set the following goals:</source>
          <target state="new">Therefore, when we designed the DocumentDB indexing subsystem, we set the following goals:</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Index documents without requiring schema: The indexing subsystem does not require any schema information or make any assumptions about schema of the documents.</source>
          <target state="new">Index documents without requiring schema: The indexing subsystem does not require any schema information or make any assumptions about schema of the documents.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Support for efficient, rich hierarchical, and relational queries: The index supports the DocumentDB query language efficiently, including support for hierarchical and relational projections.</source>
          <target state="new">Support for efficient, rich hierarchical, and relational queries: The index supports the DocumentDB query language efficiently, including support for hierarchical and relational projections.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Support for consistent queries in face of a sustained volume of writes: For high write throughput workloads with consistent queries, the index is updated incrementally, efficiently, and online in the face of a sustained volume of writes.</source>
          <target state="new">Support for consistent queries in face of a sustained volume of writes: For high write throughput workloads with consistent queries, the index is updated incrementally, efficiently, and online in the face of a sustained volume of writes.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The consistent index update is crucial to serve the queries at the consistency level in which the user configured the document service.</source>
          <target state="new">The consistent index update is crucial to serve the queries at the consistency level in which the user configured the document service.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Support for multi-tenancy: Given the reservation based model for resource governance across tenants, index updates are performed within the budget of system resources (CPU, memory, and input/output operations per second) allocated per replica.</source>
          <target state="new">Support for multi-tenancy: Given the reservation based model for resource governance across tenants, index updates are performed within the budget of system resources (CPU, memory, and input/output operations per second) allocated per replica.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Storage efficiency: For cost effectiveness, the on-disk storage overhead of the index is bounded and predictable.</source>
          <target state="new">Storage efficiency: For cost effectiveness, the on-disk storage overhead of the index is bounded and predictable.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>This is crucial because DocumentDB allows the developer to make cost based tradeoffs between index overhead in relation to the query performance.</source>
          <target state="new">This is crucial because DocumentDB allows the developer to make cost based tradeoffs between index overhead in relation to the query performance.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Refer to the <bpt id="p1">[</bpt>DocumentDB samples<ept id="p1">](https://github.com/Azure/azure-documentdb-net)</ept> on MSDN for samples showing how to configure the indexing policy for a collection.</source>
          <target state="new">Refer to the <bpt id="p1">[</bpt>DocumentDB samples<ept id="p1">](https://github.com/Azure/azure-documentdb-net)</ept> on MSDN for samples showing how to configure the indexing policy for a collection.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Let’s now get into the details of the DocumentDB SQL grammar.</source>
          <target state="new">Let’s now get into the details of the DocumentDB SQL grammar.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Basics of DocumentDB query</source>
          <target state="new">Basics of DocumentDB query</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Every query consists of a SELECT clause and optional FROM and WHERE clauses per ANSI-SQL standards.</source>
          <target state="new">Every query consists of a SELECT clause and optional FROM and WHERE clauses per ANSI-SQL standards.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Typically, for each query, the source in the FROM clause is enumerated.</source>
          <target state="new">Typically, for each query, the source in the FROM clause is enumerated.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Then the filter in the WHERE clause is applied on the source to retrieve a subset of JSON documents.</source>
          <target state="new">Then the filter in the WHERE clause is applied on the source to retrieve a subset of JSON documents.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Finally, the SELECT clause is used to project the requested JSON values in the select list.</source>
          <target state="new">Finally, the SELECT clause is used to project the requested JSON values in the select list.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>FROM clause</source>
          <target state="new">FROM clause</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`FROM &lt;from_specification&gt;`</ph> clause is optional unless the source is filtered or projected later in the query.</source>
          <target state="new">The <ph id="ph1">`FROM &lt;from_specification&gt;`</ph> clause is optional unless the source is filtered or projected later in the query.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The purpose of this clause is to specify the data source upon which the query must operate.</source>
          <target state="new">The purpose of this clause is to specify the data source upon which the query must operate.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Commonly the whole collection is the source, but one can specify a subset of the collection instead.</source>
          <target state="new">Commonly the whole collection is the source, but one can specify a subset of the collection instead.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>A query like <ph id="ph1">`SELECT * FROM Families`</ph> indicates that the entire Families collection is the source over which to enumerate.</source>
          <target state="new">A query like <ph id="ph1">`SELECT * FROM Families`</ph> indicates that the entire Families collection is the source over which to enumerate.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>A special identifier ROOT can be used to represent the collection instead of using the collection name.</source>
          <target state="new">A special identifier ROOT can be used to represent the collection instead of using the collection name.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The following list contains the rules that are enforced per query:</source>
          <target state="new">The following list contains the rules that are enforced per query:</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The collection can be aliased, such as <ph id="ph1">`SELECT f.id FROM Families AS f`</ph> or simply <ph id="ph2">`SELECT f.id FROM Families f`</ph>.</source>
          <target state="new">The collection can be aliased, such as <ph id="ph1">`SELECT f.id FROM Families AS f`</ph> or simply <ph id="ph2">`SELECT f.id FROM Families f`</ph>.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Here <ph id="ph1">`f`</ph> is the equivalent of <ph id="ph2">`Families`</ph>.</source>
          <target state="new">Here <ph id="ph1">`f`</ph> is the equivalent of <ph id="ph2">`Families`</ph>.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`AS`</ph> is an optional keyword to alias the identifier.</source>
          <target state="new"><ph id="ph1">`AS`</ph> is an optional keyword to alias the identifier.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Note that once aliased, the original source cannot be bound.</source>
          <target state="new">Note that once aliased, the original source cannot be bound.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`SELECT Families.id FROM Families f`</ph> is syntactically invalid since the identifier "Families" cannot be resolved anymore.</source>
          <target state="new">For example, <ph id="ph1">`SELECT Families.id FROM Families f`</ph> is syntactically invalid since the identifier "Families" cannot be resolved anymore.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>All properties that need to be referenced must be fully qualified.</source>
          <target state="new">All properties that need to be referenced must be fully qualified.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>In the absence of strict schema adherence, this is enforced to avoid any ambiguous bindings.</source>
          <target state="new">In the absence of strict schema adherence, this is enforced to avoid any ambiguous bindings.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Therefore, <ph id="ph1">`SELECT id FROM Families f`</ph> is syntactically invalid since the property <ph id="ph2">`id`</ph> is not bound.</source>
          <target state="new">Therefore, <ph id="ph1">`SELECT id FROM Families f`</ph> is syntactically invalid since the property <ph id="ph2">`id`</ph> is not bound.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Sub-documents</source>
          <target state="new">Sub-documents</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The source can also be reduced to a smaller subset.</source>
          <target state="new">The source can also be reduced to a smaller subset.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>For instance, to enumerating only a sub-tree in each document, the sub-root could then become the source, as shown in the following example.</source>
          <target state="new">For instance, to enumerating only a sub-tree in each document, the sub-root could then become the source, as shown in the following example.</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>While the above example used an array as the source, an object could also be used as the source, which is what's shown in the following example.</source>
          <target state="new">While the above example used an array as the source, an object could also be used as the source, which is what's shown in the following example.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Any valid JSON value (not undefined) that can be found in the source will be considered for inclusion in the result of the query.</source>
          <target state="new">Any valid JSON value (not undefined) that can be found in the source will be considered for inclusion in the result of the query.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>If some families don’t have an <ph id="ph1">`address.state`</ph> value, they will be excluded in the query result.</source>
          <target state="new">If some families don’t have an <ph id="ph1">`address.state`</ph> value, they will be excluded in the query result.</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>WHERE clause</source>
          <target state="new">WHERE clause</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The WHERE clause (<bpt id="p1">**</bpt><ph id="ph1">`WHERE &lt;filter_condition&gt;`</ph><ept id="p1">**</ept>) is optional.</source>
          <target state="new">The WHERE clause (<bpt id="p1">**</bpt><ph id="ph1">`WHERE &lt;filter_condition&gt;`</ph><ept id="p1">**</ept>) is optional.</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>It specifies the condition(s) that the JSON documents provided by the source must satisfy in order to be included as part of the result.</source>
          <target state="new">It specifies the condition(s) that the JSON documents provided by the source must satisfy in order to be included as part of the result.</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Any JSON document must evaluate the specified conditions to "true" to be considered for the result.</source>
          <target state="new">Any JSON document must evaluate the specified conditions to "true" to be considered for the result.</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The WHERE clause is used by the index layer in order to determine the absolute smallest subset of source documents that can be part of the result.</source>
          <target state="new">The WHERE clause is used by the index layer in order to determine the absolute smallest subset of source documents that can be part of the result.</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The following query requests documents that contain a name property whose value is <ph id="ph1">`AndersenFamily`</ph>.</source>
          <target state="new">The following query requests documents that contain a name property whose value is <ph id="ph1">`AndersenFamily`</ph>.</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Any other document that does not have a name property, or where the value does not match <ph id="ph1">`AndersenFamily`</ph> is excluded.</source>
          <target state="new">Any other document that does not have a name property, or where the value does not match <ph id="ph1">`AndersenFamily`</ph> is excluded.</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The previous example showed a simple equality query.</source>
          <target state="new">The previous example showed a simple equality query.</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>DocumentDB SQL also supports a variety of scalar expressions.</source>
          <target state="new">DocumentDB SQL also supports a variety of scalar expressions.</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The most commonly used are binary and unary expressions.</source>
          <target state="new">The most commonly used are binary and unary expressions.</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Property references from the source JSON object are also valid expressions.</source>
          <target state="new">Property references from the source JSON object are also valid expressions.</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The following binary operators are currently supported and can be used in queries as shown in the following examples:</source>
          <target state="new">The following binary operators are currently supported and can be used in queries as shown in the following examples:</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Arithmetic</source>
          <target state="new">Arithmetic</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>+,-,*,/,%</source>
          <target state="new">+,-,*,/,%</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Bitwise</source>
          <target state="new">Bitwise</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>|, &amp;, ^, &lt;</source>
          <target state="new">|, &amp;, ^, &lt;</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>, &gt;&gt;&gt; (zero-fill right shift)</source>
          <target state="new">, &gt;&gt;&gt; (zero-fill right shift)</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Logical</source>
          <target state="new">Logical</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>AND, OR, NOT</source>
          <target state="new">AND, OR, NOT</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Comparison</source>
          <target state="new">Comparison</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>=, !=, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, &lt;&gt;</source>
          <target state="new">=, !=, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, &lt;&gt;</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="new">String</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>|| (concatenate)</source>
          <target state="new">|| (concatenate)</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Let’s take a look at some queries using binary operators.</source>
          <target state="new">Let’s take a look at some queries using binary operators.</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The unary operators +,-, ~ and NOT are also supported, and can be used inside queries as shown in the following example:</source>
          <target state="new">The unary operators +,-, ~ and NOT are also supported, and can be used inside queries as shown in the following example:</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>In addition to binary and unary operators, property references are also allowed.</source>
          <target state="new">In addition to binary and unary operators, property references are also allowed.</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`SELECT * FROM Families f WHERE f.isRegistered`</ph> returns the JSON document containing the property <ph id="ph2">`isRegistered`</ph> where the property's value is equal to the JSON <ph id="ph3">`true`</ph> value.</source>
          <target state="new">For example, <ph id="ph1">`SELECT * FROM Families f WHERE f.isRegistered`</ph> returns the JSON document containing the property <ph id="ph2">`isRegistered`</ph> where the property's value is equal to the JSON <ph id="ph3">`true`</ph> value.</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Any other values (false, null, Undefined, <ph id="ph1">`&lt;number&gt;`</ph>, <ph id="ph2">`&lt;string&gt;`</ph>, <ph id="ph3">`&lt;object&gt;`</ph>, <ph id="ph4">`&lt;array&gt;`</ph>, etc.) leads to the source document being excluded from the result.</source>
          <target state="new">Any other values (false, null, Undefined, <ph id="ph1">`&lt;number&gt;`</ph>, <ph id="ph2">`&lt;string&gt;`</ph>, <ph id="ph3">`&lt;object&gt;`</ph>, <ph id="ph4">`&lt;array&gt;`</ph>, etc.) leads to the source document being excluded from the result.</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Equality and comparison operators</source>
          <target state="new">Equality and comparison operators</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The following table shows the result of equality comparisons in DocumentDB SQL between any two JSON types.</source>
          <target state="new">The following table shows the result of equality comparisons in DocumentDB SQL between any two JSON types.</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
            &lt;strong&gt;</ph>Op<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></source>
          <target state="new"><ph id="ph1">
            &lt;strong&gt;</ph>Op<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
            &lt;strong&gt;</ph>Undefined<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></source>
          <target state="new"><ph id="ph1">
            &lt;strong&gt;</ph>Undefined<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
            &lt;strong&gt;</ph>Null<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></source>
          <target state="new"><ph id="ph1">
            &lt;strong&gt;</ph>Null<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
            &lt;strong&gt;</ph>Boolean<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></source>
          <target state="new"><ph id="ph1">
            &lt;strong&gt;</ph>Boolean<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
            &lt;strong&gt;</ph>Number<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></source>
          <target state="new"><ph id="ph1">
            &lt;strong&gt;</ph>Number<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
            &lt;strong&gt;</ph>String<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></source>
          <target state="new"><ph id="ph1">
            &lt;strong&gt;</ph>String<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
            &lt;strong&gt;</ph>Object<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></source>
          <target state="new"><ph id="ph1">
            &lt;strong&gt;</ph>Object<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
            &lt;strong&gt;</ph>Array<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></source>
          <target state="new"><ph id="ph1">
            &lt;strong&gt;</ph>Array<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
            &lt;strong&gt;</ph>Undefined<ph id="ph2">&lt;strong&gt;</ph><ph id="ph3">
         </ph></source>
          <target state="new"><ph id="ph1">
            &lt;strong&gt;</ph>Undefined<ph id="ph2">&lt;strong&gt;</ph><ph id="ph3">
         </ph></target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
            &lt;strong&gt;</ph>Null<ph id="ph2">&lt;strong&gt;</ph><ph id="ph3">
         </ph></source>
          <target state="new"><ph id="ph1">
            &lt;strong&gt;</ph>Null<ph id="ph2">&lt;strong&gt;</ph><ph id="ph3">
         </ph></target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
            &lt;strong&gt;</ph>OK<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></source>
          <target state="new"><ph id="ph1">
            &lt;strong&gt;</ph>OK<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
            &lt;strong&gt;</ph>Boolean<ph id="ph2">&lt;strong&gt;</ph><ph id="ph3">
         </ph></source>
          <target state="new"><ph id="ph1">
            &lt;strong&gt;</ph>Boolean<ph id="ph2">&lt;strong&gt;</ph><ph id="ph3">
         </ph></target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
            &lt;strong&gt;</ph>OK<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></source>
          <target state="new"><ph id="ph1">
            &lt;strong&gt;</ph>OK<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
            &lt;strong&gt;</ph>Number<ph id="ph2">&lt;strong&gt;</ph><ph id="ph3">
         </ph></source>
          <target state="new"><ph id="ph1">
            &lt;strong&gt;</ph>Number<ph id="ph2">&lt;strong&gt;</ph><ph id="ph3">
         </ph></target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
            &lt;strong&gt;</ph>OK<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></source>
          <target state="new"><ph id="ph1">
            &lt;strong&gt;</ph>OK<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
            &lt;strong&gt;</ph>String<ph id="ph2">&lt;strong&gt;</ph><ph id="ph3">
         </ph></source>
          <target state="new"><ph id="ph1">
            &lt;strong&gt;</ph>String<ph id="ph2">&lt;strong&gt;</ph><ph id="ph3">
         </ph></target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
            &lt;strong&gt;</ph>OK<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></source>
          <target state="new"><ph id="ph1">
            &lt;strong&gt;</ph>OK<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
            &lt;strong&gt;</ph>Object<ph id="ph2">&lt;strong&gt;</ph><ph id="ph3">
         </ph></source>
          <target state="new"><ph id="ph1">
            &lt;strong&gt;</ph>Object<ph id="ph2">&lt;strong&gt;</ph><ph id="ph3">
         </ph></target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
            &lt;strong&gt;</ph>OK<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></source>
          <target state="new"><ph id="ph1">
            &lt;strong&gt;</ph>OK<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
            &lt;strong&gt;</ph>Array<ph id="ph2">&lt;strong&gt;</ph><ph id="ph3">
         </ph></source>
          <target state="new"><ph id="ph1">
            &lt;strong&gt;</ph>Array<ph id="ph2">&lt;strong&gt;</ph><ph id="ph3">
         </ph></target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
            &lt;strong&gt;</ph>OK<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></source>
          <target state="new"><ph id="ph1">
            &lt;strong&gt;</ph>OK<ph id="ph2">&lt;/strong&gt;</ph><ph id="ph3">
         </ph></target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>For other comparison operators such as &gt;, &gt;=, !=, &lt; and &lt;=, the following rules apply:</source>
          <target state="new">For other comparison operators such as &gt;, &gt;=, !=, &lt; and &lt;=, the following rules apply:</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Comparison across types results in Undefined.</source>
          <target state="new">Comparison across types results in Undefined.</target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Comparison between two objects or two arrays results in Undefined.</source>
          <target state="new">Comparison between two objects or two arrays results in Undefined.</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>If the result of the scalar expression in the filter is Undefined, the corresponding document would not be included in the result, since Undefined doesn't logically equate to "true".</source>
          <target state="new">If the result of the scalar expression in the filter is Undefined, the corresponding document would not be included in the result, since Undefined doesn't logically equate to "true".</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>BETWEEN keyword</source>
          <target state="new">BETWEEN keyword</target>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>You can also use the BETWEEN keyword to express queries against ranges of values like in ANSI SQL.</source>
          <target state="new">You can also use the BETWEEN keyword to express queries against ranges of values like in ANSI SQL.</target>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>BETWEEN can be used against any JSON primitive type (numbers, strings, Booleans and nulls).</source>
          <target state="new">BETWEEN can be used against any JSON primitive type (numbers, strings, Booleans and nulls).</target>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>For example, this query returns all family documents in which the first child's grade is between 1-5 (both inclusive).</source>
          <target state="new">For example, this query returns all family documents in which the first child's grade is between 1-5 (both inclusive).</target>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Unlike in ANSI-SQL, you can also use the BETWEEN clause in the FROM clause like in the following example.</source>
          <target state="new">Unlike in ANSI-SQL, you can also use the BETWEEN clause in the FROM clause like in the following example.</target>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>For faster query execution times, remember to create an indexing policy that uses a range index type against any numeric properties/paths that are filtered in the BETWEEN clause.</source>
          <target state="new">For faster query execution times, remember to create an indexing policy that uses a range index type against any numeric properties/paths that are filtered in the BETWEEN clause.</target>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>The main difference between using BETWEEN in DocumentDB and ANSI SQL is that you can express range queries against properties of mixed types – for example, you might have "grade" be a number (5) in some documents and strings in others ("grade4").</source>
          <target state="new">The main difference between using BETWEEN in DocumentDB and ANSI SQL is that you can express range queries against properties of mixed types – for example, you might have "grade" be a number (5) in some documents and strings in others ("grade4").</target>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>In these cases, like in JavaScript, a comparison between two different types results in "undefined", and the document will be skipped.</source>
          <target state="new">In these cases, like in JavaScript, a comparison between two different types results in "undefined", and the document will be skipped.</target>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Logical (AND, OR and NOT) operators</source>
          <target state="new">Logical (AND, OR and NOT) operators</target>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Logical operators operate on Boolean values.</source>
          <target state="new">Logical operators operate on Boolean values.</target>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The logical truth tables for these operators are shown in the following tables.</source>
          <target state="new">The logical truth tables for these operators are shown in the following tables.</target>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="new">OR</target>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="new">True</target>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="new">False</target>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Undefined</source>
          <target state="new">Undefined</target>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="new">True</target>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="new">True</target>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="new">True</target>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="new">True</target>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="new">False</target>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="new">True</target>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="new">False</target>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Undefined</source>
          <target state="new">Undefined</target>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Undefined</source>
          <target state="new">Undefined</target>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="new">True</target>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Undefined</source>
          <target state="new">Undefined</target>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Undefined</source>
          <target state="new">Undefined</target>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>AND</source>
          <target state="new">AND</target>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="new">True</target>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="new">False</target>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Undefined</source>
          <target state="new">Undefined</target>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="new">True</target>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="new">True</target>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="new">False</target>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Undefined</source>
          <target state="new">Undefined</target>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="new">False</target>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="new">False</target>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="new">False</target>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="new">False</target>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Undefined</source>
          <target state="new">Undefined</target>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Undefined</source>
          <target state="new">Undefined</target>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="new">False</target>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Undefined</source>
          <target state="new">Undefined</target>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="new">NOT</target>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="new">True</target>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="new">False</target>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="new">False</target>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="new">True</target>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Undefined</source>
          <target state="new">Undefined</target>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Undefined</source>
          <target state="new">Undefined</target>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>IN keyword</source>
          <target state="new">IN keyword</target>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>The IN keyword can be used to check whether a specified value matches any value in a list.</source>
          <target state="new">The IN keyword can be used to check whether a specified value matches any value in a list.</target>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>For example, this query returns all family documents where the id is one of "WakefieldFamily" or "AndersenFamily".</source>
          <target state="new">For example, this query returns all family documents where the id is one of "WakefieldFamily" or "AndersenFamily".</target>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>This example returns all documents where the state is any of the specified values.</source>
          <target state="new">This example returns all documents where the state is any of the specified values.</target>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>IN is equivalent to chaining multiple OR clauses, however since it can be served using a single index, DocumentDB supports a higher <bpt id="p1">[</bpt>limit<ept id="p1">](documentdb-limits.md)</ept> for the number of arguments specified within an IN clause.</source>
          <target state="new">IN is equivalent to chaining multiple OR clauses, however since it can be served using a single index, DocumentDB supports a higher <bpt id="p1">[</bpt>limit<ept id="p1">](documentdb-limits.md)</ept> for the number of arguments specified within an IN clause.</target>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Ternary (?) and Coalesce (??) operators</source>
          <target state="new">Ternary (?) and Coalesce (??) operators</target>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>The Ternary and Coalesce operators can be used to build conditional expressions, similar to popular programming languages like C# and JavaScript.</source>
          <target state="new">The Ternary and Coalesce operators can be used to build conditional expressions, similar to popular programming languages like C# and JavaScript.</target>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>The Ternary (?) operator can be very handy when constructing new JSON properties on the fly.</source>
          <target state="new">The Ternary (?) operator can be very handy when constructing new JSON properties on the fly.</target>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>For example, now you can write queries to classify the class levels into a human readable form like Beginner/Intermediate/Advanced as shown below.</source>
          <target state="new">For example, now you can write queries to classify the class levels into a human readable form like Beginner/Intermediate/Advanced as shown below.</target>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>You can also nest the calls to the operator like in the query below.</source>
          <target state="new">You can also nest the calls to the operator like in the query below.</target>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>As with other query operators, if the referenced properties in the conditional expression are missing in any document, or if the types being compared are different, then those documents will be excluded in the query results.</source>
          <target state="new">As with other query operators, if the referenced properties in the conditional expression are missing in any document, or if the types being compared are different, then those documents will be excluded in the query results.</target>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>The Coalesce (??) operator can be used to efficiently check for the presence of a property (a.k.a.</source>
          <target state="new">The Coalesce (??) operator can be used to efficiently check for the presence of a property (a.k.a.</target>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>is defined) in a document.</source>
          <target state="new">is defined) in a document.</target>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>This is useful when querying against semi-structured or data of mixed types.</source>
          <target state="new">This is useful when querying against semi-structured or data of mixed types.</target>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>For example, this query returns the "lastName" if present, or the "surname" if it isn't present.</source>
          <target state="new">For example, this query returns the "lastName" if present, or the "surname" if it isn't present.</target>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Quoted property accessor</source>
          <target state="new">Quoted property accessor</target>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>You can also access properties using the quoted property operator <ph id="ph1">`[]`</ph>.</source>
          <target state="new">You can also access properties using the quoted property operator <ph id="ph1">`[]`</ph>.</target>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`SELECT c.grade`</ph> and <ph id="ph2">`SELECT c["grade"]`</ph> are equivalent.</source>
          <target state="new">For example, <ph id="ph1">`SELECT c.grade`</ph> and <ph id="ph2">`SELECT c["grade"]`</ph> are equivalent.</target>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>This syntax is useful when you need to escape a property that contains spaces, special characters, or happens to share the same name as a SQL keyword or reserved word.</source>
          <target state="new">This syntax is useful when you need to escape a property that contains spaces, special characters, or happens to share the same name as a SQL keyword or reserved word.</target>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>SELECT clause</source>
          <target state="new">SELECT clause</target>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The SELECT clause (<bpt id="p1">**</bpt><ph id="ph1">`SELECT &lt;select_list&gt;`</ph><ept id="p1">**</ept>) is mandatory and specifies what values will be retrieved from the query, just like in ANSI-SQL.</source>
          <target state="new">The SELECT clause (<bpt id="p1">**</bpt><ph id="ph1">`SELECT &lt;select_list&gt;`</ph><ept id="p1">**</ept>) is mandatory and specifies what values will be retrieved from the query, just like in ANSI-SQL.</target>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The subset that's been filtered on top of the source documents are passed onto the projection phase, where the specified JSON values are retrieved and a new JSON object is constructed, for each input passed onto it.</source>
          <target state="new">The subset that's been filtered on top of the source documents are passed onto the projection phase, where the specified JSON values are retrieved and a new JSON object is constructed, for each input passed onto it.</target>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The following example shows a typical SELECT query.</source>
          <target state="new">The following example shows a typical SELECT query.</target>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Nested properties</source>
          <target state="new">Nested properties</target>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>In the following example, we are projecting two nested properties <ph id="ph1">`f.address.state`</ph> and <ph id="ph2">`f.address.city`</ph>.</source>
          <target state="new">In the following example, we are projecting two nested properties <ph id="ph1">`f.address.state`</ph> and <ph id="ph2">`f.address.city`</ph>.</target>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Projection also supports JSON expressions as shown in the following example.</source>
          <target state="new">Projection also supports JSON expressions as shown in the following example.</target>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>Let's look at the role of <ph id="ph1">`$1`</ph> here.</source>
          <target state="new">Let's look at the role of <ph id="ph1">`$1`</ph> here.</target>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`SELECT`</ph> clause needs to create a JSON object and since no key is provided, we use implicit argument variable names starting with <ph id="ph2">`$1`</ph>.</source>
          <target state="new">The <ph id="ph1">`SELECT`</ph> clause needs to create a JSON object and since no key is provided, we use implicit argument variable names starting with <ph id="ph2">`$1`</ph>.</target>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>For example, this query returns two implicit argument variables, labeled <ph id="ph1">`$1`</ph> and <ph id="ph2">`$2`</ph>.</source>
          <target state="new">For example, this query returns two implicit argument variables, labeled <ph id="ph1">`$1`</ph> and <ph id="ph2">`$2`</ph>.</target>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>Aliasing</source>
          <target state="new">Aliasing</target>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Now let's extend the example above with explicit aliasing of values.</source>
          <target state="new">Now let's extend the example above with explicit aliasing of values.</target>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>AS is the keyword used for aliasing.</source>
          <target state="new">AS is the keyword used for aliasing.</target>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Note that it's optional as shown while projecting the second value as <ph id="ph1">`NameInfo`</ph>.</source>
          <target state="new">Note that it's optional as shown while projecting the second value as <ph id="ph1">`NameInfo`</ph>.</target>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>In case a query has two properties with the same name, aliasing must be used to rename one or both of the properties so that they are disambiguated in the projected result.</source>
          <target state="new">In case a query has two properties with the same name, aliasing must be used to rename one or both of the properties so that they are disambiguated in the projected result.</target>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>Scalar expressions</source>
          <target state="new">Scalar expressions</target>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>In addition to property references, the SELECT clause also supports scalar expressions like constants, arithmetic expressions, logical expressions, etc. For example, here's a simple "Hello World" query.</source>
          <target state="new">In addition to property references, the SELECT clause also supports scalar expressions like constants, arithmetic expressions, logical expressions, etc. For example, here's a simple "Hello World" query.</target>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Here's a more complex example that uses a scalar expression.</source>
          <target state="new">Here's a more complex example that uses a scalar expression.</target>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>In the following example, the result of the scalar expression is a Boolean.</source>
          <target state="new">In the following example, the result of the scalar expression is a Boolean.</target>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Object and array creation</source>
          <target state="new">Object and array creation</target>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Another key feature of DocumentDB SQL is array/object creation.</source>
          <target state="new">Another key feature of DocumentDB SQL is array/object creation.</target>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>In the previous example, note that we created a new JSON object.</source>
          <target state="new">In the previous example, note that we created a new JSON object.</target>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Similarly, one can also construct arrays as shown in the following examples.</source>
          <target state="new">Similarly, one can also construct arrays as shown in the following examples.</target>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>VALUE keyword</source>
          <target state="new">VALUE keyword</target>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>VALUE<ept id="p1">**</ept> keyword provides a way to return JSON value.</source>
          <target state="new">The <bpt id="p1">**</bpt>VALUE<ept id="p1">**</ept> keyword provides a way to return JSON value.</target>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>For example, the query shown below returns the scalar <ph id="ph1">`"Hello World"`</ph> instead of <ph id="ph2">`{$1: "Hello World"}`</ph>.</source>
          <target state="new">For example, the query shown below returns the scalar <ph id="ph1">`"Hello World"`</ph> instead of <ph id="ph2">`{$1: "Hello World"}`</ph>.</target>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>The following query returns the JSON value without the <ph id="ph1">`"address"`</ph> label in the results.</source>
          <target state="new">The following query returns the JSON value without the <ph id="ph1">`"address"`</ph> label in the results.</target>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The following example extends this to show how to return JSON primitive values (the leaf level of the JSON tree).</source>
          <target state="new">The following example extends this to show how to return JSON primitive values (the leaf level of the JSON tree).</target>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>* Operator</source>
          <target state="new">* Operator</target>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>The special operator (*) is supported to project the document as-is.</source>
          <target state="new">The special operator (*) is supported to project the document as-is.</target>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>When used, it must be the only projected field.</source>
          <target state="new">When used, it must be the only projected field.</target>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>While a query like <ph id="ph1">`SELECT * FROM Families f`</ph> is valid, <ph id="ph2">`SELECT VALUE * FROM Families f `</ph> and  <ph id="ph3">`SELECT *, f.id FROM Families f `</ph> are not valid.</source>
          <target state="new">While a query like <ph id="ph1">`SELECT * FROM Families f`</ph> is valid, <ph id="ph2">`SELECT VALUE * FROM Families f `</ph> and  <ph id="ph3">`SELECT *, f.id FROM Families f `</ph> are not valid.</target>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>ORDER BY clause</source>
          <target state="new">ORDER BY clause</target>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Like in ANSI-SQL, you can include an optional Order By clause while querying.</source>
          <target state="new">Like in ANSI-SQL, you can include an optional Order By clause while querying.</target>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>The clause can include an optional ASC/DESC argument to specify the order in which results must be retrieved.</source>
          <target state="new">The clause can include an optional ASC/DESC argument to specify the order in which results must be retrieved.</target>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>For a more detailed look at Order By, refer to <bpt id="p1">[</bpt>DocumentDB Order By Walkthrough<ept id="p1">](documentdb-orderby.md)</ept>.</source>
          <target state="new">For a more detailed look at Order By, refer to <bpt id="p1">[</bpt>DocumentDB Order By Walkthrough<ept id="p1">](documentdb-orderby.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>For example, here's a query that retrieves families in order of the resident city's name.</source>
          <target state="new">For example, here's a query that retrieves families in order of the resident city's name.</target>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>And here's a query that retrieves families in order of creation date, which is stored as a number representing the epoch time, i.e, elapsed time since Jan 1, 1970 in seconds.</source>
          <target state="new">And here's a query that retrieves families in order of creation date, which is stored as a number representing the epoch time, i.e, elapsed time since Jan 1, 1970 in seconds.</target>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>Advanced concepts</source>
          <target state="new">Advanced concepts</target>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="new">Iteration</target>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>A new construct was added via the <bpt id="p1">**</bpt>IN<ept id="p1">**</ept> keyword in DocumentDB SQL to provide support for iterating over JSON arrays.</source>
          <target state="new">A new construct was added via the <bpt id="p1">**</bpt>IN<ept id="p1">**</ept> keyword in DocumentDB SQL to provide support for iterating over JSON arrays.</target>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>The FROM source provides support for iteration.</source>
          <target state="new">The FROM source provides support for iteration.</target>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>Let's start with the following example:</source>
          <target state="new">Let's start with the following example:</target>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>Now let's look at another query that performs iteration over children in the collection.</source>
          <target state="new">Now let's look at another query that performs iteration over children in the collection.</target>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>Note the difference in the output array.</source>
          <target state="new">Note the difference in the output array.</target>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>This example splits <ph id="ph1">`children`</ph> and flattens the results into a single array.</source>
          <target state="new">This example splits <ph id="ph1">`children`</ph> and flattens the results into a single array.</target>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>This can be further used to filter on each individual entry of the array as shown in the following example.</source>
          <target state="new">This can be further used to filter on each individual entry of the array as shown in the following example.</target>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>Joins</source>
          <target state="new">Joins</target>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>In a relational database, the need to join across tables is very important.</source>
          <target state="new">In a relational database, the need to join across tables is very important.</target>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>It's the logical corollary to designing normalized schemas.</source>
          <target state="new">It's the logical corollary to designing normalized schemas.</target>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>Contrary to this, DocumentDB deals with the denormalized data model of schema-free documents.</source>
          <target state="new">Contrary to this, DocumentDB deals with the denormalized data model of schema-free documents.</target>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>This is the logical equivalent of a "self-join".</source>
          <target state="new">This is the logical equivalent of a "self-join".</target>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>The syntax that the language supports is &lt;from_source1&gt; JOIN &lt;from_source2&gt; JOIN ... JOIN &lt;from_sourceN&gt;.</source>
          <target state="new">The syntax that the language supports is &lt;from_source1&gt; JOIN &lt;from_source2&gt; JOIN ... JOIN &lt;from_sourceN&gt;.</target>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>Overall, this returns a set of <bpt id="p1">**</bpt>N<ept id="p1">**</ept>-tuples (tuple with <bpt id="p2">**</bpt>N<ept id="p2">**</ept> values).</source>
          <target state="new">Overall, this returns a set of <bpt id="p1">**</bpt>N<ept id="p1">**</ept>-tuples (tuple with <bpt id="p2">**</bpt>N<ept id="p2">**</ept> values).</target>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>Each tuple has values produced by iterating all collection aliases over their respective sets.</source>
          <target state="new">Each tuple has values produced by iterating all collection aliases over their respective sets.</target>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>In other words, this is a full cross product of the sets participating in the join.</source>
          <target state="new">In other words, this is a full cross product of the sets participating in the join.</target>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>The following examples show how the JOIN clause works.</source>
          <target state="new">The following examples show how the JOIN clause works.</target>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>In the following example, the result is empty since the cross product of each document from source and an empty set is empty.</source>
          <target state="new">In the following example, the result is empty since the cross product of each document from source and an empty set is empty.</target>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>In the following example, the join is between the document root and the <ph id="ph1">`children`</ph> sub-root.</source>
          <target state="new">In the following example, the join is between the document root and the <ph id="ph1">`children`</ph> sub-root.</target>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>It's a cross product between two JSON objects.</source>
          <target state="new">It's a cross product between two JSON objects.</target>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>The fact that children is an array is not effective in the JOIN since we are dealing with a single root that is the children array.</source>
          <target state="new">The fact that children is an array is not effective in the JOIN since we are dealing with a single root that is the children array.</target>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>Hence the result contains only two results, since the cross product of each document with the array yields exactly only one document.</source>
          <target state="new">Hence the result contains only two results, since the cross product of each document with the array yields exactly only one document.</target>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>The following example shows a more conventional join:</source>
          <target state="new">The following example shows a more conventional join:</target>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>The first thing to note is that the <ph id="ph1">`from_source`</ph> of the <bpt id="p1">**</bpt>JOIN<ept id="p1">**</ept> clause is an iterator.</source>
          <target state="new">The first thing to note is that the <ph id="ph1">`from_source`</ph> of the <bpt id="p1">**</bpt>JOIN<ept id="p1">**</ept> clause is an iterator.</target>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>So, the flow in this case is as follows:</source>
          <target state="new">So, the flow in this case is as follows:</target>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>Expand each child element <bpt id="p1">**</bpt>c<ept id="p1">**</ept> in the array.</source>
          <target state="new">Expand each child element <bpt id="p1">**</bpt>c<ept id="p1">**</ept> in the array.</target>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>Apply a cross product with the root of the document <bpt id="p1">**</bpt>f<ept id="p1">**</ept> with each child element <bpt id="p2">**</bpt>c<ept id="p2">**</ept> that was flattened in the first step.</source>
          <target state="new">Apply a cross product with the root of the document <bpt id="p1">**</bpt>f<ept id="p1">**</ept> with each child element <bpt id="p2">**</bpt>c<ept id="p2">**</ept> that was flattened in the first step.</target>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Finally, project the root object <bpt id="p1">**</bpt>f<ept id="p1">**</ept> name property alone.</source>
          <target state="new">Finally, project the root object <bpt id="p1">**</bpt>f<ept id="p1">**</ept> name property alone.</target>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>The first document (<ph id="ph1">`AndersenFamily`</ph>) contains only one child element, so the result set contains only a single object corresponding to this document.</source>
          <target state="new">The first document (<ph id="ph1">`AndersenFamily`</ph>) contains only one child element, so the result set contains only a single object corresponding to this document.</target>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>The second document (<ph id="ph1">`WakefieldFamily`</ph>) contains two children.</source>
          <target state="new">The second document (<ph id="ph1">`WakefieldFamily`</ph>) contains two children.</target>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>So, the cross product produces a separate object for each child, thereby resulting in two objects, one for each child corresponding to this document.</source>
          <target state="new">So, the cross product produces a separate object for each child, thereby resulting in two objects, one for each child corresponding to this document.</target>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>Note that the root fields in both these documents will be same, just as you would expect in a cross product.</source>
          <target state="new">Note that the root fields in both these documents will be same, just as you would expect in a cross product.</target>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>The real utility of the JOIN is to form tuples from the cross-product in a shape that's otherwise difficult to project.</source>
          <target state="new">The real utility of the JOIN is to form tuples from the cross-product in a shape that's otherwise difficult to project.</target>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>Furthermore, as we will see in the example below, you could filter on the combination of a tuple that lets' the user chose a condition satisfied by the tuples overall.</source>
          <target state="new">Furthermore, as we will see in the example below, you could filter on the combination of a tuple that lets' the user chose a condition satisfied by the tuples overall.</target>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>This example is a natural extension of the preceding example, and performs a double join.</source>
          <target state="new">This example is a natural extension of the preceding example, and performs a double join.</target>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>So, the cross product can be viewed as the following pseudo-code.</source>
          <target state="new">So, the cross product can be viewed as the following pseudo-code.</target>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`AndersenFamily`</ph> has one child who has one pet.</source>
          <target state="new"><ph id="ph1">`AndersenFamily`</ph> has one child who has one pet.</target>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>So, the cross product yields one row (1<bpt id="p1">*</bpt>1<ept id="p1">*</ept>1) from this family.</source>
          <target state="new">So, the cross product yields one row (1<bpt id="p1">*</bpt>1<ept id="p1">*</ept>1) from this family.</target>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>WakefieldFamily however has two children, but only one child "Jesse" has pets.</source>
          <target state="new">WakefieldFamily however has two children, but only one child "Jesse" has pets.</target>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>Jesse has 2 pets though.</source>
          <target state="new">Jesse has 2 pets though.</target>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>Hence the cross product yields 1<bpt id="p1">*</bpt>1<ept id="p1">*</ept>2 = 2 rows from this family.</source>
          <target state="new">Hence the cross product yields 1<bpt id="p1">*</bpt>1<ept id="p1">*</ept>2 = 2 rows from this family.</target>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>In the next example, there is an additional filter on <ph id="ph1">`pet`</ph>.</source>
          <target state="new">In the next example, there is an additional filter on <ph id="ph1">`pet`</ph>.</target>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>This excludes all the tuples where the pet name is not "Shadow".</source>
          <target state="new">This excludes all the tuples where the pet name is not "Shadow".</target>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>Notice that we are able to build tuples from arrays, filter on any of the elements of the tuple, and project any combination of the elements.</source>
          <target state="new">Notice that we are able to build tuples from arrays, filter on any of the elements of the tuple, and project any combination of the elements.</target>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>JavaScript integration</source>
          <target state="new">JavaScript integration</target>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>DocumentDB provides a programming model for executing JavaScript based application logic directly on the collections in terms of stored procedures and triggers.</source>
          <target state="new">DocumentDB provides a programming model for executing JavaScript based application logic directly on the collections in terms of stored procedures and triggers.</target>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>This allows for both:</source>
          <target state="new">This allows for both:</target>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>Ability to do high performance transactional CRUD operations and queries against documents in a collection by virtue of the deep integration of JavaScript runtime directly within the database engine.</source>
          <target state="new">Ability to do high performance transactional CRUD operations and queries against documents in a collection by virtue of the deep integration of JavaScript runtime directly within the database engine.</target>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>A natural modeling of control flow, variable scoping, and assignment and integration of exception handling primitives with database transactions.</source>
          <target state="new">A natural modeling of control flow, variable scoping, and assignment and integration of exception handling primitives with database transactions.</target>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>For more details about DocumentDB support for JavaScript integration, please refer to the JavaScript server side programmability documentation.</source>
          <target state="new">For more details about DocumentDB support for JavaScript integration, please refer to the JavaScript server side programmability documentation.</target>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>User Defined Functions (UDFs)</source>
          <target state="new">User Defined Functions (UDFs)</target>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>Along with the types already defined in this article, DocumentDB SQL provides support for User Defined Functions (UDF).</source>
          <target state="new">Along with the types already defined in this article, DocumentDB SQL provides support for User Defined Functions (UDF).</target>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>In particular, scalar UDFs are supported where the developers can pass in zero or many arguments and return a single argument result back.</source>
          <target state="new">In particular, scalar UDFs are supported where the developers can pass in zero or many arguments and return a single argument result back.</target>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>Each of these arguments are checked for being legal JSON values.</source>
          <target state="new">Each of these arguments are checked for being legal JSON values.</target>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>The DocumentDB SQL grammar is extended to support custom application logic using these User Defined Functions.</source>
          <target state="new">The DocumentDB SQL grammar is extended to support custom application logic using these User Defined Functions.</target>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>UDFs can be registered with DocumentDB and then be referenced as part of a SQL query.</source>
          <target state="new">UDFs can be registered with DocumentDB and then be referenced as part of a SQL query.</target>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>In fact, the UDFs are exquisitely designed to be invoked by queries.</source>
          <target state="new">In fact, the UDFs are exquisitely designed to be invoked by queries.</target>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>As a corollary to this choice, UDFs do not have access to the context object which the other JavaScript types (stored procedures and triggers) have.</source>
          <target state="new">As a corollary to this choice, UDFs do not have access to the context object which the other JavaScript types (stored procedures and triggers) have.</target>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>Since queries execute as read-only, they can run either on primary or on secondary replicas.</source>
          <target state="new">Since queries execute as read-only, they can run either on primary or on secondary replicas.</target>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>Therefore, UDFs are designed to run on secondary replicas unlike other JavaScript types.</source>
          <target state="new">Therefore, UDFs are designed to run on secondary replicas unlike other JavaScript types.</target>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>Below is an example of how a UDF can be registered at the DocumentDB database, specifically under a document collection.</source>
          <target state="new">Below is an example of how a UDF can be registered at the DocumentDB database, specifically under a document collection.</target>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>The preceding example creates a UDF whose name is <ph id="ph1">`REGEX_MATCH`</ph>.</source>
          <target state="new">The preceding example creates a UDF whose name is <ph id="ph1">`REGEX_MATCH`</ph>.</target>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>It accepts two JSON string values <ph id="ph1">`input`</ph> and <ph id="ph2">`pattern`</ph> and checks if the first matches the pattern specified in the second using JavaScript's string.match() function.</source>
          <target state="new">It accepts two JSON string values <ph id="ph1">`input`</ph> and <ph id="ph2">`pattern`</ph> and checks if the first matches the pattern specified in the second using JavaScript's string.match() function.</target>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>We can now use this UDF in a query in a projection.</source>
          <target state="new">We can now use this UDF in a query in a projection.</target>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>UDFs must be qualified with the case-sensitive prefix "udf."</source>
          <target state="new">UDFs must be qualified with the case-sensitive prefix "udf."</target>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>when called from within queries.</source>
          <target state="new">when called from within queries.</target>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Prior to 3/17/2015, DocumentDB supported UDF calls without the "udf."</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Prior to 3/17/2015, DocumentDB supported UDF calls without the "udf."</target>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>prefix like SELECT REGEX_MATCH().</source>
          <target state="new">prefix like SELECT REGEX_MATCH().</target>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>This calling pattern has been deprecated.</source>
          <target state="new">This calling pattern has been deprecated.</target>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>The UDF can also be used inside a filter as shown in the example below, also qualified with the "udf."</source>
          <target state="new">The UDF can also be used inside a filter as shown in the example below, also qualified with the "udf."</target>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>prefix :</source>
          <target state="new">prefix :</target>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>In essence, UDFs are valid scalar expressions and can be used in both projections and filters.</source>
          <target state="new">In essence, UDFs are valid scalar expressions and can be used in both projections and filters.</target>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>To expand on the power of UDFs, let's look at another example with conditional logic:</source>
          <target state="new">To expand on the power of UDFs, let's look at another example with conditional logic:</target>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>Below is an example that exercises the UDF.</source>
          <target state="new">Below is an example that exercises the UDF.</target>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>As the preceding examples showcase, UDFs integrate the power of JavaScript language with the DocumentDB SQL to provide a rich programmable interface to do complex procedural, conditional logic with the help of inbuilt JavaScript runtime capabilities.</source>
          <target state="new">As the preceding examples showcase, UDFs integrate the power of JavaScript language with the DocumentDB SQL to provide a rich programmable interface to do complex procedural, conditional logic with the help of inbuilt JavaScript runtime capabilities.</target>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>DocumentDB SQL provides the arguments to the UDFs for each document in the source at the current stage (WHERE clause or SELECT clause) of processing the UDF.</source>
          <target state="new">DocumentDB SQL provides the arguments to the UDFs for each document in the source at the current stage (WHERE clause or SELECT clause) of processing the UDF.</target>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>The result is incorporated in the overall execution pipeline seamlessly.</source>
          <target state="new">The result is incorporated in the overall execution pipeline seamlessly.</target>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>If the properties referred to by the UDF parameters are not available in the JSON value, the parameter is considered as undefined and hence the UDF invocation is entirely skipped.</source>
          <target state="new">If the properties referred to by the UDF parameters are not available in the JSON value, the parameter is considered as undefined and hence the UDF invocation is entirely skipped.</target>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>Similarly if the result of the UDF is undefined, it's not included in the result.</source>
          <target state="new">Similarly if the result of the UDF is undefined, it's not included in the result.</target>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>In summary, UDFs are great tools to do complex business logic as part of the query.</source>
          <target state="new">In summary, UDFs are great tools to do complex business logic as part of the query.</target>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>Operator evaluation</source>
          <target state="new">Operator evaluation</target>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>DocumentDB, by the virtue of being a JSON database, draws parallels with JavaScript operators and its evaluation semantics.</source>
          <target state="new">DocumentDB, by the virtue of being a JSON database, draws parallels with JavaScript operators and its evaluation semantics.</target>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>While DocumentDB tries to preserve JavaScript semantics in terms of JSON support, the operation evaluation deviates in some instances.</source>
          <target state="new">While DocumentDB tries to preserve JavaScript semantics in terms of JSON support, the operation evaluation deviates in some instances.</target>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>In DocumentDB SQL, unlike in traditional SQL, the types of values are often not known until the values are actually retrieved from database.</source>
          <target state="new">In DocumentDB SQL, unlike in traditional SQL, the types of values are often not known until the values are actually retrieved from database.</target>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>In order to efficiently execute queries, most of the operators have strict type requirements.</source>
          <target state="new">In order to efficiently execute queries, most of the operators have strict type requirements.</target>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>DocumentDB SQL doesn't perform implicit conversions, unlike JavaScript.</source>
          <target state="new">DocumentDB SQL doesn't perform implicit conversions, unlike JavaScript.</target>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>For instance, a query like <ph id="ph1">`SELECT * FROM Person p WHERE p.Age = 21`</ph> matches documents which contain an Age property whose value is 21.</source>
          <target state="new">For instance, a query like <ph id="ph1">`SELECT * FROM Person p WHERE p.Age = 21`</ph> matches documents which contain an Age property whose value is 21.</target>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>Any other document whose Age property matches string "21", or</source>
          <target state="new">Any other document whose Age property matches string "21", or</target>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>other possibly infinite variations like "021", "21.0", "0021", "00021", etc. will not be matched.</source>
          <target state="new">other possibly infinite variations like "021", "21.0", "0021", "00021", etc. will not be matched.</target>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>This is in contrast to the JavaScript where the string values are implicitly casted to numbers (based on operator, ex: ==).</source>
          <target state="new">This is in contrast to the JavaScript where the string values are implicitly casted to numbers (based on operator, ex: ==).</target>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>This choice is crucial for efficient index matching in DocumentDB SQL.</source>
          <target state="new">This choice is crucial for efficient index matching in DocumentDB SQL.</target>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>Parameterized SQL</source>
          <target state="new">Parameterized SQL</target>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>DocumentDB supports queries with parameters expressed with the familiar @ notation.</source>
          <target state="new">DocumentDB supports queries with parameters expressed with the familiar @ notation.</target>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>Parameterized SQL provides robust handling and escaping of user input, preventing accidental exposure of data through SQL injection.</source>
          <target state="new">Parameterized SQL provides robust handling and escaping of user input, preventing accidental exposure of data through SQL injection.</target>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>For example, you can write a query that takes last name and address state as parameters, and then execute it for various values of last name and address state based on user input.</source>
          <target state="new">For example, you can write a query that takes last name and address state as parameters, and then execute it for various values of last name and address state based on user input.</target>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>This request can then be sent to DocumentDB as a parameterized JSON query like shown below.</source>
          <target state="new">This request can then be sent to DocumentDB as a parameterized JSON query like shown below.</target>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>Parameter values can be any valid JSON (strings, numbers, Booleans, null, even arrays or nested JSON).</source>
          <target state="new">Parameter values can be any valid JSON (strings, numbers, Booleans, null, even arrays or nested JSON).</target>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>Also since DocumentDB is schema-less, parameters are not validated against any type.</source>
          <target state="new">Also since DocumentDB is schema-less, parameters are not validated against any type.</target>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>Built-in functions</source>
          <target state="new">Built-in functions</target>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>DocumentDB also supports a number of built-in functions for common operations, that can be used inside queries like user defined functions (UDFs).</source>
          <target state="new">DocumentDB also supports a number of built-in functions for common operations, that can be used inside queries like user defined functions (UDFs).</target>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>Mathematical functions</source>
          <target state="new">Mathematical functions</target>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>ABS, CEILING, EXP, FLOOR, LOG, LOG10, POWER, ROUND, SIGN, SQRT, SQUARE, TRUNC, ACOS, ASIN, ATAN, ATN2, COS, COT, DEGREES, PI, RADIANS, SIN, and TAN</source>
          <target state="new">ABS, CEILING, EXP, FLOOR, LOG, LOG10, POWER, ROUND, SIGN, SQRT, SQUARE, TRUNC, ACOS, ASIN, ATAN, ATN2, COS, COT, DEGREES, PI, RADIANS, SIN, and TAN</target>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>Type checking functions</source>
          <target state="new">Type checking functions</target>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>IS_ARRAY, IS_BOOL, IS_NULL, IS_NUMBER, IS_OBJECT, IS_STRING, IS_DEFINED, and IS_PRIMITIVE</source>
          <target state="new">IS_ARRAY, IS_BOOL, IS_NULL, IS_NUMBER, IS_OBJECT, IS_STRING, IS_DEFINED, and IS_PRIMITIVE</target>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>String functions</source>
          <target state="new">String functions</target>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>CONCAT, CONTAINS, ENDSWITH, INDEX_OF, LEFT, LENGTH, LOWER, LTRIM, REPLACE, REPLICATE, REVERSE, RIGHT, RTRIM, STARTSWITH, SUBSTRING, and UPPER</source>
          <target state="new">CONCAT, CONTAINS, ENDSWITH, INDEX_OF, LEFT, LENGTH, LOWER, LTRIM, REPLACE, REPLICATE, REVERSE, RIGHT, RTRIM, STARTSWITH, SUBSTRING, and UPPER</target>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>Array functions</source>
          <target state="new">Array functions</target>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>ARRAY_CONCAT, ARRAY_CONTAINS, ARRAY_LENGTH, and ARRAY_SLICE</source>
          <target state="new">ARRAY_CONCAT, ARRAY_CONTAINS, ARRAY_LENGTH, and ARRAY_SLICE</target>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>Spatial functions</source>
          <target state="new">Spatial functions</target>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>ST_DISTANCE, ST_WITHIN, ST_ISVALID, and ST_ISVALIDDETAILED</source>
          <target state="new">ST_DISTANCE, ST_WITHIN, ST_ISVALID, and ST_ISVALIDDETAILED</target>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>If you’re currently using a user defined function (UDF) for which a built-in function is now available, you should use the corresponding built-in function as it is going to be quicker to run and more efficiently.</source>
          <target state="new">If you’re currently using a user defined function (UDF) for which a built-in function is now available, you should use the corresponding built-in function as it is going to be quicker to run and more efficiently.</target>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>Mathematical functions</source>
          <target state="new">Mathematical functions</target>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>The mathematical functions each perform a calculation, usually based on input values that are provided as arguments, and return a numeric value.</source>
          <target state="new">The mathematical functions each perform a calculation, usually based on input values that are provided as arguments, and return a numeric value.</target>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>Here’s a table of supported built-in mathematical functions.</source>
          <target state="new">Here’s a table of supported built-in mathematical functions.</target>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="new">Usage</target>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="new">Description</target>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>ABS (num_expr)</source>
          <target state="new">ABS (num_expr)</target>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>Returns the absolute (positive) value of the specified numeric expression.</source>
          <target state="new">Returns the absolute (positive) value of the specified numeric expression.</target>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>CEILING (num_expr)</source>
          <target state="new">CEILING (num_expr)</target>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source>Returns the smallest integer value greater than, or equal to, the specified numeric expression.</source>
          <target state="new">Returns the smallest integer value greater than, or equal to, the specified numeric expression.</target>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>FLOOR (num_expr)</source>
          <target state="new">FLOOR (num_expr)</target>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>Returns the largest integer less than or equal to the specified numeric expression.</source>
          <target state="new">Returns the largest integer less than or equal to the specified numeric expression.</target>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>EXP (num_expr)</source>
          <target state="new">EXP (num_expr)</target>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>Returns the exponent of the specified numeric expression.</source>
          <target state="new">Returns the exponent of the specified numeric expression.</target>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>LOG (num_expr [,base])</source>
          <target state="new">LOG (num_expr [,base])</target>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>Returns the natural logarithm of the specified numeric expression, or the logarithm using the specified base</source>
          <target state="new">Returns the natural logarithm of the specified numeric expression, or the logarithm using the specified base</target>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>LOG10 (num_expr)</source>
          <target state="new">LOG10 (num_expr)</target>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>Returns the base-10 logarithmic value of the specified numeric expression.</source>
          <target state="new">Returns the base-10 logarithmic value of the specified numeric expression.</target>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>ROUND (num_expr)</source>
          <target state="new">ROUND (num_expr)</target>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>Returns a numeric value, rounded to the closest integer value.</source>
          <target state="new">Returns a numeric value, rounded to the closest integer value.</target>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source>TRUNC (num_expr)</source>
          <target state="new">TRUNC (num_expr)</target>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source>Returns a numeric value, truncated to the closest integer value.</source>
          <target state="new">Returns a numeric value, truncated to the closest integer value.</target>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source>SQRT (num_expr)</source>
          <target state="new">SQRT (num_expr)</target>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>Returns the square root of the specified numeric expression.</source>
          <target state="new">Returns the square root of the specified numeric expression.</target>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>SQUARE (num_expr)</source>
          <target state="new">SQUARE (num_expr)</target>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>Returns the square of the specified numeric expression.</source>
          <target state="new">Returns the square of the specified numeric expression.</target>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>POWER (num_expr, num_expr)</source>
          <target state="new">POWER (num_expr, num_expr)</target>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>Returns the power of the specified numeric expression to the value specifed.</source>
          <target state="new">Returns the power of the specified numeric expression to the value specifed.</target>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>SIGN (num_expr)</source>
          <target state="new">SIGN (num_expr)</target>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>Returns the sign value (-1, 0, 1) of the specified numeric expression.</source>
          <target state="new">Returns the sign value (-1, 0, 1) of the specified numeric expression.</target>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>ACOS (num_expr)</source>
          <target state="new">ACOS (num_expr)</target>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>Returns the angle, in radians, whose cosine is the specified numeric expression; also called arccosine.</source>
          <target state="new">Returns the angle, in radians, whose cosine is the specified numeric expression; also called arccosine.</target>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>ASIN (num_expr)</source>
          <target state="new">ASIN (num_expr)</target>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>Returns the angle, in radians, whose sine is the specified numeric expression.</source>
          <target state="new">Returns the angle, in radians, whose sine is the specified numeric expression.</target>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>This is also called arcsine.</source>
          <target state="new">This is also called arcsine.</target>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>ATAN (num_expr)</source>
          <target state="new">ATAN (num_expr)</target>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>Returns the angle, in radians, whose tangent is the specified numeric expression.</source>
          <target state="new">Returns the angle, in radians, whose tangent is the specified numeric expression.</target>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>This is also called arctangent.</source>
          <target state="new">This is also called arctangent.</target>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>ATN2 (num_expr)</source>
          <target state="new">ATN2 (num_expr)</target>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>Returns the angle, in radians, between the positive x-axis and the ray from the origin to the point (y, x), where x and y are the values of the two specified float expressions.</source>
          <target state="new">Returns the angle, in radians, between the positive x-axis and the ray from the origin to the point (y, x), where x and y are the values of the two specified float expressions.</target>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>COS (num_expr)</source>
          <target state="new">COS (num_expr)</target>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>Returns the trigonometric cosine of the specified angle, in radians, in the specified expression.</source>
          <target state="new">Returns the trigonometric cosine of the specified angle, in radians, in the specified expression.</target>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>COT (num_expr)</source>
          <target state="new">COT (num_expr)</target>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>Returns the trigonometric cotangent of the specified angle, in radians, in the specified numeric expression.</source>
          <target state="new">Returns the trigonometric cotangent of the specified angle, in radians, in the specified numeric expression.</target>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>DEGREES (num_expr)</source>
          <target state="new">DEGREES (num_expr)</target>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>Returns the corresponding angle in degrees for an angle specified in radians.</source>
          <target state="new">Returns the corresponding angle in degrees for an angle specified in radians.</target>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source>PI ()</source>
          <target state="new">PI ()</target>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>Returns the constant value of PI.</source>
          <target state="new">Returns the constant value of PI.</target>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>RADIANS (num_expr)</source>
          <target state="new">RADIANS (num_expr)</target>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>Returns radians when a numeric expression, in degrees, is entered.</source>
          <target state="new">Returns radians when a numeric expression, in degrees, is entered.</target>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>SIN (num_expr)</source>
          <target state="new">SIN (num_expr)</target>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>Returns the trigonometric sine of the specified angle, in radians, in the specified expression.</source>
          <target state="new">Returns the trigonometric sine of the specified angle, in radians, in the specified expression.</target>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source>TAN (num_expr)</source>
          <target state="new">TAN (num_expr)</target>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>Returns the tangent of the input expression, in the specified expression.</source>
          <target state="new">Returns the tangent of the input expression, in the specified expression.</target>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>For example, you can now run queries like the following:</source>
          <target state="new">For example, you can now run queries like the following:</target>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>The main difference between DocumentDB’s functions compared to ANSI SQL is that they are designed to work well with schema-less and mixed schema data.</source>
          <target state="new">The main difference between DocumentDB’s functions compared to ANSI SQL is that they are designed to work well with schema-less and mixed schema data.</target>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>For example, if you have a document where the Size property is missing, or has a non-numeric value like “unknown”, then the document is skipped over, instead of returning an error.</source>
          <target state="new">For example, if you have a document where the Size property is missing, or has a non-numeric value like “unknown”, then the document is skipped over, instead of returning an error.</target>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>Type checking functions</source>
          <target state="new">Type checking functions</target>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>The type checking functions allow you to check the type of an expression within SQL queries.</source>
          <target state="new">The type checking functions allow you to check the type of an expression within SQL queries.</target>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>Type checking functions can be used to determine the type of properties within documents on the fly when it is variable or unknown.</source>
          <target state="new">Type checking functions can be used to determine the type of properties within documents on the fly when it is variable or unknown.</target>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>Here’s a table of supported built-in type checking functions.</source>
          <target state="new">Here’s a table of supported built-in type checking functions.</target>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="new">Usage</target>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="new">Description</target>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>IS_ARRAY (expr)</source>
          <target state="new">IS_ARRAY (expr)</target>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>Returns a Boolean indicating if the type of the value is an array.</source>
          <target state="new">Returns a Boolean indicating if the type of the value is an array.</target>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>IS_BOOL (expr)</source>
          <target state="new">IS_BOOL (expr)</target>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>Returns a Boolean indicating if the type of the value is a Boolean.</source>
          <target state="new">Returns a Boolean indicating if the type of the value is a Boolean.</target>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>IS_NULL (expr)</source>
          <target state="new">IS_NULL (expr)</target>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>Returns a Boolean indicating if the type of the value is null.</source>
          <target state="new">Returns a Boolean indicating if the type of the value is null.</target>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>IS_NUMBER (expr)</source>
          <target state="new">IS_NUMBER (expr)</target>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>Returns a Boolean indicating if the type of the value is a number.</source>
          <target state="new">Returns a Boolean indicating if the type of the value is a number.</target>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>IS_OBJECT (expr)</source>
          <target state="new">IS_OBJECT (expr)</target>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>Returns a Boolean indicating if the type of the value is a JSON object.</source>
          <target state="new">Returns a Boolean indicating if the type of the value is a JSON object.</target>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>IS_STRING (expr)</source>
          <target state="new">IS_STRING (expr)</target>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>Returns a Boolean indicating if the type of the value is a string.</source>
          <target state="new">Returns a Boolean indicating if the type of the value is a string.</target>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>IS_DEFINED (expr)</source>
          <target state="new">IS_DEFINED (expr)</target>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>Returns a Boolean indicating if the property has been assigned a value.</source>
          <target state="new">Returns a Boolean indicating if the property has been assigned a value.</target>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>IS_PRIMITIVE (expr)</source>
          <target state="new">IS_PRIMITIVE (expr)</target>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>Returns a Boolean indicating if the type of the value is a string, number, Boolean or null.</source>
          <target state="new">Returns a Boolean indicating if the type of the value is a string, number, Boolean or null.</target>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>Using these functions, you can now run queries like the following:</source>
          <target state="new">Using these functions, you can now run queries like the following:</target>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>String functions</source>
          <target state="new">String functions</target>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>The following scalar functions perform an operation on a string input value and return a string, numeric or Boolean value.</source>
          <target state="new">The following scalar functions perform an operation on a string input value and return a string, numeric or Boolean value.</target>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source>Here's a table of built-in string functions:</source>
          <target state="new">Here's a table of built-in string functions:</target>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="new">Usage</target>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="new">Description</target>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>LENGTH (str_expr)</source>
          <target state="new">LENGTH (str_expr)</target>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>Returns the number of characters of the specified string expression</source>
          <target state="new">Returns the number of characters of the specified string expression</target>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source>CONCAT (str_expr, str_expr [, str_expr])</source>
          <target state="new">CONCAT (str_expr, str_expr [, str_expr])</target>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>Returns a string that is the result of concatenating two or more string values.</source>
          <target state="new">Returns a string that is the result of concatenating two or more string values.</target>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>SUBSTRING (str_expr, num_expr, num_expr)</source>
          <target state="new">SUBSTRING (str_expr, num_expr, num_expr)</target>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>Returns part of a string expression.</source>
          <target state="new">Returns part of a string expression.</target>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source>STARTSWITH (str_expr, str_expr)</source>
          <target state="new">STARTSWITH (str_expr, str_expr)</target>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>Returns a Boolean indicating whether the first string expression ends with the second</source>
          <target state="new">Returns a Boolean indicating whether the first string expression ends with the second</target>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve">
          <source>ENDSWITH (str_expr, str_expr)</source>
          <target state="new">ENDSWITH (str_expr, str_expr)</target>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>Returns a Boolean indicating whether the first string expression ends with the second</source>
          <target state="new">Returns a Boolean indicating whether the first string expression ends with the second</target>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>CONTAINS (str_expr, str_expr)</source>
          <target state="new">CONTAINS (str_expr, str_expr)</target>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>Returns a Boolean indicating whether the first string expression contains the second.</source>
          <target state="new">Returns a Boolean indicating whether the first string expression contains the second.</target>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>INDEX_OF (str_expr, str_expr)</source>
          <target state="new">INDEX_OF (str_expr, str_expr)</target>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source>Returns the starting position of the first occurrence of the second string expression within the first specified string expression, or -1 if the string is not found.</source>
          <target state="new">Returns the starting position of the first occurrence of the second string expression within the first specified string expression, or -1 if the string is not found.</target>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source>LEFT (str_expr, num_expr)</source>
          <target state="new">LEFT (str_expr, num_expr)</target>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source>Returns the left part of a string with the specified number of characters.</source>
          <target state="new">Returns the left part of a string with the specified number of characters.</target>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>RIGHT (str_expr, num_expr)</source>
          <target state="new">RIGHT (str_expr, num_expr)</target>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>Returns the right part of a string with the specified number of characters.</source>
          <target state="new">Returns the right part of a string with the specified number of characters.</target>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>LTRIM (str_expr)</source>
          <target state="new">LTRIM (str_expr)</target>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source>Returns a string expression after it removes leading blanks.</source>
          <target state="new">Returns a string expression after it removes leading blanks.</target>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source>RTRIM (str_expr)</source>
          <target state="new">RTRIM (str_expr)</target>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source>Returns a string expression after truncating all trailing blanks.</source>
          <target state="new">Returns a string expression after truncating all trailing blanks.</target>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source>LOWER (str_expr)</source>
          <target state="new">LOWER (str_expr)</target>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source>Returns a string expression after converting uppercase character data to lowercase.</source>
          <target state="new">Returns a string expression after converting uppercase character data to lowercase.</target>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source>UPPER (str_expr)</source>
          <target state="new">UPPER (str_expr)</target>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source>Returns a string expression after converting lowercase character data to uppercase.</source>
          <target state="new">Returns a string expression after converting lowercase character data to uppercase.</target>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>REPLACE (str_expr, str_expr, str_expr)</source>
          <target state="new">REPLACE (str_expr, str_expr, str_expr)</target>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>Replaces all occurrences of a specified string value with another string value.</source>
          <target state="new">Replaces all occurrences of a specified string value with another string value.</target>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>REPLICATE (str_expr, num_expr)</source>
          <target state="new">REPLICATE (str_expr, num_expr)</target>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>Repeats a string value a specified number of times.</source>
          <target state="new">Repeats a string value a specified number of times.</target>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>REVERSE (str_expr)</source>
          <target state="new">REVERSE (str_expr)</target>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source>Returns the reverse order of a string value.</source>
          <target state="new">Returns the reverse order of a string value.</target>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source>Using these functions, you can now run queries like the following.</source>
          <target state="new">Using these functions, you can now run queries like the following.</target>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source>For example, you can return the family name in uppercase as follows:</source>
          <target state="new">For example, you can return the family name in uppercase as follows:</target>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>Or concatenate strings like in this example:</source>
          <target state="new">Or concatenate strings like in this example:</target>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>String functions can also be used in the WHERE clause to filter results, like in the following example:</source>
          <target state="new">String functions can also be used in the WHERE clause to filter results, like in the following example:</target>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>Array functions</source>
          <target state="new">Array functions</target>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>The following scalar functions perform an operation on an array input value and return numeric, Boolean or array value.</source>
          <target state="new">The following scalar functions perform an operation on an array input value and return numeric, Boolean or array value.</target>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>Here's a table of built-in array functions:</source>
          <target state="new">Here's a table of built-in array functions:</target>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="new">Usage</target>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="new">Description</target>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>ARRAY_LENGTH (arr_expr)</source>
          <target state="new">ARRAY_LENGTH (arr_expr)</target>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source>Returns the number of elements of the specified array expression.</source>
          <target state="new">Returns the number of elements of the specified array expression.</target>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>ARRAY_CONCAT (arr_expr, arr_expr [, arr_expr])</source>
          <target state="new">ARRAY_CONCAT (arr_expr, arr_expr [, arr_expr])</target>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve">
          <source>Returns an array that is the result of concatenating two or more array values.</source>
          <target state="new">Returns an array that is the result of concatenating two or more array values.</target>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve">
          <source>ARRAY_CONTAINS (arr_expr, expr)</source>
          <target state="new">ARRAY_CONTAINS (arr_expr, expr)</target>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>Returns a Boolean indicating whether the array contains the specified value.</source>
          <target state="new">Returns a Boolean indicating whether the array contains the specified value.</target>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>ARRAY_SLICE (arr_expr, num_expr [, num_expr])</source>
          <target state="new">ARRAY_SLICE (arr_expr, num_expr [, num_expr])</target>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>Returns part of an array expression.</source>
          <target state="new">Returns part of an array expression.</target>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>Array functions can be used to manipulate arrays within JSON.</source>
          <target state="new">Array functions can be used to manipulate arrays within JSON.</target>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>For example, here's a query that returns all documents where one of the parents is "Robin Wakefield".</source>
          <target state="new">For example, here's a query that returns all documents where one of the parents is "Robin Wakefield".</target>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve">
          <source>Here's another example that uses ARRAY_LENGTH to get the number of children per family.</source>
          <target state="new">Here's another example that uses ARRAY_LENGTH to get the number of children per family.</target>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve">
          <source>That wraps up built-in functions, and the SQL grammar for DocumentDB.</source>
          <target state="new">That wraps up built-in functions, and the SQL grammar for DocumentDB.</target>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve">
          <source>Now let's take a look at how LINQ querying works and how it interacts with the grammar we've seen so far.</source>
          <target state="new">Now let's take a look at how LINQ querying works and how it interacts with the grammar we've seen so far.</target>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>Spatial functions</source>
          <target state="new">Spatial functions</target>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>DocumentDB supports the following Open Geospatial Consortium (OGC) built-in functions for geospatial querying.</source>
          <target state="new">DocumentDB supports the following Open Geospatial Consortium (OGC) built-in functions for geospatial querying.</target>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>For more details on geospatial support in DocumentDB, please see <bpt id="p1">[</bpt>Working with geospatial data in Azure DocumentDB<ept id="p1">](documentdb-geospatial.md)</ept>.</source>
          <target state="new">For more details on geospatial support in DocumentDB, please see <bpt id="p1">[</bpt>Working with geospatial data in Azure DocumentDB<ept id="p1">](documentdb-geospatial.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="new">Usage</target>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="new">Description</target>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source>ST_DISTANCE (point_expr, point_expr)</source>
          <target state="new">ST_DISTANCE (point_expr, point_expr)</target>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>Returns the distance between the two GeoJSON point expressions.</source>
          <target state="new">Returns the distance between the two GeoJSON point expressions.</target>
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source>ST_WITHIN (point_expr, polygon_expr)</source>
          <target state="new">ST_WITHIN (point_expr, polygon_expr)</target>
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>Returns a Boolean expression indicating whether the GeoJSON point specified in the first argument is within the GeoJSON polygon in the second argument.</source>
          <target state="new">Returns a Boolean expression indicating whether the GeoJSON point specified in the first argument is within the GeoJSON polygon in the second argument.</target>
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>ST_ISVALID</source>
          <target state="new">ST_ISVALID</target>
        </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>Returns a Boolean value indicating whether the specified GeoJSON point or polygon expression is valid.</source>
          <target state="new">Returns a Boolean value indicating whether the specified GeoJSON point or polygon expression is valid.</target>
        </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve">
          <source>ST_ISVALIDDETAILED</source>
          <target state="new">ST_ISVALIDDETAILED</target>
        </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source>Returns a JSON value containing a Boolean value if the specified GeoJSON point or polygon expression is valid, and if invalid, additionally the reason as a string value.</source>
          <target state="new">Returns a JSON value containing a Boolean value if the specified GeoJSON point or polygon expression is valid, and if invalid, additionally the reason as a string value.</target>
        </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve">
          <source>Spatial functions can be used to perform proximity querries against spatial data.</source>
          <target state="new">Spatial functions can be used to perform proximity querries against spatial data.</target>
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>For example, here's a query that returns all family documents that are within 30 km of the specified location using the ST_DISTANCE built-in function.</source>
          <target state="new">For example, here's a query that returns all family documents that are within 30 km of the specified location using the ST_DISTANCE built-in function.</target>
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve">
          <source>If you include spatial indexing in your indexing policy, then "distance queries" will be served efficiently through the index.</source>
          <target state="new">If you include spatial indexing in your indexing policy, then "distance queries" will be served efficiently through the index.</target>
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source>For more details on spatial indexing, please see the section below.</source>
          <target state="new">For more details on spatial indexing, please see the section below.</target>
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve">
          <source>If you don't have a spatial index for the specified paths, you can still perform spatial queries by specifying <ph id="ph1">`x-ms-documentdb-query-enable-scan`</ph> request header with the value set to "true".</source>
          <target state="new">If you don't have a spatial index for the specified paths, you can still perform spatial queries by specifying <ph id="ph1">`x-ms-documentdb-query-enable-scan`</ph> request header with the value set to "true".</target>
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve">
          <source>In .NET, this can be done by passing the optional <bpt id="p1">**</bpt>FeedOptions<ept id="p1">**</ept> argument to queries with <bpt id="p2">[</bpt>EnableScanInQuery<ept id="p2">](https://msdn.microsoft.com/library/microsoft.azure.documents.client.feedoptions.enablescaninquery.aspx#P:Microsoft.Azure.Documents.Client.FeedOptions.EnableScanInQuery)</ept> set to true.</source>
          <target state="new">In .NET, this can be done by passing the optional <bpt id="p1">**</bpt>FeedOptions<ept id="p1">**</ept> argument to queries with <bpt id="p2">[</bpt>EnableScanInQuery<ept id="p2">](https://msdn.microsoft.com/library/microsoft.azure.documents.client.feedoptions.enablescaninquery.aspx#P:Microsoft.Azure.Documents.Client.FeedOptions.EnableScanInQuery)</ept> set to true.</target>
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve">
          <source>ST_WITHIN can be used to check if a point lies within a polygon.</source>
          <target state="new">ST_WITHIN can be used to check if a point lies within a polygon.</target>
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>Commonly polygons are used to represent boundaries like zip codes, state boundaries, or natural formations.</source>
          <target state="new">Commonly polygons are used to represent boundaries like zip codes, state boundaries, or natural formations.</target>
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source>Again if you include spatial indexing in your indexing policy, then "within" queries will be served efficiently through the index.</source>
          <target state="new">Again if you include spatial indexing in your indexing policy, then "within" queries will be served efficiently through the index.</target>
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source>Polygon arguments in ST_WITHIN can contain only a single ring, i.e. the polygons must not contain holes in them.</source>
          <target state="new">Polygon arguments in ST_WITHIN can contain only a single ring, i.e. the polygons must not contain holes in them.</target>
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>Check the <bpt id="p1">[</bpt>DocumentDB limits<ept id="p1">](documentdb-limits.md)</ept> for the maximum number of points allowed in a polygon for an ST_WITHIN query.</source>
          <target state="new">Check the <bpt id="p1">[</bpt>DocumentDB limits<ept id="p1">](documentdb-limits.md)</ept> for the maximum number of points allowed in a polygon for an ST_WITHIN query.</target>
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Similar to how mismatched types works in DocumentDB query, if the location value specified in either argument is malformed or invalid, then it will evaluate to <bpt id="p1">**</bpt>undefined<ept id="p1">**</ept> and the evaluated document to be skipped from the query results.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Similar to how mismatched types works in DocumentDB query, if the location value specified in either argument is malformed or invalid, then it will evaluate to <bpt id="p1">**</bpt>undefined<ept id="p1">**</ept> and the evaluated document to be skipped from the query results.</target>
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve">
          <source>If your query returns no results, run ST_ISVALIDDETAILED To debug why the spatail type is invalid.</source>
          <target state="new">If your query returns no results, run ST_ISVALIDDETAILED To debug why the spatail type is invalid.</target>
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve">
          <source>ST_ISVALID and ST_ISVALIDDETAILED can be used to check if a spatial object is valid.</source>
          <target state="new">ST_ISVALID and ST_ISVALIDDETAILED can be used to check if a spatial object is valid.</target>
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve">
          <source>For example, the following query checks the validity of a point with an out of range latitude value (-132.8).</source>
          <target state="new">For example, the following query checks the validity of a point with an out of range latitude value (-132.8).</target>
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve">
          <source>ST_ISVALID returns just a Boolean value, and ST_ISVALIDDETAILED returns the Boolean and a string containing the reason why it is considered invalid.</source>
          <target state="new">ST_ISVALID returns just a Boolean value, and ST_ISVALIDDETAILED returns the Boolean and a string containing the reason why it is considered invalid.</target>
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve">
          <source>These functions can also be used to validate polygons.</source>
          <target state="new">These functions can also be used to validate polygons.</target>
        </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve">
          <source>For example, here we use ST_ISVALIDDETAILED to validate a polygon that is not closed.</source>
          <target state="new">For example, here we use ST_ISVALIDDETAILED to validate a polygon that is not closed.</target>
        </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="new">Query</target>
        </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve">
          <source>That wraps up built-in functions, and the SQL grammar for DocumentDB.</source>
          <target state="new">That wraps up built-in functions, and the SQL grammar for DocumentDB.</target>
        </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve">
          <source>Now let's take a look at how LINQ querying works and how it interacts with the grammar we've seen so far.</source>
          <target state="new">Now let's take a look at how LINQ querying works and how it interacts with the grammar we've seen so far.</target>
        </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve">
          <source>LINQ to DocumentDB SQL</source>
          <target state="new">LINQ to DocumentDB SQL</target>
        </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve">
          <source>LINQ is a .NET programming model that expresses computation as queries on streams of objects.</source>
          <target state="new">LINQ is a .NET programming model that expresses computation as queries on streams of objects.</target>
        </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve">
          <source>DocumentDB provides a client side library to interface with LINQ by facilitating a conversion between JSON and .NET objects and a mapping from a subset of LINQ queries to DocumentDB queries.</source>
          <target state="new">DocumentDB provides a client side library to interface with LINQ by facilitating a conversion between JSON and .NET objects and a mapping from a subset of LINQ queries to DocumentDB queries.</target>
        </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve">
          <source>The picture below shows the architecture of supporting LINQ queries using DocumentDB.</source>
          <target state="new">The picture below shows the architecture of supporting LINQ queries using DocumentDB.</target>
        </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve">
          <source>Using the DocumentDB client, developers can create an <bpt id="p1">**</bpt>IQueryable<ept id="p1">**</ept> object that directly queries the DocumentDB query provider, which then translates the LINQ query into a DocumentDB query.</source>
          <target state="new">Using the DocumentDB client, developers can create an <bpt id="p1">**</bpt>IQueryable<ept id="p1">**</ept> object that directly queries the DocumentDB query provider, which then translates the LINQ query into a DocumentDB query.</target>
        </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve">
          <source>The query is then passed to the DocumentDB server to retrieve a set of results in JSON format.</source>
          <target state="new">The query is then passed to the DocumentDB server to retrieve a set of results in JSON format.</target>
        </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve">
          <source>The returned results are deserialized into a stream of .NET objects on the client side.</source>
          <target state="new">The returned results are deserialized into a stream of .NET objects on the client side.</target>
        </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve">
          <source>.NET and JSON mapping</source>
          <target state="new">.NET and JSON mapping</target>
        </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve">
          <source>The mapping between .NET objects and JSON documents is natural - each data member field is mapped to a JSON object, where the field name is mapped to the "key" part of the object and the "value" part is recursively mapped to the value part of the object.</source>
          <target state="new">The mapping between .NET objects and JSON documents is natural - each data member field is mapped to a JSON object, where the field name is mapped to the "key" part of the object and the "value" part is recursively mapped to the value part of the object.</target>
        </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve">
          <source>Consider the following example.</source>
          <target state="new">Consider the following example.</target>
        </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve">
          <source>The Family object created is mapped to the JSON document as shown below.</source>
          <target state="new">The Family object created is mapped to the JSON document as shown below.</target>
        </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve">
          <source>And vice versa, the JSON document is mapped back to a .NET object.</source>
          <target state="new">And vice versa, the JSON document is mapped back to a .NET object.</target>
        </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve">
          <source>C# Class</source>
          <target state="new">C# Class</target>
        </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="new">JSON</target>
        </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve">
          <source>LINQ to SQL translation</source>
          <target state="new">LINQ to SQL translation</target>
        </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve">
          <source>The DocumentDB query provider performs a best effort mapping from a LINQ query into a DocumentDB SQL query.</source>
          <target state="new">The DocumentDB query provider performs a best effort mapping from a LINQ query into a DocumentDB SQL query.</target>
        </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve">
          <source>In the following description, we assume the reader has a basic familiarity of LINQ.</source>
          <target state="new">In the following description, we assume the reader has a basic familiarity of LINQ.</target>
        </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve">
          <source>First, for the type system, we support all JSON primitive types – numeric types, boolean, string, and null.</source>
          <target state="new">First, for the type system, we support all JSON primitive types – numeric types, boolean, string, and null.</target>
        </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve">
          <source>Only these JSON types are supported.</source>
          <target state="new">Only these JSON types are supported.</target>
        </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve">
          <source>The following scalar expressions are supported.</source>
          <target state="new">The following scalar expressions are supported.</target>
        </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve">
          <source>Constant values – these includes constant values of the primitive data types at the time the query is evaluated.</source>
          <target state="new">Constant values – these includes constant values of the primitive data types at the time the query is evaluated.</target>
        </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve">
          <source>Property/array index expressions – these expressions refer to the property of an object or an array element.</source>
          <target state="new">Property/array index expressions – these expressions refer to the property of an object or an array element.</target>
        </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve">
          <source>Arithmetic expressions - These include common arithmetic expressions on numerical and boolean values.</source>
          <target state="new">Arithmetic expressions - These include common arithmetic expressions on numerical and boolean values.</target>
        </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source>For the complete list, refer to the SQL specification.</source>
          <target state="new">For the complete list, refer to the SQL specification.</target>
        </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve">
          <source>String comparison expression - these include comparing a string value to some constant string value.</source>
          <target state="new">String comparison expression - these include comparing a string value to some constant string value.</target>
        </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve">
          <source>Object/array creation expression - these expressions return an object of compound value type or anonymous type or an array of such objects.</source>
          <target state="new">Object/array creation expression - these expressions return an object of compound value type or anonymous type or an array of such objects.</target>
        </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve">
          <source>These values can be nested.</source>
          <target state="new">These values can be nested.</target>
        </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve">
          <source>Query operators</source>
          <target state="new">Query operators</target>
        </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve">
          <source>Here are some examples that illustrate how some of the standard LINQ query operators are translated down to DocumentDB queries.</source>
          <target state="new">Here are some examples that illustrate how some of the standard LINQ query operators are translated down to DocumentDB queries.</target>
        </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve">
          <source>Select Operator</source>
          <target state="new">Select Operator</target>
        </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve">
          <source>The syntax is <ph id="ph1">`input.Select(x =&gt; f(x))`</ph>, where <ph id="ph2">`f`</ph> is a scalar expression.</source>
          <target state="new">The syntax is <ph id="ph1">`input.Select(x =&gt; f(x))`</ph>, where <ph id="ph2">`f`</ph> is a scalar expression.</target>
        </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve">
          <source>LINQ lambda expression</source>
          <target state="new">LINQ lambda expression</target>
        </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve">
          <source>SQL</source>
          <target state="new">SQL</target>
        </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve">
          <source>LINQ lambda expression</source>
          <target state="new">LINQ lambda expression</target>
        </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve">
          <source>SQL</source>
          <target state="new">SQL</target>
        </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source>LINQ lambda expression</source>
          <target state="new">LINQ lambda expression</target>
        </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve">
          <source>SQL</source>
          <target state="new">SQL</target>
        </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source>SelectMany operator</source>
          <target state="new">SelectMany operator</target>
        </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source>The syntax is <ph id="ph1">`input.SelectMany(x =&gt; f(x))`</ph>, where <ph id="ph2">`f`</ph> is a scalar expression that returns a collection type.</source>
          <target state="new">The syntax is <ph id="ph1">`input.SelectMany(x =&gt; f(x))`</ph>, where <ph id="ph2">`f`</ph> is a scalar expression that returns a collection type.</target>
        </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve">
          <source>LINQ lambda expression</source>
          <target state="new">LINQ lambda expression</target>
        </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve">
          <source>SQL</source>
          <target state="new">SQL</target>
        </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve">
          <source>Where operator</source>
          <target state="new">Where operator</target>
        </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve">
          <source>The syntax is <ph id="ph1">`input.Where(x =&gt; f(x))`</ph>, where <ph id="ph2">`f`</ph> is a scalar expression which returns a Boolean value.</source>
          <target state="new">The syntax is <ph id="ph1">`input.Where(x =&gt; f(x))`</ph>, where <ph id="ph2">`f`</ph> is a scalar expression which returns a Boolean value.</target>
        </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve">
          <source>LINQ lambda expression</source>
          <target state="new">LINQ lambda expression</target>
        </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve">
          <source>SQL</source>
          <target state="new">SQL</target>
        </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve">
          <source>LINQ lambda expression</source>
          <target state="new">LINQ lambda expression</target>
        </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve">
          <source>SQL</source>
          <target state="new">SQL</target>
        </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve">
          <source>Composite queries</source>
          <target state="new">Composite queries</target>
        </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve">
          <source>The above operators can be composed to form more powerful queries.</source>
          <target state="new">The above operators can be composed to form more powerful queries.</target>
        </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve">
          <source>Since DocumentDB supports nested collections, the composition can either be concatenated or nested.</source>
          <target state="new">Since DocumentDB supports nested collections, the composition can either be concatenated or nested.</target>
        </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve">
          <source>Concatenation</source>
          <target state="new">Concatenation</target>
        </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve">
          <source>The syntax is <ph id="ph1">`input(.|.SelectMany())(.Select()|.Where())*`</ph>.</source>
          <target state="new">The syntax is <ph id="ph1">`input(.|.SelectMany())(.Select()|.Where())*`</ph>.</target>
        </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve">
          <source>A concatenated query can start with an optional <ph id="ph1">`SelectMany`</ph> query followed by multiple <ph id="ph2">`Select`</ph> or <ph id="ph3">`Where`</ph> operators.</source>
          <target state="new">A concatenated query can start with an optional <ph id="ph1">`SelectMany`</ph> query followed by multiple <ph id="ph2">`Select`</ph> or <ph id="ph3">`Where`</ph> operators.</target>
        </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve">
          <source>LINQ lambda expression</source>
          <target state="new">LINQ lambda expression</target>
        </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve">
          <source>SQL</source>
          <target state="new">SQL</target>
        </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve">
          <source>LINQ lambda expression</source>
          <target state="new">LINQ lambda expression</target>
        </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve">
          <source>SQL</source>
          <target state="new">SQL</target>
        </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve">
          <source>LINQ lambda expression</source>
          <target state="new">LINQ lambda expression</target>
        </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve">
          <source>SQL</source>
          <target state="new">SQL</target>
        </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve">
          <source>LINQ lambda expression</source>
          <target state="new">LINQ lambda expression</target>
        </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve">
          <source>SQL</source>
          <target state="new">SQL</target>
        </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve">
          <source>Nesting</source>
          <target state="new">Nesting</target>
        </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve">
          <source>The syntax is <ph id="ph1">`input.SelectMany(x=&gt;x.Q())`</ph> where Q is a <ph id="ph2">`Select`</ph>, <ph id="ph3">`SelectMany`</ph>, or <ph id="ph4">`Where`</ph> operator.</source>
          <target state="new">The syntax is <ph id="ph1">`input.SelectMany(x=&gt;x.Q())`</ph> where Q is a <ph id="ph2">`Select`</ph>, <ph id="ph3">`SelectMany`</ph>, or <ph id="ph4">`Where`</ph> operator.</target>
        </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source>In a nested query, the inner query is applied to each element of the outer collection.</source>
          <target state="new">In a nested query, the inner query is applied to each element of the outer collection.</target>
        </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source>One important feature is that the inner query can refer to the fields of the elements in the outer collection like self-joins.</source>
          <target state="new">One important feature is that the inner query can refer to the fields of the elements in the outer collection like self-joins.</target>
        </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve">
          <source>LINQ lambda expression</source>
          <target state="new">LINQ lambda expression</target>
        </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve">
          <source>SQL</source>
          <target state="new">SQL</target>
        </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve">
          <source>LINQ lambda expression</source>
          <target state="new">LINQ lambda expression</target>
        </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve">
          <source>SQL</source>
          <target state="new">SQL</target>
        </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve">
          <source>LINQ lambda expression</source>
          <target state="new">LINQ lambda expression</target>
        </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve">
          <source>SQL</source>
          <target state="new">SQL</target>
        </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve">
          <source>Executing queries</source>
          <target state="new">Executing queries</target>
        </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve">
          <source>DocumentDB exposes resources through a REST API that can be called by any language capable of making HTTP/HTTPS requests.</source>
          <target state="new">DocumentDB exposes resources through a REST API that can be called by any language capable of making HTTP/HTTPS requests.</target>
        </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve">
          <source>Additionally, DocumentDB offers programming libraries for several popular languages like .NET, Node.js, JavaScript and Python.</source>
          <target state="new">Additionally, DocumentDB offers programming libraries for several popular languages like .NET, Node.js, JavaScript and Python.</target>
        </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve">
          <source>The REST API and the various libraries all support querying through SQL.</source>
          <target state="new">The REST API and the various libraries all support querying through SQL.</target>
        </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve">
          <source>The .NET SDK supports LINQ querying in addition to SQL.</source>
          <target state="new">The .NET SDK supports LINQ querying in addition to SQL.</target>
        </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve">
          <source>The following examples show how to create a query and submit it against a DocumentDB database account.</source>
          <target state="new">The following examples show how to create a query and submit it against a DocumentDB database account.</target>
        </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve">
          <source>REST API</source>
          <target state="new">REST API</target>
        </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve">
          <source>DocumentDB offers an open RESTful programming model over HTTP.</source>
          <target state="new">DocumentDB offers an open RESTful programming model over HTTP.</target>
        </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve">
          <source>Database accounts can be provisioned using an Azure subscription.</source>
          <target state="new">Database accounts can be provisioned using an Azure subscription.</target>
        </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve">
          <source>The DocumentDB resource model consists of a sets of resources under a database account, each  of which is addressable using a logical and stable URI.</source>
          <target state="new">The DocumentDB resource model consists of a sets of resources under a database account, each  of which is addressable using a logical and stable URI.</target>
        </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve">
          <source>A set of resources is referred to as a feed in this document.</source>
          <target state="new">A set of resources is referred to as a feed in this document.</target>
        </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve">
          <source>A database account consists of a set of databases, each containing multiple collections, each of which in-turn contain documents, UDFs, and other resource types.</source>
          <target state="new">A database account consists of a set of databases, each containing multiple collections, each of which in-turn contain documents, UDFs, and other resource types.</target>
        </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve">
          <source>The basic interaction model with these resources is through the HTTP verbs GET, PUT, POST and DELETE with their standard interpretation.</source>
          <target state="new">The basic interaction model with these resources is through the HTTP verbs GET, PUT, POST and DELETE with their standard interpretation.</target>
        </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve">
          <source>The POST verb is used for creation of a new resource, for executing a stored procedure or for issuing a DocumentDB query.</source>
          <target state="new">The POST verb is used for creation of a new resource, for executing a stored procedure or for issuing a DocumentDB query.</target>
        </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve">
          <source>Queries are always read only operations with no side-effects.</source>
          <target state="new">Queries are always read only operations with no side-effects.</target>
        </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve">
          <source>The following examples show a POST for a DocumentDB query made against a collection containing the two sample documents we've reviewed so far.</source>
          <target state="new">The following examples show a POST for a DocumentDB query made against a collection containing the two sample documents we've reviewed so far.</target>
        </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve">
          <source>The query has a simple filter on the JSON name property.</source>
          <target state="new">The query has a simple filter on the JSON name property.</target>
        </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve">
          <source>Note the use of the <ph id="ph1">`x-ms-documentdb-isquery`</ph> and Content-Type: <ph id="ph2">`application/query+json`</ph> headers to denote that the operation is a query.</source>
          <target state="new">Note the use of the <ph id="ph1">`x-ms-documentdb-isquery`</ph> and Content-Type: <ph id="ph2">`application/query+json`</ph> headers to denote that the operation is a query.</target>
        </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve">
          <source>Request</source>
          <target state="new">Request</target>
        </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve">
          <source>The second example shows a more complex query that returns multiple results from the join.</source>
          <target state="new">The second example shows a more complex query that returns multiple results from the join.</target>
        </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve">
          <source>Request</source>
          <target state="new">Request</target>
        </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="new">Results</target>
        </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve">
          <source>If a query's results cannot fit within a single page of results, then the REST API returns a continuation token through the <ph id="ph1">`x-ms-continuation-token`</ph> response header.</source>
          <target state="new">If a query's results cannot fit within a single page of results, then the REST API returns a continuation token through the <ph id="ph1">`x-ms-continuation-token`</ph> response header.</target>
        </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve">
          <source>Clients can paginate results by including the header in subsequent results.</source>
          <target state="new">Clients can paginate results by including the header in subsequent results.</target>
        </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve">
          <source>The number of results per page can also be controlled through the <ph id="ph1">`x-ms-max-item-count`</ph> number header.</source>
          <target state="new">The number of results per page can also be controlled through the <ph id="ph1">`x-ms-max-item-count`</ph> number header.</target>
        </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve">
          <source>To manage the data consistency policy for queries, use the <ph id="ph1">`x-ms-consistency-level`</ph> header like all REST API requests.</source>
          <target state="new">To manage the data consistency policy for queries, use the <ph id="ph1">`x-ms-consistency-level`</ph> header like all REST API requests.</target>
        </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve">
          <source>For session consistency, it is required to also echo the latest <ph id="ph1">`x-ms-session-token`</ph> Cookie header in the query request.</source>
          <target state="new">For session consistency, it is required to also echo the latest <ph id="ph1">`x-ms-session-token`</ph> Cookie header in the query request.</target>
        </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve">
          <source>Note that the queried collection's indexing policy can also influence the consistency of query results.</source>
          <target state="new">Note that the queried collection's indexing policy can also influence the consistency of query results.</target>
        </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve">
          <source>With the default indexing policy settings, for collections the index is always current with the document contents and query results will match the consistency chosen for data.</source>
          <target state="new">With the default indexing policy settings, for collections the index is always current with the document contents and query results will match the consistency chosen for data.</target>
        </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve">
          <source>If the indexing policy is relaxed to Lazy, then queries can return stale results.</source>
          <target state="new">If the indexing policy is relaxed to Lazy, then queries can return stale results.</target>
        </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve">
          <source>For more information, refer to <bpt id="p1">[</bpt>DocumentDB Consistency Levels<ept id="p1">] [consistency-levels]</ept>.</source>
          <target state="new">For more information, refer to <bpt id="p1">[</bpt>DocumentDB Consistency Levels<ept id="p1">] [consistency-levels]</ept>.</target>
        </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve">
          <source>If the configured indexing policy on the collection cannot support the specified query, the DocumentDB server returns 400 "Bad Request".</source>
          <target state="new">If the configured indexing policy on the collection cannot support the specified query, the DocumentDB server returns 400 "Bad Request".</target>
        </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve">
          <source>This is returned for range queries against paths configured for hash (equality) lookups, and for paths explicitly excluded from indexing.</source>
          <target state="new">This is returned for range queries against paths configured for hash (equality) lookups, and for paths explicitly excluded from indexing.</target>
        </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`x-ms-documentdb-query-enable-scan`</ph> header can be specified to allow the query to perform a scan when an index is not available.</source>
          <target state="new">The <ph id="ph1">`x-ms-documentdb-query-enable-scan`</ph> header can be specified to allow the query to perform a scan when an index is not available.</target>
        </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve">
          <source>C# (.NET) SDK</source>
          <target state="new">C# (.NET) SDK</target>
        </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve">
          <source>The .NET SDK supports both LINQ and SQL querying.</source>
          <target state="new">The .NET SDK supports both LINQ and SQL querying.</target>
        </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve">
          <source>The following example shows how to perform the simple filter query introduced earlier in this document.</source>
          <target state="new">The following example shows how to perform the simple filter query introduced earlier in this document.</target>
        </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve">
          <source>This sample compares two properties for equality within each document and uses anonymous projections.</source>
          <target state="new">This sample compares two properties for equality within each document and uses anonymous projections.</target>
        </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve">
          <source>The next sample shows joins, expressed through LINQ SelectMany.</source>
          <target state="new">The next sample shows joins, expressed through LINQ SelectMany.</target>
        </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve">
          <source>The .NET client automatically iterates through all the pages of query results in the foreach blocks as shown above.</source>
          <target state="new">The .NET client automatically iterates through all the pages of query results in the foreach blocks as shown above.</target>
        </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve">
          <source>The query options introduced in the REST API section are also available in the .NET SDK using the <ph id="ph1">`FeedOptions`</ph> and <ph id="ph2">`FeedResponse`</ph> classes in the CreateDocumentQuery method.</source>
          <target state="new">The query options introduced in the REST API section are also available in the .NET SDK using the <ph id="ph1">`FeedOptions`</ph> and <ph id="ph2">`FeedResponse`</ph> classes in the CreateDocumentQuery method.</target>
        </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source>The number of pages can be controlled using the <ph id="ph1">`MaxItemCount`</ph> setting.</source>
          <target state="new">The number of pages can be controlled using the <ph id="ph1">`MaxItemCount`</ph> setting.</target>
        </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source>Developers can also explicitly control paging by creating <ph id="ph1">`IDocumentQueryable`</ph> using the <ph id="ph2">`IQueryable`</ph> object, then by reading the<ph id="ph3">` ResponseContinuationToken`</ph> values and passing them back as <ph id="ph4">`RequestContinuationToken`</ph> in <ph id="ph5">`FeedOptions`</ph>.</source>
          <target state="new">Developers can also explicitly control paging by creating <ph id="ph1">`IDocumentQueryable`</ph> using the <ph id="ph2">`IQueryable`</ph> object, then by reading the<ph id="ph3">` ResponseContinuationToken`</ph> values and passing them back as <ph id="ph4">`RequestContinuationToken`</ph> in <ph id="ph5">`FeedOptions`</ph>.</target>
        </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`EnableScanInQuery`</ph> can be set to enable scans when the query cannot be supported by the configured indexing policy.</source>
          <target state="new"><ph id="ph1">`EnableScanInQuery`</ph> can be set to enable scans when the query cannot be supported by the configured indexing policy.</target>
        </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve">
          <source>Refer to <bpt id="p1">[</bpt>DocumentDB .NET samples<ept id="p1">](https://github.com/Azure/azure-documentdb-net)</ept> for more samples containing queries.</source>
          <target state="new">Refer to <bpt id="p1">[</bpt>DocumentDB .NET samples<ept id="p1">](https://github.com/Azure/azure-documentdb-net)</ept> for more samples containing queries.</target>
        </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve">
          <source>JavaScript server-side API</source>
          <target state="new">JavaScript server-side API</target>
        </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve">
          <source>DocumentDB provides a programming model for executing JavaScript based application logic directly on the collections using stored procedures and triggers.</source>
          <target state="new">DocumentDB provides a programming model for executing JavaScript based application logic directly on the collections using stored procedures and triggers.</target>
        </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve">
          <source>The JavaScript logic registered at a collection level can then issue database operations on the operations on the documents of the given collection.</source>
          <target state="new">The JavaScript logic registered at a collection level can then issue database operations on the operations on the documents of the given collection.</target>
        </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve">
          <source>These operations are wrapped in ambient ACID transactions.</source>
          <target state="new">These operations are wrapped in ambient ACID transactions.</target>
        </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve">
          <source>The following example show how to use the queryDocuments in the JavaScript server API to make queries from inside stored procedures and triggers.</source>
          <target state="new">The following example show how to use the queryDocuments in the JavaScript server API to make queries from inside stored procedures and triggers.</target>
        </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="new">References</target>
        </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve">
          <source>Introduction to Azure DocumentDB</source>
          <target state="new">Introduction to Azure DocumentDB</target>
        </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve">
          <source>DocumentDB SQL specification</source>
          <target state="new">DocumentDB SQL specification</target>
        </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve">
          <source>DocumentDB .NET samples</source>
          <target state="new">DocumentDB .NET samples</target>
        </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve">
          <source>DocumentDB Consistency Levels</source>
          <target state="new">DocumentDB Consistency Levels</target>
        </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve">
          <source>ANSI SQL 2011 <bpt id="p1">[</bpt>http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=53681<ept id="p1">](http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=53681)</ept></source>
          <target state="new">ANSI SQL 2011 <bpt id="p1">[</bpt>http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=53681<ept id="p1">](http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=53681)</ept></target>
        </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve">
          <source>JSON <bpt id="p1">[</bpt>http://json.org/<ept id="p1">](http://json.org/)</ept></source>
          <target state="new">JSON <bpt id="p1">[</bpt>http://json.org/<ept id="p1">](http://json.org/)</ept></target>
        </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve">
          <source>Javascript Specification <bpt id="p1">[</bpt>http://www.ecma-international.org/publications/standards/Ecma-262.htm<ept id="p1">](http://www.ecma-international.org/publications/standards/Ecma-262.htm)</ept></source>
          <target state="new">Javascript Specification <bpt id="p1">[</bpt>http://www.ecma-international.org/publications/standards/Ecma-262.htm<ept id="p1">](http://www.ecma-international.org/publications/standards/Ecma-262.htm)</ept></target>
        </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve">
          <source>LINQ <bpt id="p1">[</bpt>http://msdn.microsoft.com/library/bb308959.aspx<ept id="p1">](http://msdn.microsoft.com/library/bb308959.aspx)</ept></source>
          <target state="new">LINQ <bpt id="p1">[</bpt>http://msdn.microsoft.com/library/bb308959.aspx<ept id="p1">](http://msdn.microsoft.com/library/bb308959.aspx)</ept></target>
        </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve">
          <source>Query evaluation techniques for large databases <bpt id="p1">[</bpt>http://dl.acm.org/citation.cfm?id=152611<ept id="p1">](http://dl.acm.org/citation.cfm?id=152611)</ept></source>
          <target state="new">Query evaluation techniques for large databases <bpt id="p1">[</bpt>http://dl.acm.org/citation.cfm?id=152611<ept id="p1">](http://dl.acm.org/citation.cfm?id=152611)</ept></target>
        </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve">
          <source>Query Processing in Parallel Relational Database Systems, IEEE Computer Society Press, 1994</source>
          <target state="new">Query Processing in Parallel Relational Database Systems, IEEE Computer Society Press, 1994</target>
        </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve">
          <source>Lu, Ooi, Tan, Query Processing in Parallel Relational Database Systems, IEEE Computer Society Press, 1994.</source>
          <target state="new">Lu, Ooi, Tan, Query Processing in Parallel Relational Database Systems, IEEE Computer Society Press, 1994.</target>
        </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve">
          <source>Christopher Olston, Benjamin Reed, Utkarsh Srivastava, Ravi Kumar, Andrew Tomkins: Pig Latin: A Not-So-Foreign Language for Data Processing, SIGMOD 2008.</source>
          <target state="new">Christopher Olston, Benjamin Reed, Utkarsh Srivastava, Ravi Kumar, Andrew Tomkins: Pig Latin: A Not-So-Foreign Language for Data Processing, SIGMOD 2008.</target>
        </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve">
          <source>G.</source>
          <target state="new">G.</target>
        </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve">
          <source>Graefe.</source>
          <target state="new">Graefe.</target>
        </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve">
          <source>The Cascades framework for query optimization.</source>
          <target state="new">The Cascades framework for query optimization.</target>
        </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve">
          <source>IEEE Data Eng.</source>
          <target state="new">IEEE Data Eng.</target>
        </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve">
          <source>Bull., 18(3): 1995.</source>
          <target state="new">Bull., 18(3): 1995.</target>
        </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve">
          <source>test</source>
          <target state="new">test</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">17b6e3f45ec5bdb225754b38bb0090a3c5f0076b</xliffext:olfilehash>
  </header>
</xliff>