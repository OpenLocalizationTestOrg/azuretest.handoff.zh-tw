<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Data partitioning guidance | Microsoft Azure</source>
          <target state="new">Data partitioning guidance | Microsoft Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Guidance upon how to separate partitions to be managed and accessed separately.</source>
          <target state="new">Guidance upon how to separate partitions to be managed and accessed separately.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Data partitioning guidance</source>
          <target state="new">Data partitioning guidance</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="new">Overview</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>In many large-scale solutions, data is divided into separate partitions that can be managed and accessed separately.</source>
          <target state="new">In many large-scale solutions, data is divided into separate partitions that can be managed and accessed separately.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The partitioning strategy must be chosen carefully to maximize the benefits while minimizing adverse effects.</source>
          <target state="new">The partitioning strategy must be chosen carefully to maximize the benefits while minimizing adverse effects.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Partitioning can help to improve scalability, reduce contention, and optimize performance.</source>
          <target state="new">Partitioning can help to improve scalability, reduce contention, and optimize performance.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>A side-benefit of partitioning is that can also provide a mechanism for dividing data by the pattern of use; you could archive older, more inactive (cold) data to cheaper data storage.</source>
          <target state="new">A side-benefit of partitioning is that can also provide a mechanism for dividing data by the pattern of use; you could archive older, more inactive (cold) data to cheaper data storage.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Why partition data?</source>
          <target state="new">Why partition data?</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Most cloud applications and services store and retrieve data as part of their operations.</source>
          <target state="new">Most cloud applications and services store and retrieve data as part of their operations.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The design of the data stores that an application uses can have a significant bearing on the performance, throughput, and scalability of a system.</source>
          <target state="new">The design of the data stores that an application uses can have a significant bearing on the performance, throughput, and scalability of a system.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>One technique that is commonly applied in large-scale systems is to divide the data into separate partitions.</source>
          <target state="new">One technique that is commonly applied in large-scale systems is to divide the data into separate partitions.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The term <bpt id="p1">_</bpt>partitioning<ept id="p1">_</ept> used in this guidance refers to the process of physically dividing data into separate data stores.</source>
          <target state="new">The term <bpt id="p1">_</bpt>partitioning<ept id="p1">_</ept> used in this guidance refers to the process of physically dividing data into separate data stores.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>This is not the same as SQL Server Table Partitioning, which is a different concept.</source>
          <target state="new">This is not the same as SQL Server Table Partitioning, which is a different concept.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Partitioning data can offer a number of benefits.</source>
          <target state="new">Partitioning data can offer a number of benefits.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>For example, it can be applied in order to:</source>
          <target state="new">For example, it can be applied in order to:</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Improve scalability<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Improve scalability<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Scaling up a single database system will eventually reach a physical hardware limit.</source>
          <target state="new">Scaling up a single database system will eventually reach a physical hardware limit.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Dividing data across multiple partitions, each of which is hosted on a separate server, allows the system to scale out almost indefinitely.</source>
          <target state="new">Dividing data across multiple partitions, each of which is hosted on a separate server, allows the system to scale out almost indefinitely.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Improve performance<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Improve performance<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Data access operations on each partition take place over a smaller volume of data.</source>
          <target state="new">Data access operations on each partition take place over a smaller volume of data.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Provided that the data is partitioned in a suitable way, this is much more efficient.</source>
          <target state="new">Provided that the data is partitioned in a suitable way, this is much more efficient.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Operations that affect more than one partition can execute in parallel.</source>
          <target state="new">Operations that affect more than one partition can execute in parallel.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Each partition can be located near the application that uses it to minimize network latency.</source>
          <target state="new">Each partition can be located near the application that uses it to minimize network latency.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Improve availability<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Improve availability<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Separating data across multiple servers avoids a single point of failure.</source>
          <target state="new">Separating data across multiple servers avoids a single point of failure.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>If a server fails, or is undergoing planned maintenance, only the data in that partition is unavailable.</source>
          <target state="new">If a server fails, or is undergoing planned maintenance, only the data in that partition is unavailable.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Operations on other partitions can continue.</source>
          <target state="new">Operations on other partitions can continue.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Increasing the number of partitions reduces the relative impact of a single server failure by reducing the percentage of the data that will be unavailable.</source>
          <target state="new">Increasing the number of partitions reduces the relative impact of a single server failure by reducing the percentage of the data that will be unavailable.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Replicating each partition can further reduce the chance of a single partition failure affecting operations.</source>
          <target state="new">Replicating each partition can further reduce the chance of a single partition failure affecting operations.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>It also enables the separation of critical data that must be continually and highly available from low value data (such as log files) that has lower availability requirements.</source>
          <target state="new">It also enables the separation of critical data that must be continually and highly available from low value data (such as log files) that has lower availability requirements.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Improve security<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Improve security<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Depending on the nature of the data and how it is partitioned, it may be possible to separate sensitive and non-sensitive data into different partitions, and therefore different servers or data stores.</source>
          <target state="new">Depending on the nature of the data and how it is partitioned, it may be possible to separate sensitive and non-sensitive data into different partitions, and therefore different servers or data stores.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Security can then be specifically optimized for the sensitive data.</source>
          <target state="new">Security can then be specifically optimized for the sensitive data.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Provide operational flexibility<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Provide operational flexibility<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Partitioning offers many opportunities for fine tuning operations, maximizing administrative efficiency, and minimizing cost.</source>
          <target state="new">Partitioning offers many opportunities for fine tuning operations, maximizing administrative efficiency, and minimizing cost.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Some examples are defining different strategies for management, monitoring, backup and restore, and other administrative tasks based on the importance of the data in each partition.</source>
          <target state="new">Some examples are defining different strategies for management, monitoring, backup and restore, and other administrative tasks based on the importance of the data in each partition.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Match the data store to the pattern of use<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Match the data store to the pattern of use<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Partitioning allows each partition to be deployed on a different type of data store, based on cost and the built-in features that data store offers.</source>
          <target state="new">Partitioning allows each partition to be deployed on a different type of data store, based on cost and the built-in features that data store offers.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For example, large binary data could be stored in a blob data store, while more structured data could be held in a document database.</source>
          <target state="new">For example, large binary data could be stored in a blob data store, while more structured data could be held in a document database.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For more information see <bpt id="p1">[</bpt>Building a Polyglot Solution<ept id="p1">](https://msdn.microsoft.com/library/dn313279.aspx)</ept> in the patterns &amp; practices guide <bpt id="p2">[</bpt>Data Access for Highly-Scalable Solutions: Using SQL, NoSQL, and Polyglot Persistence<ept id="p2">](https://msdn.microsoft.com/library/dn271399.aspx)</ept> on the Microsoft website.</source>
          <target state="new">For more information see <bpt id="p1">[</bpt>Building a Polyglot Solution<ept id="p1">](https://msdn.microsoft.com/library/dn313279.aspx)</ept> in the patterns &amp; practices guide <bpt id="p2">[</bpt>Data Access for Highly-Scalable Solutions: Using SQL, NoSQL, and Polyglot Persistence<ept id="p2">](https://msdn.microsoft.com/library/dn271399.aspx)</ept> on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Some systems do not implement partitioning because it is considered an overhead rather than an advantage.</source>
          <target state="new">Some systems do not implement partitioning because it is considered an overhead rather than an advantage.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Common reasons for this rationale include:</source>
          <target state="new">Common reasons for this rationale include:</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Many data storage systems do not support joins across partitions, and it can be difficult to maintain referential integrity in a partitioned system.</source>
          <target state="new">Many data storage systems do not support joins across partitions, and it can be difficult to maintain referential integrity in a partitioned system.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>It is frequently necessary to implement joins and integrity checks in application code (in the partitioning layer), which can result in additional I/O and application complexity.</source>
          <target state="new">It is frequently necessary to implement joins and integrity checks in application code (in the partitioning layer), which can result in additional I/O and application complexity.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Maintaining partitions is not always a trivial task.</source>
          <target state="new">Maintaining partitions is not always a trivial task.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>In a system where the data is volatile, you may need to rebalance partitions periodically to reduce contention and hot spots.</source>
          <target state="new">In a system where the data is volatile, you may need to rebalance partitions periodically to reduce contention and hot spots.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Some common tools do not work naturally with partitioned data.</source>
          <target state="new">Some common tools do not work naturally with partitioned data.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Designing partitions</source>
          <target state="new">Designing partitions</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Data can be partitioned in different ways: horizontally, vertically, or functionally.</source>
          <target state="new">Data can be partitioned in different ways: horizontally, vertically, or functionally.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The strategy you choose depends on the reason for partitioning the data, and the requirements of the applications and services that will use the data.</source>
          <target state="new">The strategy you choose depends on the reason for partitioning the data, and the requirements of the applications and services that will use the data.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> The partitioning schemes described in this guidance are explained in a way that is independent of the underlying data storage technology.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> The partitioning schemes described in this guidance are explained in a way that is independent of the underlying data storage technology.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>They can be applied to many types of data stores, including relational and NoSQL databases.</source>
          <target state="new">They can be applied to many types of data stores, including relational and NoSQL databases.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Partitioning strategies</source>
          <target state="new">Partitioning strategies</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The three typical strategies for partitioning data are:</source>
          <target state="new">The three typical strategies for partitioning data are:</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Horizontal partitioning<ept id="p1">**</ept> (often called <bpt id="p2">_</bpt>sharding<ept id="p2">_</ept>).</source>
          <target state="new"><bpt id="p1">**</bpt>Horizontal partitioning<ept id="p1">**</ept> (often called <bpt id="p2">_</bpt>sharding<ept id="p2">_</ept>).</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In this strategy each partition is a data store in its own right, but all partitions have the same schema.</source>
          <target state="new">In this strategy each partition is a data store in its own right, but all partitions have the same schema.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Each partition is known as a <bpt id="p1">_</bpt>shard<ept id="p1">_</ept> and holds a specific subset of the data, such as all the orders for a specific set of customers in an ecommerce application.</source>
          <target state="new">Each partition is known as a <bpt id="p1">_</bpt>shard<ept id="p1">_</ept> and holds a specific subset of the data, such as all the orders for a specific set of customers in an ecommerce application.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Vertical partitioning<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Vertical partitioning<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>In this strategy each partition holds a subset of the fields for items in the data store.</source>
          <target state="new">In this strategy each partition holds a subset of the fields for items in the data store.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The fields are divided according to their pattern of use, such as placing the frequently accessed fields in one vertical partition and the less frequently accessed fields in another.</source>
          <target state="new">The fields are divided according to their pattern of use, such as placing the frequently accessed fields in one vertical partition and the less frequently accessed fields in another.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Functional partitioning<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Functional partitioning<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>In this strategy data is aggregated according to how it is used by each bounded context in the system.</source>
          <target state="new">In this strategy data is aggregated according to how it is used by each bounded context in the system.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For example, an ecommerce system that implements separate business functions for invoicing and managing product inventory might store invoice data in one partition and product inventory data in another.</source>
          <target state="new">For example, an ecommerce system that implements separate business functions for invoicing and managing product inventory might store invoice data in one partition and product inventory data in another.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>It’s important to note that the three strategies described here can be combined.</source>
          <target state="new">It’s important to note that the three strategies described here can be combined.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>They are not mutually exclusive and you should consider them all when you design a partitioning scheme.</source>
          <target state="new">They are not mutually exclusive and you should consider them all when you design a partitioning scheme.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>For example, you might divide data into shards and then use vertical partitioning to further subdivide the data in each shard.</source>
          <target state="new">For example, you might divide data into shards and then use vertical partitioning to further subdivide the data in each shard.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Similarly, the data in a functional partition may be split into shards (which may also be vertically partitioned).</source>
          <target state="new">Similarly, the data in a functional partition may be split into shards (which may also be vertically partitioned).</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>However, the differing requirements of each strategy can raise a number of conflicting issues that you must evaluate and balance when designing a partitioning scheme that meets the overall data processing performance targets for your system.</source>
          <target state="new">However, the differing requirements of each strategy can raise a number of conflicting issues that you must evaluate and balance when designing a partitioning scheme that meets the overall data processing performance targets for your system.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The following sections explore each of the strategies in more detail.</source>
          <target state="new">The following sections explore each of the strategies in more detail.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Horizontal partitioning (sharding)</source>
          <target state="new">Horizontal partitioning (sharding)</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Figure 1 shows an overview of horizontal partitioning or sharding.</source>
          <target state="new">Figure 1 shows an overview of horizontal partitioning or sharding.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>In this example, product inventory data is divided into shards based on the product key.</source>
          <target state="new">In this example, product inventory data is divided into shards based on the product key.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Each shard holds the data for a contiguous range of shard keys (A-G and H-Z), organized alphabetically.</source>
          <target state="new">Each shard holds the data for a contiguous range of shard keys (A-G and H-Z), organized alphabetically.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Figure 1.</source>
          <target state="new">Figure 1.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>- Horizontally partitioning (sharding) data based on a partition key</source>
          <target state="new">- Horizontally partitioning (sharding) data based on a partition key</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Sharding enables you to spread the load over more computers; reducing contention, and improving performance.</source>
          <target state="new">Sharding enables you to spread the load over more computers; reducing contention, and improving performance.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>You can scale the system out by adding further shards running on additional servers.</source>
          <target state="new">You can scale the system out by adding further shards running on additional servers.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The most important factor when implementing this partitioning strategy is the choice of sharding key.</source>
          <target state="new">The most important factor when implementing this partitioning strategy is the choice of sharding key.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>It can be difficult to change the key after the system is in operation.</source>
          <target state="new">It can be difficult to change the key after the system is in operation.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The key must ensure that data is partitioned so that the workload is as even as possible across the shards.</source>
          <target state="new">The key must ensure that data is partitioned so that the workload is as even as possible across the shards.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Note that different shards do not have to contain similar volumes of data, rather the important consideration is to balance the number of requests; some shards may be very large but each item is the subject of a low number of access operations, while other shards may be smaller but each item is accessed much more frequently.</source>
          <target state="new">Note that different shards do not have to contain similar volumes of data, rather the important consideration is to balance the number of requests; some shards may be very large but each item is the subject of a low number of access operations, while other shards may be smaller but each item is accessed much more frequently.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>It is also important to ensure that a single shard does not exceed the scale limits (in terms of capacity and processing resources) of the data store being used to host that shard.</source>
          <target state="new">It is also important to ensure that a single shard does not exceed the scale limits (in terms of capacity and processing resources) of the data store being used to host that shard.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The sharding scheme should also avoid creating hotspots (or hot partitions) that may affect performance and availability.</source>
          <target state="new">The sharding scheme should also avoid creating hotspots (or hot partitions) that may affect performance and availability.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>For example, using a hash of a customer identifier instead of the first letter of a customer’s name will prevent the unbalanced distribution that would result from common and less common initial letters.</source>
          <target state="new">For example, using a hash of a customer identifier instead of the first letter of a customer’s name will prevent the unbalanced distribution that would result from common and less common initial letters.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>This is a typical technique that helps to distribute the data more evenly across partitions.</source>
          <target state="new">This is a typical technique that helps to distribute the data more evenly across partitions.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The sharding key you choose should minimize any future requirements to split large shards into smaller pieces, coalesce small shards into larger partitions, or change the schema that describes the data stored in a set of partitions.</source>
          <target state="new">The sharding key you choose should minimize any future requirements to split large shards into smaller pieces, coalesce small shards into larger partitions, or change the schema that describes the data stored in a set of partitions.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>These operations can be very time consuming, and may require taking one or more shards offline while they are performed.</source>
          <target state="new">These operations can be very time consuming, and may require taking one or more shards offline while they are performed.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>If shards are replicated, it may be possible to keep some of the replicas online while others are split, merged, or reconfigured, but the system may need to limit the operations that can be performed on the data in these shards while the reconfiguration is taking place.</source>
          <target state="new">If shards are replicated, it may be possible to keep some of the replicas online while others are split, merged, or reconfigured, but the system may need to limit the operations that can be performed on the data in these shards while the reconfiguration is taking place.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>For example, the data in the replicas could be marked as read-only to limit the scope of any inconsistences that could otherwise occur while shards are being restructured.</source>
          <target state="new">For example, the data in the replicas could be marked as read-only to limit the scope of any inconsistences that could otherwise occur while shards are being restructured.</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>For more detailed information and guidance about many of these considerations, and good practice techniques for designing data stores that implement horizontal partitioning, see the <bpt id="p1">[</bpt>Sharding Pattern<ept id="p1">](http://aka.ms/Sharding-Pattern)</ept></source>
          <target state="new">For more detailed information and guidance about many of these considerations, and good practice techniques for designing data stores that implement horizontal partitioning, see the <bpt id="p1">[</bpt>Sharding Pattern<ept id="p1">](http://aka.ms/Sharding-Pattern)</ept></target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Vertical partitioning</source>
          <target state="new">Vertical partitioning</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The most common use for vertical partitioning is to reduce the I/O and performance costs associated with fetching the items that are accessed most frequently.</source>
          <target state="new">The most common use for vertical partitioning is to reduce the I/O and performance costs associated with fetching the items that are accessed most frequently.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Figure 2 shows an overview of an example of vertical partitioning, where different properties for each data item are held in different partitions; the name, description, and price information for products are accessed more frequently than the volume in stock or the last ordered date.</source>
          <target state="new">Figure 2 shows an overview of an example of vertical partitioning, where different properties for each data item are held in different partitions; the name, description, and price information for products are accessed more frequently than the volume in stock or the last ordered date.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Figure 2.</source>
          <target state="new">Figure 2.</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>- Vertically partitioning data by its pattern of use</source>
          <target state="new">- Vertically partitioning data by its pattern of use</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>In this example, the application regularly queries the product name, description, and price together when displaying the details of products to customers.</source>
          <target state="new">In this example, the application regularly queries the product name, description, and price together when displaying the details of products to customers.</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The stock level and date when the product was last ordered from the manufacturer are held in a separate partition because these two items are commonly used together.</source>
          <target state="new">The stock level and date when the product was last ordered from the manufacturer are held in a separate partition because these two items are commonly used together.</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>This partitioning scheme has the added advantage that the relatively slow-moving data (product name, description, and price) is separated from the more dynamic data (stock level and last ordered date).</source>
          <target state="new">This partitioning scheme has the added advantage that the relatively slow-moving data (product name, description, and price) is separated from the more dynamic data (stock level and last ordered date).</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>An application may find it beneficial to cache the slow-moving data in memory if it is frequently accessed.</source>
          <target state="new">An application may find it beneficial to cache the slow-moving data in memory if it is frequently accessed.</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Another typical scenario for this partitioning strategy is to maximize the security of sensitive data.</source>
          <target state="new">Another typical scenario for this partitioning strategy is to maximize the security of sensitive data.</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>For example, by storing credit card numbers and the corresponding card security verification numbers in separate partitions.</source>
          <target state="new">For example, by storing credit card numbers and the corresponding card security verification numbers in separate partitions.</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Vertical partitioning can also reduce the amount of concurrent access required to the data.</source>
          <target state="new">Vertical partitioning can also reduce the amount of concurrent access required to the data.</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Vertical partitioning operates at the entity level within a data store, partially normalizing an entity to break it down from a <bpt id="p1">_</bpt>wide<ept id="p1">_</ept> item to a set of <bpt id="p2">_</bpt>narrow<ept id="p2">_</ept> items.</source>
          <target state="new">Vertical partitioning operates at the entity level within a data store, partially normalizing an entity to break it down from a <bpt id="p1">_</bpt>wide<ept id="p1">_</ept> item to a set of <bpt id="p2">_</bpt>narrow<ept id="p2">_</ept> items.</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>It is ideally suited for column-oriented data stores such as HBase and Cassandra.</source>
          <target state="new">It is ideally suited for column-oriented data stores such as HBase and Cassandra.</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>If the data in a collection of columns is unlikely to change, you can also consider using column stores in SQL Server.</source>
          <target state="new">If the data in a collection of columns is unlikely to change, you can also consider using column stores in SQL Server.</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Functional partitioning</source>
          <target state="new">Functional partitioning</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>For systems where it is possible to identify a bounded context for each distinct business area or service in the application, functional partitioning provides a technique for improving isolation and data access performance.</source>
          <target state="new">For systems where it is possible to identify a bounded context for each distinct business area or service in the application, functional partitioning provides a technique for improving isolation and data access performance.</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Another common use of functional partitioning is to separate read-write data from read-only data used for reporting purposes.</source>
          <target state="new">Another common use of functional partitioning is to separate read-write data from read-only data used for reporting purposes.</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Figure 3 shows an overview of functional partitioning where inventory data is separated from customer data.</source>
          <target state="new">Figure 3 shows an overview of functional partitioning where inventory data is separated from customer data.</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Figure 3.</source>
          <target state="new">Figure 3.</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>- Functionally partitioning data by bounded context or subdomain</source>
          <target state="new">- Functionally partitioning data by bounded context or subdomain</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>This partitioning strategy can help to reduce data access contention across different parts of the system.</source>
          <target state="new">This partitioning strategy can help to reduce data access contention across different parts of the system.</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Designing partitions for scalability</source>
          <target state="new">Designing partitions for scalability</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>It is vital to consider size and workload for each partition and balance them so that data is distributed to achieve maximum scalability.</source>
          <target state="new">It is vital to consider size and workload for each partition and balance them so that data is distributed to achieve maximum scalability.</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>However, you must also partition the data so that it does not exceed the scaling limits of a single partition store.</source>
          <target state="new">However, you must also partition the data so that it does not exceed the scaling limits of a single partition store.</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Follow these steps when designing the partitions for scalability:</source>
          <target state="new">Follow these steps when designing the partitions for scalability:</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Analyze the application to understand the data access patterns, such as size of the result set returned by each query, the frequency of access, the inherent latency, and the server-side compute processing requirements.</source>
          <target state="new">Analyze the application to understand the data access patterns, such as size of the result set returned by each query, the frequency of access, the inherent latency, and the server-side compute processing requirements.</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>In many cases, a few major entities will demand most of the processing resources.</source>
          <target state="new">In many cases, a few major entities will demand most of the processing resources.</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Based on the analysis, determine the current and future scalability targets such as data size and workload, and distribute the data across the partitions to meet the scalability target.</source>
          <target state="new">Based on the analysis, determine the current and future scalability targets such as data size and workload, and distribute the data across the partitions to meet the scalability target.</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>In the horizontal partitioning strategy, choosing the appropriate shard key is important to make sure distribution is even.</source>
          <target state="new">In the horizontal partitioning strategy, choosing the appropriate shard key is important to make sure distribution is even.</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>For more information see the <bpt id="p1">[</bpt>Sharding pattern<ept id="p1">](http://aka.ms/Sharding-Pattern)</ept>.</source>
          <target state="new">For more information see the <bpt id="p1">[</bpt>Sharding pattern<ept id="p1">](http://aka.ms/Sharding-Pattern)</ept>.</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Make sure that the resources available to each partition are sufficient to handle the scalability requirements in terms of data size and throughput.</source>
          <target state="new">Make sure that the resources available to each partition are sufficient to handle the scalability requirements in terms of data size and throughput.</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>For example, the node hosting a partition might impose a hard limit on the amount of storage space, processing power, or network bandwidth that it provides.</source>
          <target state="new">For example, the node hosting a partition might impose a hard limit on the amount of storage space, processing power, or network bandwidth that it provides.</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>If the data storage and processing requirements are likely to exceed these limits it may be necessary to refine your partitioning strategy or split data out further.</source>
          <target state="new">If the data storage and processing requirements are likely to exceed these limits it may be necessary to refine your partitioning strategy or split data out further.</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>For example, one scalability approach might be to separate logging data from the core application features by using separate data stores to prevent the total data storage requirements exceeding the scaling limit of the node.</source>
          <target state="new">For example, one scalability approach might be to separate logging data from the core application features by using separate data stores to prevent the total data storage requirements exceeding the scaling limit of the node.</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>If the total number of data stores exceeds the node limit, it may be necessary to use separate storage nodes.</source>
          <target state="new">If the total number of data stores exceeds the node limit, it may be necessary to use separate storage nodes.</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Monitor the system under use to verify that the data is distributed as expected and that the partitions can handle the load imposed on them.</source>
          <target state="new">Monitor the system under use to verify that the data is distributed as expected and that the partitions can handle the load imposed on them.</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>It could be possible that the usage does not match that anticipated by the analysis it may be possible to rebalance the partitions.</source>
          <target state="new">It could be possible that the usage does not match that anticipated by the analysis it may be possible to rebalance the partitions.</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Failing that, it may be necessary to redesign some parts of the system to gain the balance that is required.</source>
          <target state="new">Failing that, it may be necessary to redesign some parts of the system to gain the balance that is required.</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Note that some cloud environments allocate resources in terms of infrastructure boundaries, and you should ensure that the limits of your selected boundary provide enough room for any anticipated growth in the volume of data, in terms of data storage, processing power, and bandwidth.</source>
          <target state="new">Note that some cloud environments allocate resources in terms of infrastructure boundaries, and you should ensure that the limits of your selected boundary provide enough room for any anticipated growth in the volume of data, in terms of data storage, processing power, and bandwidth.</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>For example, if you use Azure table storage, a busy shard might require more resources than are available to a single partition to handle requests (there is a limit to the volume of requests that can be handled by a single partition in a given period of time—see the page <bpt id="p1">[</bpt>Azure Storage Scalability and Performance Targets<ept id="p1">](https://msdn.microsoft.com/library/azure/dn249410.aspx)</ept> on the Microsoft website for more details).</source>
          <target state="new">For example, if you use Azure table storage, a busy shard might require more resources than are available to a single partition to handle requests (there is a limit to the volume of requests that can be handled by a single partition in a given period of time—see the page <bpt id="p1">[</bpt>Azure Storage Scalability and Performance Targets<ept id="p1">](https://msdn.microsoft.com/library/azure/dn249410.aspx)</ept> on the Microsoft website for more details).</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>In this case, the shard may need to be repartitioned to spread the load.</source>
          <target state="new">In this case, the shard may need to be repartitioned to spread the load.</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>If the total size or throughput of these tables exceeds capacity of a storage account, it may be necessary to create additional storage accounts and spread the tables across these accounts.</source>
          <target state="new">If the total size or throughput of these tables exceeds capacity of a storage account, it may be necessary to create additional storage accounts and spread the tables across these accounts.</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>If the number of storage accounts exceeds the number of accounts that are available to a subscription, then it may be necessary to use multiple subscriptions.</source>
          <target state="new">If the number of storage accounts exceeds the number of accounts that are available to a subscription, then it may be necessary to use multiple subscriptions.</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Designing partitions for query performance</source>
          <target state="new">Designing partitions for query performance</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Query performance can often be boosted by using smaller data sets and parallel query execution.</source>
          <target state="new">Query performance can often be boosted by using smaller data sets and parallel query execution.</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Each partition should contain a small proportion of the entire data set, and this reduction in volume can improve the performance of queries.</source>
          <target state="new">Each partition should contain a small proportion of the entire data set, and this reduction in volume can improve the performance of queries.</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>However, partitioning is not an alternative for designing and configuring a database appropriately.</source>
          <target state="new">However, partitioning is not an alternative for designing and configuring a database appropriately.</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>For example, make sure that you have the necessary indexes in place if you are using a relational database.</source>
          <target state="new">For example, make sure that you have the necessary indexes in place if you are using a relational database.</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Follow these steps when designing the partitions for query performance:</source>
          <target state="new">Follow these steps when designing the partitions for query performance:</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Examine the application requirements and performance:</source>
          <target state="new">Examine the application requirements and performance:</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Use the business requirements to determine critical queries that must always perform quickly.</source>
          <target state="new">Use the business requirements to determine critical queries that must always perform quickly.</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Monitor the system to identify any queries that perform slowly.</source>
          <target state="new">Monitor the system to identify any queries that perform slowly.</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Establish which queries are performed most frequently.</source>
          <target state="new">Establish which queries are performed most frequently.</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>A single instance of each query might have minimal cost, but the cumulative consumption of resources could be significant.</source>
          <target state="new">A single instance of each query might have minimal cost, but the cumulative consumption of resources could be significant.</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>It may be beneficial to separate the data retrieved by these queries into a distinct partition, or even a cache.</source>
          <target state="new">It may be beneficial to separate the data retrieved by these queries into a distinct partition, or even a cache.</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Partition the data that is causing slow performance.</source>
          <target state="new">Partition the data that is causing slow performance.</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Ensure that you:</source>
          <target state="new">Ensure that you:</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Limit the size of each partition so that the query response time is within target.</source>
          <target state="new">Limit the size of each partition so that the query response time is within target.</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Design the shard key in a way that the application can easily find the partition if you are implementing horizontal partitioning.</source>
          <target state="new">Design the shard key in a way that the application can easily find the partition if you are implementing horizontal partitioning.</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>This prevents the query needing to scan through every partition.</source>
          <target state="new">This prevents the query needing to scan through every partition.</target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Consider the location of a partition on the performance of queries.</source>
          <target state="new">Consider the location of a partition on the performance of queries.</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>If possible, try to keep data in partitions that are geographically close to the applications and users that access it.</source>
          <target state="new">If possible, try to keep data in partitions that are geographically close to the applications and users that access it.</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>If an entity has throughput and query performance requirements, use functional partitioning based on that entity.</source>
          <target state="new">If an entity has throughput and query performance requirements, use functional partitioning based on that entity.</target>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>If this is still not able to satisfy the requirements, apply horizontal partitioning as well.</source>
          <target state="new">If this is still not able to satisfy the requirements, apply horizontal partitioning as well.</target>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>In most cases a single partitioning strategy will suffice, but in some cases it is more efficient to combine both strategies.</source>
          <target state="new">In most cases a single partitioning strategy will suffice, but in some cases it is more efficient to combine both strategies.</target>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Consider using asynchronous queries that run in parallel across partitions to improve the performance.</source>
          <target state="new">Consider using asynchronous queries that run in parallel across partitions to improve the performance.</target>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Designing partitions for availability</source>
          <target state="new">Designing partitions for availability</target>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Partitioning data can improve the availability of applications by ensuring that the entire dataset does not constitute a single point of failure and that individual subsets of the dataset can be managed independently.</source>
          <target state="new">Partitioning data can improve the availability of applications by ensuring that the entire dataset does not constitute a single point of failure and that individual subsets of the dataset can be managed independently.</target>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Replicating partitions containing critical data can also improve availability.</source>
          <target state="new">Replicating partitions containing critical data can also improve availability.</target>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>When designing and implementing partitions, consider the following factors that affect availability:</source>
          <target state="new">When designing and implementing partitions, consider the following factors that affect availability:</target>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>How critical the data is to business operations.</source>
          <target state="new">How critical the data is to business operations.</target>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Some data may comprise critical business information such as invoice details or bank transactions.</source>
          <target state="new">Some data may comprise critical business information such as invoice details or bank transactions.</target>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Other data might simply be less critical operational data, such as log files, performance traces, and so on.</source>
          <target state="new">Other data might simply be less critical operational data, such as log files, performance traces, and so on.</target>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>After identifying each type of data, consider:</source>
          <target state="new">After identifying each type of data, consider:</target>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Storing critical data in highly-available partitions with an appropriate back up plan.</source>
          <target state="new">Storing critical data in highly-available partitions with an appropriate back up plan.</target>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Establishing separate management and monitoring mechanisms or procedures for the different criticalities of each dataset.</source>
          <target state="new">Establishing separate management and monitoring mechanisms or procedures for the different criticalities of each dataset.</target>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Place data that has the same level of criticality in the same partition so that it can backed up together at an appropriate frequency.</source>
          <target state="new">Place data that has the same level of criticality in the same partition so that it can backed up together at an appropriate frequency.</target>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>For example, partitions holding data for bank transactions may need to be backed up more frequently than partitions holding logging or trace information.</source>
          <target state="new">For example, partitions holding data for bank transactions may need to be backed up more frequently than partitions holding logging or trace information.</target>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>How individual partitions can be managed.</source>
          <target state="new">How individual partitions can be managed.</target>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Designing partitions to support independent management and maintenance provides several advantages.</source>
          <target state="new">Designing partitions to support independent management and maintenance provides several advantages.</target>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="new">For example:</target>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>If a partition fails, it can be recovered independently without affecting instances of applications that access data in other partitions.</source>
          <target state="new">If a partition fails, it can be recovered independently without affecting instances of applications that access data in other partitions.</target>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Partitioning data by geographical area may allow scheduled maintenance tasks to occur at off-peak hours for each location.</source>
          <target state="new">Partitioning data by geographical area may allow scheduled maintenance tasks to occur at off-peak hours for each location.</target>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Ensure that partitions are not too big to prevent any planned maintenance from being completed during this period.</source>
          <target state="new">Ensure that partitions are not too big to prevent any planned maintenance from being completed during this period.</target>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Whether to replicate critical data across partitions.</source>
          <target state="new">Whether to replicate critical data across partitions.</target>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>This strategy can improve availability and performance, although it can also introduce consistency issues.</source>
          <target state="new">This strategy can improve availability and performance, although it can also introduce consistency issues.</target>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>It takes time for changes made to data in a partition to be synchronized with every replica, and during this period different partitions will contain different data values.</source>
          <target state="new">It takes time for changes made to data in a partition to be synchronized with every replica, and during this period different partitions will contain different data values.</target>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Issues and considerations</source>
          <target state="new">Issues and considerations</target>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Using partitioning adds complexity to the design and development of the system.</source>
          <target state="new">Using partitioning adds complexity to the design and development of the system.</target>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>It is important to consider partitioning as a fundamental part of the system design even if the system only contains a single partition initially.</source>
          <target state="new">It is important to consider partitioning as a fundamental part of the system design even if the system only contains a single partition initially.</target>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Addressing partitioning as an afterthought when the system starts to suffer performance and scalability issues only increases complexity as you probably now have a live system to maintain.</source>
          <target state="new">Addressing partitioning as an afterthought when the system starts to suffer performance and scalability issues only increases complexity as you probably now have a live system to maintain.</target>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Updating the system to incorporate partitioning in this environment necessitates not only modifying the data access logic, it can also involve migrating large quantities of existing data to distribute it across partitions, often while users expect to be able to continue using the system.</source>
          <target state="new">Updating the system to incorporate partitioning in this environment necessitates not only modifying the data access logic, it can also involve migrating large quantities of existing data to distribute it across partitions, often while users expect to be able to continue using the system.</target>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>In some cases, partitioning is not considered important because the initial dataset is small and can be easily handled by a single server.</source>
          <target state="new">In some cases, partitioning is not considered important because the initial dataset is small and can be easily handled by a single server.</target>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>This may be true in a system that is not expected to scale beyond its initial size, but many commercial systems need to be able to expand as the number of users increases.</source>
          <target state="new">This may be true in a system that is not expected to scale beyond its initial size, but many commercial systems need to be able to expand as the number of users increases.</target>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>This expansion is typically accompanied by a growth in the volume of data.</source>
          <target state="new">This expansion is typically accompanied by a growth in the volume of data.</target>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>You should also understand that partitioning is not always a function of large data stores.</source>
          <target state="new">You should also understand that partitioning is not always a function of large data stores.</target>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>For example, a small data store might be heavily accessed by hundreds of concurrent clients.</source>
          <target state="new">For example, a small data store might be heavily accessed by hundreds of concurrent clients.</target>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Partitioning the data in this situation can help to reduce contention and improve throughput.</source>
          <target state="new">Partitioning the data in this situation can help to reduce contention and improve throughput.</target>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>You should consider the following points when you design a data partitioning scheme:</source>
          <target state="new">You should consider the following points when you design a data partitioning scheme:</target>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Where possible, keep data for the most common database operations together in each partition to minimize cross-partition data access operations.</source>
          <target state="new">Where possible, keep data for the most common database operations together in each partition to minimize cross-partition data access operations.</target>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Querying across partitions can be more time-consuming than querying only within a single partition, but optimizing partitions for one set of queries might adversely affect other sets of queries.</source>
          <target state="new">Querying across partitions can be more time-consuming than querying only within a single partition, but optimizing partitions for one set of queries might adversely affect other sets of queries.</target>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>To minimize the query time across partitions where this cannot be avoided, execute parallel queries over the partitions and aggregate the results within the application.</source>
          <target state="new">To minimize the query time across partitions where this cannot be avoided, execute parallel queries over the partitions and aggregate the results within the application.</target>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>However, this approach may not be possible in some cases, such as when it is necessary to obtain a result from one query and use this in the next query.</source>
          <target state="new">However, this approach may not be possible in some cases, such as when it is necessary to obtain a result from one query and use this in the next query.</target>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>If queries make use of relatively static reference data, such as postal code tables or product lists, consider replicating this data in all of the partitions to reduce the requirement for a separate lookup operation in different partition.</source>
          <target state="new">If queries make use of relatively static reference data, such as postal code tables or product lists, consider replicating this data in all of the partitions to reduce the requirement for a separate lookup operation in different partition.</target>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>This approach can also reduce the likelihood of the reference data becoming a "hot" dataset that is subject to heavy traffic from across the entire system, although there is an additional cost associated with synchronizing any changes that might occur to this reference data.</source>
          <target state="new">This approach can also reduce the likelihood of the reference data becoming a "hot" dataset that is subject to heavy traffic from across the entire system, although there is an additional cost associated with synchronizing any changes that might occur to this reference data.</target>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Where possible, minimize requirements for referential integrity across vertical and functional partitions.</source>
          <target state="new">Where possible, minimize requirements for referential integrity across vertical and functional partitions.</target>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>In these schemes, the application itself is responsible for maintaining referential integrity across partitions when data is updated and consumed.</source>
          <target state="new">In these schemes, the application itself is responsible for maintaining referential integrity across partitions when data is updated and consumed.</target>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Queries that must join data across multiple partitions run more slowly than queries that join data only within the same partition because the application will typically need to perform consecutive queries based on a key and then on a foreign key.</source>
          <target state="new">Queries that must join data across multiple partitions run more slowly than queries that join data only within the same partition because the application will typically need to perform consecutive queries based on a key and then on a foreign key.</target>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Instead, consider replicating or de-normalizing the relevant data.</source>
          <target state="new">Instead, consider replicating or de-normalizing the relevant data.</target>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>To minimize the query time where cross-partition joins are necessary, execute parallel queries over the partitions and join the data within the application.</source>
          <target state="new">To minimize the query time where cross-partition joins are necessary, execute parallel queries over the partitions and join the data within the application.</target>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Consider the effect that the partitioning scheme might have on the data consistency across partitions.</source>
          <target state="new">Consider the effect that the partitioning scheme might have on the data consistency across partitions.</target>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>You should evaluate whether strong consistency is actually a requirement.</source>
          <target state="new">You should evaluate whether strong consistency is actually a requirement.</target>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Instead, a common approach in the cloud is to implement eventual consistency.</source>
          <target state="new">Instead, a common approach in the cloud is to implement eventual consistency.</target>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>The data in each partition is updated separately, and the application logic can take responsibility for ensuring that the updates all complete successfully—as well as handling the inconsistencies that can arise from querying data while an eventually consistent operation is running.</source>
          <target state="new">The data in each partition is updated separately, and the application logic can take responsibility for ensuring that the updates all complete successfully—as well as handling the inconsistencies that can arise from querying data while an eventually consistent operation is running.</target>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>For more information about implementing eventual consistency, see the Consistency Guidance.(#insertlink#)</source>
          <target state="new">For more information about implementing eventual consistency, see the Consistency Guidance.(#insertlink#)</target>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Consider how queries will locate the correct partition.</source>
          <target state="new">Consider how queries will locate the correct partition.</target>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>If a query must scan all partitions to locate the required data there will be a significant impact on performance, even when using multiple parallel queries.</source>
          <target state="new">If a query must scan all partitions to locate the required data there will be a significant impact on performance, even when using multiple parallel queries.</target>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Queries used with the vertical and functional partitioning strategies can naturally specify the partitions.</source>
          <target state="new">Queries used with the vertical and functional partitioning strategies can naturally specify the partitions.</target>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>However, when using horizontal partitioning (sharding), locating an item can be difficult because every shard has the same schema.</source>
          <target state="new">However, when using horizontal partitioning (sharding), locating an item can be difficult because every shard has the same schema.</target>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>A typical solution for sharding is to maintain a map that can be used to look up the shard location for specific items of data.</source>
          <target state="new">A typical solution for sharding is to maintain a map that can be used to look up the shard location for specific items of data.</target>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>This map may be implemented in the sharding logic of the application, or maintained by the data store if it supports transparent sharding.</source>
          <target state="new">This map may be implemented in the sharding logic of the application, or maintained by the data store if it supports transparent sharding.</target>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>When using a horizontal partitioning strategy, consider periodically rebalancing the shards to distribute the data evenly by size and by workload to minimize hotspots, maximize query performance, and work around physical storage limitations.</source>
          <target state="new">When using a horizontal partitioning strategy, consider periodically rebalancing the shards to distribute the data evenly by size and by workload to minimize hotspots, maximize query performance, and work around physical storage limitations.</target>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>However, this is a complex task that often requires the use of a custom tool or process.</source>
          <target state="new">However, this is a complex task that often requires the use of a custom tool or process.</target>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Replicating each partition provides additional protection against failure.</source>
          <target state="new">Replicating each partition provides additional protection against failure.</target>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>If a single replica fails, queries can be directed towards a working copy.</source>
          <target state="new">If a single replica fails, queries can be directed towards a working copy.</target>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>If you reach the physical limits of a partitioning strategy, you may need to extend the scalability to a different level.</source>
          <target state="new">If you reach the physical limits of a partitioning strategy, you may need to extend the scalability to a different level.</target>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>For example, if partitioning is at the database level it may mean locating or replicating partitions in multiple databases.</source>
          <target state="new">For example, if partitioning is at the database level it may mean locating or replicating partitions in multiple databases.</target>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>If partitioning is already at the database level, and physical limitations are an issue, it may mean locating or replicating partitions in multiple hosting accounts.</source>
          <target state="new">If partitioning is already at the database level, and physical limitations are an issue, it may mean locating or replicating partitions in multiple hosting accounts.</target>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Avoid transactions that access data in multiple partitions.</source>
          <target state="new">Avoid transactions that access data in multiple partitions.</target>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Some data stores implement transactional consistency and integrity for operations that modify data, but only when it is located in a single partition.</source>
          <target state="new">Some data stores implement transactional consistency and integrity for operations that modify data, but only when it is located in a single partition.</target>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>If you need transactional support across multiple partitions, you will probably need to implement this as part of your application logic because most partitioning systems do not provide native support.</source>
          <target state="new">If you need transactional support across multiple partitions, you will probably need to implement this as part of your application logic because most partitioning systems do not provide native support.</target>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>All data stores require some operational management and monitoring activity.</source>
          <target state="new">All data stores require some operational management and monitoring activity.</target>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The tasks can range from loading data, backing up and restoring data, reorganizing data, and ensuring that the system is performing correctly and efficiently.</source>
          <target state="new">The tasks can range from loading data, backing up and restoring data, reorganizing data, and ensuring that the system is performing correctly and efficiently.</target>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Consider the following factors that affect operational management:</source>
          <target state="new">Consider the following factors that affect operational management:</target>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Consider how you will implement appropriate management and operational tasks when the data is partitioned, such as backup and restore, archiving data, monitoring the system, and other administrative tasks.</source>
          <target state="new">Consider how you will implement appropriate management and operational tasks when the data is partitioned, such as backup and restore, archiving data, monitoring the system, and other administrative tasks.</target>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>For example, maintaining logical consistency during backup and restore operations can be a challenge.</source>
          <target state="new">For example, maintaining logical consistency during backup and restore operations can be a challenge.</target>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>How the data can be loaded into multiple partitions, and how new data arriving from other sources might be added.</source>
          <target state="new">How the data can be loaded into multiple partitions, and how new data arriving from other sources might be added.</target>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Some tools and utilities may not support sharded data operations such as loading data into the correct partition, and so this may require creating or obtaining new tools and utilities.</source>
          <target state="new">Some tools and utilities may not support sharded data operations such as loading data into the correct partition, and so this may require creating or obtaining new tools and utilities.</target>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>How the data will be archived and deleted on a regular basis (perhaps monthly) to prevent excessive growth of partitions.</source>
          <target state="new">How the data will be archived and deleted on a regular basis (perhaps monthly) to prevent excessive growth of partitions.</target>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>It may be necessary to transform the data to match a different archive schema.</source>
          <target state="new">It may be necessary to transform the data to match a different archive schema.</target>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Consider executing a periodic process to locate any data integrity issues such as data in one partition that references information in another, but this information is missing.</source>
          <target state="new">Consider executing a periodic process to locate any data integrity issues such as data in one partition that references information in another, but this information is missing.</target>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>The process could either attempt to fix these issues automatically or raise an alert to an operator to correct the problems manually.</source>
          <target state="new">The process could either attempt to fix these issues automatically or raise an alert to an operator to correct the problems manually.</target>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>For example, in an ecommerce application, order information might be held in one partition but the line items that constitute each order might be held in another.</source>
          <target state="new">For example, in an ecommerce application, order information might be held in one partition but the line items that constitute each order might be held in another.</target>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The process of placing an order needs to add data to bother partitions.</source>
          <target state="new">The process of placing an order needs to add data to bother partitions.</target>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>If this process fails, there could be line items stored for which there is no corresponding order.</source>
          <target state="new">If this process fails, there could be line items stored for which there is no corresponding order.</target>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Different data storage technologies typically provide their own features to support partitioning.</source>
          <target state="new">Different data storage technologies typically provide their own features to support partitioning.</target>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The following sections summarize the options implemented by data stores commonly used by Azure applications, and describe considerations for designing applications that can take best advantage of these features.</source>
          <target state="new">The following sections summarize the options implemented by data stores commonly used by Azure applications, and describe considerations for designing applications that can take best advantage of these features.</target>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Partitioning strategies for Azure SQL Database</source>
          <target state="new">Partitioning strategies for Azure SQL Database</target>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Azure SQL Database is a relational database-as-a-service that runs in the cloud.</source>
          <target state="new">Azure SQL Database is a relational database-as-a-service that runs in the cloud.</target>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>It is based on Microsoft SQL Server.</source>
          <target state="new">It is based on Microsoft SQL Server.</target>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>A relational database divides information into tables, and each table holds information about entities as a series of rows.</source>
          <target state="new">A relational database divides information into tables, and each table holds information about entities as a series of rows.</target>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Each row contains columns that hold the data for the individual fields of an entity.</source>
          <target state="new">Each row contains columns that hold the data for the individual fields of an entity.</target>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Azure SQL Database<ept id="p1">](https://msdn.microsoft.com/library/azure/ee336279.aspx)</ept> page on the Microsoft website provides detailed documentation on creating and using SQL databases.</source>
          <target state="new">The <bpt id="p1">[</bpt>Azure SQL Database<ept id="p1">](https://msdn.microsoft.com/library/azure/ee336279.aspx)</ept> page on the Microsoft website provides detailed documentation on creating and using SQL databases.</target>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Horizontal partitioning with Elastic Scale</source>
          <target state="new">Horizontal partitioning with Elastic Scale</target>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>A single SQL database has a limit to the volume of data that it can contain, and throughput is constrained by architectural factors and the number of concurrent connections that it supports.</source>
          <target state="new">A single SQL database has a limit to the volume of data that it can contain, and throughput is constrained by architectural factors and the number of concurrent connections that it supports.</target>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Azure SQL Database provides Elastic Scale to support horizontal scaling for a SQL database.</source>
          <target state="new">Azure SQL Database provides Elastic Scale to support horizontal scaling for a SQL database.</target>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>Using Elastic Scale, you can partition your data into shards spread across multiple SQL databases, and you can add or remove shards as the volume of data that you need to handle grows and shrinks.</source>
          <target state="new">Using Elastic Scale, you can partition your data into shards spread across multiple SQL databases, and you can add or remove shards as the volume of data that you need to handle grows and shrinks.</target>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Using Elastic Scale can also help to reduce contention by distributing the load across databases.</source>
          <target state="new">Using Elastic Scale can also help to reduce contention by distributing the load across databases.</target>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Elastic Scale is currently in preview as of January 2015.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Elastic Scale is currently in preview as of January 2015.</target>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>It is a replacement for Azure SQL Database Federations which will be retired.</source>
          <target state="new">It is a replacement for Azure SQL Database Federations which will be retired.</target>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Existing Azure SQL Database Federation installations can be migrated to Elastic Scale by using the <bpt id="p1">[</bpt>Federations Migration Utility<ept id="p1">](https://code.msdn.microsoft.com/vstudio/Federations-Migration-ce61e9c1)</ept>.</source>
          <target state="new">Existing Azure SQL Database Federation installations can be migrated to Elastic Scale by using the <bpt id="p1">[</bpt>Federations Migration Utility<ept id="p1">](https://code.msdn.microsoft.com/vstudio/Federations-Migration-ce61e9c1)</ept>.</target>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Alternatively, you can implement your own sharding mechanism if your scenario does not lend itself naturally to the features provided by Elastic Scale.</source>
          <target state="new">Alternatively, you can implement your own sharding mechanism if your scenario does not lend itself naturally to the features provided by Elastic Scale.</target>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>Each shard is implemented as a SQL database.</source>
          <target state="new">Each shard is implemented as a SQL database.</target>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>A shard can hold more than one dataset (referred to as a <bpt id="p1">_</bpt>shardlet<ept id="p1">_</ept>), and each database maintains metadata that describes the shardlets that it contains.</source>
          <target state="new">A shard can hold more than one dataset (referred to as a <bpt id="p1">_</bpt>shardlet<ept id="p1">_</ept>), and each database maintains metadata that describes the shardlets that it contains.</target>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>A shardlet can be a single data item, or it can be a group of items that share the same shardlet key.</source>
          <target state="new">A shardlet can be a single data item, or it can be a group of items that share the same shardlet key.</target>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>For example, if you are sharding data in a multi-tenant application, the shardlet key could be the tenant ID and all data for a given tenant would be held as part of the same shardlet.</source>
          <target state="new">For example, if you are sharding data in a multi-tenant application, the shardlet key could be the tenant ID and all data for a given tenant would be held as part of the same shardlet.</target>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Data for other tenants would be held in different shardlets.</source>
          <target state="new">Data for other tenants would be held in different shardlets.</target>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>It is the programmer's responsibility to associate a dataset with a shardlet key.</source>
          <target state="new">It is the programmer's responsibility to associate a dataset with a shardlet key.</target>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>A separate SQL database acts as a global shard-map manager that contains a list of databases (shards) that comprise the entire system together with information about the shardlets in each database.</source>
          <target state="new">A separate SQL database acts as a global shard-map manager that contains a list of databases (shards) that comprise the entire system together with information about the shardlets in each database.</target>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>A client application that accesses data first connects to the global shard-map manager database to obtain a copy of the shard-map (listing shards and shardlets) which it caches locally.</source>
          <target state="new">A client application that accesses data first connects to the global shard-map manager database to obtain a copy of the shard-map (listing shards and shardlets) which it caches locally.</target>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>The application then uses this information to route data requests to the appropriate shard.</source>
          <target state="new">The application then uses this information to route data requests to the appropriate shard.</target>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>This functionality is hidden behind a series of APIs contained in the Azure SQL Database Elastic Scale Client Library, available as a NuGet package.</source>
          <target state="new">This functionality is hidden behind a series of APIs contained in the Azure SQL Database Elastic Scale Client Library, available as a NuGet package.</target>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>The page <bpt id="p1">[</bpt>Azure SQL Database Elastic Scale Overview<ept id="p1">](sql-database-elastic-scale-introduction.md)</ept> on the Microsoft website provides a more comprehensive introduction to Elastic Scale.</source>
          <target state="new">The page <bpt id="p1">[</bpt>Azure SQL Database Elastic Scale Overview<ept id="p1">](sql-database-elastic-scale-introduction.md)</ept> on the Microsoft website provides a more comprehensive introduction to Elastic Scale.</target>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> You can replicate the global shard-map manager database to reduce latency and improve availability.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> You can replicate the global shard-map manager database to reduce latency and improve availability.</target>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>If you implement the database by using one of the Premium pricing tiers you can configure active geo-replication to continuously copy data to databases in different regions.</source>
          <target state="new">If you implement the database by using one of the Premium pricing tiers you can configure active geo-replication to continuously copy data to databases in different regions.</target>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>Create a copy of the database in each region in which users are based, and configure your application to connect to this copy to obtain the shard map.</source>
          <target state="new">Create a copy of the database in each region in which users are based, and configure your application to connect to this copy to obtain the shard map.</target>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>An alternative approach is to use Azure SQL Data Sync or an Azure Data Factory pipeline to replicate the shard-map manager database across regions.</source>
          <target state="new">An alternative approach is to use Azure SQL Data Sync or an Azure Data Factory pipeline to replicate the shard-map manager database across regions.</target>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>This form of replication runs periodically and is more suitable if the shard map changes infrequently.</source>
          <target state="new">This form of replication runs periodically and is more suitable if the shard map changes infrequently.</target>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Additionally, the shard-map manager database does not have to be created by using a Premium pricing tier.</source>
          <target state="new">Additionally, the shard-map manager database does not have to be created by using a Premium pricing tier.</target>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>Elastic Scale provides two schemes for mapping data to shardlets and storing them in shards:</source>
          <target state="new">Elastic Scale provides two schemes for mapping data to shardlets and storing them in shards:</target>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>A List Shard Map describes an association between single key and a shardlet.</source>
          <target state="new">A List Shard Map describes an association between single key and a shardlet.</target>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>For example, in a multi-tenant system, the data for each tenant could be associated with a unique key and stored in its own shardlet.</source>
          <target state="new">For example, in a multi-tenant system, the data for each tenant could be associated with a unique key and stored in its own shardlet.</target>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>To guarantee privacy and isolation (to prevent one tenant from exhausting the data storage resources available to others), each shardlet could be held within its own shard.</source>
          <target state="new">To guarantee privacy and isolation (to prevent one tenant from exhausting the data storage resources available to others), each shardlet could be held within its own shard.</target>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Figure 4.</source>
          <target state="new">Figure 4.</target>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>- Using a list shard map to store tenant data in separate shards</source>
          <target state="new">- Using a list shard map to store tenant data in separate shards</target>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>A Range Shard Map describes an association between a set of contiguous key values and a shardlet.</source>
          <target state="new">A Range Shard Map describes an association between a set of contiguous key values and a shardlet.</target>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>In the multi-tenant example described previously, as an alternative to implementing dedicated shardlets, you could group the data for a set of tenants (each with their own key) within the same shardlet.</source>
          <target state="new">In the multi-tenant example described previously, as an alternative to implementing dedicated shardlets, you could group the data for a set of tenants (each with their own key) within the same shardlet.</target>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>This scheme is less expensive than the first (tenants share data storage resources), but at the risk of reduced data privacy and isolation.</source>
          <target state="new">This scheme is less expensive than the first (tenants share data storage resources), but at the risk of reduced data privacy and isolation.</target>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>Figure 5.</source>
          <target state="new">Figure 5.</target>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>- Using a range shard map to store data for a range of tenants in a shard</source>
          <target state="new">- Using a range shard map to store data for a range of tenants in a shard</target>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Note that a single shard can contain the data for several shardlets.</source>
          <target state="new">Note that a single shard can contain the data for several shardlets.</target>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>For example, you could use list shardlets to store data for different non-contiguous tenants in the same shard.</source>
          <target state="new">For example, you could use list shardlets to store data for different non-contiguous tenants in the same shard.</target>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>You can also mix range shardlets and list shardlets in the same shard, although they will be addressed through different maps in the global shard-map manager database (the global shard-map manager database can contain multiple shard maps).</source>
          <target state="new">You can also mix range shardlets and list shardlets in the same shard, although they will be addressed through different maps in the global shard-map manager database (the global shard-map manager database can contain multiple shard maps).</target>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>Figure 6 depicts this approach.</source>
          <target state="new">Figure 6 depicts this approach.</target>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Figure 6.</source>
          <target state="new">Figure 6.</target>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>- Implementing multiple shard maps</source>
          <target state="new">- Implementing multiple shard maps</target>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>The partitioning scheme that you implement can have a significant bearing on the performance of your system, and also affect the rate at which shards have to be added or removed or the data repartitioned across shards.</source>
          <target state="new">The partitioning scheme that you implement can have a significant bearing on the performance of your system, and also affect the rate at which shards have to be added or removed or the data repartitioned across shards.</target>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>You should consider the following points when using Elastic Scale to partition data:</source>
          <target state="new">You should consider the following points when using Elastic Scale to partition data:</target>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>Group data that is used together into the same shard and avoid operations that need to access data held in multiple shards.</source>
          <target state="new">Group data that is used together into the same shard and avoid operations that need to access data held in multiple shards.</target>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>Bear in mind that with Elastic Scale a shard is a SQL database in its own right, and Azure SQL Database does not support cross-database joins; these operations have to be performed on the client-side.</source>
          <target state="new">Bear in mind that with Elastic Scale a shard is a SQL database in its own right, and Azure SQL Database does not support cross-database joins; these operations have to be performed on the client-side.</target>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>Also remember that with Azure SQL Database referential integrity constraints, triggers, and stored procedures in one database cannot reference objects in another, so don't design a system that has dependencies between shards.</source>
          <target state="new">Also remember that with Azure SQL Database referential integrity constraints, triggers, and stored procedures in one database cannot reference objects in another, so don't design a system that has dependencies between shards.</target>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>However, a SQL database can contain tables holding copies of reference data frequently used by queries and other operations, and these tables do not have to belong to any specific shardlet.</source>
          <target state="new">However, a SQL database can contain tables holding copies of reference data frequently used by queries and other operations, and these tables do not have to belong to any specific shardlet.</target>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Replicating this data across shards can help to remove the need to join data that spans databases.</source>
          <target state="new">Replicating this data across shards can help to remove the need to join data that spans databases.</target>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>Ideally, such data should be static or slow-moving to minimize the replication effort and reduce the chances of it becoming stale.</source>
          <target state="new">Ideally, such data should be static or slow-moving to minimize the replication effort and reduce the chances of it becoming stale.</target>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Although Azure SQL Database does not support cross-database joins, the Elastic Scale API enables you to perform cross-shard queries that can transparently iterate through the data held in all the shardlets referenced by a shard map.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Although Azure SQL Database does not support cross-database joins, the Elastic Scale API enables you to perform cross-shard queries that can transparently iterate through the data held in all the shardlets referenced by a shard map.</target>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>The Elastic Scale API breaks cross-shard queries down into a series of individual queries (one for each database) and then merges the results together.</source>
          <target state="new">The Elastic Scale API breaks cross-shard queries down into a series of individual queries (one for each database) and then merges the results together.</target>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Multi-Shard Querying<ept id="p1">](sql-database-elastic-scale-multishard-querying.md)</ept> page on the Microsoft website.</source>
          <target state="new">For more information, see the <bpt id="p1">[</bpt>Multi-Shard Querying<ept id="p1">](sql-database-elastic-scale-multishard-querying.md)</ept> page on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>The data stored in shardlets that belong to the same shard map should have the same schema.</source>
          <target state="new">The data stored in shardlets that belong to the same shard map should have the same schema.</target>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>For example, don't create a list shard map that points to some shardlets containing tenant data and other shardlets containing product information.</source>
          <target state="new">For example, don't create a list shard map that points to some shardlets containing tenant data and other shardlets containing product information.</target>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>This rule is not enforced by Elastic Scale, but data management and querying becomes very complex if each shardlet has a different schema.</source>
          <target state="new">This rule is not enforced by Elastic Scale, but data management and querying becomes very complex if each shardlet has a different schema.</target>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>In the example just cited, you should create two list shard maps; one referencing tenant data and the other point to product information.</source>
          <target state="new">In the example just cited, you should create two list shard maps; one referencing tenant data and the other point to product information.</target>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>Remember that the data belonging to different shardlets can be stored in the same shard.</source>
          <target state="new">Remember that the data belonging to different shardlets can be stored in the same shard.</target>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> The cross-shard query functionality of the Elastic Scale API depends on each shardlet in the shard map containing the same schema.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> The cross-shard query functionality of the Elastic Scale API depends on each shardlet in the shard map containing the same schema.</target>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>Transactional operations are only supported for data held within the same shard, and not across shards.</source>
          <target state="new">Transactional operations are only supported for data held within the same shard, and not across shards.</target>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>Transactions can span shardlets as long as they are part of the same shard.</source>
          <target state="new">Transactions can span shardlets as long as they are part of the same shard.</target>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>Therefore, if your business logic needs to perform transactions, either store the affected data in the same shard or implement eventual consistency.</source>
          <target state="new">Therefore, if your business logic needs to perform transactions, either store the affected data in the same shard or implement eventual consistency.</target>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>For more information, see the Data Consistency guidance.</source>
          <target state="new">For more information, see the Data Consistency guidance.</target>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>Place shards near to the users that access the data in those shards (geo-locate shards).</source>
          <target state="new">Place shards near to the users that access the data in those shards (geo-locate shards).</target>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>This strategy will help to reduce latency.</source>
          <target state="new">This strategy will help to reduce latency.</target>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>Avoid having a mixture of highly active (hotspots) and relatively inactive shards.</source>
          <target state="new">Avoid having a mixture of highly active (hotspots) and relatively inactive shards.</target>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>Try and spread the load evenly across shards.</source>
          <target state="new">Try and spread the load evenly across shards.</target>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>This may require hashing the shardlet keys.</source>
          <target state="new">This may require hashing the shardlet keys.</target>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>If you are geo-locating shards, make sure that the hashed keys map to shardlets held in shards stored close to the users that access that data.</source>
          <target state="new">If you are geo-locating shards, make sure that the hashed keys map to shardlets held in shards stored close to the users that access that data.</target>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>Currently, only a limited set of SQL data types are supported as shardlet keys; <bpt id="p1">_</bpt>int, bigint, varbinary,<ept id="p1">_</ept> and <bpt id="p2">_</bpt>uniqueidentifier<ept id="p2">_</ept>.</source>
          <target state="new">Currently, only a limited set of SQL data types are supported as shardlet keys; <bpt id="p1">_</bpt>int, bigint, varbinary,<ept id="p1">_</ept> and <bpt id="p2">_</bpt>uniqueidentifier<ept id="p2">_</ept>.</target>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>The SQL <bpt id="p1">_</bpt>int<ept id="p1">_</ept> and <bpt id="p2">_</bpt>bigint<ept id="p2">_</ept> types correspond to the <bpt id="p3">_</bpt>int<ept id="p3">_</ept> and <bpt id="p4">_</bpt>long<ept id="p4">_</ept> data types in C#, and have the same ranges.</source>
          <target state="new">The SQL <bpt id="p1">_</bpt>int<ept id="p1">_</ept> and <bpt id="p2">_</bpt>bigint<ept id="p2">_</ept> types correspond to the <bpt id="p3">_</bpt>int<ept id="p3">_</ept> and <bpt id="p4">_</bpt>long<ept id="p4">_</ept> data types in C#, and have the same ranges.</target>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>The SQL <bpt id="p1">_</bpt>varbinary<ept id="p1">_</ept> type can be handled by using a <bpt id="p2">_</bpt>Byte<ept id="p2">_</ept> array in C#, and the SQL <bpt id="p3">_</bpt>uniqueidentier<ept id="p3">_</ept> type corresponds to the <bpt id="p4">_</bpt>Guid<ept id="p4">_</ept> class in the .NET Framework.</source>
          <target state="new">The SQL <bpt id="p1">_</bpt>varbinary<ept id="p1">_</ept> type can be handled by using a <bpt id="p2">_</bpt>Byte<ept id="p2">_</ept> array in C#, and the SQL <bpt id="p3">_</bpt>uniqueidentier<ept id="p3">_</ept> type corresponds to the <bpt id="p4">_</bpt>Guid<ept id="p4">_</ept> class in the .NET Framework.</target>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>As the name implies, Elastic Scale enables a system to add and remove shards as the volume of data shrinks and grows.</source>
          <target state="new">As the name implies, Elastic Scale enables a system to add and remove shards as the volume of data shrinks and grows.</target>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>The APIs in the Azure SQL Database Elastic Scale Client Library enable an application to create and delete shards dynamically (and transparently update the shard-map manager), but removing a shard is a destructive operation that also requires deleting all the data in that shard.</source>
          <target state="new">The APIs in the Azure SQL Database Elastic Scale Client Library enable an application to create and delete shards dynamically (and transparently update the shard-map manager), but removing a shard is a destructive operation that also requires deleting all the data in that shard.</target>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>If an application needs to split a shard into two separate shards or combine shards together, Elastic Scale provides a separate Split/Merge service.</source>
          <target state="new">If an application needs to split a shard into two separate shards or combine shards together, Elastic Scale provides a separate Split/Merge service.</target>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>This service runs in a cloud-hosted service (the developer has to create this cloud-hosted service), and takes care of migrating data between shards safely.</source>
          <target state="new">This service runs in a cloud-hosted service (the developer has to create this cloud-hosted service), and takes care of migrating data between shards safely.</target>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>For more information, see the topic <bpt id="p1">[</bpt>Splitting and Merging with Elastic Scale<ept id="p1">](sql-database-elastic-scale-overview-split-and-merge.md)</ept> on the Microsoft website.</source>
          <target state="new">For more information, see the topic <bpt id="p1">[</bpt>Splitting and Merging with Elastic Scale<ept id="p1">](sql-database-elastic-scale-overview-split-and-merge.md)</ept> on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>Partitioning strategies for Azure Storage</source>
          <target state="new">Partitioning strategies for Azure Storage</target>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>Azure storage provides three abstractions for managing data:</source>
          <target state="new">Azure storage provides three abstractions for managing data:</target>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>Table Storage, which implements scalable structure storage.</source>
          <target state="new">Table Storage, which implements scalable structure storage.</target>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>A table contains a collection of entities, each of which can comprise a set of properties and values.</source>
          <target state="new">A table contains a collection of entities, each of which can comprise a set of properties and values.</target>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>Blob Storage, which supplies storage for large objects and files.</source>
          <target state="new">Blob Storage, which supplies storage for large objects and files.</target>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>Storage Queues, which support reliable asynchronous messaging between applications.</source>
          <target state="new">Storage Queues, which support reliable asynchronous messaging between applications.</target>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>Table Storage and Blob Storage are essentially key-value stores optimized to hold structured and unstructured data respectively.</source>
          <target state="new">Table Storage and Blob Storage are essentially key-value stores optimized to hold structured and unstructured data respectively.</target>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>Storage Queues provide a mechanism for building loosely coupled, scalable applications.</source>
          <target state="new">Storage Queues provide a mechanism for building loosely coupled, scalable applications.</target>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>Table Storage, Blob Storage, and Storage Queues are created within the context of an Azure storage account.</source>
          <target state="new">Table Storage, Blob Storage, and Storage Queues are created within the context of an Azure storage account.</target>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Azure storage accounts support three forms of redundancy:</source>
          <target state="new">Azure storage accounts support three forms of redundancy:</target>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>Locally redundant storage, which maintains three copies of data within a single datacenter.</source>
          <target state="new">Locally redundant storage, which maintains three copies of data within a single datacenter.</target>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>This form of redundancy protects against hardware failure but not against a disaster that encompasses the entire datacenter.</source>
          <target state="new">This form of redundancy protects against hardware failure but not against a disaster that encompasses the entire datacenter.</target>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>Zone-redundant storage which maintains three copies of data spread across different datacenters within the same region (or across two geographically close regions).</source>
          <target state="new">Zone-redundant storage which maintains three copies of data spread across different datacenters within the same region (or across two geographically close regions).</target>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>This form of redundancy can protect against disasters that occur within a single datacenter, but cannot protect against large-scale network disconnects that affect an entire region.</source>
          <target state="new">This form of redundancy can protect against disasters that occur within a single datacenter, but cannot protect against large-scale network disconnects that affect an entire region.</target>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>Note that zone-redundant storage is only currently only available for block blobs.</source>
          <target state="new">Note that zone-redundant storage is only currently only available for block blobs.</target>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>Geo-redundant storage, which maintains six copies of data; three copies in one region (your local region), and another three copies in a remote region.</source>
          <target state="new">Geo-redundant storage, which maintains six copies of data; three copies in one region (your local region), and another three copies in a remote region.</target>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>This form of redundancy provides the highest level of disaster protection.</source>
          <target state="new">This form of redundancy provides the highest level of disaster protection.</target>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>Microsoft has published scalability targets for Azure storage accounts; see the page <bpt id="p1">[</bpt>Azure Storage Scalability and Performance Targets<ept id="p1">](https://msdn.microsoft.com/library/azure/dn249410.aspx)</ept> on the Microsoft website.</source>
          <target state="new">Microsoft has published scalability targets for Azure storage accounts; see the page <bpt id="p1">[</bpt>Azure Storage Scalability and Performance Targets<ept id="p1">](https://msdn.microsoft.com/library/azure/dn249410.aspx)</ept> on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>Currently, the total storage account capacity (the size of data held in table storage, blob storage, and outstanding messages held in storage queue) cannot exceed 500TB.</source>
          <target state="new">Currently, the total storage account capacity (the size of data held in table storage, blob storage, and outstanding messages held in storage queue) cannot exceed 500TB.</target>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>The maximum request rate (assuming a 1KB entity, blob, or message size) is 20K per second.</source>
          <target state="new">The maximum request rate (assuming a 1KB entity, blob, or message size) is 20K per second.</target>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>If your system is likely to exceed these limits, then consider partitioning the load across multiple storage accounts; a single Azure subscription can create up to 100 storage accounts.</source>
          <target state="new">If your system is likely to exceed these limits, then consider partitioning the load across multiple storage accounts; a single Azure subscription can create up to 100 storage accounts.</target>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>However, note that these limits may change over time.</source>
          <target state="new">However, note that these limits may change over time.</target>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>Partitioning Azure table storage</source>
          <target state="new">Partitioning Azure table storage</target>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>Azure table storage is a key/value stored designed around partitioning.</source>
          <target state="new">Azure table storage is a key/value stored designed around partitioning.</target>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>All entities are stored in a partition, and partitions are managed internally by Azure table storage.</source>
          <target state="new">All entities are stored in a partition, and partitions are managed internally by Azure table storage.</target>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>Each entity stored in a table must provide a two-part key comprising:</source>
          <target state="new">Each entity stored in a table must provide a two-part key comprising:</target>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>The partition key.</source>
          <target state="new">The partition key.</target>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>This is a string values that determines in which partition Azure table storage will place the entity.</source>
          <target state="new">This is a string values that determines in which partition Azure table storage will place the entity.</target>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>All entities with the same partition key will be stored in the same partition.</source>
          <target state="new">All entities with the same partition key will be stored in the same partition.</target>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>The row key.</source>
          <target state="new">The row key.</target>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>This is another string value that identifies the entity within the partition.</source>
          <target state="new">This is another string value that identifies the entity within the partition.</target>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>All entities within a partition are sorted lexically, in ascending order, by this key.</source>
          <target state="new">All entities within a partition are sorted lexically, in ascending order, by this key.</target>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>The partition key/row key combination must be unique for each entity and cannot exceed 1KB in length.</source>
          <target state="new">The partition key/row key combination must be unique for each entity and cannot exceed 1KB in length.</target>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>The remainder of the data for an entity consists of application-defined fields.</source>
          <target state="new">The remainder of the data for an entity consists of application-defined fields.</target>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>No particular schemas are enforced, and each row can contain a different set of application-defined fields.</source>
          <target state="new">No particular schemas are enforced, and each row can contain a different set of application-defined fields.</target>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>The only limitation is that the maximum size of an entity (including the partition and row keys) is currently 1MB.</source>
          <target state="new">The only limitation is that the maximum size of an entity (including the partition and row keys) is currently 1MB.</target>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>The maximum size of a table is 200TB, although these figures may change in the future (check the page <bpt id="p1">[</bpt>Azure Storage Scalability and Performance Targets<ept id="p1">](https://msdn.microsoft.com/library/azure/dn249410.aspx)</ept> on the Microsoft website for the most recent information about these limits.</source>
          <target state="new">The maximum size of a table is 200TB, although these figures may change in the future (check the page <bpt id="p1">[</bpt>Azure Storage Scalability and Performance Targets<ept id="p1">](https://msdn.microsoft.com/library/azure/dn249410.aspx)</ept> on the Microsoft website for the most recent information about these limits.</target>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>If you are attempting to store entities that exceed this capacity, then consider splitting them into multiple tables; use vertical partitioning and divide the fields into the groups that are most likely to be accessed together.</source>
          <target state="new">If you are attempting to store entities that exceed this capacity, then consider splitting them into multiple tables; use vertical partitioning and divide the fields into the groups that are most likely to be accessed together.</target>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>Figure 7 shows the logical structure of an example storage account (Contoso Data) for a fictitious ecommerce application.</source>
          <target state="new">Figure 7 shows the logical structure of an example storage account (Contoso Data) for a fictitious ecommerce application.</target>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>The storage accounts contains three tables (Customer Info, Product Info, and Order Info), and each table has multiple partitions.</source>
          <target state="new">The storage accounts contains three tables (Customer Info, Product Info, and Order Info), and each table has multiple partitions.</target>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>In the Customer Info table the data is partitioned according to the city in which the customer is located, and the row key contains the customer ID.</source>
          <target state="new">In the Customer Info table the data is partitioned according to the city in which the customer is located, and the row key contains the customer ID.</target>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>In the Product Info table the products are partitioned by product category and the row key contains the product number.</source>
          <target state="new">In the Product Info table the products are partitioned by product category and the row key contains the product number.</target>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>In the Order Info table the orders are partitioned by the date on which they were placed and the row key specified the time the order was received.</source>
          <target state="new">In the Order Info table the orders are partitioned by the date on which they were placed and the row key specified the time the order was received.</target>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>Note that all data is ordered by the row key in each partition.</source>
          <target state="new">Note that all data is ordered by the row key in each partition.</target>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>Figure 7.</source>
          <target state="new">Figure 7.</target>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>- The tables and partitions in an example storage account</source>
          <target state="new">- The tables and partitions in an example storage account</target>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Azure table storage also adds a timestamp field to each entity.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Azure table storage also adds a timestamp field to each entity.</target>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>The timestamp field is maintained by table storage and is updated each time the entity is modified and written back to a partition.</source>
          <target state="new">The timestamp field is maintained by table storage and is updated each time the entity is modified and written back to a partition.</target>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>The table storage service uses this field to implement optimistic concurrency (each time an application writes an entity back to table storage, the table storage service compares the value of the timestamp in the entity being written with the value held in table storage, and if they are different another application must have modified the entity since it was retrieved and the write operation fails).</source>
          <target state="new">The table storage service uses this field to implement optimistic concurrency (each time an application writes an entity back to table storage, the table storage service compares the value of the timestamp in the entity being written with the value held in table storage, and if they are different another application must have modified the entity since it was retrieved and the write operation fails).</target>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>You should not modify this field in your own code, and neither should you specify a value for this field when you create a new entity.</source>
          <target state="new">You should not modify this field in your own code, and neither should you specify a value for this field when you create a new entity.</target>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>Azure table storage uses the partition key to determine how to store the data.</source>
          <target state="new">Azure table storage uses the partition key to determine how to store the data.</target>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>If an entity is added to a table with a previously unused partition key, Azure table storage will create a new partition for this entity.</source>
          <target state="new">If an entity is added to a table with a previously unused partition key, Azure table storage will create a new partition for this entity.</target>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>Other entities with the same partition key will be stored in the same partition.</source>
          <target state="new">Other entities with the same partition key will be stored in the same partition.</target>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>This mechanism effectively implements an automatic scale-out strategy.</source>
          <target state="new">This mechanism effectively implements an automatic scale-out strategy.</target>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>Each partition will be stored on a single server in an Azure datacenter (to help ensure that queries that retrieve data from a single partition run quickly), but different partitions can be distributed across multiple servers.</source>
          <target state="new">Each partition will be stored on a single server in an Azure datacenter (to help ensure that queries that retrieve data from a single partition run quickly), but different partitions can be distributed across multiple servers.</target>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>Additionally, a single server can host multiple partitions if these partitions are limited in size.</source>
          <target state="new">Additionally, a single server can host multiple partitions if these partitions are limited in size.</target>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>You should consider the following points when you design your entities for Azure table storage:</source>
          <target state="new">You should consider the following points when you design your entities for Azure table storage:</target>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>The selection of partition key and row key values should be driven by the way in which the data is accessed.</source>
          <target state="new">The selection of partition key and row key values should be driven by the way in which the data is accessed.</target>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>You should choose a partition key/row key combination that supports the majority of your queries.</source>
          <target state="new">You should choose a partition key/row key combination that supports the majority of your queries.</target>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>The most efficient queries will retrieve data by specifying the partition key and the row key.</source>
          <target state="new">The most efficient queries will retrieve data by specifying the partition key and the row key.</target>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>Queries that specify a partition key and a range of row keys can be satisfied by scanning a single partition; this is relatively fast because the data is held in row key order.</source>
          <target state="new">Queries that specify a partition key and a range of row keys can be satisfied by scanning a single partition; this is relatively fast because the data is held in row key order.</target>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>Queries that don't at least specify the partition key may require Azure table storage to scan every partition for your data.</source>
          <target state="new">Queries that don't at least specify the partition key may require Azure table storage to scan every partition for your data.</target>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.TIP]</ph> If an entity has one natural key, then use it as the partition key and specify an empty string as the row key.</source>
          <target state="new"><ph id="ph1">[AZURE.TIP]</ph> If an entity has one natural key, then use it as the partition key and specify an empty string as the row key.</target>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>If an entity has a composite key comprising two properties, select the slowest changing property as the partition key and the other as the row key.</source>
          <target state="new">If an entity has a composite key comprising two properties, select the slowest changing property as the partition key and the other as the row key.</target>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>If an entity has more than two key properties, use a concatenation of properties to provide the partition and row keys.</source>
          <target state="new">If an entity has more than two key properties, use a concatenation of properties to provide the partition and row keys.</target>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>If you regularly perform queries that look up data using fields other than the partition and row keys, consider implementing the <bpt id="p1">[</bpt>Index Table Pattern<ept id="p1">](https://msdn.microsoft.com/library/dn589791.aspx)</ept>.</source>
          <target state="new">If you regularly perform queries that look up data using fields other than the partition and row keys, consider implementing the <bpt id="p1">[</bpt>Index Table Pattern<ept id="p1">](https://msdn.microsoft.com/library/dn589791.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>If you generate partition keys using a monotonic increasing or decreasing sequence (such as "0001", "0002", "0003", …) and each partition only contains a limited amount of data, then Azure table storage may physically group these partitions together on the same server.</source>
          <target state="new">If you generate partition keys using a monotonic increasing or decreasing sequence (such as "0001", "0002", "0003", …) and each partition only contains a limited amount of data, then Azure table storage may physically group these partitions together on the same server.</target>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>This mechanism assumes that the application is most likely to perform queries across a contiguous range of partitions (range queries) and is optimized for this case.</source>
          <target state="new">This mechanism assumes that the application is most likely to perform queries across a contiguous range of partitions (range queries) and is optimized for this case.</target>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>However, this approach can lead to hotspots focused on a single server as all inserts of new entities will likely be concentrated at one or other end of the contiguous ranges.</source>
          <target state="new">However, this approach can lead to hotspots focused on a single server as all inserts of new entities will likely be concentrated at one or other end of the contiguous ranges.</target>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>It can also reduce scalability.</source>
          <target state="new">It can also reduce scalability.</target>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>To spread the load more evenly across servers, consider hashing the partition key to make the sequence more random.</source>
          <target state="new">To spread the load more evenly across servers, consider hashing the partition key to make the sequence more random.</target>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>Azure table storage supports transactional operations for entities that belong to the same partition.</source>
          <target state="new">Azure table storage supports transactional operations for entities that belong to the same partition.</target>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>This means that an application can perform multiple insert, update, delete, replace, or merge operations as an atomic unit (subject to the transaction not including more than 100 entities and the payload of the request not exceeding 4MB in size).</source>
          <target state="new">This means that an application can perform multiple insert, update, delete, replace, or merge operations as an atomic unit (subject to the transaction not including more than 100 entities and the payload of the request not exceeding 4MB in size).</target>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>Operations that span multiple partitions are not transactional, and may require you to implement eventual consistency as described by the Data Consistency Guidance.</source>
          <target state="new">Operations that span multiple partitions are not transactional, and may require you to implement eventual consistency as described by the Data Consistency Guidance.</target>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>For more information about table storage and transactions, visit the <bpt id="p1">[</bpt>Performing Entity Group Transactions<ept id="p1">](https://msdn.microsoft.com/library/azure/dd894038.aspx)</ept> page on the Microsoft website.</source>
          <target state="new">For more information about table storage and transactions, visit the <bpt id="p1">[</bpt>Performing Entity Group Transactions<ept id="p1">](https://msdn.microsoft.com/library/azure/dd894038.aspx)</ept> page on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>Give careful attention to the granularity of the partition key:</source>
          <target state="new">Give careful attention to the granularity of the partition key:</target>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>Using the same partition key for every entity will cause the table storage service to create a single large partition held on one server preventing it from scaling out and instead focusing the load on a single server.</source>
          <target state="new">Using the same partition key for every entity will cause the table storage service to create a single large partition held on one server preventing it from scaling out and instead focusing the load on a single server.</target>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>As a result, this approach is only suitable for systems that manage a small number of entities.</source>
          <target state="new">As a result, this approach is only suitable for systems that manage a small number of entities.</target>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>However, this approach does ensure that all entities can participate in entity group transactions.</source>
          <target state="new">However, this approach does ensure that all entities can participate in entity group transactions.</target>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>Using a unique partition key for every entity will cause the table storage service to create a separate partition for each entity, possibly resulting in a large number of small partitions (depending on the size of the entities).</source>
          <target state="new">Using a unique partition key for every entity will cause the table storage service to create a separate partition for each entity, possibly resulting in a large number of small partitions (depending on the size of the entities).</target>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>This approach is more scalable than using a single partition key, but entity group transactions are not possible and queries that fetch more than one entity may involve reading from more than one server.</source>
          <target state="new">This approach is more scalable than using a single partition key, but entity group transactions are not possible and queries that fetch more than one entity may involve reading from more than one server.</target>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>However, if the application performs range queries then using a monotonic sequence to generate the partition keys might help to optimize these queries.</source>
          <target state="new">However, if the application performs range queries then using a monotonic sequence to generate the partition keys might help to optimize these queries.</target>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>Sharing the partition key across a subset of entities enables you to group related entities in the same partition.</source>
          <target state="new">Sharing the partition key across a subset of entities enables you to group related entities in the same partition.</target>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>Operations that involve related entities can be performed by using entity group transactions, and queries that fetch a set of related entities may be satisfied by accessing a single server.</source>
          <target state="new">Operations that involve related entities can be performed by using entity group transactions, and queries that fetch a set of related entities may be satisfied by accessing a single server.</target>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>For additional information on partitioning data in Azure table storage, see the article <bpt id="p1">[</bpt>Designing a Scalable Partitioning Strategy for Azure Table Storage<ept id="p1">](https://msdn.microsoft.com/library/azure/hh508997.aspx)</ept> on the Microsoft website.</source>
          <target state="new">For additional information on partitioning data in Azure table storage, see the article <bpt id="p1">[</bpt>Designing a Scalable Partitioning Strategy for Azure Table Storage<ept id="p1">](https://msdn.microsoft.com/library/azure/hh508997.aspx)</ept> on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>Partitioning Azure blob storage</source>
          <target state="new">Partitioning Azure blob storage</target>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>Azure Blob Storage enables you to hold large binary objects, currently up to 200GB in size for block blobs, or 1TB for page blobs (for the most recent information, visit the <bpt id="p1">[</bpt>Azure Storage Scalability and Performance Targets<ept id="p1">](https://msdn.microsoft.com/library/azure/dn249410.aspx)</ept> page on the Microsoft website).</source>
          <target state="new">Azure Blob Storage enables you to hold large binary objects, currently up to 200GB in size for block blobs, or 1TB for page blobs (for the most recent information, visit the <bpt id="p1">[</bpt>Azure Storage Scalability and Performance Targets<ept id="p1">](https://msdn.microsoft.com/library/azure/dn249410.aspx)</ept> page on the Microsoft website).</target>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>Use block blobs in scenarios such as streaming where you need to upload or download large volumes of data quickly.</source>
          <target state="new">Use block blobs in scenarios such as streaming where you need to upload or download large volumes of data quickly.</target>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>Use page blobs for applications that require random rather than serial access to parts of the data.</source>
          <target state="new">Use page blobs for applications that require random rather than serial access to parts of the data.</target>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>Each blob (either block or page) is held in a container in an Azure storage account.</source>
          <target state="new">Each blob (either block or page) is held in a container in an Azure storage account.</target>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>You can use containers to group related blobs that have the same security requirements together, although this grouping is logical rather than physical.</source>
          <target state="new">You can use containers to group related blobs that have the same security requirements together, although this grouping is logical rather than physical.</target>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>Inside a container each blob has a unique name.</source>
          <target state="new">Inside a container each blob has a unique name.</target>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>Blob storage is automatically partitioned based on the blob name.</source>
          <target state="new">Blob storage is automatically partitioned based on the blob name.</target>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>Each blob is held in its own partition, and blobs in the same container do not share a partition.</source>
          <target state="new">Each blob is held in its own partition, and blobs in the same container do not share a partition.</target>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>This architecture enables Azure blob storage to balance the load across servers transparently as different blobs in the same container may be distributed across different servers.</source>
          <target state="new">This architecture enables Azure blob storage to balance the load across servers transparently as different blobs in the same container may be distributed across different servers.</target>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>The actions of writing a single block (block blob) or page (page blob) are atomic, but operations that span blocks, pages, or blobs are not.</source>
          <target state="new">The actions of writing a single block (block blob) or page (page blob) are atomic, but operations that span blocks, pages, or blobs are not.</target>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>If you need to ensure consistency when performing write operations across blocks, pages, and blobs, you will need to take out a write lock by using a blob lease.</source>
          <target state="new">If you need to ensure consistency when performing write operations across blocks, pages, and blobs, you will need to take out a write lock by using a blob lease.</target>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>Azure blob storage supports transfer rates of up to 60MB per second or 500 requests per second for each blob.</source>
          <target state="new">Azure blob storage supports transfer rates of up to 60MB per second or 500 requests per second for each blob.</target>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>If you anticipate surpassing these limits, and the blob data is relatively static, then consider replicating blobs by using the Azure Content Delivery Network (CDN).</source>
          <target state="new">If you anticipate surpassing these limits, and the blob data is relatively static, then consider replicating blobs by using the Azure Content Delivery Network (CDN).</target>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>For more information, see the page <bpt id="p1">[</bpt>Using CDN for Azure<ept id="p1">](cdn-how-to-use.md)</ept> on the Microsoft website.</source>
          <target state="new">For more information, see the page <bpt id="p1">[</bpt>Using CDN for Azure<ept id="p1">](cdn-how-to-use.md)</ept> on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>For additional guidance and considerations, see the article Content Delivery Network (CDN).</source>
          <target state="new">For additional guidance and considerations, see the article Content Delivery Network (CDN).</target>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>Partitioning Azure storage queues</source>
          <target state="new">Partitioning Azure storage queues</target>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>Azure storage queues enable you to implement asynchronous messaging between processes.</source>
          <target state="new">Azure storage queues enable you to implement asynchronous messaging between processes.</target>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>An Azure storage account can contain any number of queues, and each queue can contain any number of messages.</source>
          <target state="new">An Azure storage account can contain any number of queues, and each queue can contain any number of messages.</target>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>The only limitation is the space available in the storage account.</source>
          <target state="new">The only limitation is the space available in the storage account.</target>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>The maximum size of an individual message is 64KB.</source>
          <target state="new">The maximum size of an individual message is 64KB.</target>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>If you require messages bigger than this, then consider using Azure Service Bus queues instead.</source>
          <target state="new">If you require messages bigger than this, then consider using Azure Service Bus queues instead.</target>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source>Each storage queue has a unique name within the storage account in which it is contained.</source>
          <target state="new">Each storage queue has a unique name within the storage account in which it is contained.</target>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>Azure partitions queues based on the name, and all messages for the same queue are stored in the same partition, controlled by a single server.</source>
          <target state="new">Azure partitions queues based on the name, and all messages for the same queue are stored in the same partition, controlled by a single server.</target>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>Different queues can be managed by different servers to help balance the load.</source>
          <target state="new">Different queues can be managed by different servers to help balance the load.</target>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>The allocation of queues to servers is transparent to applications and users.</source>
          <target state="new">The allocation of queues to servers is transparent to applications and users.</target>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source>In a large scale application, don't use the same storage queue for all instances of the application as this approach may cause the server hosting the queue to become a hotspot; use different queues for different functional areas of the application.</source>
          <target state="new">In a large scale application, don't use the same storage queue for all instances of the application as this approach may cause the server hosting the queue to become a hotspot; use different queues for different functional areas of the application.</target>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>Azure storage queues do not support transactions, so directing messages to different queues should have little impact on messaging consistency.</source>
          <target state="new">Azure storage queues do not support transactions, so directing messages to different queues should have little impact on messaging consistency.</target>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>An Azure storage queue can handle up to 2000 messages per second.</source>
          <target state="new">An Azure storage queue can handle up to 2000 messages per second.</target>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>If you need to process messages at a greater rate than this then consider creating multiple queues.</source>
          <target state="new">If you need to process messages at a greater rate than this then consider creating multiple queues.</target>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>For example, in a global application, create separate storage queues in separate storage accounts to handle application instances running in each region.</source>
          <target state="new">For example, in a global application, create separate storage queues in separate storage accounts to handle application instances running in each region.</target>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>Partitioning strategies for Azure Service Bus</source>
          <target state="new">Partitioning strategies for Azure Service Bus</target>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>Azure Service Bus uses a message broker to handle messages sent to a Service Bus queue or topic.</source>
          <target state="new">Azure Service Bus uses a message broker to handle messages sent to a Service Bus queue or topic.</target>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>By default, all messages sent to a queue or topic are handled by the same message broker process.</source>
          <target state="new">By default, all messages sent to a queue or topic are handled by the same message broker process.</target>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>This architecture can place a limitation on the overall throughput of the message queue.</source>
          <target state="new">This architecture can place a limitation on the overall throughput of the message queue.</target>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>However, you can also partition a queue or topic when it is created by setting the <bpt id="p1">_</bpt>EnablePartitioning<ept id="p1">_</ept> property of the queue or topic description to <bpt id="p2">_</bpt>true<ept id="p2">_</ept>.</source>
          <target state="new">However, you can also partition a queue or topic when it is created by setting the <bpt id="p1">_</bpt>EnablePartitioning<ept id="p1">_</ept> property of the queue or topic description to <bpt id="p2">_</bpt>true<ept id="p2">_</ept>.</target>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>A partitioned queue or topic is divided up into multiple fragments, each of which is backed by a separate message store and message broker.</source>
          <target state="new">A partitioned queue or topic is divided up into multiple fragments, each of which is backed by a separate message store and message broker.</target>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source>Service Bus takes responsibility for creating and managing these fragments.</source>
          <target state="new">Service Bus takes responsibility for creating and managing these fragments.</target>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source>When an application posts a message to a partitioned queue or topic, Service Bus assigns the message to a fragment for that queue or topic.</source>
          <target state="new">When an application posts a message to a partitioned queue or topic, Service Bus assigns the message to a fragment for that queue or topic.</target>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source>When an application receives a message from a queue or subscription, Service Bus checks each fragment for the next available message and then passes it to the application for processing.</source>
          <target state="new">When an application receives a message from a queue or subscription, Service Bus checks each fragment for the next available message and then passes it to the application for processing.</target>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>This structure helps to distribute the load across message brokers and message stores, increasing scalability and improving availability; if the message broker or message store for one fragment is temporarily unavailable, Service Bus can retrieve messages from one of the remaining available fragments.</source>
          <target state="new">This structure helps to distribute the load across message brokers and message stores, increasing scalability and improving availability; if the message broker or message store for one fragment is temporarily unavailable, Service Bus can retrieve messages from one of the remaining available fragments.</target>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>Service Bus assigns a message to a fragment as follows:</source>
          <target state="new">Service Bus assigns a message to a fragment as follows:</target>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>If the message belongs to a session, all messages with the same value for the _ SessionId_  property are sent to the same fragment.</source>
          <target state="new">If the message belongs to a session, all messages with the same value for the _ SessionId_  property are sent to the same fragment.</target>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>If the message does not belong to a session but the sender has specified a value for the <bpt id="p1">_</bpt>PartitionKey<ept id="p1">_</ept> property, then all messages with the same <bpt id="p2">_</bpt>PartitionKey<ept id="p2">_</ept> value are send to the same fragment.</source>
          <target state="new">If the message does not belong to a session but the sender has specified a value for the <bpt id="p1">_</bpt>PartitionKey<ept id="p1">_</ept> property, then all messages with the same <bpt id="p2">_</bpt>PartitionKey<ept id="p2">_</ept> value are send to the same fragment.</target>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> If the <bpt id="p1">_</bpt>SessionId<ept id="p1">_</ept> and <bpt id="p2">_</bpt>PartitionKey<ept id="p2">_</ept> properties are both specified, then they must be set to the same value otherwise the message will be rejected.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> If the <bpt id="p1">_</bpt>SessionId<ept id="p1">_</ept> and <bpt id="p2">_</bpt>PartitionKey<ept id="p2">_</ept> properties are both specified, then they must be set to the same value otherwise the message will be rejected.</target>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>If the <bpt id="p1">_</bpt>SessionId<ept id="p1">_</ept> and <bpt id="p2">_</bpt>PartitionKey<ept id="p2">_</ept> properties for a message are not specified, but duplicate detection is enabled, the <bpt id="p3">_</bpt>MessageId<ept id="p3">_</ept> property will be used.</source>
          <target state="new">If the <bpt id="p1">_</bpt>SessionId<ept id="p1">_</ept> and <bpt id="p2">_</bpt>PartitionKey<ept id="p2">_</ept> properties for a message are not specified, but duplicate detection is enabled, the <bpt id="p3">_</bpt>MessageId<ept id="p3">_</ept> property will be used.</target>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>All messages with the same <bpt id="p1">_</bpt>MessageId<ept id="p1">_</ept> will be directed to the same fragment.</source>
          <target state="new">All messages with the same <bpt id="p1">_</bpt>MessageId<ept id="p1">_</ept> will be directed to the same fragment.</target>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>If messages do not include a <bpt id="p1">_</bpt>SessionId, PartitionKey,<ept id="p1">_</ept> or <bpt id="p2">_</bpt>MessageId<ept id="p2">_</ept> property, then Service Bus assigns messages to fragments in a round-robin fashion.</source>
          <target state="new">If messages do not include a <bpt id="p1">_</bpt>SessionId, PartitionKey,<ept id="p1">_</ept> or <bpt id="p2">_</bpt>MessageId<ept id="p2">_</ept> property, then Service Bus assigns messages to fragments in a round-robin fashion.</target>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>If a fragment is unavailable, Service Bus will move on to the next.</source>
          <target state="new">If a fragment is unavailable, Service Bus will move on to the next.</target>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>In this way, a temporary fault in the messaging infrastructure does not cause the message-send operation to fail.</source>
          <target state="new">In this way, a temporary fault in the messaging infrastructure does not cause the message-send operation to fail.</target>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>You should consider the following points when deciding and how, or whether, to partition a Service Bus message queue or topic:</source>
          <target state="new">You should consider the following points when deciding and how, or whether, to partition a Service Bus message queue or topic:</target>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>Service Bus queues and topics are created within the scope of a Service Bus namespace.</source>
          <target state="new">Service Bus queues and topics are created within the scope of a Service Bus namespace.</target>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>Service Bus currently allows up to 100 partitioned queues or topics per namespace.</source>
          <target state="new">Service Bus currently allows up to 100 partitioned queues or topics per namespace.</target>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>Each Service Bus namespace imposes quotas on the resources available, such as the number of subscriptions per topic, the number of concurrent send and receive requests per second, and the maximum number of concurrent connections that can be established.</source>
          <target state="new">Each Service Bus namespace imposes quotas on the resources available, such as the number of subscriptions per topic, the number of concurrent send and receive requests per second, and the maximum number of concurrent connections that can be established.</target>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>These quotas are documented on the Microsoft website on the page <bpt id="p1">[</bpt>Service Bus Quotas<ept id="p1">](https://msdn.microsoft.com/library/azure/ee732538.aspx)</ept>.</source>
          <target state="new">These quotas are documented on the Microsoft website on the page <bpt id="p1">[</bpt>Service Bus Quotas<ept id="p1">](https://msdn.microsoft.com/library/azure/ee732538.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>If you expect to exceed these values, then create additional namespaces with their own queues and topics, and spread the work across these namespaces.</source>
          <target state="new">If you expect to exceed these values, then create additional namespaces with their own queues and topics, and spread the work across these namespaces.</target>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>For example, in a global application, create separate namespaces in each region and configure application instances to use the queues and topics in the nearest namespace.</source>
          <target state="new">For example, in a global application, create separate namespaces in each region and configure application instances to use the queues and topics in the nearest namespace.</target>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>Messages that are sent as part of a transaction must specify a partition key.</source>
          <target state="new">Messages that are sent as part of a transaction must specify a partition key.</target>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>This can be a <bpt id="p1">_</bpt>SessionId, PartitionKey,<ept id="p1">_</ept> or <bpt id="p2">_</bpt>MessageId<ept id="p2">_</ept>.</source>
          <target state="new">This can be a <bpt id="p1">_</bpt>SessionId, PartitionKey,<ept id="p1">_</ept> or <bpt id="p2">_</bpt>MessageId<ept id="p2">_</ept>.</target>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>All messages that are sent as part of the same transaction must specify the same partition key because they must be handled by the same message broker process.</source>
          <target state="new">All messages that are sent as part of the same transaction must specify the same partition key because they must be handled by the same message broker process.</target>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>You cannot send messages to different queues or topics within the same transaction.</source>
          <target state="new">You cannot send messages to different queues or topics within the same transaction.</target>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>You cannot configure a partitioned queue or topic to be automatically deleted when it becomes idle.</source>
          <target state="new">You cannot configure a partitioned queue or topic to be automatically deleted when it becomes idle.</target>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>If you are building cross-platform or hybrid solutions, you cannot currently use partitioned queues and topics with the Advanced Message Queuing Protocol (AMQP).</source>
          <target state="new">If you are building cross-platform or hybrid solutions, you cannot currently use partitioned queues and topics with the Advanced Message Queuing Protocol (AMQP).</target>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source>Partitioning strategies for Azure DocumentDB</source>
          <target state="new">Partitioning strategies for Azure DocumentDB</target>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>Azure DocumentDB is a NoSQL database that can store documents.</source>
          <target state="new">Azure DocumentDB is a NoSQL database that can store documents.</target>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>A document in DocumentDB is a JSON-serialized representation of an object or other piece of data.</source>
          <target state="new">A document in DocumentDB is a JSON-serialized representation of an object or other piece of data.</target>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>No fixed schemas are enforced except that every document must contain a unique ID.</source>
          <target state="new">No fixed schemas are enforced except that every document must contain a unique ID.</target>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>Documents are organized into collections.</source>
          <target state="new">Documents are organized into collections.</target>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>A collection enables you to group related documents together.</source>
          <target state="new">A collection enables you to group related documents together.</target>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source>For example, in a system that maintains blog postings, you could store the contents of each blog post as a document in a collection, and create collections for each subject type.</source>
          <target state="new">For example, in a system that maintains blog postings, you could store the contents of each blog post as a document in a collection, and create collections for each subject type.</target>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>Alternatively, in a multitenant application such as a system that enables different authors to control and manage their own blog posts, you could partition blogs by author and create a separate collection for each author.</source>
          <target state="new">Alternatively, in a multitenant application such as a system that enables different authors to control and manage their own blog posts, you could partition blogs by author and create a separate collection for each author.</target>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>The storage space allocated to collections is elastic and can shrink or grow as needed.</source>
          <target state="new">The storage space allocated to collections is elastic and can shrink or grow as needed.</target>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>Document collections provide a natural mechanism to partition data within a single database.</source>
          <target state="new">Document collections provide a natural mechanism to partition data within a single database.</target>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>Internally, a DocumentDB database can span several servers, and DocumentDB may attempt to spread the load by distributing collections across servers.</source>
          <target state="new">Internally, a DocumentDB database can span several servers, and DocumentDB may attempt to spread the load by distributing collections across servers.</target>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>The simplest way to implement sharding is to create a collection for each shard.</source>
          <target state="new">The simplest way to implement sharding is to create a collection for each shard.</target>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Each DocumentDB is allocated resources in terms of a <bpt id="p1">_</bpt>performance level<ept id="p1">_</ept>.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Each DocumentDB is allocated resources in terms of a <bpt id="p1">_</bpt>performance level<ept id="p1">_</ept>.</target>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>A performance level is associated with with a <bpt id="p1">_</bpt>request unit<ept id="p1">_</ept> (RU) rate limit.</source>
          <target state="new">A performance level is associated with with a <bpt id="p1">_</bpt>request unit<ept id="p1">_</ept> (RU) rate limit.</target>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>The RU rate limit specifies the volume of resources that will be reserved for that collection and is available for exclusive use by that collection.</source>
          <target state="new">The RU rate limit specifies the volume of resources that will be reserved for that collection and is available for exclusive use by that collection.</target>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>The cost of a collection depends on the performance level selected for that collection; the higher the performance level (and RU rate limit) the higher the charge.</source>
          <target state="new">The cost of a collection depends on the performance level selected for that collection; the higher the performance level (and RU rate limit) the higher the charge.</target>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>You can adjust the performance level of a collection by using the Azure management portal.</source>
          <target state="new">You can adjust the performance level of a collection by using the Azure management portal.</target>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>For more information, see the page <bpt id="p1">[</bpt>Performance levels in DocumentDB<ept id="p1">](documentdb-performance-levels.md)</ept> on the Microsoft website.</source>
          <target state="new">For more information, see the page <bpt id="p1">[</bpt>Performance levels in DocumentDB<ept id="p1">](documentdb-performance-levels.md)</ept> on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>All databases are created in the context of a DocumentDB account.</source>
          <target state="new">All databases are created in the context of a DocumentDB account.</target>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>A single DocumentDB account can contain several databases, and specifies in which region the databases are created.</source>
          <target state="new">A single DocumentDB account can contain several databases, and specifies in which region the databases are created.</target>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>Each DocumentDB account also enforces its own access control.</source>
          <target state="new">Each DocumentDB account also enforces its own access control.</target>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>You can use DocumentDB accounts to geo-locate shards (collections within databases) close to the users that need to access them, and enforce restrictions so that only those users can connect to them.</source>
          <target state="new">You can use DocumentDB accounts to geo-locate shards (collections within databases) close to the users that need to access them, and enforce restrictions so that only those users can connect to them.</target>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>Each DocumentDB account has a quota that limits the number of databases and collections that it can contain and the amount of document storage available.</source>
          <target state="new">Each DocumentDB account has a quota that limits the number of databases and collections that it can contain and the amount of document storage available.</target>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>These limits are subject to change, but are described on the page <bpt id="p1">[</bpt>DocumentDB limits and quotas<ept id="p1">](documentdb-limits.md)</ept> on the Microsoft website.</source>
          <target state="new">These limits are subject to change, but are described on the page <bpt id="p1">[</bpt>DocumentDB limits and quotas<ept id="p1">](documentdb-limits.md)</ept> on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>It is theoretically possible that if you implement a system where all shards belong to the same database you might reach the storage capacity limit of the account.</source>
          <target state="new">It is theoretically possible that if you implement a system where all shards belong to the same database you might reach the storage capacity limit of the account.</target>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>In this case, you may need to create additional DocumentDB accounts and databases, and distribute the shards across these databases.</source>
          <target state="new">In this case, you may need to create additional DocumentDB accounts and databases, and distribute the shards across these databases.</target>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>However, even if you are unlikely to hit the storage capacity of a database, a good reason for using multiple databases is that each database has its own set of users and permissions.</source>
          <target state="new">However, even if you are unlikely to hit the storage capacity of a database, a good reason for using multiple databases is that each database has its own set of users and permissions.</target>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>You can use this mechanism to isolate access to collections on a per-database basis.</source>
          <target state="new">You can use this mechanism to isolate access to collections on a per-database basis.</target>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>Figure 8 illustrates the high-level structure of the DocumentDB architecture.</source>
          <target state="new">Figure 8 illustrates the high-level structure of the DocumentDB architecture.</target>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>Figure 8.</source>
          <target state="new">Figure 8.</target>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>- The structure of DocumentDB</source>
          <target state="new">- The structure of DocumentDB</target>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the client application to direct requests to the appropriate shard, usually by implementing its own mapping mechanism based on some attributes of the data that define the shard key.</source>
          <target state="new">It is the responsibility of the client application to direct requests to the appropriate shard, usually by implementing its own mapping mechanism based on some attributes of the data that define the shard key.</target>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>Figure 9 shows two DocumentDB databases, each containing two collections acting as shards.</source>
          <target state="new">Figure 9 shows two DocumentDB databases, each containing two collections acting as shards.</target>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>The data is sharded by tenant ID and contains the data for a specific tenant.</source>
          <target state="new">The data is sharded by tenant ID and contains the data for a specific tenant.</target>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>The databases are created in separate DocumenDB accounts which are located in the same region as the tenants whose data they contain.</source>
          <target state="new">The databases are created in separate DocumenDB accounts which are located in the same region as the tenants whose data they contain.</target>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>The routing logic in the client application uses the tenant ID as the shard key.</source>
          <target state="new">The routing logic in the client application uses the tenant ID as the shard key.</target>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>Figure 9.</source>
          <target state="new">Figure 9.</target>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>- Implementing sharding using Azure DocumentDB</source>
          <target state="new">- Implementing sharding using Azure DocumentDB</target>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>You should consider the following points when deciding how to partition data with DocumentDB:</source>
          <target state="new">You should consider the following points when deciding how to partition data with DocumentDB:</target>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>The resources available to a DocumentDB database are subject to the quota limitations of the DocumentDB account.</source>
          <target state="new">The resources available to a DocumentDB database are subject to the quota limitations of the DocumentDB account.</target>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source>Each database can hold a number of collections (again, there is a limit) and each collection is associated with a performance level that governs the RU rate limit (reserved throughput) for that collection.</source>
          <target state="new">Each database can hold a number of collections (again, there is a limit) and each collection is associated with a performance level that governs the RU rate limit (reserved throughput) for that collection.</target>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>For more information, visit the <bpt id="p1">[</bpt>DocumentDB limits and quotas<ept id="p1">](documentdb-limits.md)</ept> page on the Microsoft website.</source>
          <target state="new">For more information, visit the <bpt id="p1">[</bpt>DocumentDB limits and quotas<ept id="p1">](documentdb-limits.md)</ept> page on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>Each document must have an attribute that can be used to uniquely identify that document within the collection in which it is held.</source>
          <target state="new">Each document must have an attribute that can be used to uniquely identify that document within the collection in which it is held.</target>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>This is different from the shard key which defines in which collection the document is held.</source>
          <target state="new">This is different from the shard key which defines in which collection the document is held.</target>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>A collection can contain a large number of documents, in theory only limited by the maximum length of the document ID.</source>
          <target state="new">A collection can contain a large number of documents, in theory only limited by the maximum length of the document ID.</target>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source>The document ID can be up to 255 characters.</source>
          <target state="new">The document ID can be up to 255 characters.</target>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>All operations against a document are performed within the context of a transaction that is scoped to the collection in which the document is contained.</source>
          <target state="new">All operations against a document are performed within the context of a transaction that is scoped to the collection in which the document is contained.</target>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>If an operation fails, the work that it has performed is rolled back.</source>
          <target state="new">If an operation fails, the work that it has performed is rolled back.</target>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>While a document is subject to an operation, any changes made are subject to snapshot level isolation.</source>
          <target state="new">While a document is subject to an operation, any changes made are subject to snapshot level isolation.</target>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source>This mechanism guarantees that if, for example, a request to create a new document fails, another user querying the database simultaneously will not see a partial document that is then removed.</source>
          <target state="new">This mechanism guarantees that if, for example, a request to create a new document fails, another user querying the database simultaneously will not see a partial document that is then removed.</target>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>DocumentDB queries are also scoped to the collection level.</source>
          <target state="new">DocumentDB queries are also scoped to the collection level.</target>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve">
          <source>A single query can only retrieve data from one collection.</source>
          <target state="new">A single query can only retrieve data from one collection.</target>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>If you need to retrieve data from multiple collections you must query each collection individually and merge the results in your application code.</source>
          <target state="new">If you need to retrieve data from multiple collections you must query each collection individually and merge the results in your application code.</target>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>DocumentDB supports programmable items that can all be stored in a collection alongside documents: stored procedures, user-defined functions, and triggers (written in JavaScript).</source>
          <target state="new">DocumentDB supports programmable items that can all be stored in a collection alongside documents: stored procedures, user-defined functions, and triggers (written in JavaScript).</target>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>These items can access any document within the same collection.</source>
          <target state="new">These items can access any document within the same collection.</target>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>Furthermore, these items execute either inside the scope of the ambient transaction (in the case of a trigger that fires as the result of a create, delete, or replace operation performed against a document), or by starting a new transaction (in the case of a stored procedure that is executed as the result of an explicit client request).</source>
          <target state="new">Furthermore, these items execute either inside the scope of the ambient transaction (in the case of a trigger that fires as the result of a create, delete, or replace operation performed against a document), or by starting a new transaction (in the case of a stored procedure that is executed as the result of an explicit client request).</target>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source>If the code in a programmable item throws an exception, the transaction is rolled back.</source>
          <target state="new">If the code in a programmable item throws an exception, the transaction is rolled back.</target>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source>You can use stored procedures and triggers to maintain integrity and consistency between documents, but these documents must all be part of the same collection.</source>
          <target state="new">You can use stored procedures and triggers to maintain integrity and consistency between documents, but these documents must all be part of the same collection.</target>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source>You should ensure that the collections that you intend to hold in the databases in a DocumentDB account are unlikely to exceed the throughput limits defined by the performance levels of the collections.</source>
          <target state="new">You should ensure that the collections that you intend to hold in the databases in a DocumentDB account are unlikely to exceed the throughput limits defined by the performance levels of the collections.</target>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>These limits are described on the <bpt id="p1">[</bpt>Manage DocumentDB capacity needs<ept id="p1">](documentdb-manage.md)</ept> page on the Microsoft website.</source>
          <target state="new">These limits are described on the <bpt id="p1">[</bpt>Manage DocumentDB capacity needs<ept id="p1">](documentdb-manage.md)</ept> page on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>If you anticipate reaching these limits, consider splitting collections across databases in different DocumentDB accounts to reduce the load per collection.</source>
          <target state="new">If you anticipate reaching these limits, consider splitting collections across databases in different DocumentDB accounts to reduce the load per collection.</target>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>Partitioning Strategies for Azure Search</source>
          <target state="new">Partitioning Strategies for Azure Search</target>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source>The ability to search for data is often the primary method of navigation and exploration provided by many web applications, enabling users to quickly find resources (for example, products in an ecommerce application) based on combinations of search criteria.</source>
          <target state="new">The ability to search for data is often the primary method of navigation and exploration provided by many web applications, enabling users to quickly find resources (for example, products in an ecommerce application) based on combinations of search criteria.</target>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source>The Azure Search service provides full-text search capabilities over web content, and includes features such as type-ahead, suggested queries based on near matches, and faceted navigation.</source>
          <target state="new">The Azure Search service provides full-text search capabilities over web content, and includes features such as type-ahead, suggested queries based on near matches, and faceted navigation.</target>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source>A full description of these capabilities is available on the <bpt id="p1">[</bpt>Azure Search Overview<ept id="p1">](https://msdn.microsoft.com/library/azure/dn798933.aspx)</ept> page on the Microsoft website.</source>
          <target state="new">A full description of these capabilities is available on the <bpt id="p1">[</bpt>Azure Search Overview<ept id="p1">](https://msdn.microsoft.com/library/azure/dn798933.aspx)</ept> page on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source>The Search service stores searchable content as JSON documents in a database.</source>
          <target state="new">The Search service stores searchable content as JSON documents in a database.</target>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source>You define indexes that specify the searchable fields in these documents and provide these definitions to the Search service.</source>
          <target state="new">You define indexes that specify the searchable fields in these documents and provide these definitions to the Search service.</target>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source>When a user submits a search request, the Search service uses the appropriate indexes to find matching items.</source>
          <target state="new">When a user submits a search request, the Search service uses the appropriate indexes to find matching items.</target>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source>To reduce contention, the storage used by the Search service can be divided into up into 1, 2, 3, 4, 6, or 12 partitions, and each partition can be replicated up to 6 times.</source>
          <target state="new">To reduce contention, the storage used by the Search service can be divided into up into 1, 2, 3, 4, 6, or 12 partitions, and each partition can be replicated up to 6 times.</target>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>The product of the number of partitions multiplied by the number of replicas is called the <bpt id="p1">_</bpt>Search Unit<ept id="p1">_</ept> (SU).</source>
          <target state="new">The product of the number of partitions multiplied by the number of replicas is called the <bpt id="p1">_</bpt>Search Unit<ept id="p1">_</ept> (SU).</target>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>A single instance of the Search Service can contain a maximum of 36 SUs (a database with 12 partitions only supports a maximum of 3 replicas).</source>
          <target state="new">A single instance of the Search Service can contain a maximum of 36 SUs (a database with 12 partitions only supports a maximum of 3 replicas).</target>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>You are billed for each SU that is allocated to your service.</source>
          <target state="new">You are billed for each SU that is allocated to your service.</target>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>As the volume of searchable content increases or the rate of search requests grows, you can add SUs to an existing instance of the Search service to handle the extra load.</source>
          <target state="new">As the volume of searchable content increases or the rate of search requests grows, you can add SUs to an existing instance of the Search service to handle the extra load.</target>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>The Search Service itself takes responsibility for distributing the documents evenly across the partitions, and no manual partitioning strategies are currently supported.</source>
          <target state="new">The Search Service itself takes responsibility for distributing the documents evenly across the partitions, and no manual partitioning strategies are currently supported.</target>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source>Each partition can contain a maximum of 15 million documents or occupy 300GB of storage space (whichever is the lower, depending on the size of your documents and indexes).</source>
          <target state="new">Each partition can contain a maximum of 15 million documents or occupy 300GB of storage space (whichever is the lower, depending on the size of your documents and indexes).</target>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source>You can create up to 50 indexes.</source>
          <target state="new">You can create up to 50 indexes.</target>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source>The performance of the service will vary depending on the complexity of the documents, the available indexes, and the effects of network latency.</source>
          <target state="new">The performance of the service will vary depending on the complexity of the documents, the available indexes, and the effects of network latency.</target>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>On average, a single replica (1SU) should be able to handle 15 queries per second (QPS), although you should perform benchmarking with your own data to obtain a more precise measure of throughput.</source>
          <target state="new">On average, a single replica (1SU) should be able to handle 15 queries per second (QPS), although you should perform benchmarking with your own data to obtain a more precise measure of throughput.</target>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Limits and Constraints (Azure Search API)<ept id="p1">]( https://msdn.microsoft.com/library/azure/dn798934.aspx)</ept> page on the Microsoft website.</source>
          <target state="new">For more information, see the <bpt id="p1">[</bpt>Limits and Constraints (Azure Search API)<ept id="p1">]( https://msdn.microsoft.com/library/azure/dn798934.aspx)</ept> page on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> You can store a limited set of data types in searchable documents; strings, Booleans, numeric data, datetime data, and some geographical data.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> You can store a limited set of data types in searchable documents; strings, Booleans, numeric data, datetime data, and some geographical data.</target>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>For more details, see the <bpt id="p1">[</bpt>Supported Data Types (Azure Search)<ept id="p1">]( https://msdn.microsoft.com/library/azure/dn798938.aspx)</ept> page on the Microsoft website.</source>
          <target state="new">For more details, see the <bpt id="p1">[</bpt>Supported Data Types (Azure Search)<ept id="p1">]( https://msdn.microsoft.com/library/azure/dn798938.aspx)</ept> page on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>You have limited control over how the Azure Search service partitions data for each instance of the service.</source>
          <target state="new">You have limited control over how the Azure Search service partitions data for each instance of the service.</target>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>However, in a global environment you may be able to improve performance and reduce latency  and contention further by partitioning the service itself using either of the following strategies:</source>
          <target state="new">However, in a global environment you may be able to improve performance and reduce latency  and contention further by partitioning the service itself using either of the following strategies:</target>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source>Create an instance of the Search service in each geographic region, and ensure that client applications are directed towards the nearest available instance.</source>
          <target state="new">Create an instance of the Search service in each geographic region, and ensure that client applications are directed towards the nearest available instance.</target>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>This strategy requires that any updates to searchable content are replicated in a timely manner across all instances of the service.</source>
          <target state="new">This strategy requires that any updates to searchable content are replicated in a timely manner across all instances of the service.</target>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>Create two-tiers of Search service; a local service in each region that contains the data most frequently accessed by users in that region, and a global service that encompasses all of the data.</source>
          <target state="new">Create two-tiers of Search service; a local service in each region that contains the data most frequently accessed by users in that region, and a global service that encompasses all of the data.</target>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>Users can direct requests either to the local service (for fast but limited results), or to the global service (for slower but more complete results).</source>
          <target state="new">Users can direct requests either to the local service (for fast but limited results), or to the global service (for slower but more complete results).</target>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>This approach is most suitable when there is a significant regional variation in the data being searched.</source>
          <target state="new">This approach is most suitable when there is a significant regional variation in the data being searched.</target>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source>Partitioning strategies for Azure Redis Cache</source>
          <target state="new">Partitioning strategies for Azure Redis Cache</target>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source>Azure Redis Cache provides a shared caching service in the cloud that is based on the Redis key/value data store.</source>
          <target state="new">Azure Redis Cache provides a shared caching service in the cloud that is based on the Redis key/value data store.</target>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>As its name implies, Azure Redis Cache is intended as a caching solution and so should only be used for holding transient data rather than as a permanent data store; applications that utilize Azure Redis Cache should be able to continue functioning if the cache is unavailable.</source>
          <target state="new">As its name implies, Azure Redis Cache is intended as a caching solution and so should only be used for holding transient data rather than as a permanent data store; applications that utilize Azure Redis Cache should be able to continue functioning if the cache is unavailable.</target>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source>Azure Redis Cache supports primary/secondary replication to provide high availability, but currently limits the maximum cache size to 53GB.</source>
          <target state="new">Azure Redis Cache supports primary/secondary replication to provide high availability, but currently limits the maximum cache size to 53GB.</target>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>If you need more space than this, you must create additional caches.</source>
          <target state="new">If you need more space than this, you must create additional caches.</target>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve">
          <source>For more information visit the <bpt id="p1">[</bpt>Microsoft Azure Cache<ept id="p1">](http://azure.microsoft.com/services/cache/)</ept> page on the Microsoft website.</source>
          <target state="new">For more information visit the <bpt id="p1">[</bpt>Microsoft Azure Cache<ept id="p1">](http://azure.microsoft.com/services/cache/)</ept> page on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve">
          <source>Partitioning a Redis data store involves splitting the data across instances of the Redis service.</source>
          <target state="new">Partitioning a Redis data store involves splitting the data across instances of the Redis service.</target>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>Each instance constitutes a single partition.</source>
          <target state="new">Each instance constitutes a single partition.</target>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>Azure Redis Cache abstracts the Redis services behind a façade and does not expose them directly.</source>
          <target state="new">Azure Redis Cache abstracts the Redis services behind a façade and does not expose them directly.</target>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>The simplest way to implement partitioning is to create multiple Azure Redis caches and spread the data across them.</source>
          <target state="new">The simplest way to implement partitioning is to create multiple Azure Redis caches and spread the data across them.</target>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>You can associate each data item with an identifier (a partition key) that specifies in which cache it should be stored.</source>
          <target state="new">You can associate each data item with an identifier (a partition key) that specifies in which cache it should be stored.</target>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>Your client application logic can use this identifier to route requests to the appropriate partition.</source>
          <target state="new">Your client application logic can use this identifier to route requests to the appropriate partition.</target>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve">
          <source>This scheme is very simple, but if the partitioning scheme changes (if additional Azure Redis Caches are created, for example), client applications may need to be reconfigured.</source>
          <target state="new">This scheme is very simple, but if the partitioning scheme changes (if additional Azure Redis Caches are created, for example), client applications may need to be reconfigured.</target>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve">
          <source>Native Redis (not Azure Redis Cache) supports server-side partitioning based on Redis clustering.</source>
          <target state="new">Native Redis (not Azure Redis Cache) supports server-side partitioning based on Redis clustering.</target>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve">
          <source>In this approach, the data is divided evenly across servers by using a hashing mechanism.</source>
          <target state="new">In this approach, the data is divided evenly across servers by using a hashing mechanism.</target>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve">
          <source>Each Redis server stores metadata that describes the range of hash keys that the partition holds, and also contains information about which hash keys are located in the partitions on other servers.</source>
          <target state="new">Each Redis server stores metadata that describes the range of hash keys that the partition holds, and also contains information about which hash keys are located in the partitions on other servers.</target>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>Client applications simply send requests to any of the participating Redis servers (probably the closest server).The Redis server examines the client request and if it can be resolved locally it will perform the requested operation, otherwise it will forward the request on to the appropriate server.</source>
          <target state="new">Client applications simply send requests to any of the participating Redis servers (probably the closest server).The Redis server examines the client request and if it can be resolved locally it will perform the requested operation, otherwise it will forward the request on to the appropriate server.</target>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve">
          <source>This model is implemented by using Redis clustering, and is described in more detail on the <bpt id="p1">[</bpt>Redis cluster tutorial<ept id="p1">](http://redis.io/topics/cluster-tutorial)</ept> page on the Redis website.</source>
          <target state="new">This model is implemented by using Redis clustering, and is described in more detail on the <bpt id="p1">[</bpt>Redis cluster tutorial<ept id="p1">](http://redis.io/topics/cluster-tutorial)</ept> page on the Redis website.</target>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve">
          <source>Redis clustering is transparent to client applications, and additional Redis servers can be added to the cluster (and the data re-partitioned) without requiring that you reconfigure the clients.</source>
          <target state="new">Redis clustering is transparent to client applications, and additional Redis servers can be added to the cluster (and the data re-partitioned) without requiring that you reconfigure the clients.</target>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.IMPORTANT]</ph> Azure Redis Cache does not currently support Redis clustering.</source>
          <target state="new"><ph id="ph1">[AZURE.IMPORTANT]</ph> Azure Redis Cache does not currently support Redis clustering.</target>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>If you wish to implement this approach with Azure then you must implement your own Redis servers by installing Redis on a set of Azure virtual machines and configuring them manually.</source>
          <target state="new">If you wish to implement this approach with Azure then you must implement your own Redis servers by installing Redis on a set of Azure virtual machines and configuring them manually.</target>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>The page <bpt id="p1">[</bpt>Running Redis on a CentOS Linux VM in Azure<ept id="p1">](http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx)</ept> on the Microsoft website walks through an example showing how to build and configure a Redis node running as an Azure VM.</source>
          <target state="new">The page <bpt id="p1">[</bpt>Running Redis on a CentOS Linux VM in Azure<ept id="p1">](http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx)</ept> on the Microsoft website walks through an example showing how to build and configure a Redis node running as an Azure VM.</target>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>The page <bpt id="p1">[</bpt>Partitioning: how to split data among multiple Redis instances<ept id="p1">](http://redis.io/topics/partitioning)</ept> on the Redis website provides further information about implementing partitioning with Redis.</source>
          <target state="new">The page <bpt id="p1">[</bpt>Partitioning: how to split data among multiple Redis instances<ept id="p1">](http://redis.io/topics/partitioning)</ept> on the Redis website provides further information about implementing partitioning with Redis.</target>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>The remainder of this section assumes that you are implementing client-side or proxy-assisted partitioning.</source>
          <target state="new">The remainder of this section assumes that you are implementing client-side or proxy-assisted partitioning.</target>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source>You should consider the following points when deciding how to partition data with Azure Redis Cache:</source>
          <target state="new">You should consider the following points when deciding how to partition data with Azure Redis Cache:</target>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>Azure Redis Cache is not intended to act as a permanent data store, so whatever partitioning scheme you implement your application code should be prepared to accept that the data is not found in the cache and has to be retrieved from elsewhere.</source>
          <target state="new">Azure Redis Cache is not intended to act as a permanent data store, so whatever partitioning scheme you implement your application code should be prepared to accept that the data is not found in the cache and has to be retrieved from elsewhere.</target>
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source>Keep data that is frequently accessed together in the same partition.</source>
          <target state="new">Keep data that is frequently accessed together in the same partition.</target>
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>Redis is a powerful key/value store that provides several highly-optimized mechanisms for structuring data, ranging from simple strings (actually, binary data up to 512MB in length) to aggregate types such as lists (that can act as queues and stacks), sets (ordered and unordered), and hashes (that can group related fields together, such as the items that represent the fields in an object).</source>
          <target state="new">Redis is a powerful key/value store that provides several highly-optimized mechanisms for structuring data, ranging from simple strings (actually, binary data up to 512MB in length) to aggregate types such as lists (that can act as queues and stacks), sets (ordered and unordered), and hashes (that can group related fields together, such as the items that represent the fields in an object).</target>
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>The aggregate types enable you to associate many related values with the same key; a Redis key identifies a list, set, or hash rather than the data items that it contains.</source>
          <target state="new">The aggregate types enable you to associate many related values with the same key; a Redis key identifies a list, set, or hash rather than the data items that it contains.</target>
        </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>These types are all available with Azure Redis Cache and are described by the <bpt id="p1">[</bpt>Data Types<ept id="p1">](http://redis.io/topics/data-types)</ept> page on the Redis website.</source>
          <target state="new">These types are all available with Azure Redis Cache and are described by the <bpt id="p1">[</bpt>Data Types<ept id="p1">](http://redis.io/topics/data-types)</ept> page on the Redis website.</target>
        </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve">
          <source>For example, in part of an ecommerce system that tracks the orders placed by customers, the details of each customer could be stored in a Redis hash keyed by using the customer ID.</source>
          <target state="new">For example, in part of an ecommerce system that tracks the orders placed by customers, the details of each customer could be stored in a Redis hash keyed by using the customer ID.</target>
        </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source>Each hash could hold a collection of order IDs for the customer.</source>
          <target state="new">Each hash could hold a collection of order IDs for the customer.</target>
        </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve">
          <source>A separate Redis set could hold the orders, again structured as hashes, keyed by using the order ID.</source>
          <target state="new">A separate Redis set could hold the orders, again structured as hashes, keyed by using the order ID.</target>
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>Figure 10 shows this structure.</source>
          <target state="new">Figure 10 shows this structure.</target>
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source>Note that Redis does not implement any form of referential integrity, so it is the developer's responsibility to maintain the relationships between customers and orders.</source>
          <target state="new">Note that Redis does not implement any form of referential integrity, so it is the developer's responsibility to maintain the relationships between customers and orders.</target>
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source>Figure 10.</source>
          <target state="new">Figure 10.</target>
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve">
          <source>- Suggested structure in Redis storage for recording customer orders and their details</source>
          <target state="new">- Suggested structure in Redis storage for recording customer orders and their details</target>
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> In Redis, all keys are binary data values (like Redis strings) and can contain up to 512MB of data, so in theory a key can contain almost any information.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> In Redis, all keys are binary data values (like Redis strings) and can contain up to 512MB of data, so in theory a key can contain almost any information.</target>
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve">
          <source>However, you should adopt a consistent naming convention for keys that is descriptive of the type of data and that identifies the entity, but that is not excessively long.</source>
          <target state="new">However, you should adopt a consistent naming convention for keys that is descriptive of the type of data and that identifies the entity, but that is not excessively long.</target>
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve">
          <source>A common approach is to use keys of the form "entity_type:ID", such as "customer:99" to indicate the key for customer with the ID 99.</source>
          <target state="new">A common approach is to use keys of the form "entity_type:ID", such as "customer:99" to indicate the key for customer with the ID 99.</target>
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve">
          <source>You can implement vertical partitioning by storing related information in different aggregations in the same database.</source>
          <target state="new">You can implement vertical partitioning by storing related information in different aggregations in the same database.</target>
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>For example, in an ecommerce application you could store commonly accessed information about products in one Redis hash and the less frequently used detailed information in another.</source>
          <target state="new">For example, in an ecommerce application you could store commonly accessed information about products in one Redis hash and the less frequently used detailed information in another.</target>
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source>Both hashes could use the same product ID as part of the key, for example "product:<bpt id="p1">_</bpt>nn<ept id="p1">_</ept>" where <bpt id="p2">_</bpt>nn<ept id="p2">_</ept> is the product ID for product information and "product_details: <bpt id="p3">_</bpt>nn<ept id="p3">_</ept>" for the detailed data.</source>
          <target state="new">Both hashes could use the same product ID as part of the key, for example "product:<bpt id="p1">_</bpt>nn<ept id="p1">_</ept>" where <bpt id="p2">_</bpt>nn<ept id="p2">_</ept> is the product ID for product information and "product_details: <bpt id="p3">_</bpt>nn<ept id="p3">_</ept>" for the detailed data.</target>
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source>This strategy can help to reduce the volume of data that most queries are likely to retrieve.</source>
          <target state="new">This strategy can help to reduce the volume of data that most queries are likely to retrieve.</target>
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>Repartitioning a Redis data store is a complex and time-consuming task.</source>
          <target state="new">Repartitioning a Redis data store is a complex and time-consuming task.</target>
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source>Redis clustering can repartition data automatically, but this facility is not available with Azure Redis Cache.</source>
          <target state="new">Redis clustering can repartition data automatically, but this facility is not available with Azure Redis Cache.</target>
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve">
          <source>Therefore, when you design your partitioning scheme, you should endeavor to leave sufficient free space in each partition to allow for expected data growth over time.</source>
          <target state="new">Therefore, when you design your partitioning scheme, you should endeavor to leave sufficient free space in each partition to allow for expected data growth over time.</target>
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve">
          <source>However, remember that Azure Redis Cache is intended to cache data temporarily, and that data held in the cache can have a limited lifetime specified as a time-to-live (TTL) value.</source>
          <target state="new">However, remember that Azure Redis Cache is intended to cache data temporarily, and that data held in the cache can have a limited lifetime specified as a time-to-live (TTL) value.</target>
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve">
          <source>For relatively volatile data the TTL should be short, but for static data the TTL can be a lot longer.</source>
          <target state="new">For relatively volatile data the TTL should be short, but for static data the TTL can be a lot longer.</target>
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve">
          <source>You should avoid storing large amounts of long-lived data in the cache if the volume of this data is likely to fill the cache.</source>
          <target state="new">You should avoid storing large amounts of long-lived data in the cache if the volume of this data is likely to fill the cache.</target>
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve">
          <source>You can specify an eviction policy that causes Azure Redis Cache to remove data if space is at a premium.</source>
          <target state="new">You can specify an eviction policy that causes Azure Redis Cache to remove data if space is at a premium.</target>
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Azure Redis cache enables you to specify the maximum size of the cache (from 250MB to 53GB) by selecting the appropriate pricing tier.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Azure Redis cache enables you to specify the maximum size of the cache (from 250MB to 53GB) by selecting the appropriate pricing tier.</target>
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve">
          <source>However, once an Azure Redis Cache has been created, you cannot increase (or decrease) its size.</source>
          <target state="new">However, once an Azure Redis Cache has been created, you cannot increase (or decrease) its size.</target>
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve">
          <source>Redis batches and transactions cannot span multiple connections, so all data affected by a batch or transaction should be held in the same database (shard).</source>
          <target state="new">Redis batches and transactions cannot span multiple connections, so all data affected by a batch or transaction should be held in the same database (shard).</target>
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> A sequence of operations in a Redis transaction is not necessarily atomic.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> A sequence of operations in a Redis transaction is not necessarily atomic.</target>
        </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve">
          <source>The commands that comprise a transaction are verified and queued prior to execution, and if an error occurs during this phase the entire queue is discarded.</source>
          <target state="new">The commands that comprise a transaction are verified and queued prior to execution, and if an error occurs during this phase the entire queue is discarded.</target>
        </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve">
          <source>However, once the transaction has been successfully submitted, the queued commands will be executed in sequence.</source>
          <target state="new">However, once the transaction has been successfully submitted, the queued commands will be executed in sequence.</target>
        </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve">
          <source>If any command fails only that command is aborted; all previous and subsequent commands in the queue are performed.</source>
          <target state="new">If any command fails only that command is aborted; all previous and subsequent commands in the queue are performed.</target>
        </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve">
          <source>If you need to perform atomic operations.</source>
          <target state="new">If you need to perform atomic operations.</target>
        </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve">
          <source>For more information, visit the <bpt id="p1">[</bpt>Transactions<ept id="p1">](http://redis.io/topics/transactions)</ept> page on the Redis website.</source>
          <target state="new">For more information, visit the <bpt id="p1">[</bpt>Transactions<ept id="p1">](http://redis.io/topics/transactions)</ept> page on the Redis website.</target>
        </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve">
          <source>Redis supports a limited number of atomic operations, and the only operations of this type that support multiple keys and values are MGET (which returns a collection of values for a specified list of keys), and MSET (which can store a collection of values for a specified list of keys).</source>
          <target state="new">Redis supports a limited number of atomic operations, and the only operations of this type that support multiple keys and values are MGET (which returns a collection of values for a specified list of keys), and MSET (which can store a collection of values for a specified list of keys).</target>
        </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve">
          <source>If you need to use these operations, the key/value pairs referenced by the MSET and MGET commands must be stored within the same database.</source>
          <target state="new">If you need to use these operations, the key/value pairs referenced by the MSET and MGET commands must be stored within the same database.</target>
        </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve">
          <source>Rebalancing partitions</source>
          <target state="new">Rebalancing partitions</target>
        </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve">
          <source>As a system matures and the pattern of usage becomes better understood, it is possible that it may be necessary to adjust the partitioning scheme.</source>
          <target state="new">As a system matures and the pattern of usage becomes better understood, it is possible that it may be necessary to adjust the partitioning scheme.</target>
        </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve">
          <source>This could be due to individual partitions attracting a disproportionate volume of traffic and becoming hot, leading to excessive contention.</source>
          <target state="new">This could be due to individual partitions attracting a disproportionate volume of traffic and becoming hot, leading to excessive contention.</target>
        </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve">
          <source>Additionally, you might have under-estimated the volume of data in some partitions, causing you to approach the limits of the storage capacity in these partitions.</source>
          <target state="new">Additionally, you might have under-estimated the volume of data in some partitions, causing you to approach the limits of the storage capacity in these partitions.</target>
        </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve">
          <source>Whatever the cause, it is sometimes necessary to rebalance partitions to spread the load more evenly.</source>
          <target state="new">Whatever the cause, it is sometimes necessary to rebalance partitions to spread the load more evenly.</target>
        </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve">
          <source>In some cases, data storage systems which do not publicly expose the way in which data is allocated to servers can automatically rebalance partitions within the limits of the resources available.</source>
          <target state="new">In some cases, data storage systems which do not publicly expose the way in which data is allocated to servers can automatically rebalance partitions within the limits of the resources available.</target>
        </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve">
          <source>In other situations, rebalancing is an administrative task that consists of two stages:</source>
          <target state="new">In other situations, rebalancing is an administrative task that consists of two stages:</target>
        </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve">
          <source>Determining the new partitioning strategy to ascertain which partitions may need to be split (or possibly combined), and how to allocate data to these new partitions by designing new partition keys.</source>
          <target state="new">Determining the new partitioning strategy to ascertain which partitions may need to be split (or possibly combined), and how to allocate data to these new partitions by designing new partition keys.</target>
        </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve">
          <source>Migrating the affected data from the old partitioning scheme to the new set of partitions.</source>
          <target state="new">Migrating the affected data from the old partitioning scheme to the new set of partitions.</target>
        </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> The mapping of DocumentDB collections to servers is transparent, but you might still reach the storage capacity and throughput limits of a DocumentDB account, in which case you may need to redesign your partitioning scheme and migrate the data.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> The mapping of DocumentDB collections to servers is transparent, but you might still reach the storage capacity and throughput limits of a DocumentDB account, in which case you may need to redesign your partitioning scheme and migrate the data.</target>
        </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve">
          <source>Depending on the data storage technology and the design of your data storage system, you may be able to migrate data between partitions while they are in use (online migration).</source>
          <target state="new">Depending on the data storage technology and the design of your data storage system, you may be able to migrate data between partitions while they are in use (online migration).</target>
        </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve">
          <source>If this is not possible, you may need to make the affected partitions temporarily unavailable while the data is relocated (offline migration).</source>
          <target state="new">If this is not possible, you may need to make the affected partitions temporarily unavailable while the data is relocated (offline migration).</target>
        </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve">
          <source>Offline migration</source>
          <target state="new">Offline migration</target>
        </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve">
          <source>Offline migration is arguably the simplest approach as it reduces the chances of contention occurring; the data being migrated should not change while it is being moved and restructured.</source>
          <target state="new">Offline migration is arguably the simplest approach as it reduces the chances of contention occurring; the data being migrated should not change while it is being moved and restructured.</target>
        </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve">
          <source>Conceptually, this process comprises the following steps:</source>
          <target state="new">Conceptually, this process comprises the following steps:</target>
        </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve">
          <source>Mark the shard offline,</source>
          <target state="new">Mark the shard offline,</target>
        </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve">
          <source>Split/merge and move the data to the new shards,</source>
          <target state="new">Split/merge and move the data to the new shards,</target>
        </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve">
          <source>Verify the data,</source>
          <target state="new">Verify the data,</target>
        </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve">
          <source>Bring the new shards online,</source>
          <target state="new">Bring the new shards online,</target>
        </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve">
          <source>Remove the old shard.</source>
          <target state="new">Remove the old shard.</target>
        </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve">
          <source>To retain some availability, it could be possible to mark the original shard as read-only in step 1 rather than making it unavailable.</source>
          <target state="new">To retain some availability, it could be possible to mark the original shard as read-only in step 1 rather than making it unavailable.</target>
        </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source>This would allow applications to read the data while it is being moved but not change it.</source>
          <target state="new">This would allow applications to read the data while it is being moved but not change it.</target>
        </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve">
          <source>Online migration</source>
          <target state="new">Online migration</target>
        </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve">
          <source>Online migration is more complex to perform but is less disruptive to users as data remains available during the entire procedure.</source>
          <target state="new">Online migration is more complex to perform but is less disruptive to users as data remains available during the entire procedure.</target>
        </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve">
          <source>The process is similar to that used by offline migration, except that the original shard is not marked offline (step 1).</source>
          <target state="new">The process is similar to that used by offline migration, except that the original shard is not marked offline (step 1).</target>
        </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve">
          <source>Depending on the granularity of the migration process (item by item or shard by shard), the data access code in the client applications may have to handle reading and writing data held in two locations (the original shard and the new shard)</source>
          <target state="new">Depending on the granularity of the migration process (item by item or shard by shard), the data access code in the client applications may have to handle reading and writing data held in two locations (the original shard and the new shard)</target>
        </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve">
          <source>For an example of a solution that supports online migration, see the <bpt id="p1">[</bpt>Split/Merge Service for Elastic Scale<ept id="p1">](sql-database-elastic-scale-overview-split-and-merge.md)</ept>, documented online on the Microsoft website.</source>
          <target state="new">For an example of a solution that supports online migration, see the <bpt id="p1">[</bpt>Split/Merge Service for Elastic Scale<ept id="p1">](sql-database-elastic-scale-overview-split-and-merge.md)</ept>, documented online on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve">
          <source>Related patterns and guidance</source>
          <target state="new">Related patterns and guidance</target>
        </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve">
          <source>The following patterns may also be relevant to your scenario when considering strategies for implementing data consistency:</source>
          <target state="new">The following patterns may also be relevant to your scenario when considering strategies for implementing data consistency:</target>
        </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve">
          <source>The Data Consistency Guidance page, available on the Microsoft website, describes strategies for maintaining consistency in a distributed environment such as the cloud.</source>
          <target state="new">The Data Consistency Guidance page, available on the Microsoft website, describes strategies for maintaining consistency in a distributed environment such as the cloud.</target>
        </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Data Partitioning Guidance<ept id="p1">](https://msdn.microsoft.com/library/dn589795.aspx)</ept> page on the Microsoft website provides a general overview of designing partitions to meet various criteria in a distributed solution.</source>
          <target state="new">The <bpt id="p1">[</bpt>Data Partitioning Guidance<ept id="p1">](https://msdn.microsoft.com/library/dn589795.aspx)</ept> page on the Microsoft website provides a general overview of designing partitions to meet various criteria in a distributed solution.</target>
        </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Sharding Pattern<ept id="p1">](https://msdn.microsoft.com/library/dn589797.aspx)</ept>, described on the Microsoft website, summarizes some common strategies for sharding data.</source>
          <target state="new">The <bpt id="p1">[</bpt>Sharding Pattern<ept id="p1">](https://msdn.microsoft.com/library/dn589797.aspx)</ept>, described on the Microsoft website, summarizes some common strategies for sharding data.</target>
        </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Index Table Pattern<ept id="p1">](https://msdn.microsoft.com/library/dn589791.aspx)</ept> described on the Microsoft website illustrates how to create secondary indexes over data.</source>
          <target state="new">The <bpt id="p1">[</bpt>Index Table Pattern<ept id="p1">](https://msdn.microsoft.com/library/dn589791.aspx)</ept> described on the Microsoft website illustrates how to create secondary indexes over data.</target>
        </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source>This approach enables an application to quickly retrieve data by using queries that do not reference the primary key of a collection.</source>
          <target state="new">This approach enables an application to quickly retrieve data by using queries that do not reference the primary key of a collection.</target>
        </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Materialized View Pattern<ept id="p1">](https://msdn.microsoft.com/library/dn589782.aspx)</ept> discussed on the Microsoft website describes how to generate pre-populated views that summarize data to support fast query operations.</source>
          <target state="new">The <bpt id="p1">[</bpt>Materialized View Pattern<ept id="p1">](https://msdn.microsoft.com/library/dn589782.aspx)</ept> discussed on the Microsoft website describes how to generate pre-populated views that summarize data to support fast query operations.</target>
        </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source>This approach can be useful in a partitioned data store if the partitions containing the data being summarized are distributed across multiple sites.</source>
          <target state="new">This approach can be useful in a partitioned data store if the partitions containing the data being summarized are distributed across multiple sites.</target>
        </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source>The article Content Delivery Network (CDN) provides additional guidance on configuring and using CDN with Azure.</source>
          <target state="new">The article Content Delivery Network (CDN) provides additional guidance on configuring and using CDN with Azure.</target>
        </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve">
          <source>More Information</source>
          <target state="new">More Information</target>
        </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Azure SQL Database<ept id="p1">](https://msdn.microsoft.com/library/azure/ee336279.aspx)</ept> page on the Microsoft website provides detailed documentation describing how to create and use SQL databases.</source>
          <target state="new">The <bpt id="p1">[</bpt>Azure SQL Database<ept id="p1">](https://msdn.microsoft.com/library/azure/ee336279.aspx)</ept> page on the Microsoft website provides detailed documentation describing how to create and use SQL databases.</target>
        </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve">
          <source>The page <bpt id="p1">[</bpt>Azure SQL Database Elastic Scale Overview<ept id="p1">](sql-database-elastic-scale-introduction.md)</ept> on the Microsoft website provides a comprehensive introduction to Elastic Scale.</source>
          <target state="new">The page <bpt id="p1">[</bpt>Azure SQL Database Elastic Scale Overview<ept id="p1">](sql-database-elastic-scale-introduction.md)</ept> on the Microsoft website provides a comprehensive introduction to Elastic Scale.</target>
        </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve">
          <source>The topic <bpt id="p1">[</bpt>Splitting and Merging with Elastic Scale<ept id="p1">](sql-database-elastic-scale-overview-split-and-merge.md)</ept> on the Microsoft website contains information on using the Split/Merge service to manage Elastic Scale shards.</source>
          <target state="new">The topic <bpt id="p1">[</bpt>Splitting and Merging with Elastic Scale<ept id="p1">](sql-database-elastic-scale-overview-split-and-merge.md)</ept> on the Microsoft website contains information on using the Split/Merge service to manage Elastic Scale shards.</target>
        </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve">
          <source>The page <bpt id="p1">[</bpt>Azure Storage Scalability and Performance Targets<ept id="p1">](https://msdn.microsoft.com/library/azure/dn249410.aspx)</ept> on the Microsoft website documents the current sizing and throughput limits of Azure storage.</source>
          <target state="new">The page <bpt id="p1">[</bpt>Azure Storage Scalability and Performance Targets<ept id="p1">](https://msdn.microsoft.com/library/azure/dn249410.aspx)</ept> on the Microsoft website documents the current sizing and throughput limits of Azure storage.</target>
        </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Performing Entity Group Transactions<ept id="p1">](https://msdn.microsoft.com/library/azure/dd894038.aspx)</ept> page on the Microsoft website provides detailed information about implementing transactional operations over entities stored in Azure table storage.</source>
          <target state="new">The <bpt id="p1">[</bpt>Performing Entity Group Transactions<ept id="p1">](https://msdn.microsoft.com/library/azure/dd894038.aspx)</ept> page on the Microsoft website provides detailed information about implementing transactional operations over entities stored in Azure table storage.</target>
        </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve">
          <source>The article <bpt id="p1">[</bpt>Designing a Scalable Partitioning Strategy for Azure Table Storage<ept id="p1">](https://msdn.microsoft.com/library/azure/hh508997.aspx)</ept> on the Microsoft website contains detailed information on partitioning data in Azure table storage.</source>
          <target state="new">The article <bpt id="p1">[</bpt>Designing a Scalable Partitioning Strategy for Azure Table Storage<ept id="p1">](https://msdn.microsoft.com/library/azure/hh508997.aspx)</ept> on the Microsoft website contains detailed information on partitioning data in Azure table storage.</target>
        </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve">
          <source>The page <bpt id="p1">[</bpt>Using CDN for Azure<ept id="p1">](cdn-how-to-use.md)</ept> on the Microsoft website describes how to replicate data held in Azure Blob Storage by using the Azure Content Delivery Network (CDN).</source>
          <target state="new">The page <bpt id="p1">[</bpt>Using CDN for Azure<ept id="p1">](cdn-how-to-use.md)</ept> on the Microsoft website describes how to replicate data held in Azure Blob Storage by using the Azure Content Delivery Network (CDN).</target>
        </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve">
          <source>The page <bpt id="p1">[</bpt>DocumentDB Limits for the Preview Release<ept id="p1">](documentdb-limits.md)</ept> on the Microsoft website describes the current limits and quotas for Microsoft DocumentDB.</source>
          <target state="new">The page <bpt id="p1">[</bpt>DocumentDB Limits for the Preview Release<ept id="p1">](documentdb-limits.md)</ept> on the Microsoft website describes the current limits and quotas for Microsoft DocumentDB.</target>
        </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve">
          <source>The page <bpt id="p1">[</bpt>Manage DocumentDB Capacity and Performance<ept id="p1">](documentdb-manage.md)</ept> on the Microsoft website contains information about how Azure DocumentDB allocates resources to databases.</source>
          <target state="new">The page <bpt id="p1">[</bpt>Manage DocumentDB Capacity and Performance<ept id="p1">](documentdb-manage.md)</ept> on the Microsoft website contains information about how Azure DocumentDB allocates resources to databases.</target>
        </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Azure Search Overview<ept id="p1">](https://msdn.microsoft.com/library/azure/dn798933.aspx)</ept> page on the Microsoft website provides a full description of the capabilities available with the Azure Search service.</source>
          <target state="new">The <bpt id="p1">[</bpt>Azure Search Overview<ept id="p1">](https://msdn.microsoft.com/library/azure/dn798933.aspx)</ept> page on the Microsoft website provides a full description of the capabilities available with the Azure Search service.</target>
        </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Limits and Constraints (Azure Search API)<ept id="p1">](https://msdn.microsoft.com/library/azure/dn798934.aspx)</ept> page on the Microsoft website contains information on the capacity of each instance of the Azure Search service.</source>
          <target state="new">The <bpt id="p1">[</bpt>Limits and Constraints (Azure Search API)<ept id="p1">](https://msdn.microsoft.com/library/azure/dn798934.aspx)</ept> page on the Microsoft website contains information on the capacity of each instance of the Azure Search service.</target>
        </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Supported Data Types (Azure Search)<ept id="p1">](https://msdn.microsoft.com/library/azure/dn798938.aspx)</ept> page on the Microsoft website summarizes the data types that you can use in searchable documents and indexes.</source>
          <target state="new">The <bpt id="p1">[</bpt>Supported Data Types (Azure Search)<ept id="p1">](https://msdn.microsoft.com/library/azure/dn798938.aspx)</ept> page on the Microsoft website summarizes the data types that you can use in searchable documents and indexes.</target>
        </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Microsoft Azure Cache<ept id="p1">](http://azure.microsoft.com/services/cache.md)</ept> page on the Microsoft website provides an introduction to Azure Redis Cache.</source>
          <target state="new">The <bpt id="p1">[</bpt>Microsoft Azure Cache<ept id="p1">](http://azure.microsoft.com/services/cache.md)</ept> page on the Microsoft website provides an introduction to Azure Redis Cache.</target>
        </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve">
          <source>The page <bpt id="p1">[</bpt>Partitioning: how to split data among multiple Redis instances<ept id="p1">](http://redis.io/topics/partitioning)</ept> on the Redis website provides information on implementing partitioning with Redis.</source>
          <target state="new">The page <bpt id="p1">[</bpt>Partitioning: how to split data among multiple Redis instances<ept id="p1">](http://redis.io/topics/partitioning)</ept> on the Redis website provides information on implementing partitioning with Redis.</target>
        </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve">
          <source>The page <bpt id="p1">[</bpt>Running Redis on a CentOS Linux VM in Azure<ept id="p1">](http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx)</ept> on the Microsoft website walks through an example showing how to build and configure a Redis node running as an Azure VM.</source>
          <target state="new">The page <bpt id="p1">[</bpt>Running Redis on a CentOS Linux VM in Azure<ept id="p1">](http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx)</ept> on the Microsoft website walks through an example showing how to build and configure a Redis node running as an Azure VM.</target>
        </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Data Types<ept id="p1">](http://redis.io/topics/data-types)</ept> page on the Redis website describes the data types that are available with Redis and Azure Redis Cache.</source>
          <target state="new">The <bpt id="p1">[</bpt>Data Types<ept id="p1">](http://redis.io/topics/data-types)</ept> page on the Redis website describes the data types that are available with Redis and Azure Redis Cache.</target>
        </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve">
          <source>test</source>
          <target state="new">test</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">25d652a9824de2db806214cfbc6e4fe3aa5ab82f</xliffext:olfilehash>
  </header>
</xliff>