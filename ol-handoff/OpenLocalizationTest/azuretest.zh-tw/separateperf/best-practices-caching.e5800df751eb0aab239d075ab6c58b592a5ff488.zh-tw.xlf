<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Caching guidance | Microsoft Azure</source>
          <target state="new">Caching guidance | Microsoft Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Guidance on caching to improve performance and scalability.</source>
          <target state="new">Guidance on caching to improve performance and scalability.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Caching guidance</source>
          <target state="new">Caching guidance</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Caching is a common technique that aims to improve the performance and</source>
          <target state="new">Caching is a common technique that aims to improve the performance and</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>scalability of a system by temporarily copying frequently accessed data</source>
          <target state="new">scalability of a system by temporarily copying frequently accessed data</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>to fast storage located close to the application.</source>
          <target state="new">to fast storage located close to the application.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>If this fast data storage</source>
          <target state="new">If this fast data storage</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>is located closer to the application than the original source then caching</source>
          <target state="new">is located closer to the application than the original source then caching</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>can significantly improve response times for client applications by serving</source>
          <target state="new">can significantly improve response times for client applications by serving</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>data more quickly.</source>
          <target state="new">data more quickly.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Caching is most effective when a client instance repeatedly</source>
          <target state="new">Caching is most effective when a client instance repeatedly</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>reads the same data, especially if the data remains relatively static and</source>
          <target state="new">reads the same data, especially if the data remains relatively static and</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>the original data store is slow relative to the speed of the cache, is</source>
          <target state="new">the original data store is slow relative to the speed of the cache, is</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>subject to a high level of contention, or is far away when network latency</source>
          <target state="new">subject to a high level of contention, or is far away when network latency</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>can cause access to be slow.</source>
          <target state="new">can cause access to be slow.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Caching in distributed applications</source>
          <target state="new">Caching in distributed applications</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Distributed applications typically implement either or both of the</source>
          <target state="new">Distributed applications typically implement either or both of the</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>following strategies when caching data:</source>
          <target state="new">following strategies when caching data:</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Using a private cache, where data is held locally on the computer running an instance of an application or service.</source>
          <target state="new">Using a private cache, where data is held locally on the computer running an instance of an application or service.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Using a shared cache, serving as a common source which can be accessed by multiple processes and/or machines.</source>
          <target state="new">Using a shared cache, serving as a common source which can be accessed by multiple processes and/or machines.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>In both cases, caching could be performed client-side (by the process providing</source>
          <target state="new">In both cases, caching could be performed client-side (by the process providing</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>the user interface for a system, such as a web browser or desktop application),</source>
          <target state="new">the user interface for a system, such as a web browser or desktop application),</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>and/or server-side (by the process providing the business services</source>
          <target state="new">and/or server-side (by the process providing the business services</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>running remotely).</source>
          <target state="new">running remotely).</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Private caching</source>
          <target state="new">Private caching</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The most basic type of cache is an in-memory store, held in the address</source>
          <target state="new">The most basic type of cache is an in-memory store, held in the address</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>space of a single process and accessed directly by the code that runs</source>
          <target state="new">space of a single process and accessed directly by the code that runs</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>in that process.</source>
          <target state="new">in that process.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>This type of cache is very quick to access, and it can</source>
          <target state="new">This type of cache is very quick to access, and it can</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>provide an extremely effective strategy for storing modest amounts of</source>
          <target state="new">provide an extremely effective strategy for storing modest amounts of</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>static data as the size of a cache is typically constrained by the</source>
          <target state="new">static data as the size of a cache is typically constrained by the</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>volume of memory available on the machine hosting the process.</source>
          <target state="new">volume of memory available on the machine hosting the process.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>If you</source>
          <target state="new">If you</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>need to cache more information than is physically possible in memory,</source>
          <target state="new">need to cache more information than is physically possible in memory,</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>you can write cached data to the local file system.</source>
          <target state="new">you can write cached data to the local file system.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>This will</source>
          <target state="new">This will</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>necessarily be slower to access than data held in-memory, but should</source>
          <target state="new">necessarily be slower to access than data held in-memory, but should</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>still be faster and more reliable than retrieving data across a network.</source>
          <target state="new">still be faster and more reliable than retrieving data across a network.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>If you have multiple instances of an application that uses this model</source>
          <target state="new">If you have multiple instances of an application that uses this model</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>running concurrently, each application instance will have its own</source>
          <target state="new">running concurrently, each application instance will have its own</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>independent cache holding its own copy of data.</source>
          <target state="new">independent cache holding its own copy of data.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You should think of a cache as a snapshot of the original data at some</source>
          <target state="new">You should think of a cache as a snapshot of the original data at some</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>point in the past.</source>
          <target state="new">point in the past.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>If this data is not static, it is likely that</source>
          <target state="new">If this data is not static, it is likely that</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>different application instances will hold different versions of the</source>
          <target state="new">different application instances will hold different versions of the</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>data in their caches.</source>
          <target state="new">data in their caches.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Therefore, the same query performed by these</source>
          <target state="new">Therefore, the same query performed by these</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>instances could return different results, as shown in Figure 1.</source>
          <target state="new">instances could return different results, as shown in Figure 1.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Using an in-memory cache in different instances of an application</source>
          <target state="new">Using an in-memory cache in different instances of an application</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Figure 1: Using an in-memory cache in different instances of an application</source>
          <target state="new">Figure 1: Using an in-memory cache in different instances of an application</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Shared Caching</source>
          <target state="new">Shared Caching</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Using a shared cache can help to alleviate the concern that data may</source>
          <target state="new">Using a shared cache can help to alleviate the concern that data may</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>differ in each cache, as can occur with in-memory caching.</source>
          <target state="new">differ in each cache, as can occur with in-memory caching.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Shared</source>
          <target state="new">Shared</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>caching ensures that different application instances see the same</source>
          <target state="new">caching ensures that different application instances see the same</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>view of cached data by locating the cache in a separate location,</source>
          <target state="new">view of cached data by locating the cache in a separate location,</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>typically hosted as part of a separate service, as shown in Figure 2.</source>
          <target state="new">typically hosted as part of a separate service, as shown in Figure 2.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Using a shared cache_</source>
          <target state="new">Using a shared cache_</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Figure 2: Using a shared cache</source>
          <target state="new">Figure 2: Using a shared cache</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>An important benefit of using the shared caching approach is the</source>
          <target state="new">An important benefit of using the shared caching approach is the</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>scalability it can help to provide.</source>
          <target state="new">scalability it can help to provide.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Many shared cache services are</source>
          <target state="new">Many shared cache services are</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>implemented by using a cluster of servers, and utilize software that</source>
          <target state="new">implemented by using a cluster of servers, and utilize software that</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>distributes the data across the cluster in a transparent manner.</source>
          <target state="new">distributes the data across the cluster in a transparent manner.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="new">An</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>application instance simply sends a request to the cache service,</source>
          <target state="new">application instance simply sends a request to the cache service,</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>and the underlying infrastructure is responsible for determining the</source>
          <target state="new">and the underlying infrastructure is responsible for determining the</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>location of the cached data in the cluster.</source>
          <target state="new">location of the cached data in the cluster.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>You can easily scale the</source>
          <target state="new">You can easily scale the</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>cache by adding more servers.</source>
          <target state="new">cache by adding more servers.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The disadvantages of the shared caching approach are that the cache</source>
          <target state="new">The disadvantages of the shared caching approach are that the cache</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>is slower to access because it is no longer held locally to each</source>
          <target state="new">is slower to access because it is no longer held locally to each</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>application instance, and the requirement to implement a separate</source>
          <target state="new">application instance, and the requirement to implement a separate</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>cache service may add complexity to the solution.</source>
          <target state="new">cache service may add complexity to the solution.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Considerations for using caching</source>
          <target state="new">Considerations for using caching</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The following sections describe in more detail the considerations</source>
          <target state="new">The following sections describe in more detail the considerations</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>for designing and using a cache.</source>
          <target state="new">for designing and using a cache.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>When should data be cached?</source>
          <target state="new">When should data be cached?</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Caching can dramatically improve performance, scalability, and availability.</source>
          <target state="new">Caching can dramatically improve performance, scalability, and availability.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The more data</source>
          <target state="new">The more data</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>that you have and the larger the number of users that need to access this data, the greater</source>
          <target state="new">that you have and the larger the number of users that need to access this data, the greater</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>the benefits of caching become by reducing latency and contention associated with handling</source>
          <target state="new">the benefits of caching become by reducing latency and contention associated with handling</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>large volumes of concurrent requests in the original data store.</source>
          <target state="new">large volumes of concurrent requests in the original data store.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For example, a database</source>
          <target state="new">For example, a database</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>may support a limited number of concurrent connections, but retrieving data from a shared</source>
          <target state="new">may support a limited number of concurrent connections, but retrieving data from a shared</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>cache rather than the underlying database allows a client application to access this data</source>
          <target state="new">cache rather than the underlying database allows a client application to access this data</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>even if the number of available connections is currently exhausted.</source>
          <target state="new">even if the number of available connections is currently exhausted.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Additionally, if the</source>
          <target state="new">Additionally, if the</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>database becomes unavailable, client applications may be able to continue by using the</source>
          <target state="new">database becomes unavailable, client applications may be able to continue by using the</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>data held in the cache.</source>
          <target state="new">data held in the cache.</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>You should consider caching data that is read frequently but that is modified infrequently</source>
          <target state="new">You should consider caching data that is read frequently but that is modified infrequently</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>(the data has a high proportion of read operations compared to write operations).</source>
          <target state="new">(the data has a high proportion of read operations compared to write operations).</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>However,</source>
          <target state="new">However,</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>you should not use the cache as the authoritative store of critical information; you should</source>
          <target state="new">you should not use the cache as the authoritative store of critical information; you should</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>ensure that all changes that your application cannot afford to lose are always saved to a</source>
          <target state="new">ensure that all changes that your application cannot afford to lose are always saved to a</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>persistent data store.</source>
          <target state="new">persistent data store.</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>In this way, if the cache is unavailable, your application can</source>
          <target state="new">In this way, if the cache is unavailable, your application can</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>still continue to operate by using the data store and you will not lose important</source>
          <target state="new">still continue to operate by using the data store and you will not lose important</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>information.</source>
          <target state="new">information.</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Types of data and cache population strategies</source>
          <target state="new">Types of data and cache population strategies</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The key to using a cache effectively lies in determining the most appropriate data to</source>
          <target state="new">The key to using a cache effectively lies in determining the most appropriate data to</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>cache, and caching it at the appropriate time.</source>
          <target state="new">cache, and caching it at the appropriate time.</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The data may be added to the cache on</source>
          <target state="new">The data may be added to the cache on</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>demand the first time it is retrieved by an application, so that the application needs</source>
          <target state="new">demand the first time it is retrieved by an application, so that the application needs</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>fetch the data only once from the data store and subsequent accesses can be satisfied</source>
          <target state="new">fetch the data only once from the data store and subsequent accesses can be satisfied</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>by using the cache.</source>
          <target state="new">by using the cache.</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Alternatively, a cache may be partially or fully populated with data in advance,</source>
          <target state="new">Alternatively, a cache may be partially or fully populated with data in advance,</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>typically when the application starts (an approach known as seeding).</source>
          <target state="new">typically when the application starts (an approach known as seeding).</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>However, it may</source>
          <target state="new">However, it may</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>not be advisable to implement seeding for a large cache as this approach can impose</source>
          <target state="new">not be advisable to implement seeding for a large cache as this approach can impose</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>a sudden, high load on the original data store when the application starts running.</source>
          <target state="new">a sudden, high load on the original data store when the application starts running.</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Often an analysis of usage patterns can help to decide whether to fully or partially</source>
          <target state="new">Often an analysis of usage patterns can help to decide whether to fully or partially</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>prepopulate a cache, and to choose the data that should be cached.</source>
          <target state="new">prepopulate a cache, and to choose the data that should be cached.</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>For example, it</source>
          <target state="new">For example, it</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>would probably be useful to seed the cache with the static user profile data for</source>
          <target state="new">would probably be useful to seed the cache with the static user profile data for</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>customers who use the application regularly (perhaps every day), but not for</source>
          <target state="new">customers who use the application regularly (perhaps every day), but not for</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>customers who use the application only once a week.</source>
          <target state="new">customers who use the application only once a week.</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Caching typically works well with data that is immutable or that changes</source>
          <target state="new">Caching typically works well with data that is immutable or that changes</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>infrequently.</source>
          <target state="new">infrequently.</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Examples include reference information such as product and pricing</source>
          <target state="new">Examples include reference information such as product and pricing</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>information in an ecommerce application, or shared static resources that are costly</source>
          <target state="new">information in an ecommerce application, or shared static resources that are costly</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>to construct.</source>
          <target state="new">to construct.</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Some or all of this data can be loaded into the cache at application</source>
          <target state="new">Some or all of this data can be loaded into the cache at application</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>startup to minimize demand on resources and to improve performance.</source>
          <target state="new">startup to minimize demand on resources and to improve performance.</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>It may also be</source>
          <target state="new">It may also be</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>appropriate to have a background process that periodically updates reference data</source>
          <target state="new">appropriate to have a background process that periodically updates reference data</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>in the cache to ensure it is up to date, or refreshes the cache when reference</source>
          <target state="new">in the cache to ensure it is up to date, or refreshes the cache when reference</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>data changes.</source>
          <target state="new">data changes.</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Caching may be less useful for dynamic data, although there are some exceptions to</source>
          <target state="new">Caching may be less useful for dynamic data, although there are some exceptions to</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>this consideration (see the section Caching Highly Dynamic Data later in this</source>
          <target state="new">this consideration (see the section Caching Highly Dynamic Data later in this</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>guidance for more information).</source>
          <target state="new">guidance for more information).</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>When the original data regularly changes, either</source>
          <target state="new">When the original data regularly changes, either</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>the cached information can become stale very quickly or the overhead of keeping</source>
          <target state="new">the cached information can become stale very quickly or the overhead of keeping</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>the cache synchronized with the original data store reduces the effectiveness of</source>
          <target state="new">the cache synchronized with the original data store reduces the effectiveness of</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>caching.</source>
          <target state="new">caching.</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Note that a cache does not have to include the complete data for an</source>
          <target state="new">Note that a cache does not have to include the complete data for an</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>entity.</source>
          <target state="new">entity.</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>For example, if a data item represents a multivalued object such as a bank</source>
          <target state="new">For example, if a data item represents a multivalued object such as a bank</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>customer with a name, address, and account balance, some of these elements may</source>
          <target state="new">customer with a name, address, and account balance, some of these elements may</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>remain static (the name and address), while others (such as the account balance)</source>
          <target state="new">remain static (the name and address), while others (such as the account balance)</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>may be more dynamic.</source>
          <target state="new">may be more dynamic.</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>In these situations, it could be useful to cache the static</source>
          <target state="new">In these situations, it could be useful to cache the static</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>portions of the data and only retrieve (or calculate) the remaining information as</source>
          <target state="new">portions of the data and only retrieve (or calculate) the remaining information as</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>and when it is required.</source>
          <target state="new">and when it is required.</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Performance testing and usage analysis should be carried out to determine whether</source>
          <target state="new">Performance testing and usage analysis should be carried out to determine whether</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>pre-population or on-demand loading of the cache, or a combination of both, is</source>
          <target state="new">pre-population or on-demand loading of the cache, or a combination of both, is</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>appropriate.</source>
          <target state="new">appropriate.</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>The decision should be based on a combination of the volatility and</source>
          <target state="new">The decision should be based on a combination of the volatility and</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>usage pattern of the data.</source>
          <target state="new">usage pattern of the data.</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Cache utilization and performance analysis is</source>
          <target state="new">Cache utilization and performance analysis is</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>particularly important in applications that encounter heavy loads and must be</source>
          <target state="new">particularly important in applications that encounter heavy loads and must be</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>highly scalable.</source>
          <target state="new">highly scalable.</target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>For example, in highly scalable scenarios it may make sense to</source>
          <target state="new">For example, in highly scalable scenarios it may make sense to</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>seed the cache to reduce the load on the data store at peak times.</source>
          <target state="new">seed the cache to reduce the load on the data store at peak times.</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Caching can also be used to avoid repeating computations as the application is</source>
          <target state="new">Caching can also be used to avoid repeating computations as the application is</target>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>running.</source>
          <target state="new">running.</target>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>If an operation transforms data or performs a complicated calculation,</source>
          <target state="new">If an operation transforms data or performs a complicated calculation,</target>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>it can save the results of the operation in the cache.</source>
          <target state="new">it can save the results of the operation in the cache.</target>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>If the same calculation</source>
          <target state="new">If the same calculation</target>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>is required subsequently, the application can simply retrieve the results from</source>
          <target state="new">is required subsequently, the application can simply retrieve the results from</target>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>the cache.</source>
          <target state="new">the cache.</target>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>An application can modify data held in a cache, but you should consider the</source>
          <target state="new">An application can modify data held in a cache, but you should consider the</target>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>cache as a transient data store that could disappear at any time.</source>
          <target state="new">cache as a transient data store that could disappear at any time.</target>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Do not store</source>
          <target state="new">Do not store</target>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>valuable data only in the cache, but make sure that you maintain the information</source>
          <target state="new">valuable data only in the cache, but make sure that you maintain the information</target>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>in the original data store as well.</source>
          <target state="new">in the original data store as well.</target>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>In this way, if the cache should become</source>
          <target state="new">In this way, if the cache should become</target>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>unavailable, you minimize the chance of losing data.</source>
          <target state="new">unavailable, you minimize the chance of losing data.</target>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Caching highly dynamic data</source>
          <target state="new">Caching highly dynamic data</target>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Storing information that changes rapidly in a persistent data store can impose</source>
          <target state="new">Storing information that changes rapidly in a persistent data store can impose</target>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>an overhead on the system.</source>
          <target state="new">an overhead on the system.</target>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>For example, consider a device that continually reports</source>
          <target state="new">For example, consider a device that continually reports</target>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>status or some other measurement.</source>
          <target state="new">status or some other measurement.</target>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>If an application chooses not to cache this</source>
          <target state="new">If an application chooses not to cache this</target>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>data on the basis that the cached information will nearly always be outdated, then</source>
          <target state="new">data on the basis that the cached information will nearly always be outdated, then</target>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>the same consideration could be true when storing and retrieving this information</source>
          <target state="new">the same consideration could be true when storing and retrieving this information</target>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>from the data store; in the time taken to save and fetch this data it may have</source>
          <target state="new">from the data store; in the time taken to save and fetch this data it may have</target>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>changed.</source>
          <target state="new">changed.</target>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>In a situation such as this, consider the benefits of storing the dynamic</source>
          <target state="new">In a situation such as this, consider the benefits of storing the dynamic</target>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>information directly in the cache instead of the persistent data store.</source>
          <target state="new">information directly in the cache instead of the persistent data store.</target>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="new">If the</target>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>data is non-critical and does not require to be audited, then it does not matter</source>
          <target state="new">data is non-critical and does not require to be audited, then it does not matter</target>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>if the occasional change is lost.</source>
          <target state="new">if the occasional change is lost.</target>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Managing data expiration in a cache</source>
          <target state="new">Managing data expiration in a cache</target>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>In most cases, data held in a cache is a copy of the data held in the original data</source>
          <target state="new">In most cases, data held in a cache is a copy of the data held in the original data</target>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>store.</source>
          <target state="new">store.</target>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The data in the original data store might change after it was cached, causing</source>
          <target state="new">The data in the original data store might change after it was cached, causing</target>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>the cached data to become stale.</source>
          <target state="new">the cached data to become stale.</target>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Many caching systems enable you to configure the</source>
          <target state="new">Many caching systems enable you to configure the</target>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>cache to expire data and reduce the period for which data may be out of date.</source>
          <target state="new">cache to expire data and reduce the period for which data may be out of date.</target>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>When cached data expires it is removed from the cache, and the application must</source>
          <target state="new">When cached data expires it is removed from the cache, and the application must</target>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>retrieve the data from the original data store (it can put the newly-fetched</source>
          <target state="new">retrieve the data from the original data store (it can put the newly-fetched</target>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>information back into cache).</source>
          <target state="new">information back into cache).</target>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>You can set a default expiration policy when you</source>
          <target state="new">You can set a default expiration policy when you</target>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>configure the cache.</source>
          <target state="new">configure the cache.</target>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>In many cache services you can also stipulate the expiration</source>
          <target state="new">In many cache services you can also stipulate the expiration</target>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>period for individual objects when you store them programmatically in the cache</source>
          <target state="new">period for individual objects when you store them programmatically in the cache</target>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>(some caches enable you to specify the expiration period as an absolute value, or</source>
          <target state="new">(some caches enable you to specify the expiration period as an absolute value, or</target>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>as a sliding value that causes the item to be removed from cache if it is not</source>
          <target state="new">as a sliding value that causes the item to be removed from cache if it is not</target>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>accessed within the specified time.</source>
          <target state="new">accessed within the specified time.</target>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>This setting overrides any cache-wide</source>
          <target state="new">This setting overrides any cache-wide</target>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>expiration policy, but only for the specified objects.</source>
          <target state="new">expiration policy, but only for the specified objects.</target>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Consider the expiration period for the cache and the objects that it contains carefully.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Consider the expiration period for the cache and the objects that it contains carefully.</target>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>If you make it too short, objects will expire too quickly and you will reduce the benefits of using the cache.</source>
          <target state="new">If you make it too short, objects will expire too quickly and you will reduce the benefits of using the cache.</target>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>If you make the period too long, you risk the data becoming stale.</source>
          <target state="new">If you make the period too long, you risk the data becoming stale.</target>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>It is also possible that the cache might fill up if data is allowed to remain</source>
          <target state="new">It is also possible that the cache might fill up if data is allowed to remain</target>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>resident for a long time.</source>
          <target state="new">resident for a long time.</target>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>In this case, any requests to add new items to the</source>
          <target state="new">In this case, any requests to add new items to the</target>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>cache might cause some items to be forcibly removed, in a process known as</source>
          <target state="new">cache might cause some items to be forcibly removed, in a process known as</target>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>eviction.</source>
          <target state="new">eviction.</target>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Cache services typically evict data on a least-recently-used (LRU)</source>
          <target state="new">Cache services typically evict data on a least-recently-used (LRU)</target>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>basis, but you can usually override this policy and prevent items from being</source>
          <target state="new">basis, but you can usually override this policy and prevent items from being</target>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>evicted.</source>
          <target state="new">evicted.</target>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>However, if you adopt this approach you risk your cache exceeding the</source>
          <target state="new">However, if you adopt this approach you risk your cache exceeding the</target>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>memory that it has available, and an application that attempts to add an item</source>
          <target state="new">memory that it has available, and an application that attempts to add an item</target>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>to the cache will fail with an exception.</source>
          <target state="new">to the cache will fail with an exception.</target>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Some caching implementations may provide additional eviction policies.</source>
          <target state="new">Some caching implementations may provide additional eviction policies.</target>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>These</source>
          <target state="new">These</target>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>typically include the most-recently-used policy (in the expectation that the</source>
          <target state="new">typically include the most-recently-used policy (in the expectation that the</target>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>data will not be required again), first-in-first-out policy (oldest data is</source>
          <target state="new">data will not be required again), first-in-first-out policy (oldest data is</target>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>evicted first), or explicit removal based on a triggered event (such as the</source>
          <target state="new">evicted first), or explicit removal based on a triggered event (such as the</target>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>data being modified).</source>
          <target state="new">data being modified).</target>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Invalidating data in a client-side cache</source>
          <target state="new">Invalidating data in a client-side cache</target>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Data held in a client-side cache is generally considered to be outside of</source>
          <target state="new">Data held in a client-side cache is generally considered to be outside of</target>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>the auspices of the service providing the data to the client; a service</source>
          <target state="new">the auspices of the service providing the data to the client; a service</target>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>cannot directly force a client to add or remove information from a</source>
          <target state="new">cannot directly force a client to add or remove information from a</target>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>client-side cache.</source>
          <target state="new">client-side cache.</target>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>This means that it is possible for a client that uses</source>
          <target state="new">This means that it is possible for a client that uses</target>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>a poorly configured cache (for example, expiration policies are not</source>
          <target state="new">a poorly configured cache (for example, expiration policies are not</target>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>properly implemented) to continue using outdated information cached</source>
          <target state="new">properly implemented) to continue using outdated information cached</target>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>locally when the information in the original data source has changed.</source>
          <target state="new">locally when the information in the original data source has changed.</target>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>If you are building a web application that serves data over an HTTP</source>
          <target state="new">If you are building a web application that serves data over an HTTP</target>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>connection, you can implicitly force a web client (such as a browser or</source>
          <target state="new">connection, you can implicitly force a web client (such as a browser or</target>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>web proxy) to fetch the most recent information if a resource is updated</source>
          <target state="new">web proxy) to fetch the most recent information if a resource is updated</target>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>by changing the URI of that resource.</source>
          <target state="new">by changing the URI of that resource.</target>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Web clients typically use the URI</source>
          <target state="new">Web clients typically use the URI</target>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>of a resource as the key in the client-side cache, so changing the URI</source>
          <target state="new">of a resource as the key in the client-side cache, so changing the URI</target>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>causes the web client to ignore any previously cached version of a</source>
          <target state="new">causes the web client to ignore any previously cached version of a</target>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>resource and fetch the new version instead.</source>
          <target state="new">resource and fetch the new version instead.</target>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Managing concurrency in a cache</source>
          <target state="new">Managing concurrency in a cache</target>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Caches are often designed to be shared by multiple instances of an</source>
          <target state="new">Caches are often designed to be shared by multiple instances of an</target>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>application.</source>
          <target state="new">application.</target>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Each application instance can read and modify data in</source>
          <target state="new">Each application instance can read and modify data in</target>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>the cache.</source>
          <target state="new">the cache.</target>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Consequently, the same concurrency issues that arise with</source>
          <target state="new">Consequently, the same concurrency issues that arise with</target>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>any shared data store are also applicable to a cache.</source>
          <target state="new">any shared data store are also applicable to a cache.</target>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>In a situation</source>
          <target state="new">In a situation</target>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>where an application needs to modify data held in the cache, you may</source>
          <target state="new">where an application needs to modify data held in the cache, you may</target>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>need to ensure that updates made by one instance of the application</source>
          <target state="new">need to ensure that updates made by one instance of the application</target>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>do not blindly overwrite the changes made by another instance.</source>
          <target state="new">do not blindly overwrite the changes made by another instance.</target>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Depending on the nature of the data and the likelihood of collisions,</source>
          <target state="new">Depending on the nature of the data and the likelihood of collisions,</target>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>you can adopt one of two approaches to concurrency:</source>
          <target state="new">you can adopt one of two approaches to concurrency:</target>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Optimistic.</source>
          <target state="new">Optimistic.</target>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>The application checks to see whether the data in the cache has changed since it was retrieved, immediately prior to updating it.</source>
          <target state="new">The application checks to see whether the data in the cache has changed since it was retrieved, immediately prior to updating it.</target>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>If the data is still the same, the change can be made.</source>
          <target state="new">If the data is still the same, the change can be made.</target>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>Otherwise, the application has to decide whether to update it (the business logic that drives this decision will be application-specific).</source>
          <target state="new">Otherwise, the application has to decide whether to update it (the business logic that drives this decision will be application-specific).</target>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>This approach is suitable for situations where updates are infrequent, or where collisions are unlikely to occur.</source>
          <target state="new">This approach is suitable for situations where updates are infrequent, or where collisions are unlikely to occur.</target>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>Pessimistic.</source>
          <target state="new">Pessimistic.</target>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>The application locks the data in the cache when it retrieves it to prevent another instance from changing the data.</source>
          <target state="new">The application locks the data in the cache when it retrieves it to prevent another instance from changing the data.</target>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>This process ensures that collisions cannot occur, but could block other instances that need to process the same data.</source>
          <target state="new">This process ensures that collisions cannot occur, but could block other instances that need to process the same data.</target>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>Pessimistic concurrency can affect the scalability of the solution and should be used only for short-lived operations.</source>
          <target state="new">Pessimistic concurrency can affect the scalability of the solution and should be used only for short-lived operations.</target>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>This approach may be appropriate for situations where collisions are more likely, especially if an application updates multiple items in the cache and must ensure that these changes are applied consistently.</source>
          <target state="new">This approach may be appropriate for situations where collisions are more likely, especially if an application updates multiple items in the cache and must ensure that these changes are applied consistently.</target>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Implementing high availability, and scalability, and improving performance</source>
          <target state="new">Implementing high availability, and scalability, and improving performance</target>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>A cache should not be the primary repository of data; this is the role</source>
          <target state="new">A cache should not be the primary repository of data; this is the role</target>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>of the original data store from which the cache is populated.</source>
          <target state="new">of the original data store from which the cache is populated.</target>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="new">The</target>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>original data store is responsible for ensuring the persistence of the</source>
          <target state="new">original data store is responsible for ensuring the persistence of the</target>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>data.</source>
          <target state="new">data.</target>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Be careful not to introduce critical dependencies on the availability</source>
          <target state="new">Be careful not to introduce critical dependencies on the availability</target>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>of a shared cache service into your solutions.</source>
          <target state="new">of a shared cache service into your solutions.</target>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>An application should be</source>
          <target state="new">An application should be</target>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>able to continue functioning if the service providing the shared cache</source>
          <target state="new">able to continue functioning if the service providing the shared cache</target>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>is unavailable; the application should not hang or fail while waiting</source>
          <target state="new">is unavailable; the application should not hang or fail while waiting</target>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>for the cache service to resume.</source>
          <target state="new">for the cache service to resume.</target>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Therefore, the application must be</source>
          <target state="new">Therefore, the application must be</target>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>prepared to detect the availability of the cache service and fall back</source>
          <target state="new">prepared to detect the availability of the cache service and fall back</target>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>to the original data store if the cache is inaccessible.</source>
          <target state="new">to the original data store if the cache is inaccessible.</target>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="new">The</target>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Circuit-Breaker Pattern<ept id="p1">](http://msdn.microsoft.com/library/dn589784.aspx)</ept> is useful for handling this scenario.</source>
          <target state="new"><bpt id="p1">[</bpt>Circuit-Breaker Pattern<ept id="p1">](http://msdn.microsoft.com/library/dn589784.aspx)</ept> is useful for handling this scenario.</target>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="new">The</target>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>service providing the cache can be recovered, and once it becomes</source>
          <target state="new">service providing the cache can be recovered, and once it becomes</target>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>available the cache can be repopulated as data is read form the</source>
          <target state="new">available the cache can be repopulated as data is read form the</target>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>original data store, following a strategy such as the <bpt id="p1">[</bpt>Cache-Aside pattern<ept id="p1">](http://msdn.microsoft.com/library/dn589799.aspx)</ept>.</source>
          <target state="new">original data store, following a strategy such as the <bpt id="p1">[</bpt>Cache-Aside pattern<ept id="p1">](http://msdn.microsoft.com/library/dn589799.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>However, falling back to the original data store if the cache is</source>
          <target state="new">However, falling back to the original data store if the cache is</target>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>temporarily unavailable may have a scalability impact on the system;</source>
          <target state="new">temporarily unavailable may have a scalability impact on the system;</target>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>while the data store is being recovered the original data store</source>
          <target state="new">while the data store is being recovered the original data store</target>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>could be swamped with requests for data, resulting in timeouts and</source>
          <target state="new">could be swamped with requests for data, resulting in timeouts and</target>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>failed connections.</source>
          <target state="new">failed connections.</target>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>A strategy that you should consider is to</source>
          <target state="new">A strategy that you should consider is to</target>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>implement a local, private cache in each instance of an application</source>
          <target state="new">implement a local, private cache in each instance of an application</target>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>together with the shared cache that all application instances</source>
          <target state="new">together with the shared cache that all application instances</target>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>access.</source>
          <target state="new">access.</target>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>When the application retrieves an item, it can check first</source>
          <target state="new">When the application retrieves an item, it can check first</target>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>in its local cache, then the shared cache, and finally the original</source>
          <target state="new">in its local cache, then the shared cache, and finally the original</target>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>data store.</source>
          <target state="new">data store.</target>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>The local cache can be populated using the data in the</source>
          <target state="new">The local cache can be populated using the data in the</target>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>shared cache, or the database if the shared cache is unavailable.</source>
          <target state="new">shared cache, or the database if the shared cache is unavailable.</target>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>This approach requires careful configuration to prevent the local</source>
          <target state="new">This approach requires careful configuration to prevent the local</target>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>cache becoming too stale with respect to the shared cache, but it</source>
          <target state="new">cache becoming too stale with respect to the shared cache, but it</target>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>acts as a buffer if the shared cache is unreachable.</source>
          <target state="new">acts as a buffer if the shared cache is unreachable.</target>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>Figure 3</source>
          <target state="new">Figure 3</target>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>shows this structure.</source>
          <target state="new">shows this structure.</target>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source><ph id="ph1">![</ph>Using a local, private cache with a shared cache_<ph id="ph2">](media/best-practices-caching/Caching3.png)</ph></source>
          <target state="new"><ph id="ph1">![</ph>Using a local, private cache with a shared cache_<ph id="ph2">](media/best-practices-caching/Caching3.png)</ph></target>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source><bpt id="p1">_</bpt>Figure 3: Using a local, private cache with a shared cache<ept id="p1">_</ept></source>
          <target state="new"><bpt id="p1">_</bpt>Figure 3: Using a local, private cache with a shared cache<ept id="p1">_</ept></target>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>To support large caches that hold relatively long-lived data, some</source>
          <target state="new">To support large caches that hold relatively long-lived data, some</target>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>cache services provide a high-availability option that implements</source>
          <target state="new">cache services provide a high-availability option that implements</target>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>automatic failover if the cache becomes unavailable.</source>
          <target state="new">automatic failover if the cache becomes unavailable.</target>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>This approach</source>
          <target state="new">This approach</target>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>typically involves replicating the cached data stored on a primary</source>
          <target state="new">typically involves replicating the cached data stored on a primary</target>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>cache server to a secondary cache server, and switching to the</source>
          <target state="new">cache server to a secondary cache server, and switching to the</target>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>secondary server if the primary server fails or connectivity is</source>
          <target state="new">secondary server if the primary server fails or connectivity is</target>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>lost.</source>
          <target state="new">lost.</target>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>To reduce the latency associated with writing to multiple</source>
          <target state="new">To reduce the latency associated with writing to multiple</target>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>destinations, when data is written to the cache on the primary</source>
          <target state="new">destinations, when data is written to the cache on the primary</target>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>server, the replication to the secondary server may occur</source>
          <target state="new">server, the replication to the secondary server may occur</target>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>asynchronously.</source>
          <target state="new">asynchronously.</target>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>This approach leads to the possibility that some</source>
          <target state="new">This approach leads to the possibility that some</target>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>cached information may be lost in the event of a failure, but the</source>
          <target state="new">cached information may be lost in the event of a failure, but the</target>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>proportion of this data should be small compared to the overall</source>
          <target state="new">proportion of this data should be small compared to the overall</target>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>size of the cache.</source>
          <target state="new">size of the cache.</target>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>If a shared cache is large, it may be beneficial to partition the</source>
          <target state="new">If a shared cache is large, it may be beneficial to partition the</target>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>cached data across nodes to reduce the chances of contention and</source>
          <target state="new">cached data across nodes to reduce the chances of contention and</target>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>improve scalability.</source>
          <target state="new">improve scalability.</target>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>Many shared caches support the ability to</source>
          <target state="new">Many shared caches support the ability to</target>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>dynamically add (and remove) nodes and rebalance the data across</source>
          <target state="new">dynamically add (and remove) nodes and rebalance the data across</target>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>partitions.</source>
          <target state="new">partitions.</target>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>This approach may involve clustering whereby the</source>
          <target state="new">This approach may involve clustering whereby the</target>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>collection of nodes is presented to client applications as a</source>
          <target state="new">collection of nodes is presented to client applications as a</target>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>seamless, single cache, but internally the data is dispersed</source>
          <target state="new">seamless, single cache, but internally the data is dispersed</target>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>between nodes following some predefined distribution strategy</source>
          <target state="new">between nodes following some predefined distribution strategy</target>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>which balances the load evenly.</source>
          <target state="new">which balances the load evenly.</target>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Data Partitioning Guidance document<ept id="p1">](http://msdn.microsoft.com/library/dn589795.aspx)</ept></source>
          <target state="new">The <bpt id="p1">[</bpt>Data Partitioning Guidance document<ept id="p1">](http://msdn.microsoft.com/library/dn589795.aspx)</ept></target>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>on the Microsoft website provides more information about possible</source>
          <target state="new">on the Microsoft website provides more information about possible</target>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>partitioning strategies.</source>
          <target state="new">partitioning strategies.</target>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>Clustering can also add further availability of the cache; if a</source>
          <target state="new">Clustering can also add further availability of the cache; if a</target>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>node fails, the remainder of the cache is still accessible.</source>
          <target state="new">node fails, the remainder of the cache is still accessible.</target>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>Clustering is frequently used in conjunction with replication</source>
          <target state="new">Clustering is frequently used in conjunction with replication</target>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>and failover; each node can be replicated and the replica</source>
          <target state="new">and failover; each node can be replicated and the replica</target>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>quickly brought online if the node fails.</source>
          <target state="new">quickly brought online if the node fails.</target>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>Many read and write operations will likely involve single data</source>
          <target state="new">Many read and write operations will likely involve single data</target>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>values or objects.</source>
          <target state="new">values or objects.</target>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>However, there may be times when it is</source>
          <target state="new">However, there may be times when it is</target>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>necessary to store or retrieve large volumes of data quickly.</source>
          <target state="new">necessary to store or retrieve large volumes of data quickly.</target>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>For example, seeding a cache could involve writing hundreds or</source>
          <target state="new">For example, seeding a cache could involve writing hundreds or</target>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>thousands of items to the cache, or an application may need to</source>
          <target state="new">thousands of items to the cache, or an application may need to</target>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>retrieve a large number of related items from the cache as</source>
          <target state="new">retrieve a large number of related items from the cache as</target>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>part of the same request.</source>
          <target state="new">part of the same request.</target>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>Many large-scale caches provide batch</source>
          <target state="new">Many large-scale caches provide batch</target>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>operations for these purposes, enabling a client application to</source>
          <target state="new">operations for these purposes, enabling a client application to</target>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>package up a large volume of items into a single request and</source>
          <target state="new">package up a large volume of items into a single request and</target>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>reducing the overhead associated with performing a large number</source>
          <target state="new">reducing the overhead associated with performing a large number</target>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>of small requests.</source>
          <target state="new">of small requests.</target>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>Caching and eventual consistency</source>
          <target state="new">Caching and eventual consistency</target>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>The Cache-Aside pattern depends on the instance of the application</source>
          <target state="new">The Cache-Aside pattern depends on the instance of the application</target>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>populating the cache having access to the most recent and</source>
          <target state="new">populating the cache having access to the most recent and</target>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>consistent version of the data.</source>
          <target state="new">consistent version of the data.</target>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>In a system that implements</source>
          <target state="new">In a system that implements</target>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>eventual consistency (such as a replicated data store) this may</source>
          <target state="new">eventual consistency (such as a replicated data store) this may</target>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>not be the case.</source>
          <target state="new">not be the case.</target>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>One instance of an application could modify a</source>
          <target state="new">One instance of an application could modify a</target>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>data item and invalidate the cached version of that item.</source>
          <target state="new">data item and invalidate the cached version of that item.</target>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>Another</source>
          <target state="new">Another</target>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>instance of the application may attempt to read this item from</source>
          <target state="new">instance of the application may attempt to read this item from</target>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>cache which causes a cache-miss, so it reads the data from the</source>
          <target state="new">cache which causes a cache-miss, so it reads the data from the</target>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>data store and adds it to the cache.</source>
          <target state="new">data store and adds it to the cache.</target>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>However, if the data store</source>
          <target state="new">However, if the data store</target>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>has not been fully synchronized with the other replicas the</source>
          <target state="new">has not been fully synchronized with the other replicas the</target>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>application instance could read and populate the cache with the</source>
          <target state="new">application instance could read and populate the cache with the</target>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>old value.</source>
          <target state="new">old value.</target>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>For more information about handling data consistency, see the</source>
          <target state="new">For more information about handling data consistency, see the</target>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>Data Consistency Guidance page on the Microsoft website.</source>
          <target state="new">Data Consistency Guidance page on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>Protecting cached data</source>
          <target state="new">Protecting cached data</target>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>Irrespective of the cache service you use, you should consider</source>
          <target state="new">Irrespective of the cache service you use, you should consider</target>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>how to protect the data held in the cache from unauthorized</source>
          <target state="new">how to protect the data held in the cache from unauthorized</target>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>access.</source>
          <target state="new">access.</target>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>There are two main concerns:</source>
          <target state="new">There are two main concerns:</target>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>The privacy of the data in the cache.</source>
          <target state="new">The privacy of the data in the cache.</target>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>The privacy of data as it flows between the cache and the</source>
          <target state="new">The privacy of data as it flows between the cache and the</target>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>application using the cache.</source>
          <target state="new">application using the cache.</target>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>To protect data in the cache, the cache service may implement</source>
          <target state="new">To protect data in the cache, the cache service may implement</target>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>an authentication mechanism requiring that applications</source>
          <target state="new">an authentication mechanism requiring that applications</target>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>identify themselves, and an authorization scheme that</source>
          <target state="new">identify themselves, and an authorization scheme that</target>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>specifies which identities can access data in the cache, and</source>
          <target state="new">specifies which identities can access data in the cache, and</target>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>the operations (read and write) that these identities are</source>
          <target state="new">the operations (read and write) that these identities are</target>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>allowed to perform.</source>
          <target state="new">allowed to perform.</target>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>To reduce overheads associated with</source>
          <target state="new">To reduce overheads associated with</target>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>reading and writing data, once an identity has been granted</source>
          <target state="new">reading and writing data, once an identity has been granted</target>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>write and/or read access to the cache, that identity can use</source>
          <target state="new">write and/or read access to the cache, that identity can use</target>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>any data in the cache.</source>
          <target state="new">any data in the cache.</target>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>If you need to restrict access to</source>
          <target state="new">If you need to restrict access to</target>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>subsets of the cached data, you can:</source>
          <target state="new">subsets of the cached data, you can:</target>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>Split the cache into partitions (by using different cache</source>
          <target state="new">Split the cache into partitions (by using different cache</target>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>servers) and only grant access to identities for the</source>
          <target state="new">servers) and only grant access to identities for the</target>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>partitions that they should be allowed to use, or</source>
          <target state="new">partitions that they should be allowed to use, or</target>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>Encrypt the data in each subset by using different keys</source>
          <target state="new">Encrypt the data in each subset by using different keys</target>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>and only provide the encryption keys to identities that</source>
          <target state="new">and only provide the encryption keys to identities that</target>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>should have access to each subset.</source>
          <target state="new">should have access to each subset.</target>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>A client application</source>
          <target state="new">A client application</target>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>may still be able to retrieve all of the data in the cache,</source>
          <target state="new">may still be able to retrieve all of the data in the cache,</target>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>but it will only be able to decrypt the data for which it</source>
          <target state="new">but it will only be able to decrypt the data for which it</target>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>has the keys.</source>
          <target state="new">has the keys.</target>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>To protect the data as it flows into and out of the cache you</source>
          <target state="new">To protect the data as it flows into and out of the cache you</target>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>are dependent on the security features provided by the network</source>
          <target state="new">are dependent on the security features provided by the network</target>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>infrastructure that client applications use to connect to the</source>
          <target state="new">infrastructure that client applications use to connect to the</target>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>cache.</source>
          <target state="new">cache.</target>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>If the cache is implemented using an on-site server</source>
          <target state="new">If the cache is implemented using an on-site server</target>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>within the same organization that hosts the client applications,</source>
          <target state="new">within the same organization that hosts the client applications,</target>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>then the isolation of the network itself may not require you to</source>
          <target state="new">then the isolation of the network itself may not require you to</target>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>take any additional steps.</source>
          <target state="new">take any additional steps.</target>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>If the cache is located remotely and</source>
          <target state="new">If the cache is located remotely and</target>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>requires a TCP or HTTP connection over a public network (such</source>
          <target state="new">requires a TCP or HTTP connection over a public network (such</target>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>as the Internet), you should consider implementing SSL.</source>
          <target state="new">as the Internet), you should consider implementing SSL.</target>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>Considerations for implementing caching with Microsoft Azure</source>
          <target state="new">Considerations for implementing caching with Microsoft Azure</target>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>Azure provides the Azure Redis Cache.</source>
          <target state="new">Azure provides the Azure Redis Cache.</target>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>This is an implementation</source>
          <target state="new">This is an implementation</target>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>of the open source Redis Cache that runs as a service in an</source>
          <target state="new">of the open source Redis Cache that runs as a service in an</target>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>Azure datacenter.</source>
          <target state="new">Azure datacenter.</target>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>It provides a caching service that can be</source>
          <target state="new">It provides a caching service that can be</target>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>accessed from any Azure application, whether the application</source>
          <target state="new">accessed from any Azure application, whether the application</target>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>is implemented as a cloud service, a website, or inside an</source>
          <target state="new">is implemented as a cloud service, a website, or inside an</target>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>Azure virtual machine.</source>
          <target state="new">Azure virtual machine.</target>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>Caches can be shared by client</source>
          <target state="new">Caches can be shared by client</target>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>applications that have the appropriate access key.</source>
          <target state="new">applications that have the appropriate access key.</target>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>Redis is a high-performance caching solution that provides</source>
          <target state="new">Redis is a high-performance caching solution that provides</target>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>availability, scalability and security.</source>
          <target state="new">availability, scalability and security.</target>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>It typically runs</source>
          <target state="new">It typically runs</target>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>as a service spread across one or more dedicated machines and</source>
          <target state="new">as a service spread across one or more dedicated machines and</target>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>attempts to store as much information as it can in memory to</source>
          <target state="new">attempts to store as much information as it can in memory to</target>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>ensure fast access.</source>
          <target state="new">ensure fast access.</target>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>This architecture is intended to provide</source>
          <target state="new">This architecture is intended to provide</target>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source>low latency and high throughput by reducing the need to</source>
          <target state="new">low latency and high throughput by reducing the need to</target>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>perform slow I/O operations.</source>
          <target state="new">perform slow I/O operations.</target>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>The Azure Redis cache is compatible with many of the various</source>
          <target state="new">The Azure Redis cache is compatible with many of the various</target>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>APIs used by client applications.</source>
          <target state="new">APIs used by client applications.</target>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source>If you have existing</source>
          <target state="new">If you have existing</target>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>applications that already use Redis running on-premises, the</source>
          <target state="new">applications that already use Redis running on-premises, the</target>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>Azure Redis cache provides a quick migration path to caching</source>
          <target state="new">Azure Redis cache provides a quick migration path to caching</target>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>in the cloud.</source>
          <target state="new">in the cloud.</target>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Azure also provides the Managed Cache Service.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Azure also provides the Managed Cache Service.</target>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>This</source>
          <target state="new">This</target>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>service is based on the Microsoft AppFabric Cache engine.</source>
          <target state="new">service is based on the Microsoft AppFabric Cache engine.</target>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>It</source>
          <target state="new">It</target>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>enables you to create a distributed cache that can be shared</source>
          <target state="new">enables you to create a distributed cache that can be shared</target>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>by loosely-coupled applications.</source>
          <target state="new">by loosely-coupled applications.</target>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>The cache is hosted on</source>
          <target state="new">The cache is hosted on</target>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source>high-performance servers running in an Azure datacenter.</source>
          <target state="new">high-performance servers running in an Azure datacenter.</target>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source>However, this option is no longer recommended and is only</source>
          <target state="new">However, this option is no longer recommended and is only</target>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source>provided to support existing applications that have been built</source>
          <target state="new">provided to support existing applications that have been built</target>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>to use it.</source>
          <target state="new">to use it.</target>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>For all new development, use the Azure Redis</source>
          <target state="new">For all new development, use the Azure Redis</target>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>Cache instead.</source>
          <target state="new">Cache instead.</target>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>Additionally, Azure supports in-role caching.</source>
          <target state="new">Additionally, Azure supports in-role caching.</target>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>This feature</source>
          <target state="new">This feature</target>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>enables you to create a cache specific to a cloud service.</source>
          <target state="new">enables you to create a cache specific to a cloud service.</target>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>The cache is hosted by instances of a web or worker role, and</source>
          <target state="new">The cache is hosted by instances of a web or worker role, and</target>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>can only be accessed by roles operating as part of the same</source>
          <target state="new">can only be accessed by roles operating as part of the same</target>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>cloud service deployment unit (a deployment unit is the set</source>
          <target state="new">cloud service deployment unit (a deployment unit is the set</target>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>of role instances deployed as a cloud service to a specific</source>
          <target state="new">of role instances deployed as a cloud service to a specific</target>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>region).</source>
          <target state="new">region).</target>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>The cache is clustered, and all instances of the</source>
          <target state="new">The cache is clustered, and all instances of the</target>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>role within the same deployment unit that host the cache</source>
          <target state="new">role within the same deployment unit that host the cache</target>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>become part of the same cache cluster.</source>
          <target state="new">become part of the same cache cluster.</target>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>Existing applications</source>
          <target state="new">Existing applications</target>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>that use in-role caching can continue to do so, but</source>
          <target state="new">that use in-role caching can continue to do so, but</target>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>migrating to the Azure Redis Cache may bring more benefits.</source>
          <target state="new">migrating to the Azure Redis Cache may bring more benefits.</target>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>For more information about whether to use Azure Redis Cache</source>
          <target state="new">For more information about whether to use Azure Redis Cache</target>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>or an in-role cache, visit the page</source>
          <target state="new">or an in-role cache, visit the page</target>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source><bpt id="p1">  [</bpt>Which Azure Cache offering is right for me?<ept id="p1">](http://msdn.microsoft.com/library/azure/dn766201.aspx)</ept> on the Microsoft website.</source>
          <target state="new"><bpt id="p1">  [</bpt>Which Azure Cache offering is right for me?<ept id="p1">](http://msdn.microsoft.com/library/azure/dn766201.aspx)</ept> on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>Features of Redis</source>
          <target state="new">Features of Redis</target>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>Redis is more than a simple cache server; it provides a distributed in-memory</source>
          <target state="new">Redis is more than a simple cache server; it provides a distributed in-memory</target>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>database with an extensive command set that supports many common scenarios,</source>
          <target state="new">database with an extensive command set that supports many common scenarios,</target>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source>as described in the section Use-cases for Redis caching later in this</source>
          <target state="new">as described in the section Use-cases for Redis caching later in this</target>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>document.</source>
          <target state="new">document.</target>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>This section summarizes some of the key features that Redis</source>
          <target state="new">This section summarizes some of the key features that Redis</target>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>provides.</source>
          <target state="new">provides.</target>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>Redis as an in-memory database</source>
          <target state="new">Redis as an in-memory database</target>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>Redis supports both reading and writing operations.</source>
          <target state="new">Redis supports both reading and writing operations.</target>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source>Unlike many caches (which should be considered as transitory data stores), writes can be protected from system failure either by being stored in periodically in a local snapshot file or in an append-only log file.</source>
          <target state="new">Unlike many caches (which should be considered as transitory data stores), writes can be protected from system failure either by being stored in periodically in a local snapshot file or in an append-only log file.</target>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>All writes are asynchronous and do not block clients reading and writing data.</source>
          <target state="new">All writes are asynchronous and do not block clients reading and writing data.</target>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>When Redis starts running, it reads the data from the snapshot or log file and uses it to construct the in-memory cache.</source>
          <target state="new">When Redis starts running, it reads the data from the snapshot or log file and uses it to construct the in-memory cache.</target>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Redis Persistence<ept id="p1">](http://redis.io/topics/persistence)</ept> on the Redis website.</source>
          <target state="new">For more information, see <bpt id="p1">[</bpt>Redis Persistence<ept id="p1">](http://redis.io/topics/persistence)</ept> on the Redis website.</target>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Redis does not guarantee that all writes will be saved in the event</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Redis does not guarantee that all writes will be saved in the event</target>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>of a catastrophic failure, but at worst you should only lose a few-seconds</source>
          <target state="new">of a catastrophic failure, but at worst you should only lose a few-seconds</target>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>worth of data.</source>
          <target state="new">worth of data.</target>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>Remember that a cache is not intended to act as an</source>
          <target state="new">Remember that a cache is not intended to act as an</target>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>authoritative data source, and it is the responsibility of the applications</source>
          <target state="new">authoritative data source, and it is the responsibility of the applications</target>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>using the cache to ensure that critical data is saved successfully to an</source>
          <target state="new">using the cache to ensure that critical data is saved successfully to an</target>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>appropriate data store.</source>
          <target state="new">appropriate data store.</target>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>For more information, see the Cache-Aside pattern.</source>
          <target state="new">For more information, see the Cache-Aside pattern.</target>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>Redis data types</source>
          <target state="new">Redis data types</target>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>Redis is a key-value store, where values can contain simple types or complex data structures such as hashes, lists, and sets.</source>
          <target state="new">Redis is a key-value store, where values can contain simple types or complex data structures such as hashes, lists, and sets.</target>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>It supports a set of atomic operations on these data types.</source>
          <target state="new">It supports a set of atomic operations on these data types.</target>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>Keys can be permanent or tagged with a limited time to live at which point the key and its corresponding value are automatically removed from the cache.</source>
          <target state="new">Keys can be permanent or tagged with a limited time to live at which point the key and its corresponding value are automatically removed from the cache.</target>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>For more information about redis keys and values, visit the page <bpt id="p1">[</bpt>An Introduction to Redis data types and abstractions<ept id="p1">](http://redis.io/topics/data-types-intro)</ept> on the Redis website.</source>
          <target state="new">For more information about redis keys and values, visit the page <bpt id="p1">[</bpt>An Introduction to Redis data types and abstractions<ept id="p1">](http://redis.io/topics/data-types-intro)</ept> on the Redis website.</target>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>Redis replication and clustering</source>
          <target state="new">Redis replication and clustering</target>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>Redis supports master/subordinate replication to help ensure availability and maintain throughput; write operations to a Redis master node are replicated to one or more subordinate nodes, and read operations can be served by the master or any of the subordinates.</source>
          <target state="new">Redis supports master/subordinate replication to help ensure availability and maintain throughput; write operations to a Redis master node are replicated to one or more subordinate nodes, and read operations can be served by the master or any of the subordinates.</target>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>In the event of a network partition, subordinates can continue to serve data and then transparently resynchronize with the master when the connection is reestablished.</source>
          <target state="new">In the event of a network partition, subordinates can continue to serve data and then transparently resynchronize with the master when the connection is reestablished.</target>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>For further details, visit the <bpt id="p1">[</bpt>Replication<ept id="p1">](http://redis.io/topics/replication)</ept> page on the Redis website.</source>
          <target state="new">For further details, visit the <bpt id="p1">[</bpt>Replication<ept id="p1">](http://redis.io/topics/replication)</ept> page on the Redis website.</target>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>Redis also provides clustering, enabling you to transparently partition data into shards across servers and spread the load.</source>
          <target state="new">Redis also provides clustering, enabling you to transparently partition data into shards across servers and spread the load.</target>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>This feature improves scalability as new Redis servers can be added and the data repartitioned as the size of the cache increases.</source>
          <target state="new">This feature improves scalability as new Redis servers can be added and the data repartitioned as the size of the cache increases.</target>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>Furthermore, each server in the cluster can be replicated by using master/subordinate replication to ensure availability across each node in the cluster.</source>
          <target state="new">Furthermore, each server in the cluster can be replicated by using master/subordinate replication to ensure availability across each node in the cluster.</target>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>For more information about clustering and sharding, visit the <bpt id="p1">[</bpt>Redis Cluster Tutorial page<ept id="p1">](http://redis.io/topics/cluster-tutorial)</ept> on the Redis website.</source>
          <target state="new">For more information about clustering and sharding, visit the <bpt id="p1">[</bpt>Redis Cluster Tutorial page<ept id="p1">](http://redis.io/topics/cluster-tutorial)</ept> on the Redis website.</target>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Azure Redis Cache does not currently support clustering.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Azure Redis Cache does not currently support clustering.</target>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>If you wish to create a Redis cluster you can build your own custom Redis server.</source>
          <target state="new">If you wish to create a Redis cluster you can build your own custom Redis server.</target>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>For more information, see the section Building a Custom Redis Cache later in this document.</source>
          <target state="new">For more information, see the section Building a Custom Redis Cache later in this document.</target>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>Redis memory use</source>
          <target state="new">Redis memory use</target>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>A Redis cache has a finite size depending on the resources available on the host computer.</source>
          <target state="new">A Redis cache has a finite size depending on the resources available on the host computer.</target>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>When you configure a Redis server, you can specify the maximum amount of memory it can use.</source>
          <target state="new">When you configure a Redis server, you can specify the maximum amount of memory it can use.</target>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>A key in a Redis cache can be configured with an expiration time, after which it is automatically removed from the cache.</source>
          <target state="new">A key in a Redis cache can be configured with an expiration time, after which it is automatically removed from the cache.</target>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>This feature can help prevent the in-memory cache from being filled with old or stale data.</source>
          <target state="new">This feature can help prevent the in-memory cache from being filled with old or stale data.</target>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>As memory fills up, Redis can automatically evict keys and their values by following a number of policies.</source>
          <target state="new">As memory fills up, Redis can automatically evict keys and their values by following a number of policies.</target>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source>The default is LRU (least recently used), but you can also select other policies such as evicting keys at random, or turning off eviction altogether (in which case, attempts to add items to the cache will fail if it is full).</source>
          <target state="new">The default is LRU (least recently used), but you can also select other policies such as evicting keys at random, or turning off eviction altogether (in which case, attempts to add items to the cache will fail if it is full).</target>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>The page <bpt id="p1">[</bpt>Using Redis as an LRU Cache<ept id="p1">](http://redis.io/topics/lru-cache)</ept> provides more information.</source>
          <target state="new">The page <bpt id="p1">[</bpt>Using Redis as an LRU Cache<ept id="p1">](http://redis.io/topics/lru-cache)</ept> provides more information.</target>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>Redis transactions and batches</source>
          <target state="new">Redis transactions and batches</target>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>Redis enables a client application to submit a series of operations that read and write data in the cache as an atomic transaction.</source>
          <target state="new">Redis enables a client application to submit a series of operations that read and write data in the cache as an atomic transaction.</target>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>All of the commands in the transaction are guaranteed to be executed sequentially and no commands issued by other concurrent clients will be interwoven between them.</source>
          <target state="new">All of the commands in the transaction are guaranteed to be executed sequentially and no commands issued by other concurrent clients will be interwoven between them.</target>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source>However, these are not true transactions as a relational database would perform them.</source>
          <target state="new">However, these are not true transactions as a relational database would perform them.</target>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>Transaction processing consists of two stages; command queuing and command execution.</source>
          <target state="new">Transaction processing consists of two stages; command queuing and command execution.</target>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>During the command queuing stage, the commands that comprise the transaction are submitted by the client.</source>
          <target state="new">During the command queuing stage, the commands that comprise the transaction are submitted by the client.</target>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>If some sort of error occurs at this point (such as a syntax error, or the wrong number of parameters) then Redis will refuse to process the entire transaction and discard it.</source>
          <target state="new">If some sort of error occurs at this point (such as a syntax error, or the wrong number of parameters) then Redis will refuse to process the entire transaction and discard it.</target>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source>During the execution phase, Redis performs each queued command in sequence.</source>
          <target state="new">During the execution phase, Redis performs each queued command in sequence.</target>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>If a command fails during this phase Redis will continue with the next queued command and it does not roll back the effects of any commands that have already been executed.</source>
          <target state="new">If a command fails during this phase Redis will continue with the next queued command and it does not roll back the effects of any commands that have already been executed.</target>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve">
          <source>This simplified form of transaction helps to maintain performance and avoid performance problems caused by contention.</source>
          <target state="new">This simplified form of transaction helps to maintain performance and avoid performance problems caused by contention.</target>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>Redis does implement a form of optimistic locking to assist in maintaining consistency.</source>
          <target state="new">Redis does implement a form of optimistic locking to assist in maintaining consistency.</target>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>For detailed information about transactions and locking with Redis, visit the <bpt id="p1">[</bpt>Transactions page<ept id="p1">](http://redis.io/topics/transactions)</ept> on the Redis website.</source>
          <target state="new">For detailed information about transactions and locking with Redis, visit the <bpt id="p1">[</bpt>Transactions page<ept id="p1">](http://redis.io/topics/transactions)</ept> on the Redis website.</target>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>Redis also supports non-transactional batching of requests.</source>
          <target state="new">Redis also supports non-transactional batching of requests.</target>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>The Redis protocol that clients use to send commands to a Redis server enables a client to send a series of operations as part of the same request.</source>
          <target state="new">The Redis protocol that clients use to send commands to a Redis server enables a client to send a series of operations as part of the same request.</target>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source>This can help to reduce packet fragmentation on the network.</source>
          <target state="new">This can help to reduce packet fragmentation on the network.</target>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source>When the batch is processed, each command is performed.</source>
          <target state="new">When the batch is processed, each command is performed.</target>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source>Unlike a transaction, if any of these commands are malformed they will be rejected but the remaining commands will be performed.</source>
          <target state="new">Unlike a transaction, if any of these commands are malformed they will be rejected but the remaining commands will be performed.</target>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>There is also no guarantee on the order in which the commands in the batch will be processed.</source>
          <target state="new">There is also no guarantee on the order in which the commands in the batch will be processed.</target>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>Redis security</source>
          <target state="new">Redis security</target>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>Redis is focused purely on providing fast access to data, and is designed to run inside a trusted environment and be accessed only by trusted clients.</source>
          <target state="new">Redis is focused purely on providing fast access to data, and is designed to run inside a trusted environment and be accessed only by trusted clients.</target>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source>Redis only supports a limited security model based on password authentication (it is possible to remove authentication completely, although this is not recommended).</source>
          <target state="new">Redis only supports a limited security model based on password authentication (it is possible to remove authentication completely, although this is not recommended).</target>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source>All authenticated clients share the same global password, and have access to the same resources.</source>
          <target state="new">All authenticated clients share the same global password, and have access to the same resources.</target>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source>If you need more comprehensive login security, you must implement your own security layer in front of the Redis server and all client requests should pass through this additional layer; Redis should not be directly exposed to untrusted or unauthenticated clients.</source>
          <target state="new">If you need more comprehensive login security, you must implement your own security layer in front of the Redis server and all client requests should pass through this additional layer; Redis should not be directly exposed to untrusted or unauthenticated clients.</target>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source>You can restrict access to commands by disabling them or renaming them (and only providing privileged clients with the new names).</source>
          <target state="new">You can restrict access to commands by disabling them or renaming them (and only providing privileged clients with the new names).</target>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source>Redis does not directly support any form of data encryption, so all encoding must be performed by client applications.</source>
          <target state="new">Redis does not directly support any form of data encryption, so all encoding must be performed by client applications.</target>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source>Additionally, Redis does not provide any form of transport security, so if you need to protect data as it flows across the network you should implement an SSL proxy.</source>
          <target state="new">Additionally, Redis does not provide any form of transport security, so if you need to protect data as it flows across the network you should implement an SSL proxy.</target>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source>For more information, visit the <bpt id="p1">[</bpt>Redis Security<ept id="p1">](http://redis.io/topics/security)</ept> page on the Redis website.</source>
          <target state="new">For more information, visit the <bpt id="p1">[</bpt>Redis Security<ept id="p1">](http://redis.io/topics/security)</ept> page on the Redis website.</target>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Azure Redis Cache provides its own security layer through which clients connect; the underlying Redis</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Azure Redis Cache provides its own security layer through which clients connect; the underlying Redis</target>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>servers are not exposed to the public network.</source>
          <target state="new">servers are not exposed to the public network.</target>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>Using the Azure Redis cache</source>
          <target state="new">Using the Azure Redis cache</target>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>The Azure Redis Cache provides access to Redis servers running on servers hosted at an Azure datacenter; it acts as a faade that provides access control and security.</source>
          <target state="new">The Azure Redis Cache provides access to Redis servers running on servers hosted at an Azure datacenter; it acts as a faade that provides access control and security.</target>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>You can provision a cache by using the Azure Management portal.</source>
          <target state="new">You can provision a cache by using the Azure Management portal.</target>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source>The portal provides a number of predefined configurations, ranging from a 53GB cache running as a dedicated service that supports SSL communications (for privacy) and master/subordinate replication with an SLA of 99.9% availability, down to a 250MB cache without replication (no availability guarantees) running on shared hardware.</source>
          <target state="new">The portal provides a number of predefined configurations, ranging from a 53GB cache running as a dedicated service that supports SSL communications (for privacy) and master/subordinate replication with an SLA of 99.9% availability, down to a 250MB cache without replication (no availability guarantees) running on shared hardware.</target>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source>Using the Azure Management portal you can also configure the eviction policy of the cache, and control access to the cache by adding users to the roles provided; Owner, Contributor, Reader.</source>
          <target state="new">Using the Azure Management portal you can also configure the eviction policy of the cache, and control access to the cache by adding users to the roles provided; Owner, Contributor, Reader.</target>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source>These roles define the operations that members can perform.</source>
          <target state="new">These roles define the operations that members can perform.</target>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>For example, members of the Owner role have complete control over the cache (including security) and its contents, members of the Contributor role can read and write information in the cache, and members of the Reader role can only retrieve data from the cache.</source>
          <target state="new">For example, members of the Owner role have complete control over the cache (including security) and its contents, members of the Contributor role can read and write information in the cache, and members of the Reader role can only retrieve data from the cache.</target>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve">
          <source>Most administrative tasks are performed through the Azure Management portal, and for this reason many of the administrative commands available in the standard version of Redis are not available, including the ability to modify the configuration programmatically, shutdown the Redis server, configure additional slaves, or forcibly save data to disk.</source>
          <target state="new">Most administrative tasks are performed through the Azure Management portal, and for this reason many of the administrative commands available in the standard version of Redis are not available, including the ability to modify the configuration programmatically, shutdown the Redis server, configure additional slaves, or forcibly save data to disk.</target>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>The Azure management portal includes a convenient graphical display that enables you to monitor the performance of the cache.</source>
          <target state="new">The Azure management portal includes a convenient graphical display that enables you to monitor the performance of the cache.</target>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>For example, you can view the number of connections being made, the number of requests performed, the volume of reads and writes, and the number of cache hits versus cache misses.</source>
          <target state="new">For example, you can view the number of connections being made, the number of requests performed, the volume of reads and writes, and the number of cache hits versus cache misses.</target>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>Using this information you can determine the effectiveness of the cache and if necessary switch to a different configuration or change the eviction policy.</source>
          <target state="new">Using this information you can determine the effectiveness of the cache and if necessary switch to a different configuration or change the eviction policy.</target>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>Additionally, you can create alerts that send email messages to an administrator if one or more critical metrics fall outside of an expected range.</source>
          <target state="new">Additionally, you can create alerts that send email messages to an administrator if one or more critical metrics fall outside of an expected range.</target>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source>For example, if the number of cache misses exceeds a specified value in the last hour, an administrator could be alerted as the cache may be too small or data may be being evicted too quickly.</source>
          <target state="new">For example, if the number of cache misses exceeds a specified value in the last hour, an administrator could be alerted as the cache may be too small or data may be being evicted too quickly.</target>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>You can also monitor CPU, memory, and network usage for the cache.</source>
          <target state="new">You can also monitor CPU, memory, and network usage for the cache.</target>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Azure Redis Cache is intended to act purely as a cache rather than a database.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Azure Redis Cache is intended to act purely as a cache rather than a database.</target>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>As a result, it does not currently implement Redis persistence.</source>
          <target state="new">As a result, it does not currently implement Redis persistence.</target>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>For further information and examples showing how to create and configure an Azure Redis Cache, visit the page <bpt id="p1">[</bpt>Lap around Azure Redis Cache<ept id="p1">](http://azure.microsoft.com/blog/2014/06/04/lap-around-azure-redis-cache-preview/)</ept> on the Azure blog.</source>
          <target state="new">For further information and examples showing how to create and configure an Azure Redis Cache, visit the page <bpt id="p1">[</bpt>Lap around Azure Redis Cache<ept id="p1">](http://azure.microsoft.com/blog/2014/06/04/lap-around-azure-redis-cache-preview/)</ept> on the Azure blog.</target>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source>Caching session state and HTML output</source>
          <target state="new">Caching session state and HTML output</target>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source>If you building ASP.NET web applications that run by using Azure web roles, you can save session state information and HTML output in an Azure Redis Cache.</source>
          <target state="new">If you building ASP.NET web applications that run by using Azure web roles, you can save session state information and HTML output in an Azure Redis Cache.</target>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>The Session State Provider for Azure Redis Cache enables you to share session information between different instances of an ASP.NET web application, and is very useful in web farm situations where client-server affinity is not available and caching session data in-memory would not be appropriate.</source>
          <target state="new">The Session State Provider for Azure Redis Cache enables you to share session information between different instances of an ASP.NET web application, and is very useful in web farm situations where client-server affinity is not available and caching session data in-memory would not be appropriate.</target>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source>Using the Session State Provider with Azure Redis Cache delivers several benefits, including:</source>
          <target state="new">Using the Session State Provider with Azure Redis Cache delivers several benefits, including:</target>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>It can share session state amongst a large number of instances of an ASP.NET web application, providing improved scalability,</source>
          <target state="new">It can share session state amongst a large number of instances of an ASP.NET web application, providing improved scalability,</target>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve">
          <source>It supports controlled, concurrent access to the same session state data for multiple readers and a single writer, and</source>
          <target state="new">It supports controlled, concurrent access to the same session state data for multiple readers and a single writer, and</target>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve">
          <source>It can use compression to save memory and improve network performance.</source>
          <target state="new">It can use compression to save memory and improve network performance.</target>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>For more information visit the <bpt id="p1">[</bpt>ASP.NET Session State Provider for Azure Redis Cache<ept id="p1">](http://msdn.microsoft.com/library/azure/dn690522.aspx)</ept> page on the Microsoft website.</source>
          <target state="new">For more information visit the <bpt id="p1">[</bpt>ASP.NET Session State Provider for Azure Redis Cache<ept id="p1">](http://msdn.microsoft.com/library/azure/dn690522.aspx)</ept> page on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Do not use the Session State Provider for Azure Redis Cache for ASP.NET applications that run outside of the Azure environment.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Do not use the Session State Provider for Azure Redis Cache for ASP.NET applications that run outside of the Azure environment.</target>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>The latency of accessing the cache from outside of Azure can eliminate the performance benefits of caching data.</source>
          <target state="new">The latency of accessing the cache from outside of Azure can eliminate the performance benefits of caching data.</target>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>Similarly, the Output Cache Provider for Azure Redis Cache enables you to save the HTTP responses generated by an ASP.NET web application.</source>
          <target state="new">Similarly, the Output Cache Provider for Azure Redis Cache enables you to save the HTTP responses generated by an ASP.NET web application.</target>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>Using the Output Cache Provider with Azure Redis Cache can improve the response times of applications that render complex HTML output; application instances generating similar responses can make use of the shared output fragments in the cache rather than generating this HTML output afresh.</source>
          <target state="new">Using the Output Cache Provider with Azure Redis Cache can improve the response times of applications that render complex HTML output; application instances generating similar responses can make use of the shared output fragments in the cache rather than generating this HTML output afresh.</target>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve">
          <source>For more information visit the <bpt id="p1">[</bpt>ASP.NET Output Cache Provider for Azure Redis Cache<ept id="p1">](http://msdn.microsoft.com/library/azure/dn798898.aspx)</ept> page on the Microsoft website.</source>
          <target state="new">For more information visit the <bpt id="p1">[</bpt>ASP.NET Output Cache Provider for Azure Redis Cache<ept id="p1">](http://msdn.microsoft.com/library/azure/dn798898.aspx)</ept> page on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve">
          <source>Building a custom Redis cache</source>
          <target state="new">Building a custom Redis cache</target>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve">
          <source>The Azure Redis cache acts as a faade to the underlying Redis servers.</source>
          <target state="new">The Azure Redis cache acts as a faade to the underlying Redis servers.</target>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve">
          <source>Currently it supports a fixed set of configurations but does not provide for Redis clustering.</source>
          <target state="new">Currently it supports a fixed set of configurations but does not provide for Redis clustering.</target>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>If you require an advanced configuration that is not covered by the Azure Redis cache (such as a cache bigger than 53GB) you can build and host your own Redis servers by using Azure virtual machines.</source>
          <target state="new">If you require an advanced configuration that is not covered by the Azure Redis cache (such as a cache bigger than 53GB) you can build and host your own Redis servers by using Azure virtual machines.</target>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve">
          <source>This is a potentially complex process as you may need to create several VMs to act as master and subordinate nodes if you want to implement replication.</source>
          <target state="new">This is a potentially complex process as you may need to create several VMs to act as master and subordinate nodes if you want to implement replication.</target>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve">
          <source>Furthermore, if you wish to create a cluster, then you will need multiple masters and subordinate servers; a minimal clustered, replication topology that provides a high degree of availability and scalability comprises at least 6 VMs organized as 3 pairs of master/subordinate servers (a cluster must contain at least 3 master nodes).</source>
          <target state="new">Furthermore, if you wish to create a cluster, then you will need multiple masters and subordinate servers; a minimal clustered, replication topology that provides a high degree of availability and scalability comprises at least 6 VMs organized as 3 pairs of master/subordinate servers (a cluster must contain at least 3 master nodes).</target>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>Each master/subordinate pair should be located close together to minimize latency, but each set of pairs can be running in different Azure datacenters located in different regions if you wish to locate cached data close to the applications that are most likely to use it.</source>
          <target state="new">Each master/subordinate pair should be located close together to minimize latency, but each set of pairs can be running in different Azure datacenters located in different regions if you wish to locate cached data close to the applications that are most likely to use it.</target>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>The page <bpt id="p1">[</bpt>Running Redis on a CentOS Linux VM in Azure<ept id="p1">](http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx)</ept> on the Microsoft website walks through an example showing how to build and configure a Redis node running as an Azure VM.</source>
          <target state="new">The page <bpt id="p1">[</bpt>Running Redis on a CentOS Linux VM in Azure<ept id="p1">](http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx)</ept> on the Microsoft website walks through an example showing how to build and configure a Redis node running as an Azure VM.</target>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>Note that if you implement your own Redis cache in this way, you are responsible for monitoring, managing, and securing the service.</source>
          <target state="new">Note that if you implement your own Redis cache in this way, you are responsible for monitoring, managing, and securing the service.</target>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>Partitioning a Redis cache</source>
          <target state="new">Partitioning a Redis cache</target>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>Partitioning the cache involves splitting the cache across multiple computers.</source>
          <target state="new">Partitioning the cache involves splitting the cache across multiple computers.</target>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source>This structure gives you several advantages over using a single cache server, including:</source>
          <target state="new">This structure gives you several advantages over using a single cache server, including:</target>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>Creating a cache that is much bigger than can be stored on a single server.</source>
          <target state="new">Creating a cache that is much bigger than can be stored on a single server.</target>
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source>Distributing data across servers, improving availability.</source>
          <target state="new">Distributing data across servers, improving availability.</target>
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>If one server fails or becomes inaccessible, only the data that it holds is unavailable; the data on the remaining servers can still be accessed.</source>
          <target state="new">If one server fails or becomes inaccessible, only the data that it holds is unavailable; the data on the remaining servers can still be accessed.</target>
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>For a cache, this is not crucial as the cached data is only a transient copy of the data held in a database, and cached data on a server that becomes inaccessible can be cached on a different server instead.</source>
          <target state="new">For a cache, this is not crucial as the cached data is only a transient copy of the data held in a database, and cached data on a server that becomes inaccessible can be cached on a different server instead.</target>
        </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>Spreading the load across servers, thereby improving performance and scalability.</source>
          <target state="new">Spreading the load across servers, thereby improving performance and scalability.</target>
        </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve">
          <source>Geolocating data close to the users that access it, reducing latency.</source>
          <target state="new">Geolocating data close to the users that access it, reducing latency.</target>
        </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source>For a cache, the most common form of partitioning is sharding.</source>
          <target state="new">For a cache, the most common form of partitioning is sharding.</target>
        </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve">
          <source>In this strategy each partition (or shard) is a Redis cache in its own right.</source>
          <target state="new">In this strategy each partition (or shard) is a Redis cache in its own right.</target>
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>Data is directed to a specific partition by using sharding logic, which can use a variety of approaches to distribute the data.</source>
          <target state="new">Data is directed to a specific partition by using sharding logic, which can use a variety of approaches to distribute the data.</target>
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Sharding Pattern<ept id="p1">](http://msdn.microsoft.com/library/dn589797.aspx)</ept> provides more information on implementing sharding.</source>
          <target state="new">The <bpt id="p1">[</bpt>Sharding Pattern<ept id="p1">](http://msdn.microsoft.com/library/dn589797.aspx)</ept> provides more information on implementing sharding.</target>
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source>To implement partitioning in a Redis cache, you can adopt one of the following approaches:</source>
          <target state="new">To implement partitioning in a Redis cache, you can adopt one of the following approaches:</target>
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve">
          <source>Server-side query routing.</source>
          <target state="new">Server-side query routing.</target>
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source>In this technique, a client application sends a request to any of the</source>
          <target state="new">In this technique, a client application sends a request to any of the</target>
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve">
          <source>Redis servers that comprise the cache (probably the closest server).</source>
          <target state="new">Redis servers that comprise the cache (probably the closest server).</target>
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve">
          <source>Each Redis server stores</source>
          <target state="new">Each Redis server stores</target>
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve">
          <source>metadata that describes the partition that it holds, and also contains information about which</source>
          <target state="new">metadata that describes the partition that it holds, and also contains information about which</target>
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>partitions are located on other servers.</source>
          <target state="new">partitions are located on other servers.</target>
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source>The Redis server examines the client request and if it</source>
          <target state="new">The Redis server examines the client request and if it</target>
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source>can be resolved locally it will perform the requested operation, otherwise it will forward the</source>
          <target state="new">can be resolved locally it will perform the requested operation, otherwise it will forward the</target>
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>request on to the appropriate server.</source>
          <target state="new">request on to the appropriate server.</target>
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source>This model is implemented by Redis clustering, and is</source>
          <target state="new">This model is implemented by Redis clustering, and is</target>
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve">
          <source>described in more detail on the <bpt id="p1">[</bpt>Redis cluster tutorial<ept id="p1">](http://redis.io/topics/cluster-tutorial)</ept> page on the Redis website.</source>
          <target state="new">described in more detail on the <bpt id="p1">[</bpt>Redis cluster tutorial<ept id="p1">](http://redis.io/topics/cluster-tutorial)</ept> page on the Redis website.</target>
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve">
          <source>Redis clustering</source>
          <target state="new">Redis clustering</target>
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve">
          <source>is transparent to client applications, and additional Redis servers can be added to the cluster</source>
          <target state="new">is transparent to client applications, and additional Redis servers can be added to the cluster</target>
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve">
          <source>(and the data re-partitioned) without requiring that you reconfigure the clients.</source>
          <target state="new">(and the data re-partitioned) without requiring that you reconfigure the clients.</target>
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.IMPORTANT]</ph> Azure Redis Cache does not currently support Redis clustering.</source>
          <target state="new"><ph id="ph1">[AZURE.IMPORTANT]</ph> Azure Redis Cache does not currently support Redis clustering.</target>
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve">
          <source>If you wish to</source>
          <target state="new">If you wish to</target>
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve">
          <source>implement this approach then you should build a custom Redis cache as described earlier.</source>
          <target state="new">implement this approach then you should build a custom Redis cache as described earlier.</target>
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve">
          <source>Client-side partitioning.</source>
          <target state="new">Client-side partitioning.</target>
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve">
          <source>In this model, the client application contains logic (possibly in</source>
          <target state="new">In this model, the client application contains logic (possibly in</target>
        </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve">
          <source>the form of a library) that routes requests to the appropriate Redis server.</source>
          <target state="new">the form of a library) that routes requests to the appropriate Redis server.</target>
        </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve">
          <source>This approach</source>
          <target state="new">This approach</target>
        </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve">
          <source>can be used with Azure Redis Cache; create multiple Azure Redis Caches (one for each data</source>
          <target state="new">can be used with Azure Redis Cache; create multiple Azure Redis Caches (one for each data</target>
        </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve">
          <source>partition) and implement the client-side logic that routes the requests to the correct</source>
          <target state="new">partition) and implement the client-side logic that routes the requests to the correct</target>
        </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve">
          <source>cache.</source>
          <target state="new">cache.</target>
        </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve">
          <source>If the partitioning scheme changes (if additional Azure Redis Caches are created,</source>
          <target state="new">If the partitioning scheme changes (if additional Azure Redis Caches are created,</target>
        </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve">
          <source>for example), client applications may need to be reconfigured.</source>
          <target state="new">for example), client applications may need to be reconfigured.</target>
        </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve">
          <source>Proxy-assisted partitioning.</source>
          <target state="new">Proxy-assisted partitioning.</target>
        </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve">
          <source>In this scheme, client applications send requests to an</source>
          <target state="new">In this scheme, client applications send requests to an</target>
        </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve">
          <source>intermediary proxy service which understands how the data is partitioned and then routes</source>
          <target state="new">intermediary proxy service which understands how the data is partitioned and then routes</target>
        </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve">
          <source>the request to the appropriate Redis server.</source>
          <target state="new">the request to the appropriate Redis server.</target>
        </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve">
          <source>This approach can also be used with Azure</source>
          <target state="new">This approach can also be used with Azure</target>
        </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve">
          <source>Redis Cache; the proxy service could be implemented as an Azure cloud service.</source>
          <target state="new">Redis Cache; the proxy service could be implemented as an Azure cloud service.</target>
        </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve">
          <source>This</source>
          <target state="new">This</target>
        </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve">
          <source>approach requires an additional level of complexity to implement the service, and</source>
          <target state="new">approach requires an additional level of complexity to implement the service, and</target>
        </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve">
          <source>requests may take longer to perform than using client-side partitioning.</source>
          <target state="new">requests may take longer to perform than using client-side partitioning.</target>
        </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve">
          <source>The page <bpt id="p1">[</bpt>Partitioning: how to split data among multiple Redis instances<ept id="p1">](http://redis.io/topics/partitioning)</ept></source>
          <target state="new">The page <bpt id="p1">[</bpt>Partitioning: how to split data among multiple Redis instances<ept id="p1">](http://redis.io/topics/partitioning)</ept></target>
        </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve">
          <source>on the Redis website provides further information about implementing partitioning with Redis.</source>
          <target state="new">on the Redis website provides further information about implementing partitioning with Redis.</target>
        </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve">
          <source>Implementing Redis cache client applications</source>
          <target state="new">Implementing Redis cache client applications</target>
        </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve">
          <source>Redis supports client applications written in numerous programming languages.</source>
          <target state="new">Redis supports client applications written in numerous programming languages.</target>
        </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve">
          <source>If you are building new applications by using the .NET Framework, the recommended approach is to use the StackExchange.Redis client library.</source>
          <target state="new">If you are building new applications by using the .NET Framework, the recommended approach is to use the StackExchange.Redis client library.</target>
        </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve">
          <source>This library provides a .NET Framework object model that abstracts the details for connecting to a Redis server, sending commands, and receiving responses.</source>
          <target state="new">This library provides a .NET Framework object model that abstracts the details for connecting to a Redis server, sending commands, and receiving responses.</target>
        </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve">
          <source>It is available in Visual Studio as a NuGet package.</source>
          <target state="new">It is available in Visual Studio as a NuGet package.</target>
        </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve">
          <source>You can use this same library to connect to an Azure Redis cache, or a custom Redis cache hosted on a VM.</source>
          <target state="new">You can use this same library to connect to an Azure Redis cache, or a custom Redis cache hosted on a VM.</target>
        </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve">
          <source>To connect to a Redis server you use the static <ph id="ph1">`Connect`</ph> method of the <ph id="ph2">`ConnectionMultiplexer`</ph> class.</source>
          <target state="new">To connect to a Redis server you use the static <ph id="ph1">`Connect`</ph> method of the <ph id="ph2">`ConnectionMultiplexer`</ph> class.</target>
        </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve">
          <source>The connection that this method creates is designed to be used throughout the lifetime of the client application, and the same connection can be used by multiple concurrent threads; do not reconnect and disconnect each time you perform a Redis operation as this can degrade performance.</source>
          <target state="new">The connection that this method creates is designed to be used throughout the lifetime of the client application, and the same connection can be used by multiple concurrent threads; do not reconnect and disconnect each time you perform a Redis operation as this can degrade performance.</target>
        </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve">
          <source>You can specify the connection parameters, such as the address of the Redis host and the password.</source>
          <target state="new">You can specify the connection parameters, such as the address of the Redis host and the password.</target>
        </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve">
          <source>If you are using the Azure Redis cache, the password this is either the primary or secondary key generated for the Azure Redis Cache by using the Azure Management portal.</source>
          <target state="new">If you are using the Azure Redis cache, the password this is either the primary or secondary key generated for the Azure Redis Cache by using the Azure Management portal.</target>
        </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source>After you have connected to the Redis server, you can obtain a handle on the Redis database that acts as the cache.</source>
          <target state="new">After you have connected to the Redis server, you can obtain a handle on the Redis database that acts as the cache.</target>
        </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve">
          <source>The Redis connection provides the <ph id="ph1">`GetDatabase`</ph> method to do this.</source>
          <target state="new">The Redis connection provides the <ph id="ph1">`GetDatabase`</ph> method to do this.</target>
        </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve">
          <source>You can then retrieve items from the cache and store data in the cache by using the <ph id="ph1">`StringGet`</ph> and <ph id="ph2">`StringSet`</ph> methods.</source>
          <target state="new">You can then retrieve items from the cache and store data in the cache by using the <ph id="ph1">`StringGet`</ph> and <ph id="ph2">`StringSet`</ph> methods.</target>
        </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve">
          <source>These methods expect a key as a parameter, and either return the item in the cache that has a matching value (<ph id="ph1">`StringGet`</ph>) or add the item to the cache with this key (<ph id="ph2">`StringSet`</ph>).</source>
          <target state="new">These methods expect a key as a parameter, and either return the item in the cache that has a matching value (<ph id="ph1">`StringGet`</ph>) or add the item to the cache with this key (<ph id="ph2">`StringSet`</ph>).</target>
        </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve">
          <source>Depending on the location of the Redis server, many operations may incur some latency while a request is transmitted to the server and a response returned to the client.</source>
          <target state="new">Depending on the location of the Redis server, many operations may incur some latency while a request is transmitted to the server and a response returned to the client.</target>
        </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve">
          <source>The StackExchange library provides asynchronous versions of many of the methods that it exposes to help client applications remain responsive.</source>
          <target state="new">The StackExchange library provides asynchronous versions of many of the methods that it exposes to help client applications remain responsive.</target>
        </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve">
          <source>These methods support the <bpt id="p1">[</bpt>Task-based Asynchronous Pattern<ept id="p1">](http://msdn.microsoft.com/library/hh873175.aspx)</ept> in the .NET Framework.</source>
          <target state="new">These methods support the <bpt id="p1">[</bpt>Task-based Asynchronous Pattern<ept id="p1">](http://msdn.microsoft.com/library/hh873175.aspx)</ept> in the .NET Framework.</target>
        </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve">
          <source>The following code snippet shows a method named <ph id="ph1">`RetrieveItem`</ph> that illustrates an example of an implementation of the cache-aside pattern based on Redis and the StackExchange library.</source>
          <target state="new">The following code snippet shows a method named <ph id="ph1">`RetrieveItem`</ph> that illustrates an example of an implementation of the cache-aside pattern based on Redis and the StackExchange library.</target>
        </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve">
          <source>The method takes a string key value, and attempts to retrieve the corresponding item from the Redis cache by calling the <ph id="ph1">`StringGetAsync`</ph> method (the asynchronous version of <ph id="ph2">`StringGet`</ph>).</source>
          <target state="new">The method takes a string key value, and attempts to retrieve the corresponding item from the Redis cache by calling the <ph id="ph1">`StringGetAsync`</ph> method (the asynchronous version of <ph id="ph2">`StringGet`</ph>).</target>
        </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve">
          <source>If the item is not found, it is fetched from the underlying data source using the <ph id="ph1">`GetItemFromDataSourceAsync`</ph> method (which is a local method and not part of the StackExchange library), and then added to the cache by using the <ph id="ph2">`StringSetAsync`</ph> method so it can be retrieved more quickly next time.</source>
          <target state="new">If the item is not found, it is fetched from the underlying data source using the <ph id="ph1">`GetItemFromDataSourceAsync`</ph> method (which is a local method and not part of the StackExchange library), and then added to the cache by using the <ph id="ph2">`StringSetAsync`</ph> method so it can be retrieved more quickly next time.</target>
        </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`StringGet`</ph> and <ph id="ph2">`StringSet`</ph> methods are not restricted to retrieving or storing string values; they can take any item serialized as an array of bytes.</source>
          <target state="new">The <ph id="ph1">`StringGet`</ph> and <ph id="ph2">`StringSet`</ph> methods are not restricted to retrieving or storing string values; they can take any item serialized as an array of bytes.</target>
        </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve">
          <source>If you need to save a .NET object you can serialize it as a byte stream and use the StringSet method to write it to the cache.</source>
          <target state="new">If you need to save a .NET object you can serialize it as a byte stream and use the StringSet method to write it to the cache.</target>
        </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source>Similarly, you can read an object from cache by using the StringGet method and deserialize it as a .NET object.</source>
          <target state="new">Similarly, you can read an object from cache by using the StringGet method and deserialize it as a .NET object.</target>
        </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve">
          <source>The following code shows a set of extension methods for the IDatabase interface (the GetDatabase method of a Redis connection returns an <ph id="ph1">`IDatabase`</ph> object),  and some sample code that uses these methods to read and write a BlogPost object to the cache:</source>
          <target state="new">The following code shows a set of extension methods for the IDatabase interface (the GetDatabase method of a Redis connection returns an <ph id="ph1">`IDatabase`</ph> object),  and some sample code that uses these methods to read and write a BlogPost object to the cache:</target>
        </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source>The following code illustrates a method named <ph id="ph1">`RetrieveBlogPost`</ph> that uses these extension methods to read and write a serializable <ph id="ph2">`BlogPost`</ph> object to the cache following the cache-aside pattern:</source>
          <target state="new">The following code illustrates a method named <ph id="ph1">`RetrieveBlogPost`</ph> that uses these extension methods to read and write a serializable <ph id="ph2">`BlogPost`</ph> object to the cache following the cache-aside pattern:</target>
        </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source>Redis supports command pipelining if a client application sends multiple asynchronous requests.</source>
          <target state="new">Redis supports command pipelining if a client application sends multiple asynchronous requests.</target>
        </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve">
          <source>Redis can multiplex the requests using the same connection rather than receiving and responding to commands in a strict sequence.</source>
          <target state="new">Redis can multiplex the requests using the same connection rather than receiving and responding to commands in a strict sequence.</target>
        </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve">
          <source>This approach helps to reduce latency by making more efficient use of the network.</source>
          <target state="new">This approach helps to reduce latency by making more efficient use of the network.</target>
        </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve">
          <source>The following code snippet shows an example that retrieves the details of two customers concurrently.</source>
          <target state="new">The following code snippet shows an example that retrieves the details of two customers concurrently.</target>
        </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve">
          <source>The code submits two requests and then performs some other processing (not shown) before waiting to receive the results.</source>
          <target state="new">The code submits two requests and then performs some other processing (not shown) before waiting to receive the results.</target>
        </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve">
          <source>The Wait method of the cache object is similar to the .NET Framework Task.Wait method:</source>
          <target state="new">The Wait method of the cache object is similar to the .NET Framework Task.Wait method:</target>
        </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve">
          <source>The page <bpt id="p1">[</bpt>Develop for Azure Redis Cache<ept id="p1">](http://msdn.microsoft.com/library/azure/dn690520.aspx)</ept> on the Microsoft website provides more information on how to write client applications that can use the Azure Redis cache.</source>
          <target state="new">The page <bpt id="p1">[</bpt>Develop for Azure Redis Cache<ept id="p1">](http://msdn.microsoft.com/library/azure/dn690520.aspx)</ept> on the Microsoft website provides more information on how to write client applications that can use the Azure Redis cache.</target>
        </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve">
          <source>Additional information is available on the <bpt id="p1">[</bpt>Basic Usage page<ept id="p1">](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Basics.md)</ept> on the StackExchange.Redis website, and the page <bpt id="p2">[</bpt>Pipelines and Multiplexers<ept id="p2">](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/PipelinesMultiplexers.md)</ept> on the same website provides more information about asynchronous operations and pipelining with Redis and the StackExchange library.</source>
          <target state="new">Additional information is available on the <bpt id="p1">[</bpt>Basic Usage page<ept id="p1">](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Basics.md)</ept> on the StackExchange.Redis website, and the page <bpt id="p2">[</bpt>Pipelines and Multiplexers<ept id="p2">](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/PipelinesMultiplexers.md)</ept> on the same website provides more information about asynchronous operations and pipelining with Redis and the StackExchange library.</target>
        </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve">
          <source>The section Use-Cases for Redis Caching later in this guidance provides examples of some of the more advanced techniques that you can apply to data held in a Redis cache.</source>
          <target state="new">The section Use-Cases for Redis Caching later in this guidance provides examples of some of the more advanced techniques that you can apply to data held in a Redis cache.</target>
        </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve">
          <source>Use-cases for Redis caching</source>
          <target state="new">Use-cases for Redis caching</target>
        </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve">
          <source>The simplest use of Redis for caching concerns storing key/value pairs where the value is an uninterpreted string of arbitrary length that can contain any binary data (it is essentially  an array of bytes that can be treated as a string).</source>
          <target state="new">The simplest use of Redis for caching concerns storing key/value pairs where the value is an uninterpreted string of arbitrary length that can contain any binary data (it is essentially  an array of bytes that can be treated as a string).</target>
        </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve">
          <source>This scenario was illustrated in the section Implementing Redis Cache Client Applications earlier in this guidance.</source>
          <target state="new">This scenario was illustrated in the section Implementing Redis Cache Client Applications earlier in this guidance.</target>
        </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve">
          <source>You should note that keys also contain uninterpreted data, so you can use any binary information as the key, although the longer the key is the more space it will take to store, and the longer it will take to perform lookup operations.</source>
          <target state="new">You should note that keys also contain uninterpreted data, so you can use any binary information as the key, although the longer the key is the more space it will take to store, and the longer it will take to perform lookup operations.</target>
        </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve">
          <source>For usability and ease of maintenance design your keyspace carefully and use meaningful (but not verbose) keys.</source>
          <target state="new">For usability and ease of maintenance design your keyspace carefully and use meaningful (but not verbose) keys.</target>
        </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve">
          <source>For example, use structured keys such as "customer:100" to represent the key for the customer with ID 100 rather than simply "100".</source>
          <target state="new">For example, use structured keys such as "customer:100" to represent the key for the customer with ID 100 rather than simply "100".</target>
        </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve">
          <source>This scheme enables you to easily distinguish between values that store different data types.</source>
          <target state="new">This scheme enables you to easily distinguish between values that store different data types.</target>
        </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve">
          <source>For example, you could also use the key "orders:100" to represent the key for the order with ID 100.</source>
          <target state="new">For example, you could also use the key "orders:100" to represent the key for the order with ID 100.</target>
        </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve">
          <source>Apart from one-dimensional binary strings, a value in a Redis key/value pair can also hold more structured information, including lists, sets (sorted and unsorted), and hashes.</source>
          <target state="new">Apart from one-dimensional binary strings, a value in a Redis key/value pair can also hold more structured information, including lists, sets (sorted and unsorted), and hashes.</target>
        </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve">
          <source>Redis provides a comprehensive command set that can manipulate these types, and many of these commands are available to .NET Framework applications through a client library such as StackExchange.</source>
          <target state="new">Redis provides a comprehensive command set that can manipulate these types, and many of these commands are available to .NET Framework applications through a client library such as StackExchange.</target>
        </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve">
          <source>The page <bpt id="p1">[</bpt>An introduction to Redis data types and abstractions<ept id="p1">](http://redis.io/topics/data-types-intro)</ept> on the Redis website provides a more detailed overview of these types and the commands that you can use to manipulate them.</source>
          <target state="new">The page <bpt id="p1">[</bpt>An introduction to Redis data types and abstractions<ept id="p1">](http://redis.io/topics/data-types-intro)</ept> on the Redis website provides a more detailed overview of these types and the commands that you can use to manipulate them.</target>
        </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve">
          <source>This section summarizes some common use-cases for these data types and commands.</source>
          <target state="new">This section summarizes some common use-cases for these data types and commands.</target>
        </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve">
          <source>Performing atomic and batch operations</source>
          <target state="new">Performing atomic and batch operations</target>
        </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve">
          <source>Redis supports a series of atomic get-and-set operations on string values.</source>
          <target state="new">Redis supports a series of atomic get-and-set operations on string values.</target>
        </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve">
          <source>These operations remove the possible race hazards that might occur when using separate <ph id="ph1">`GET`</ph> and <ph id="ph2">`SET`</ph> commands.</source>
          <target state="new">These operations remove the possible race hazards that might occur when using separate <ph id="ph1">`GET`</ph> and <ph id="ph2">`SET`</ph> commands.</target>
        </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve">
          <source>The operations available include:</source>
          <target state="new">The operations available include:</target>
        </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`INCR`</ph>, <ph id="ph2">`INCRBY`</ph>, <ph id="ph3">`DECR`</ph>, and <ph id="ph4">`DECRBY`</ph> which perform atomic increment and decrement operations on</source>
          <target state="new"><ph id="ph1">`INCR`</ph>, <ph id="ph2">`INCRBY`</ph>, <ph id="ph3">`DECR`</ph>, and <ph id="ph4">`DECRBY`</ph> which perform atomic increment and decrement operations on</target>
        </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source>integer numeric data values.</source>
          <target state="new">integer numeric data values.</target>
        </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve">
          <source>The StackExchange library provides overloaded versions of the</source>
          <target state="new">The StackExchange library provides overloaded versions of the</target>
        </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`IDatabase.StringIncrementAsync`</ph> and <ph id="ph2">`IDatabase.StringDecrementAsync`</ph> methods to perform</source>
          <target state="new"><ph id="ph1">`IDatabase.StringIncrementAsync`</ph> and <ph id="ph2">`IDatabase.StringDecrementAsync`</ph> methods to perform</target>
        </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve">
          <source>these operations and return the resulting value stored in the cache.</source>
          <target state="new">these operations and return the resulting value stored in the cache.</target>
        </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve">
          <source>The following code</source>
          <target state="new">The following code</target>
        </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve">
          <source>snippet illustrates how to use these methods:</source>
          <target state="new">snippet illustrates how to use these methods:</target>
        </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`GETSET`</ph> which retrieves the value associated with a key and changes it to a new value.</source>
          <target state="new"><ph id="ph1">`GETSET`</ph> which retrieves the value associated with a key and changes it to a new value.</target>
        </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="new">The</target>
        </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve">
          <source>StackExchange library makes this operation available through the <ph id="ph1">`IDatabase.StringGetSetAsync`</ph></source>
          <target state="new">StackExchange library makes this operation available through the <ph id="ph1">`IDatabase.StringGetSetAsync`</ph></target>
        </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve">
          <source>method.</source>
          <target state="new">method.</target>
        </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve">
          <source>The code snippet below shows an example of this method.</source>
          <target state="new">The code snippet below shows an example of this method.</target>
        </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve">
          <source>This code returns the current</source>
          <target state="new">This code returns the current</target>
        </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve">
          <source>value associated with the key "data:counter" from the previous example and resets the value</source>
          <target state="new">value associated with the key "data:counter" from the previous example and resets the value</target>
        </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve">
          <source>for this key back to zero, all as part of the same operation:</source>
          <target state="new">for this key back to zero, all as part of the same operation:</target>
        </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`MGET`</ph> and <ph id="ph2">`MSET`</ph>, which can return or change a set of string values as a single operation.</source>
          <target state="new"><ph id="ph1">`MGET`</ph> and <ph id="ph2">`MSET`</ph>, which can return or change a set of string values as a single operation.</target>
        </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="new">The</target>
        </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`IDatabase.StringGetAsync`</ph> and <ph id="ph2">`IDatabase.StringSetAsync`</ph> methods are overloaded to support</source>
          <target state="new"><ph id="ph1">`IDatabase.StringGetAsync`</ph> and <ph id="ph2">`IDatabase.StringSetAsync`</ph> methods are overloaded to support</target>
        </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve">
          <source>this functionality, as shown in the following example:</source>
          <target state="new">this functionality, as shown in the following example:</target>
        </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve">
          <source>You can also combine multiple operations into a single Redis transaction as described in the Redis Transactions and Batches section in this guidance.</source>
          <target state="new">You can also combine multiple operations into a single Redis transaction as described in the Redis Transactions and Batches section in this guidance.</target>
        </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve">
          <source>The StackExchange library provides support for transactions through the <ph id="ph1">`ITransaction`</ph> interface.</source>
          <target state="new">The StackExchange library provides support for transactions through the <ph id="ph1">`ITransaction`</ph> interface.</target>
        </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve">
          <source>You can create an ITransaction object by using the IDatabase.CreateTransaction method, and invoke commands to the transaction by using the methods provided <ph id="ph1">`ITransaction`</ph> object.</source>
          <target state="new">You can create an ITransaction object by using the IDatabase.CreateTransaction method, and invoke commands to the transaction by using the methods provided <ph id="ph1">`ITransaction`</ph> object.</target>
        </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ITransaction`</ph> interface provides access to a similar set of methods as the <ph id="ph2">`IDatabase`</ph> interface except that all the methods are asynchronous; they are only performed when the <ph id="ph3">`ITransaction.Execute`</ph> method is invoked.</source>
          <target state="new">The <ph id="ph1">`ITransaction`</ph> interface provides access to a similar set of methods as the <ph id="ph2">`IDatabase`</ph> interface except that all the methods are asynchronous; they are only performed when the <ph id="ph3">`ITransaction.Execute`</ph> method is invoked.</target>
        </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve">
          <source>The value returned by the execute method indicates whether the transaction was created successfully (true) or it failed (false).</source>
          <target state="new">The value returned by the execute method indicates whether the transaction was created successfully (true) or it failed (false).</target>
        </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve">
          <source>The following code snippet shows an example that increments and decrements two counters as part of the same transaction:</source>
          <target state="new">The following code snippet shows an example that increments and decrements two counters as part of the same transaction:</target>
        </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve">
          <source>Remember that Redis transactions are unlike transactions in relational databases.</source>
          <target state="new">Remember that Redis transactions are unlike transactions in relational databases.</target>
        </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve">
          <source>The Execute method simply queues all the commands that comprise the transaction for execution, and if any of them is malformed then the transaction is aborted.</source>
          <target state="new">The Execute method simply queues all the commands that comprise the transaction for execution, and if any of them is malformed then the transaction is aborted.</target>
        </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve">
          <source>If all the commands have been queued successfully, each command will be run asynchronously.</source>
          <target state="new">If all the commands have been queued successfully, each command will be run asynchronously.</target>
        </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve">
          <source>If any command fails, the others will still continue processing.</source>
          <target state="new">If any command fails, the others will still continue processing.</target>
        </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve">
          <source>If you need to verify that a command has completed successfully you must fetch the results of the command by using the Result property of the corresponding task, as shown in the example above.</source>
          <target state="new">If you need to verify that a command has completed successfully you must fetch the results of the command by using the Result property of the corresponding task, as shown in the example above.</target>
        </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve">
          <source>Reading the Result property will block until the task has completed.</source>
          <target state="new">Reading the Result property will block until the task has completed.</target>
        </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Transactions in Redis<ept id="p1">](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Transactions.md)</ept> page on the StackExchange.Redis website.</source>
          <target state="new">For more information, see the <bpt id="p1">[</bpt>Transactions in Redis<ept id="p1">](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Transactions.md)</ept> page on the StackExchange.Redis website.</target>
        </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve">
          <source>For performing batch operations, you can use the IBatch interface of the StackExchange library.</source>
          <target state="new">For performing batch operations, you can use the IBatch interface of the StackExchange library.</target>
        </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve">
          <source>This interface provides access to a similar set of methods as the IDatabase interface except that all the methods are asynchronous.</source>
          <target state="new">This interface provides access to a similar set of methods as the IDatabase interface except that all the methods are asynchronous.</target>
        </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve">
          <source>You create an IBatch object by using the IDatabase.CreateBatch method and then run the batch by using the IBatch.Execute method, as shown in the following example.</source>
          <target state="new">You create an IBatch object by using the IDatabase.CreateBatch method and then run the batch by using the IBatch.Execute method, as shown in the following example.</target>
        </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve">
          <source>This code simply sets a string value, and increments and decrements the same counters used in the previous example and displays the results:</source>
          <target state="new">This code simply sets a string value, and increments and decrements the same counters used in the previous example and displays the results:</target>
        </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve">
          <source>It is important to understand that unlike a transaction, if a command in a batch fails because it is malformed the other commands may still run; the IBatch.Execute method does not return any indication of success or failure.</source>
          <target state="new">It is important to understand that unlike a transaction, if a command in a batch fails because it is malformed the other commands may still run; the IBatch.Execute method does not return any indication of success or failure.</target>
        </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve">
          <source>Performing fire-and-forget cache operations</source>
          <target state="new">Performing fire-and-forget cache operations</target>
        </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve">
          <source>Redis supports fire-and-forget operations by using command flags.</source>
          <target state="new">Redis supports fire-and-forget operations by using command flags.</target>
        </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve">
          <source>In this situation, the client simply initiates an operation but has no interest in the result and does not wait for the command to be completed.</source>
          <target state="new">In this situation, the client simply initiates an operation but has no interest in the result and does not wait for the command to be completed.</target>
        </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve">
          <source>The example below shows how to perform the INCR command as a fire-and-forget operation:</source>
          <target state="new">The example below shows how to perform the INCR command as a fire-and-forget operation:</target>
        </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve">
          <source>Automatically expiring keys</source>
          <target state="new">Automatically expiring keys</target>
        </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve">
          <source>When you store an item in a Redis cache, you can specify a timeout after which the item will be automatically removed from the cache.</source>
          <target state="new">When you store an item in a Redis cache, you can specify a timeout after which the item will be automatically removed from the cache.</target>
        </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve">
          <source>You can also query how much more time a key has before it expires by using the <ph id="ph1">`TTL`</ph> command; this command is available to StackExchange applications by using the IDatabase.KeyTimeToLive method.</source>
          <target state="new">You can also query how much more time a key has before it expires by using the <ph id="ph1">`TTL`</ph> command; this command is available to StackExchange applications by using the IDatabase.KeyTimeToLive method.</target>
        </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve">
          <source>The following code snippet shows an example of setting an expiration time of 20 seconds on a key, and querying the remaining lifetime of the key:</source>
          <target state="new">The following code snippet shows an example of setting an expiration time of 20 seconds on a key, and querying the remaining lifetime of the key:</target>
        </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve">
          <source>You can also set the expiration time to a specific date and time by using the EXPIRE command, available in the StackExchange library as the KeyExpireAsync method:</source>
          <target state="new">You can also set the expiration time to a specific date and time by using the EXPIRE command, available in the StackExchange library as the KeyExpireAsync method:</target>
        </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve">
          <source><bpt id="p1">_</bpt>Tip:<ept id="p1">_</ept> You can manually remove an item from the cache by using the DEL command, which is available through the StackExchange library as the IDatabase.KeyDeleteAsync method.</source>
          <target state="new"><bpt id="p1">_</bpt>Tip:<ept id="p1">_</ept> You can manually remove an item from the cache by using the DEL command, which is available through the StackExchange library as the IDatabase.KeyDeleteAsync method.</target>
        </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve">
          <source>Using tags to cross-correlate cached items</source>
          <target state="new">Using tags to cross-correlate cached items</target>
        </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve">
          <source>A Redis set is a collection of multiple items that share a single key.</source>
          <target state="new">A Redis set is a collection of multiple items that share a single key.</target>
        </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve">
          <source>You can create a set by using the SADD command.</source>
          <target state="new">You can create a set by using the SADD command.</target>
        </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source>You can retrieve the items in a set by using the SMEMBERS command.</source>
          <target state="new">You can retrieve the items in a set by using the SMEMBERS command.</target>
        </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source>The StackExchange library implements the SADD command through the IDatabase.SetAddAsync method, and the SMEMBERS command with the IDatabase.SetMembersAsync method.</source>
          <target state="new">The StackExchange library implements the SADD command through the IDatabase.SetAddAsync method, and the SMEMBERS command with the IDatabase.SetMembersAsync method.</target>
        </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve">
          <source>You can also combine existing sets to create new sets by using the SDIFF (set difference), SINTER (set intersection), and SUNION (set union) commands.</source>
          <target state="new">You can also combine existing sets to create new sets by using the SDIFF (set difference), SINTER (set intersection), and SUNION (set union) commands.</target>
        </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve">
          <source>The StackExchange library unifies these operations in the IDatabase.SetCombineAsync method; the first parameter to this method specifies the set operation to perform.</source>
          <target state="new">The StackExchange library unifies these operations in the IDatabase.SetCombineAsync method; the first parameter to this method specifies the set operation to perform.</target>
        </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve">
          <source>The following code snippets show how sets can be useful for quickly storing and retrieving collections of related items.</source>
          <target state="new">The following code snippets show how sets can be useful for quickly storing and retrieving collections of related items.</target>
        </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve">
          <source>This code uses the BlogPost type described in the section Implementing Redis Cache Client Applications.</source>
          <target state="new">This code uses the BlogPost type described in the section Implementing Redis Cache Client Applications.</target>
        </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve">
          <source>A BlogPost object contains four fieldsan ID, a title, a ranking score, and a collection of tags.</source>
          <target state="new">A BlogPost object contains four fieldsan ID, a title, a ranking score, and a collection of tags.</target>
        </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve">
          <source>The first code snippet below shows the sample data used for populating a C# list of BlogPost objects:</source>
          <target state="new">The first code snippet below shows the sample data used for populating a C# list of BlogPost objects:</target>
        </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve">
          <source>You can store the tags for each BlogPost object as a set in a Redis cache and associate each set with the ID of the BlogPost.</source>
          <target state="new">You can store the tags for each BlogPost object as a set in a Redis cache and associate each set with the ID of the BlogPost.</target>
        </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve">
          <source>This enables an application to quickly find all the tags belonging to a specific blog post.</source>
          <target state="new">This enables an application to quickly find all the tags belonging to a specific blog post.</target>
        </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve">
          <source>To enable searching in the opposite direction and find all blog posts that share a specific tag, you can create another set that holds the blog posts referencing the tag ID in the key:</source>
          <target state="new">To enable searching in the opposite direction and find all blog posts that share a specific tag, you can create another set that holds the blog posts referencing the tag ID in the key:</target>
        </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve">
          <source>These structures enable you to perform many common queries very efficiently.</source>
          <target state="new">These structures enable you to perform many common queries very efficiently.</target>
        </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve">
          <source>For example, you can find and display all of the tags for blog post 1 like this:</source>
          <target state="new">For example, you can find and display all of the tags for blog post 1 like this:</target>
        </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve">
          <source>You can find all tags that are common to blog post 1 and blog post 2 by performing a set intersection operation, as follows:</source>
          <target state="new">You can find all tags that are common to blog post 1 and blog post 2 by performing a set intersection operation, as follows:</target>
        </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve">
          <source>And you can find all blog posts that contain a specific tag:</source>
          <target state="new">And you can find all blog posts that contain a specific tag:</target>
        </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve">
          <source>Finding recently accessed items</source>
          <target state="new">Finding recently accessed items</target>
        </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve">
          <source>A common problem required by many applications is to find the most recently accessed items.</source>
          <target state="new">A common problem required by many applications is to find the most recently accessed items.</target>
        </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve">
          <source>For example, a blogging site might want to display information about the most recently read blog posts.</source>
          <target state="new">For example, a blogging site might want to display information about the most recently read blog posts.</target>
        </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve">
          <source>You can implement this functionality by using a Redis list.</source>
          <target state="new">You can implement this functionality by using a Redis list.</target>
        </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve">
          <source>A Redis list contains multiple items that share the same key, but the list acts as a double-ended queue.</source>
          <target state="new">A Redis list contains multiple items that share the same key, but the list acts as a double-ended queue.</target>
        </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve">
          <source>You can push items on to either end of the list by using the LPUSH (left push) and RPUSH (right push) commands.</source>
          <target state="new">You can push items on to either end of the list by using the LPUSH (left push) and RPUSH (right push) commands.</target>
        </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve">
          <source>You can retrieve items from either end of the list by using the LPOP and RPOP commands.</source>
          <target state="new">You can retrieve items from either end of the list by using the LPOP and RPOP commands.</target>
        </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve">
          <source>You can also return a set of elements by using the LRANGE and RRANGE commands.</source>
          <target state="new">You can also return a set of elements by using the LRANGE and RRANGE commands.</target>
        </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve">
          <source>The code snippets below show how you can perform these operations by using the StackExchange library.</source>
          <target state="new">The code snippets below show how you can perform these operations by using the StackExchange library.</target>
        </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve">
          <source>This code uses the BlogPost type from the previous examples.</source>
          <target state="new">This code uses the BlogPost type from the previous examples.</target>
        </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve">
          <source>As a blog post is read by a user, the title of the blog post is pushed onto a list associated with the key "blog:recent_posts" in the Redis cache by using the IDatabase.ListLeftPushAsync method:</source>
          <target state="new">As a blog post is read by a user, the title of the blog post is pushed onto a list associated with the key "blog:recent_posts" in the Redis cache by using the IDatabase.ListLeftPushAsync method:</target>
        </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve">
          <source>As more blog posts are read, their titles are pushed onto the same list.</source>
          <target state="new">As more blog posts are read, their titles are pushed onto the same list.</target>
        </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve">
          <source>The list is ordered by the sequence in which they have been added; the most recently read blog posts are towards the left end of the list (if the same blog post is read more than once, it will have multiple entries in the list).</source>
          <target state="new">The list is ordered by the sequence in which they have been added; the most recently read blog posts are towards the left end of the list (if the same blog post is read more than once, it will have multiple entries in the list).</target>
        </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve">
          <source>You can display the titles of the most recently read posts by using the IDatabase.ListRange method.</source>
          <target state="new">You can display the titles of the most recently read posts by using the IDatabase.ListRange method.</target>
        </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve">
          <source>This method takes the key that contains the list, a starting point, and an ending point.</source>
          <target state="new">This method takes the key that contains the list, a starting point, and an ending point.</target>
        </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve">
          <source>The following code retrieves the titles of the 10 blog posts (items from 0 to 9) at the left-most end of the list:</source>
          <target state="new">The following code retrieves the titles of the 10 blog posts (items from 0 to 9) at the left-most end of the list:</target>
        </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve">
          <source>Note that ListRangeAsync does not remove items from the list; to do this you can use the IDatabase.ListLeftPopAsync and IDatabase.ListRightPopAsync methods.</source>
          <target state="new">Note that ListRangeAsync does not remove items from the list; to do this you can use the IDatabase.ListLeftPopAsync and IDatabase.ListRightPopAsync methods.</target>
        </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve">
          <source>To prevent the list from growing indefinitely, you can periodically cull items by trimming the list.</source>
          <target state="new">To prevent the list from growing indefinitely, you can periodically cull items by trimming the list.</target>
        </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve">
          <source>The code snippet below, removes all but the 5 left-most items from the list:</source>
          <target state="new">The code snippet below, removes all but the 5 left-most items from the list:</target>
        </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve">
          <source>Implementing a leader board</source>
          <target state="new">Implementing a leader board</target>
        </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve">
          <source>By default the items in a set are not held in any specific order.</source>
          <target state="new">By default the items in a set are not held in any specific order.</target>
        </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve">
          <source>You can create an ordered set by using the ZADD command (the IDatabase.SortedSetAdd method in the StackExchange library).</source>
          <target state="new">You can create an ordered set by using the ZADD command (the IDatabase.SortedSetAdd method in the StackExchange library).</target>
        </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve">
          <source>The items are ordered by using a numeric value called a score provided as a parameter to the command.</source>
          <target state="new">The items are ordered by using a numeric value called a score provided as a parameter to the command.</target>
        </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve">
          <source>The following code snippet adds the title of a blog post to an ordered list.</source>
          <target state="new">The following code snippet adds the title of a blog post to an ordered list.</target>
        </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve">
          <source>In the example, each blog post also has a score field that contains the ranking of the blog post.</source>
          <target state="new">In the example, each blog post also has a score field that contains the ranking of the blog post.</target>
        </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve">
          <source>You can retrieve the blog post titles and scores in ascending score order by using the IDatabase.SortedSetRangeByRankWithScores method:</source>
          <target state="new">You can retrieve the blog post titles and scores in ascending score order by using the IDatabase.SortedSetRangeByRankWithScores method:</target>
        </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> The StackExchange library also provides the IDatabase.SortedSetRangeByRankAsync method which returns the data in score order, but does not return the scores.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> The StackExchange library also provides the IDatabase.SortedSetRangeByRankAsync method which returns the data in score order, but does not return the scores.</target>
        </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve">
          <source>You can also retrieve items in descending order of scores, and limit the number of items returned by providing additional parameters to the IDatabase.SortedSetRangeByRankWithScoresAsync method.</source>
          <target state="new">You can also retrieve items in descending order of scores, and limit the number of items returned by providing additional parameters to the IDatabase.SortedSetRangeByRankWithScoresAsync method.</target>
        </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve">
          <source>The next example displays the titles and scores of the top 10 ranked blog posts:</source>
          <target state="new">The next example displays the titles and scores of the top 10 ranked blog posts:</target>
        </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve">
          <source>The next example uses the IDatabase.SortedSetRangeByScoreWithScoresAsync method which you can use to limit the items returned to those that fall within a given score range:</source>
          <target state="new">The next example uses the IDatabase.SortedSetRangeByScoreWithScoresAsync method which you can use to limit the items returned to those that fall within a given score range:</target>
        </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve">
          <source>Messaging by using channels</source>
          <target state="new">Messaging by using channels</target>
        </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve">
          <source>Apart from acting as a data cache, a Redis server provides messaging through a high-performance publisher/subscriber mechanism.</source>
          <target state="new">Apart from acting as a data cache, a Redis server provides messaging through a high-performance publisher/subscriber mechanism.</target>
        </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve">
          <source>Client applications can subscribe to a channel, and other applications or services can publish messages to the channel.</source>
          <target state="new">Client applications can subscribe to a channel, and other applications or services can publish messages to the channel.</target>
        </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve">
          <source>Subscribing applications will then receive these messages and can process them.</source>
          <target state="new">Subscribing applications will then receive these messages and can process them.</target>
        </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve">
          <source>To subscribe to channel, Redis provides the SUBSCRIBE command.</source>
          <target state="new">To subscribe to channel, Redis provides the SUBSCRIBE command.</target>
        </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve">
          <source>This command expects the name of one or more channels on which the application will accept messages.</source>
          <target state="new">This command expects the name of one or more channels on which the application will accept messages.</target>
        </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve">
          <source>The StackExchange library includes the ISubscription interface which enables a .NET Framework application to subscribe and publish to channels.</source>
          <target state="new">The StackExchange library includes the ISubscription interface which enables a .NET Framework application to subscribe and publish to channels.</target>
        </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve">
          <source>You create an ISubscription object by using the GetSubscriber method of the connection to the Redis server, and then listen for messages on a channel by using the SubscribeAsync method of this object.</source>
          <target state="new">You create an ISubscription object by using the GetSubscriber method of the connection to the Redis server, and then listen for messages on a channel by using the SubscribeAsync method of this object.</target>
        </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve">
          <source>The following code example shows how to subscribe to a channel named "messages:blogPosts":</source>
          <target state="new">The following code example shows how to subscribe to a channel named "messages:blogPosts":</target>
        </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve">
          <source>The first parameter to the Subscribe method is the name of the channel.</source>
          <target state="new">The first parameter to the Subscribe method is the name of the channel.</target>
        </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve">
          <source>This name follows the same conventions as that used by keys in the cache, and can contain any binary data, although it is advisable to use relatively short, meaningful strings to help ensure good performance and maintainability.</source>
          <target state="new">This name follows the same conventions as that used by keys in the cache, and can contain any binary data, although it is advisable to use relatively short, meaningful strings to help ensure good performance and maintainability.</target>
        </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve">
          <source>You should also note that the namespace used by channels is separate from that used by keys, so you can have channels and keys that have the same name, although this may make your application code more difficult to maintain.</source>
          <target state="new">You should also note that the namespace used by channels is separate from that used by keys, so you can have channels and keys that have the same name, although this may make your application code more difficult to maintain.</target>
        </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve">
          <source>The second parameter is an Action delegate.</source>
          <target state="new">The second parameter is an Action delegate.</target>
        </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve">
          <source>This delegate runs asynchronously whenever a new message appears on the channel.</source>
          <target state="new">This delegate runs asynchronously whenever a new message appears on the channel.</target>
        </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve">
          <source>This example simply displays the message on the console (the message will contain the title of a blog post).</source>
          <target state="new">This example simply displays the message on the console (the message will contain the title of a blog post).</target>
        </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve">
          <source>To publish to a channel, an application can use the Redis PUBLISH command.</source>
          <target state="new">To publish to a channel, an application can use the Redis PUBLISH command.</target>
        </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve">
          <source>The StackExchange library provides the IServer.PublishAsync method to perform this operation.</source>
          <target state="new">The StackExchange library provides the IServer.PublishAsync method to perform this operation.</target>
        </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve">
          <source>The next code snippet shows how to publish a message to the "messages:blogPosts" channel:</source>
          <target state="new">The next code snippet shows how to publish a message to the "messages:blogPosts" channel:</target>
        </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve">
          <source>There are several points you should understand about the publish/subscribe mechanism:</source>
          <target state="new">There are several points you should understand about the publish/subscribe mechanism:</target>
        </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve">
          <source>Multiple subscribers can subscribe to the same channel, and they will all receive the messages published to that channel.</source>
          <target state="new">Multiple subscribers can subscribe to the same channel, and they will all receive the messages published to that channel.</target>
        </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve">
          <source>Subscribers only receive messages that have been published after they have subscribed.</source>
          <target state="new">Subscribers only receive messages that have been published after they have subscribed.</target>
        </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve">
          <source>Channels are not buffered, and once a message is published the Redis infrastructure pushes the message to each subscriber and then removes it.</source>
          <target state="new">Channels are not buffered, and once a message is published the Redis infrastructure pushes the message to each subscriber and then removes it.</target>
        </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve">
          <source>By default, messages are received by subscribers in the order in which they are sent.</source>
          <target state="new">By default, messages are received by subscribers in the order in which they are sent.</target>
        </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve">
          <source>In a highly active system with a large number</source>
          <target state="new">In a highly active system with a large number</target>
        </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve">
          <source>of messages and many subscribers and publishers, guaranteed sequential delivery of messages can slow performance of the system.</source>
          <target state="new">of messages and many subscribers and publishers, guaranteed sequential delivery of messages can slow performance of the system.</target>
        </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="new">If</target>
        </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve">
          <source>each message is independent and the order is immaterial you can enable concurrent processing by the Redis system which can help to</source>
          <target state="new">each message is independent and the order is immaterial you can enable concurrent processing by the Redis system which can help to</target>
        </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve">
          <source>improve responsiveness.</source>
          <target state="new">improve responsiveness.</target>
        </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve">
          <source>You can achieve this in a StackExchange client by setting the PreserveAsyncOrder of the connection used by</source>
          <target state="new">You can achieve this in a StackExchange client by setting the PreserveAsyncOrder of the connection used by</target>
        </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve">
          <source>the subscriber to false:</source>
          <target state="new">the subscriber to false:</target>
        </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve">
          <source>Related Patterns and Guidance</source>
          <target state="new">Related Patterns and Guidance</target>
        </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve">
          <source>The following pattern may also be relevant to your scenario when implementing caching in your applications:</source>
          <target state="new">The following pattern may also be relevant to your scenario when implementing caching in your applications:</target>
        </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Cache-Aside Pattern<ept id="p1">](http://msdn.microsoft.com/library/dn589799.aspx)</ept>: This pattern describes how to load data on-demand into a cache from a data store.</source>
          <target state="new"><bpt id="p1">[</bpt>Cache-Aside Pattern<ept id="p1">](http://msdn.microsoft.com/library/dn589799.aspx)</ept>: This pattern describes how to load data on-demand into a cache from a data store.</target>
        </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve">
          <source>This pattern also helps to maintain consistency between data held in the cache and the data in the original data store.</source>
          <target state="new">This pattern also helps to maintain consistency between data held in the cache and the data in the original data store.</target>
        </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Sharding Pattern<ept id="p1">](http://msdn.microsoft.com/library/dn589797.aspx)</ept> provides information on implementing horizontal partitioning to help improve scalability when storing and accessing large volumes of data.</source>
          <target state="new">The <bpt id="p1">[</bpt>Sharding Pattern<ept id="p1">](http://msdn.microsoft.com/library/dn589797.aspx)</ept> provides information on implementing horizontal partitioning to help improve scalability when storing and accessing large volumes of data.</target>
        </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve">
          <source>More Information</source>
          <target state="new">More Information</target>
        </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>MemoryCache Class<ept id="p1">](http://msdn.microsoft.com/library/system.runtime.caching.memorycache.aspx)</ept> page on the Microsoft website.</source>
          <target state="new">The <bpt id="p1">[</bpt>MemoryCache Class<ept id="p1">](http://msdn.microsoft.com/library/system.runtime.caching.memorycache.aspx)</ept> page on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Microsoft Azure Cache<ept id="p1">](http://msdn.microsoft.com/library/windowsazure/gg278356.aspx)</ept> page on the Microsoft website.</source>
          <target state="new">The <bpt id="p1">[</bpt>Microsoft Azure Cache<ept id="p1">](http://msdn.microsoft.com/library/windowsazure/gg278356.aspx)</ept> page on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Which Azure Cache offering is right for me?<ept id="p1">](http://msdn.microsoft.com/library/azure/dn766201.aspx)</ept> page on the Microsoft website.</source>
          <target state="new">The <bpt id="p1">[</bpt>Which Azure Cache offering is right for me?<ept id="p1">](http://msdn.microsoft.com/library/azure/dn766201.aspx)</ept> page on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Configuration Model<ept id="p1">](http://msdn.microsoft.com/library/windowsazure/hh914149.aspx)</ept> page on the Microsoft website.</source>
          <target state="new">The <bpt id="p1">[</bpt>Configuration Model<ept id="p1">](http://msdn.microsoft.com/library/windowsazure/hh914149.aspx)</ept> page on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Task-based Asynchronous Pattern<ept id="p1">](http://msdn.microsoft.com/library/hh873175.aspx)</ept> page on the Microsoft website.</source>
          <target state="new">The <bpt id="p1">[</bpt>Task-based Asynchronous Pattern<ept id="p1">](http://msdn.microsoft.com/library/hh873175.aspx)</ept> page on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Pipelines and Multiplexers<ept id="p1">](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/PipelinesMultiplexers.md)</ept> page on the StackExchange.Redis GitHub repo.</source>
          <target state="new">The <bpt id="p1">[</bpt>Pipelines and Multiplexers<ept id="p1">](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/PipelinesMultiplexers.md)</ept> page on the StackExchange.Redis GitHub repo.</target>
        </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Redis Persistence<ept id="p1">](http://redis.io/topics/persistence)</ept> page on the Redis website.</source>
          <target state="new">The <bpt id="p1">[</bpt>Redis Persistence<ept id="p1">](http://redis.io/topics/persistence)</ept> page on the Redis website.</target>
        </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Replication page<ept id="p1">](http://redis.io/topics/replication)</ept> on the Redis website.</source>
          <target state="new">The <bpt id="p1">[</bpt>Replication page<ept id="p1">](http://redis.io/topics/replication)</ept> on the Redis website.</target>
        </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Redis Cluster Tutorial<ept id="p1">](http://redis.io/topics/cluster-tutorial)</ept> page on the Redis website.</source>
          <target state="new">The <bpt id="p1">[</bpt>Redis Cluster Tutorial<ept id="p1">](http://redis.io/topics/cluster-tutorial)</ept> page on the Redis website.</target>
        </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Partitioning: how to split data among multiple Redis instances<ept id="p1">](http://redis.io/topics/partitioning)</ept> page on the Redis website.</source>
          <target state="new">The <bpt id="p1">[</bpt>Partitioning: how to split data among multiple Redis instances<ept id="p1">](http://redis.io/topics/partitioning)</ept> page on the Redis website.</target>
        </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve">
          <source>The page <bpt id="p1">[</bpt>Using Redis as an LRU Cache<ept id="p1">](http://redis.io/topics/lru-cache)</ept> on the Redis website.</source>
          <target state="new">The page <bpt id="p1">[</bpt>Using Redis as an LRU Cache<ept id="p1">](http://redis.io/topics/lru-cache)</ept> on the Redis website.</target>
        </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Transactions page<ept id="p1">](http://redis.io/topics/transactions)</ept> on the Redis website.</source>
          <target state="new">The <bpt id="p1">[</bpt>Transactions page<ept id="p1">](http://redis.io/topics/transactions)</ept> on the Redis website.</target>
        </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Redis Security<ept id="p1">](http://redis.io/topics/security)</ept> page on the Redis website.</source>
          <target state="new">The <bpt id="p1">[</bpt>Redis Security<ept id="p1">](http://redis.io/topics/security)</ept> page on the Redis website.</target>
        </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve">
          <source>The page <bpt id="p1">[</bpt>Lap around Azure Redis Cache<ept id="p1">](http://azure.microsoft.com/blog/2014/06/04/lap-around-azure-redis-cache-preview/)</ept> on the Azure blog.</source>
          <target state="new">The page <bpt id="p1">[</bpt>Lap around Azure Redis Cache<ept id="p1">](http://azure.microsoft.com/blog/2014/06/04/lap-around-azure-redis-cache-preview/)</ept> on the Azure blog.</target>
        </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve">
          <source>The page <bpt id="p1">[</bpt>Running Redis on a CentOS Linux VM<ept id="p1">](http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx)</ept> in Azure on the Microsoft website.</source>
          <target state="new">The page <bpt id="p1">[</bpt>Running Redis on a CentOS Linux VM<ept id="p1">](http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx)</ept> in Azure on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>ASP.NET Session State Provider for Azure Redis Cache<ept id="p1">](http://msdn.microsoft.com/library/azure/dn690522.aspx)</ept> page on the Microsoft website.</source>
          <target state="new">The <bpt id="p1">[</bpt>ASP.NET Session State Provider for Azure Redis Cache<ept id="p1">](http://msdn.microsoft.com/library/azure/dn690522.aspx)</ept> page on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>ASP.NET Output Cache Provider for Azure Redis Cache<ept id="p1">](http://msdn.microsoft.com/library/azure/dn798898.aspx)</ept> page on the Microsoft website.</source>
          <target state="new">The <bpt id="p1">[</bpt>ASP.NET Output Cache Provider for Azure Redis Cache<ept id="p1">](http://msdn.microsoft.com/library/azure/dn798898.aspx)</ept> page on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve">
          <source>The page <bpt id="p1">[</bpt>Develop for Azure Redis Cache<ept id="p1">](http://msdn.microsoft.com/library/azure/dn690520.aspx)</ept> on the Azure site.</source>
          <target state="new">The page <bpt id="p1">[</bpt>Develop for Azure Redis Cache<ept id="p1">](http://msdn.microsoft.com/library/azure/dn690520.aspx)</ept> on the Azure site.</target>
        </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve">
          <source>The page <bpt id="p1">[</bpt>An Introduction to Redis data types and abstractions<ept id="p1">](http://redis.io/topics/data-types-intro)</ept> on the Redis website.</source>
          <target state="new">The page <bpt id="p1">[</bpt>An Introduction to Redis data types and abstractions<ept id="p1">](http://redis.io/topics/data-types-intro)</ept> on the Redis website.</target>
        </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Basic Usage<ept id="p1">](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Basics.md)</ept> page on the StackExchange.Redis website.</source>
          <target state="new">The <bpt id="p1">[</bpt>Basic Usage<ept id="p1">](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Basics.md)</ept> page on the StackExchange.Redis website.</target>
        </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Transactions in Redis<ept id="p1">](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Transactions.md)</ept> page on the StackExchange.Redis repo.</source>
          <target state="new">The <bpt id="p1">[</bpt>Transactions in Redis<ept id="p1">](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Transactions.md)</ept> page on the StackExchange.Redis repo.</target>
        </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Data Partitioning Guide<ept id="p1">](http://msdn.microsoft.com/library/dn589795.aspx)</ept> on the Microsoft website.</source>
          <target state="new">The <bpt id="p1">[</bpt>Data Partitioning Guide<ept id="p1">](http://msdn.microsoft.com/library/dn589795.aspx)</ept> on the Microsoft website.</target>
        </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve">
          <source>test1111111111111222</source>
          <target state="new">test1111111111111222</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">693e0cae3c3cf592185296d99329312ca2ad062c</xliffext:olfilehash>
  </header>
</xliff>