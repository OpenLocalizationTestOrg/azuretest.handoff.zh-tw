<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-tw">
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>How to partition data in DocumentDB with the .NET SDK | Microsoft Azure</source>
          <target state="new">How to partition data in DocumentDB with the .NET SDK | Microsoft Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Learn how to use the Azure DocumentDB .NET SDK to partition (shard) data and route requests across multiple collections</source>
          <target state="new">Learn how to use the Azure DocumentDB .NET SDK to partition (shard) data and route requests across multiple collections</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>How to partition data in DocumentDB with the .NET SDK</source>
          <target state="new">How to partition data in DocumentDB with the .NET SDK</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Azure DocumentDB is a document database service that enables you to seamlessly scale your account through provisioning of collections using the <bpt id="p1">[</bpt>SDKs<ept id="p1">](https://msdn.microsoft.com/library/azure/dn781482.aspx)</ept> and <bpt id="p2">[</bpt>REST APIs<ept id="p2">](https://msdn.microsoft.com/library/azure/dn781481.aspx)</ept> (also called <bpt id="p3">**</bpt>sharding<ept id="p3">**</ept>).</source>
          <target state="new">Azure DocumentDB is a document database service that enables you to seamlessly scale your account through provisioning of collections using the <bpt id="p1">[</bpt>SDKs<ept id="p1">](https://msdn.microsoft.com/library/azure/dn781482.aspx)</ept> and <bpt id="p2">[</bpt>REST APIs<ept id="p2">](https://msdn.microsoft.com/library/azure/dn781481.aspx)</ept> (also called <bpt id="p3">**</bpt>sharding<ept id="p3">**</ept>).</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>In order to make it easier to develop partitioned applications and reduce the amount of boiler-plate code required for partitioning tasks, we have added functionality in the .NET SDK that makes it easier to build applications that are scaled out across multiple partitions.</source>
          <target state="new">In order to make it easier to develop partitioned applications and reduce the amount of boiler-plate code required for partitioning tasks, we have added functionality in the .NET SDK that makes it easier to build applications that are scaled out across multiple partitions.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>In this article, we'll take a look at the classes and interfaces in the .NET SDK and how you can use them to develop partitioned applications.</source>
          <target state="new">In this article, we'll take a look at the classes and interfaces in the .NET SDK and how you can use them to develop partitioned applications.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Partitioning with the DocumentDB SDK</source>
          <target state="new">Partitioning with the DocumentDB SDK</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Before we dig deeper into partitioning, let's recap some basic DocumentDB concepts that relate to partitioning.</source>
          <target state="new">Before we dig deeper into partitioning, let's recap some basic DocumentDB concepts that relate to partitioning.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Every Azure DocumentDB database account consists of a set of databases, each containing multiple collections, each of which can contain stored procedures, triggers, UDFs, documents, and related attachments.</source>
          <target state="new">Every Azure DocumentDB database account consists of a set of databases, each containing multiple collections, each of which can contain stored procedures, triggers, UDFs, documents, and related attachments.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Collections can be treated as partitions in DocumentDB and have the following properties:</source>
          <target state="new">Collections can be treated as partitions in DocumentDB and have the following properties:</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Collections are physical partitions, not just logical containers.</source>
          <target state="new">Collections are physical partitions, not just logical containers.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Hence there is a performance benefit in querying or processing documents which are located within the same collection.</source>
          <target state="new">Hence there is a performance benefit in querying or processing documents which are located within the same collection.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Collections are the boundary for ACID transactions, i.e., stored procedures and triggers.</source>
          <target state="new">Collections are the boundary for ACID transactions, i.e., stored procedures and triggers.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Collections do not enforce a schema, so they can be used for JSON documents of the same type or different types.</source>
          <target state="new">Collections do not enforce a schema, so they can be used for JSON documents of the same type or different types.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Starting with version <bpt id="p1">[</bpt>1.1.0 of the Azure DocumentDB .NET SDK<ept id="p1">](http://www.nuget.org/packages/Microsoft.Azure.DocumentDB/)</ept>, you can perform document operations directly against a database.</source>
          <target state="new">Starting with version <bpt id="p1">[</bpt>1.1.0 of the Azure DocumentDB .NET SDK<ept id="p1">](http://www.nuget.org/packages/Microsoft.Azure.DocumentDB/)</ept>, you can perform document operations directly against a database.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Internally the <bpt id="p1">[</bpt>DocumentClient<ept id="p1">](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.client.documentclient.aspx)</ept> uses the PartitionResolver that you have specified for the database to route requests to the appropriate collection.</source>
          <target state="new">Internally the <bpt id="p1">[</bpt>DocumentClient<ept id="p1">](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.client.documentclient.aspx)</ept> uses the PartitionResolver that you have specified for the database to route requests to the appropriate collection.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Each PartitionResolver class is a concrete implementation of an <bpt id="p1">[</bpt>IPartitionResolver<ept id="p1">](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.client.ipartitionresolver.aspx)</ept> interface that has three methods - <bpt id="p2">[</bpt>GetPartitionKey<ept id="p2">](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.client.ipartitionresolver.getpartitionkey.aspx)</ept>, <bpt id="p3">[</bpt>ResolveForCreate<ept id="p3">](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.client.ipartitionresolver.resolveforcreate.aspx)</ept> and <bpt id="p4">[</bpt>ResolveForRead<ept id="p4">](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.client.ipartitionresolver.resolveforread.aspx)</ept>.</source>
          <target state="new">Each PartitionResolver class is a concrete implementation of an <bpt id="p1">[</bpt>IPartitionResolver<ept id="p1">](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.client.ipartitionresolver.aspx)</ept> interface that has three methods - <bpt id="p2">[</bpt>GetPartitionKey<ept id="p2">](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.client.ipartitionresolver.getpartitionkey.aspx)</ept>, <bpt id="p3">[</bpt>ResolveForCreate<ept id="p3">](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.client.ipartitionresolver.resolveforcreate.aspx)</ept> and <bpt id="p4">[</bpt>ResolveForRead<ept id="p4">](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.client.ipartitionresolver.resolveforread.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>LINQ queries and ReadFeed iterators use the ResolveForRead method internally to iterate over all the collections that match the partition key for the request.</source>
          <target state="new">LINQ queries and ReadFeed iterators use the ResolveForRead method internally to iterate over all the collections that match the partition key for the request.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Similarly, create operations use the ResolveForCreate method to route creates to the right partition.</source>
          <target state="new">Similarly, create operations use the ResolveForCreate method to route creates to the right partition.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>There are no changes required for Replace, Delete and Read since they use documents, which already contain the reference to the corresponding collection.</source>
          <target state="new">There are no changes required for Replace, Delete and Read since they use documents, which already contain the reference to the corresponding collection.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The SDK also includes two classes that support the two canonical partitioning techniques, hashing and range lookups, via a <bpt id="p1">[</bpt>HashPartitionResolver<ept id="p1">](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.partitioning.hashpartitionresolver.aspx)</ept> and a <bpt id="p2">[</bpt>RangePartitionResolver<ept id="p2">](https://msdn.microsoft.com/library/azure/mt126047.aspx)</ept>.</source>
          <target state="new">The SDK also includes two classes that support the two canonical partitioning techniques, hashing and range lookups, via a <bpt id="p1">[</bpt>HashPartitionResolver<ept id="p1">](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.partitioning.hashpartitionresolver.aspx)</ept> and a <bpt id="p2">[</bpt>RangePartitionResolver<ept id="p2">](https://msdn.microsoft.com/library/azure/mt126047.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>You can use these classes to easily add partitioning logic to your application.</source>
          <target state="new">You can use these classes to easily add partitioning logic to your application.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Add partitioning logic and register the PartitionResolver</source>
          <target state="new">Add partitioning logic and register the PartitionResolver</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Here's a snippet showing how to create a <bpt id="p1">[</bpt>HashPartitionResolver<ept id="p1">](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.partitioning.hashpartitionresolver.aspx)</ept> and register with the DocumentClient for a database.</source>
          <target state="new">Here's a snippet showing how to create a <bpt id="p1">[</bpt>HashPartitionResolver<ept id="p1">](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.partitioning.hashpartitionresolver.aspx)</ept> and register with the DocumentClient for a database.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Create documents in a partition</source>
          <target state="new">Create documents in a partition</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Once the PartitionResolver is registered, you can perform creates and queries directly against the database as shown below.</source>
          <target state="new">Once the PartitionResolver is registered, you can perform creates and queries directly against the database as shown below.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>In this example, the SDK uses the PartitionResolver to extract the UserId, hash it, and then use that value to route the create operation to the correct collection.</source>
          <target state="new">In this example, the SDK uses the PartitionResolver to extract the UserId, hash it, and then use that value to route the create operation to the correct collection.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Create queries against partitions</source>
          <target state="new">Create queries against partitions</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>You can query using the <bpt id="p1">[</bpt>CreateDocumentQuery<ept id="p1">]( https://msdn.microsoft.com/library/azure/microsoft.azure.documents.linq.documentqueryable.createdocumentquery.aspx)</ept> method by passing in the database and a partition key.</source>
          <target state="new">You can query using the <bpt id="p1">[</bpt>CreateDocumentQuery<ept id="p1">]( https://msdn.microsoft.com/library/azure/microsoft.azure.documents.linq.documentqueryable.createdocumentquery.aspx)</ept> method by passing in the database and a partition key.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The query returns a single result-set over all the collections within the database that map to the partition key.</source>
          <target state="new">The query returns a single result-set over all the collections within the database that map to the partition key.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Create queries against all collections in the database</source>
          <target state="new">Create queries against all collections in the database</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>You can also query all collections within the database and enumerate the results as show below, by skipping the partition key argument.</source>
          <target state="new">You can also query all collections within the database and enumerate the results as show below, by skipping the partition key argument.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Hash Partition Resolver</source>
          <target state="new">Hash Partition Resolver</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>With hash partitioning, partitions are assigned based on the value of a hash function, allowing you to evenly distribute requests and data across a number of partitions.</source>
          <target state="new">With hash partitioning, partitions are assigned based on the value of a hash function, allowing you to evenly distribute requests and data across a number of partitions.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>This approach is commonly used to partition data produced or consumed from a large number of distinct clients, and is useful for storing user profiles, catalog items, and IoT ("Internet of Things") telemetry data.</source>
          <target state="new">This approach is commonly used to partition data produced or consumed from a large number of distinct clients, and is useful for storing user profiles, catalog items, and IoT ("Internet of Things") telemetry data.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Hash Partitioning:<ept id="p1">**</ept></source>
          <target state="new"><bpt id="p1">**</bpt>Hash Partitioning:<ept id="p1">**</ept></target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><ph id="ph1">![</ph>Diagram illustrating how hash partitioning evenly distributes requests across partitions<ph id="ph2">](media/documentdb-sharding/partition-hash.png "Hash partitioning")</ph></source>
          <target state="new"><ph id="ph1">![</ph>Diagram illustrating how hash partitioning evenly distributes requests across partitions<ph id="ph2">](media/documentdb-sharding/partition-hash.png "Hash partitioning")</ph></target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>A simple hash partitioning scheme across <bpt id="p1">*</bpt>N<ept id="p1">*</ept> collections would be to take any document, compute <bpt id="p2">*</bpt>hash(d) mod N<ept id="p2">*</ept> to determine which collection it's placed in.</source>
          <target state="new">A simple hash partitioning scheme across <bpt id="p1">*</bpt>N<ept id="p1">*</ept> collections would be to take any document, compute <bpt id="p2">*</bpt>hash(d) mod N<ept id="p2">*</ept> to determine which collection it's placed in.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>But a problem with this simple technique is that it does not work well when you add new collections, or remove collections as this would require almost all the data to get reshuffled.</source>
          <target state="new">But a problem with this simple technique is that it does not work well when you add new collections, or remove collections as this would require almost all the data to get reshuffled.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>[Consistent hashing] (http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.23.3738) is a well-known algorithm that addresses this by implementing a hashing scheme that minimizes the amount of data movement required during adding or removing collections.</source>
          <target state="new">[Consistent hashing] (http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.23.3738) is a well-known algorithm that addresses this by implementing a hashing scheme that minimizes the amount of data movement required during adding or removing collections.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>HashPartitionResolver<ept id="p1">](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.partitioning.hashpartitionresolver.aspx)</ept> class implements logic to build a consistent hash ring over the hash function specified in the <bpt id="p2">[</bpt>IHashGenerator<ept id="p2">](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.partitioning.ihashgenerator.aspx)</ept> interface.</source>
          <target state="new">The <bpt id="p1">[</bpt>HashPartitionResolver<ept id="p1">](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.partitioning.hashpartitionresolver.aspx)</ept> class implements logic to build a consistent hash ring over the hash function specified in the <bpt id="p2">[</bpt>IHashGenerator<ept id="p2">](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.partitioning.ihashgenerator.aspx)</ept> interface.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>By default, the HashPartitionResolver uses an MD5 hash function, but you can swap this out with your own hashing implementation.</source>
          <target state="new">By default, the HashPartitionResolver uses an MD5 hash function, but you can swap this out with your own hashing implementation.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The HashPartitionResolver internally creates 16 hashes or "virtual nodes" within the hash ring for each collection in order to achieve a more uniform distribution of documents across the collections, but you can vary this number to trade off data skewness with the amount of client side computation.</source>
          <target state="new">The HashPartitionResolver internally creates 16 hashes or "virtual nodes" within the hash ring for each collection in order to achieve a more uniform distribution of documents across the collections, but you can vary this number to trade off data skewness with the amount of client side computation.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Consistent hashing with HashPartitionResolver:<ept id="p1">**</ept></source>
          <target state="new"><bpt id="p1">**</bpt>Consistent hashing with HashPartitionResolver:<ept id="p1">**</ept></target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><ph id="ph1">![</ph>Diagram illustrating how HashPartitionResolver creates a hash ring<ph id="ph2">](media/documentdb-sharding/HashPartitionResolver.JPG "Consistent hashing")</ph></source>
          <target state="new"><ph id="ph1">![</ph>Diagram illustrating how HashPartitionResolver creates a hash ring<ph id="ph2">](media/documentdb-sharding/HashPartitionResolver.JPG "Consistent hashing")</ph></target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Range Partition Resolver</source>
          <target state="new">Range Partition Resolver</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>In range partitioning, partitions are assigned based on whether the partition key is within a certain range.</source>
          <target state="new">In range partitioning, partitions are assigned based on whether the partition key is within a certain range.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>This is commonly used for partitioning with time stamp properties (e.g., eventTime between Apr 1, 2015 and Apr 14, 2015).</source>
          <target state="new">This is commonly used for partitioning with time stamp properties (e.g., eventTime between Apr 1, 2015 and Apr 14, 2015).</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RangePartitionResolver<ept id="p1">](https://msdn.microsoft.com/library/azure/mt126047.aspx)</ept> class helps you maintain a mapping between a Range\&lt;T\&gt; and collection self-link.</source>
          <target state="new">The <bpt id="p1">[</bpt>RangePartitionResolver<ept id="p1">](https://msdn.microsoft.com/library/azure/mt126047.aspx)</ept> class helps you maintain a mapping between a Range\&lt;T\&gt; and collection self-link.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Range\&lt;T\&gt;<ept id="p1">](https://msdn.microsoft.com/library/azure/mt126048.aspx)</ept> is a simple class that manages ranges of any types that implement IComparable\&lt;T\&gt; and IEquatable\&lt;T\&gt; like strings or numbers.</source>
          <target state="new"><bpt id="p1">[</bpt>Range\&lt;T\&gt;<ept id="p1">](https://msdn.microsoft.com/library/azure/mt126048.aspx)</ept> is a simple class that manages ranges of any types that implement IComparable\&lt;T\&gt; and IEquatable\&lt;T\&gt; like strings or numbers.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For reads and creates, you can pass in any arbitrary range, and the resolver identifies all the candidate collections by identifying the ranges of the partitions that intersect with the requested range.</source>
          <target state="new">For reads and creates, you can pass in any arbitrary range, and the resolver identifies all the candidate collections by identifying the ranges of the partitions that intersect with the requested range.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>This functionality can be useful when performing range queries against time series data.</source>
          <target state="new">This functionality can be useful when performing range queries against time series data.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Range Partitioning:</source>
          <target state="new">Range Partitioning:</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Diagram illustrating how range partitioning evenly distributes requests across partitions</source>
          <target state="new">Diagram illustrating how range partitioning evenly distributes requests across partitions</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>A special case of range partitioning is when the range is just a single discrete value, sometimes called "lookup partitioning".</source>
          <target state="new">A special case of range partitioning is when the range is just a single discrete value, sometimes called "lookup partitioning".</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>This is commonly used for partitioning by region (e.g. the partition for Scandinavia contains Norway, Denmark, and Sweden) or for partitioning tenants in a multi-tenant application.</source>
          <target state="new">This is commonly used for partitioning by region (e.g. the partition for Scandinavia contains Norway, Denmark, and Sweden) or for partitioning tenants in a multi-tenant application.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Samples</source>
          <target state="new">Samples</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Take a look at the  <bpt id="p1">[</bpt>DocumentDB Partitioning Samples Github project<ept id="p1">](https://github.com/Azure/azure-documentdb-net/tree/master/samples/code-samples/Partitioning)</ept> containing code snippets on how to use these PartitionResolvers and extend them to implement your own resolvers to fit specific use cases, like the following:</source>
          <target state="new">Take a look at the  <bpt id="p1">[</bpt>DocumentDB Partitioning Samples Github project<ept id="p1">](https://github.com/Azure/azure-documentdb-net/tree/master/samples/code-samples/Partitioning)</ept> containing code snippets on how to use these PartitionResolvers and extend them to implement your own resolvers to fit specific use cases, like the following:</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>How to specify an arbitrary lambda expression for GetPartitionKey and use it to implement compound partitioning keys or to partition different types of objects differently.</source>
          <target state="new">How to specify an arbitrary lambda expression for GetPartitionKey and use it to implement compound partitioning keys or to partition different types of objects differently.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>How to create a simple <bpt id="p1">[</bpt>LookupPartitionResolver<ept id="p1">](https://github.com/Azure/azure-documentdb-net/tree/master/samples/code-samples/Partitioning/Partitioners/LookupPartitionResolver.cs)</ept> that uses a manual lookup table to perform partitioning.</source>
          <target state="new">How to create a simple <bpt id="p1">[</bpt>LookupPartitionResolver<ept id="p1">](https://github.com/Azure/azure-documentdb-net/tree/master/samples/code-samples/Partitioning/Partitioners/LookupPartitionResolver.cs)</ept> that uses a manual lookup table to perform partitioning.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>This pattern is commonly used for partitioning based on discrete values like region, tenant ID or application name.</source>
          <target state="new">This pattern is commonly used for partitioning based on discrete values like region, tenant ID or application name.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>How to create a <bpt id="p1">[</bpt>ManagedPartitionResolver<ept id="p1">](https://github.com/Azure/azure-documentdb-net/tree/master/samples/code-samples/Partitioning/Partitioners/ManagedHashPartitionResolver.cs)</ept> that creates collections automatically based on a template that defines a naming scheme, IndexingPolicy and stored procedures that need to be registered against new collections.</source>
          <target state="new">How to create a <bpt id="p1">[</bpt>ManagedPartitionResolver<ept id="p1">](https://github.com/Azure/azure-documentdb-net/tree/master/samples/code-samples/Partitioning/Partitioners/ManagedHashPartitionResolver.cs)</ept> that creates collections automatically based on a template that defines a naming scheme, IndexingPolicy and stored procedures that need to be registered against new collections.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>How to create a scheme-less <bpt id="p1">[</bpt>SpilloverPartitionResolver<ept id="p1">](https://github.com/Azure/azure-documentdb-net/tree/master/samples/code-samples/Partitioning/Partitioners/SpilloverPartitionResolver.cs)</ept> that simply creates new collections as the old collections fill up.</source>
          <target state="new">How to create a scheme-less <bpt id="p1">[</bpt>SpilloverPartitionResolver<ept id="p1">](https://github.com/Azure/azure-documentdb-net/tree/master/samples/code-samples/Partitioning/Partitioners/SpilloverPartitionResolver.cs)</ept> that simply creates new collections as the old collections fill up.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>How to serialize and deserialize your PartitionResolver state as JSON, so that you can share between processes and across shutdowns.</source>
          <target state="new">How to serialize and deserialize your PartitionResolver state as JSON, so that you can share between processes and across shutdowns.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>You can persist these in config files, or even in a DocumentDB collection.</source>
          <target state="new">You can persist these in config files, or even in a DocumentDB collection.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>DocumentClientHashPartitioningManager<ept id="p1">](https://github.com/Azure/azure-documentdb-net/tree/master/samples/code-samples/Partitioning/Util/DocumentClientHashPartitioningManager.cs)</ept> class for dynamically adding and removing partitions to a database partitioned based on consistent hashing.</source>
          <target state="new">A <bpt id="p1">[</bpt>DocumentClientHashPartitioningManager<ept id="p1">](https://github.com/Azure/azure-documentdb-net/tree/master/samples/code-samples/Partitioning/Util/DocumentClientHashPartitioningManager.cs)</ept> class for dynamically adding and removing partitions to a database partitioned based on consistent hashing.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Internally it uses a <bpt id="p1">[</bpt>TransitionHashPartitionResolver<ept id="p1">]( https://github.com/Azure/azure-documentdb-net/tree/master/samples/code-samples/Partitioning/Partitioners/TransitionHashPartitionResolver.cs)</ept> to route reads and writes during migration using one of four modes - read from the old partitioning scheme (ReadCurrent), the new one (ReadNext), merge results from both (ReadBoth) or be unavailable during migration (None).</source>
          <target state="new">Internally it uses a <bpt id="p1">[</bpt>TransitionHashPartitionResolver<ept id="p1">]( https://github.com/Azure/azure-documentdb-net/tree/master/samples/code-samples/Partitioning/Partitioners/TransitionHashPartitionResolver.cs)</ept> to route reads and writes during migration using one of four modes - read from the old partitioning scheme (ReadCurrent), the new one (ReadNext), merge results from both (ReadBoth) or be unavailable during migration (None).</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The samples are open source and we encourage you to submit pull requests with contributions that could benefit other DocumentDB developers.</source>
          <target state="new">The samples are open source and we encourage you to submit pull requests with contributions that could benefit other DocumentDB developers.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Please refer to the <bpt id="p1">[</bpt>Contribution guidelines<ept id="p1">](https://github.com/Azure/azure-documentdb-net/blob/master/Contributing.md)</ept> for guidance on how to contribute.</source>
          <target state="new">Please refer to the <bpt id="p1">[</bpt>Contribution guidelines<ept id="p1">](https://github.com/Azure/azure-documentdb-net/blob/master/Contributing.md)</ept> for guidance on how to contribute.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> Collection creates are rate-limited by DocumentDB, so some of the sample methods shown here might take a few minutes to complete.</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> Collection creates are rate-limited by DocumentDB, so some of the sample methods shown here might take a few minutes to complete.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>FAQ</source>
          <target state="new">FAQ</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Why does DocumentDB support client-side partitioning vs. server-side partitioning?<ept id="p1">**</ept></source>
          <target state="new"><bpt id="p1">**</bpt>Why does DocumentDB support client-side partitioning vs. server-side partitioning?<ept id="p1">**</ept></target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>DocumentDB supports client-side partitioning for a couple of reasons:</source>
          <target state="new">DocumentDB supports client-side partitioning for a couple of reasons:</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>It is really difficult to abstract away the concept of a collection from developers without compromising one of the three among consistent indexing/querying, high availability and ACID transaction guarantees.</source>
          <target state="new">It is really difficult to abstract away the concept of a collection from developers without compromising one of the three among consistent indexing/querying, high availability and ACID transaction guarantees.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Document databases often require flexibility in terms of defining partitioning strategies, which a server-side approach might not be able to accommodate.</source>
          <target state="new">Document databases often require flexibility in terms of defining partitioning strategies, which a server-side approach might not be able to accommodate.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Why is partitioning not supported in other platforms (Node.js, Java, or Python)?</source>
          <target state="new">Why is partitioning not supported in other platforms (Node.js, Java, or Python)?</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>We will gradually rollout partitioning support to other platforms based on feedback from the .NET SDK customers.</source>
          <target state="new">We will gradually rollout partitioning support to other platforms based on feedback from the .NET SDK customers.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>How do I add or remove a collection to my partitioning scheme?</source>
          <target state="new">How do I add or remove a collection to my partitioning scheme?</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Take a look at the implementation of DocumentClientHashPartitioningManager in the samples project for an example of how you can implement repartitioning.</source>
          <target state="new">Take a look at the implementation of DocumentClientHashPartitioningManager in the samples project for an example of how you can implement repartitioning.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>How do I persist or share my partitioning configuration with other clients?</source>
          <target state="new">How do I persist or share my partitioning configuration with other clients?</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>You can serialize the partitioner state as JSON and store in configuration files, or even within DocumentDB collections.</source>
          <target state="new">You can serialize the partitioner state as JSON and store in configuration files, or even within DocumentDB collections.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Take a look at the RunSerializeDeserializeSample method in the samples project for an example.</source>
          <target state="new">Take a look at the RunSerializeDeserializeSample method in the samples project for an example.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>How do I chain various partitioning techniques?</source>
          <target state="new">How do I chain various partitioning techniques?</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>You can chain PartitionResolvers by implementing your own IPartitionResolver that internally uses one or more existing resolvers.</source>
          <target state="new">You can chain PartitionResolvers by implementing your own IPartitionResolver that internally uses one or more existing resolvers.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Take a look at TransitionHashPartitionResolver in the samples project for an example.</source>
          <target state="new">Take a look at TransitionHashPartitionResolver in the samples project for an example.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="new">References</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Partitioning code samples on Github</source>
          <target state="new">Partitioning code samples on Github</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Partitioning data with DocumentDB concepts</source>
          <target state="new">Partitioning data with DocumentDB concepts</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>DocumentDB collections and performance levels</source>
          <target state="new">DocumentDB collections and performance levels</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>DocumentDB .NET SDK Documentation at MSDN</source>
          <target state="new">DocumentDB .NET SDK Documentation at MSDN</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>DocumentDB .NET samples</source>
          <target state="new">DocumentDB .NET samples</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>DocumentDB Limits</source>
          <target state="new">DocumentDB Limits</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>DocumentDB Blog on Performance Tips</source>
          <target state="new">DocumentDB Blog on Performance Tips</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>test</source>
          <target state="new">test</target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
    </xliffext:oltranslationpriority>
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a923e70fb76c3c965c41499766e3a78df4d90416</xliffext:olfilehash>
  </header>
</xliff>